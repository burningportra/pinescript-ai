[
  {
    "id": "doc-0",
    "type": "documentation",
    "source": "LLM_MANIFEST.md",
    "section": "root",
    "title": "3. Function Reference (By Namespace)",
    "content": "# Pine Script v6 Documentation Manifest\n\n**Purpose:** This file acts as a directory map for Large Language Models (LLMs). Use this manifest to determine which specific documentation files to retrieve based on the user's request.\n\n**Protocol:** 1.  Identify the user's intent (e.g., \"Drawing a line\", \"Calculating RSI\", \"Backtesting\").\n2.  Locate the relevant file path below.\n3.  Retrieve ONLY that file to conserve context window.\n\n## 1. Syntax and Core Concepts\n\n*Use these files when the user asks about language mechanics, execution flow, or type errors.*\n\n* **`concepts/execution_model.md`**\n  * **Content:** How the script executes bar-by-bar, historical vs. real-time context, and the `var` keyword.\n  * **Keywords:** `barstate`, `history`, `realtime`, `calc_on_every_tick`, `var`, `varip`.\n\n* **`concepts/timeframes.md`**\n  * **Content:** Handling multi-timeframe data and preventing repainting.\n  * **Keywords:** `request.security`, `timeframe.period`, `repainting`, `HTF`.\n\n* **`concepts/colors_and_display.md`**\n  * **Content:** Defining colors, gradients, and transparency.\n  * **Keywords:** `color.new`, `color.from_gradient`, `bgcolor`.\n\n* **`concepts/common_errors.md`**\n  * **Content:** Explanations for common runtime and compile-time errors.\n  * **Keywords:** \"Series string\", \"Undeclared identifier\", \"max_bars_back\".\n\n## 2. API Reference (The Dictionary)\n\n*Use these files for looking up built-in variables, constants, and keywords.*\n\n* **`reference/variables.md`**\n  * **Content:** Built-in read-only variables regarding the bar, symbol, or status.\n  * **Keywords:** `open`, `high`, `low`, `close`, `volume`, `time`, `syminfo.ticker`, `timeframe.multiplier`, `bar_index`.\n\n* **`reference/constants.md`**\n  * **Content:** Fixed constants used as arguments for functions.\n  * **Keywords:** `color.red`, `shape.triangle`, `plot.style_line`, `size.small`, `alert.freq_once_per_bar`.\n\n* **`reference/types.md`**\n  * **Content:** Data type definitions and type-casting functions.\n  * **Keywords:** `int`, `float`, `bool`, `color`, `string`, `line`, `label`, `box`, `simple`, `series`, `input`.\n\n* **`reference/keywords.md`**\n  * **Content:** Language keywords and control structures.\n  * **Keywords:** `if`, `else`, `switch`, `for`, `while`, `export`, `import`, `method`.",
    "keywords": [
      "e.g",
      "execution_model.md",
      "timeframes.md",
      "request.security",
      "timeframe.period",
      "colors_and_display.md",
      "color.new",
      "color.from_gradient",
      "common_errors.md",
      "variables.md",
      "syminfo.ticker",
      "timeframe.multiplier",
      "constants.md",
      "color.red",
      "shape.triangle",
      "plot.style_line",
      "size.small",
      "alert.freq_once_per_bar",
      "types.md",
      "keywords.md",
      "input",
      "plot",
      "bgcolor",
      "alert",
      "var",
      "varip",
      "series",
      "simple",
      "const",
      "export",
      "import",
      "method",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-1",
    "type": "documentation",
    "source": "LLM_MANIFEST.md",
    "section": "root",
    "title": "üß≠ Routing Logic for LLMs",
    "content": "## 3. Function Reference (By Namespace)\n\n*Use these files to find syntax for specific function calls.*\n\n* **`reference/functions/ta.md` (Technical Analysis)**\n  * **Content:** Math for indicators and signal generation.\n  * **Keywords:** `ta.rsi`, `ta.sma`, `ta.ema`, `ta.macd`, `ta.crossover`, `ta.lowest`, `ta.highest`, `ta.pivot`.\n\n* **`reference/functions/strategy.md` (Backtesting)**\n  * **Content:** Strategy testing engine, orders, and trade management.\n  * **Keywords:** `strategy.entry`, `strategy.close`, `strategy.exit`, `strategy.position_size`, `strategy.equity`, `strategy.risk`.\n\n* **`reference/functions/request.md` (External Data)**\n  * **Content:** Requesting data from other symbols, financial data, or seeds.\n  * **Keywords:** `request.security`, `request.financial`, `request.seed`, `request.currency_rate`.\n\n* **`reference/functions/drawing.md` (Visuals)**\n  * **Content:** Plotting data on the chart and drawing geometric shapes.\n  * **Keywords:** `plot`, `plotshape`, `plotchar`, `line.new`, `box.new`, `label.new`, `polyline.new`, `fill`.\n\n* **`reference/functions/collections.md` (Arrays, Maps, Matrices)**\n  * **Content:** Advanced data structures for complex logic.\n  * **Keywords:** `array.new`, `array.push`, `matrix.new`, `matrix.mult`, `map.new`, `map.put`.\n\n* **`reference/functions/general.md` (Math, Strings, Inputs)**\n  * **Content:** Core math, string manipulation, and user inputs.\n  * **Keywords:** `math.abs`, `math.round`, `str.tostring`, `str.format`, `input.int`, `input.bool`, `alert()`.\n\n## üß≠ Routing Logic for LLMs\n\n* **IF** user asks \"Write an RSI indicator\":\n  * retrieve `reference/functions/ta.md` (for RSI math)\n  * retrieve `reference/functions/drawing.md` (for `plot` and `hline`)\n\n* **IF** user asks \"Create a moving average crossover strategy\":\n  * retrieve `reference/functions/ta.md` (for `ta.crossover`)\n  * retrieve `reference/functions/strategy.md` (for `strategy.entry`)\n\n* **IF** user asks \"Draw a box around the high and low of the last 10 bars\":\n  * retrieve `reference/functions/drawing.md` (for `box.new`)\n  * retrieve `reference/functions/ta.md` (for `ta.highest`, `ta.lowest`)\n\n* **IF** user asks \"Why is my variable resetting every bar?\":\n  * retrieve `concepts/execution_model.md` (check `var` usage)",
    "keywords": [
      "ta.md",
      "ta.rsi",
      "ta.sma",
      "ta.ema",
      "ta.macd",
      "ta.crossover",
      "ta.lowest",
      "ta.highest",
      "ta.pivot",
      "strategy.md",
      "strategy.entry",
      "strategy.close",
      "strategy.exit",
      "strategy.position_size",
      "strategy.equity",
      "strategy.risk",
      "request.md",
      "request.security",
      "request.financial",
      "request.seed",
      "request.currency_rate",
      "drawing.md",
      "line.new",
      "box.new",
      "label.new",
      "polyline.new",
      "collections.md",
      "array.new",
      "array.push",
      "matrix.new",
      "matrix.mult",
      "map.new",
      "map.put",
      "general.md",
      "math.abs",
      "math.round",
      "str.tostring",
      "str.format",
      "input.int",
      "input.bool",
      "execution_model.md",
      "indicator",
      "strategy",
      "input",
      "plot",
      "hline",
      "fill",
      "alert",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-2",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Constant  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)",
    "content": "# [Colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#colors)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/visuals/colors/#introduction)\n\nScript visuals can play a critical role in the usability of the indicators we write in Pine Script¬Æ. Well-designed plots and drawings make indicators easier to use and understand. Good visual designs establish a visual hierarchy that allows the more important information to stand out, and the less important one to not get in the way.\n\nUsing colors in Pine can be as simple as you want, or as involved as your concept requires. The 4,294,967,296 possible assemblies of color and transparency available in Pine Script can be applied to:\n\n-   Any element you can plot or draw in an indicator‚Äôs visual space, be it lines, fills, text or candles.\n-   The background of a script‚Äôs visual space, whether the script is running in its own pane, or in overlay mode on the chart.\n-   The color of bars or the body of candles appearing on a chart.\n\nA script can only color the elements it places in its own visual space. The only exception to this rule is that a pane indicator can color chart bars or candles.\n\nPine Script has built-in colors such as  [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green), as well as functions like  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  which allow you to dynamically generate any color in the RGBA color space.\n\n### [Transparency](https://www.tradingview.com/pine-script-docs/visuals/colors/#transparency)\n\nEach color in Pine Script is defined by four values:\n\n-   Its red, green and blue components (0-255), following the  [RGB color model](https://en.wikipedia.org/wiki/RGB_color_space).\n-   Its transparency (0-100), often referred to as the Alpha channel outside Pine, as defined in the  [RGBA color model](https://en.wikipedia.org/wiki/RGBA_color_model). Even though transparency is expressed in the 0-100 range, its value can be a ‚Äúfloat‚Äù when used in functions, which gives you access to the 256 underlying values of the alpha channel.\n\nThe transparency of a color defines how opaque it is: zero is fully opaque, 100 makes the color ‚Äî whichever it is ‚Äî invisible. Modulating transparency can be crucial in more involved color visuals or when using backgrounds, to control which colors dominate the others, and how they mix together when superimposed.",
    "keywords": [
      "www.tradingview",
      "color.green",
      "const_color.green",
      "color.rgb",
      "fun_color.rgb",
      "en.wikipedia",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "simple",
      "const",
      "import",
      "for"
    ]
  },
  {
    "id": "doc-3",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Conditional  coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)",
    "content": "## [Constant  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)\n\nThere are 17 built-in colors in Pine Script. This table lists their names, hexadecimal equivalent, and RGB values as arguments to  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb):\n\nName\n\nHex\n\nRGB values\n\ncolor.aqua\n\n#00BCD4\n\ncolor.rgb(0, 188, 212)\n\ncolor.black\n\n#363A45\n\ncolor.rgb(54, 58, 69)\n\ncolor.blue\n\n#2196F3\n\ncolor.rgb(33, 150, 243)\n\ncolor.fuchsia\n\n#E040FB\n\ncolor.rgb(224, 64, 251)\n\ncolor.gray\n\n#787B86\n\ncolor.rgb(120, 123, 134)\n\ncolor.green\n\n#4CAF50\n\ncolor.rgb(76, 175, 80)\n\ncolor.lime\n\n#00E676\n\ncolor.rgb(0, 230, 118)\n\ncolor.maroon\n\n#880E4F\n\ncolor.rgb(136, 14, 79)\n\ncolor.navy\n\n#311B92\n\ncolor.rgb(49, 27, 146)\n\ncolor.olive\n\n#808000\n\ncolor.rgb(128, 128, 0)\n\ncolor.orange\n\n#FF9800\n\ncolor.rgb(255, 152, 0)\n\ncolor.purple\n\n#9C27B0\n\ncolor.rgb(156, 39, 176)\n\ncolor.red\n\n#F23645\n\ncolor.rgb(242, 54, 69)\n\ncolor.silver\n\n#B2B5BE\n\ncolor.rgb(178, 181, 190)\n\ncolor.teal\n\n#089981\n\ncolor.rgb(8, 153, 129)\n\ncolor.white\n\n#FFFFFF\n\ncolor.rgb(255, 255, 255)\n\ncolor.yellow\n\n#FDD835\n\ncolor.rgb(253, 216, 53)\n\nThe following script shows three different ways to express  [color.olive](https://www.tradingview.com/pine-script-reference/v6/#const_color.olive)  with 40% transparency. All three methods are functionally equivalent:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-Constant-colors-1.CnlC-u-k_1ibe2x.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Constant colors demo\",  overlay  =  true)  \n  \n// Create a plot using the hex color code equivalent for `color.olive` with `99` as the alpha value (60% opacity).  \nplot(ta.sma(close,  10),  \"10-bar SMA\",  #80800099,  3)  \n// Create a plot using `color.new()` to modify `color.olive` with 40% transparency.  \nplot(ta.sma(close,  30),  \"30-bar SMA\",  color.new(color.olive,  40),  3)  \n// Create a plot using `color.rgb()` with the `r`, `g`, and `b` components of `color.olive` and 40% transparency.  \nplot(ta.sma(close,  50),  \"50-bar SMA\",  color.rgb(128,  128,  0,  40),  3)  \n``\n\nNote that:\n\n-   An alpha value of  `99`  in a hexadecimal color code is equivalent to 60% opacity, meaning the resulting color is 40% transparent.\n-   Transparency does  _not_  affect plot outputs in the status line, price scale, or Data Window. All these locations show the color with 0% transparency.\n\nThe colors in the previous script do not vary as the script executes bar to bar. Sometimes, however, colors need to be created as the script executes on each bar because they depend on conditions that are unknown at compile time, or when the script begins execution on bar zero. For those cases, programmers have two options:\n\n1.  Use conditional statements to select colors from a few pre-determined base colors.\n2.  Build new colors dynamically, by calculating them as the script executes bar to bar, to implement color gradients, for example.",
    "keywords": [
      "www.tradingview",
      "color.rgb",
      "fun_color.rgb",
      "color.aqua",
      "color.black",
      "color.blue",
      "color.fuchsia",
      "color.gray",
      "color.green",
      "color.lime",
      "color.maroon",
      "color.navy",
      "color.olive",
      "color.orange",
      "color.purple",
      "color.red",
      "color.silver",
      "color.teal",
      "color.white",
      "color.yellow",
      "const_color.olive",
      "tradingview.com",
      "ta.sma",
      "color.new",
      "indicator",
      "overlay",
      "plot",
      "var",
      "const",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-4",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Calculated  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)",
    "content": "## [Conditional  coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)\n\nLet‚Äôs say you want to color a moving average in different colors, depending on some conditions you define. To do so, you can use a conditional statement that will select a different color for each of your states. Let‚Äôs start by coloring a moving average in a bull color when it‚Äôs rising, and in a bear color when it‚Äôs not:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-1.D1QaF3Y-_ZumNWi.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Conditional colors\",  \"\",  true)  \nint  lengthInput  =  input.int(20,  \"Length\",  minval  =  2)  \ncolor  maBullColorInput  =  input.color(color.green,  \"Bull\")  \ncolor  maBearColorInput  =  input.color(color.maroon,  \"Bear\")  \nfloat  ma  =  ta.sma(close,  lengthInput)  \n// Define our states.  \nbool  maRising  =  ta.rising(ma,  1)  \n// Build our color.  \ncolor  maColor  =  maRising  ?  maBullColorInput  :  maBearColorInput  \nplot(ma,  \"MA\",  maColor,  2)  \n`\n\nNote that:\n\n-   We provide users of our script a selection of colors for our bull/bear colors.\n-   We define an  `maRising`  boolean variable which will hold  `true`  when the moving average is higher on the current bar than it was on the last.\n-   We define an  `maColor`  variable that is assigned one of our two colors, depending on the value of the  `maRising`  variable. We use the  [ternary operator](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator)  to define our conditional expression.\n\nYou can also use conditional colors to avoid plotting under certain conditions. Here, we plot high and low pivots using a line, but we do not want to plot anything when a new pivot comes in, to avoid the joints that would otherwise appear in pivot transitions. To do so, we test for pivot changes and use  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  as the color value when a change is detected, so that no line is plotted on that bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-2.erY98c4P_Z1OwyIO.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Conditional colors\",  \"\",  true)  \nint  legsInput  =  input.int(5,  \"Pivot Legs\",  minval  =  1)  \ncolor  pHiColorInput  =  input.color(color.olive,  \"High pivots\")  \ncolor  pLoColorInput  =  input.color(color.orange,  \"Low pivots\")  \n// Intialize the pivot level variables.  \nvar  float  pHi  =  na  \nvar  float  pLo  =  na  \n// When a new pivot is detected, save its value.  \npHi  :=  nz(ta.pivothigh(legsInput,  legsInput),  pHi)  \npLo  :=  nz(ta.pivotlow( legsInput,  legsInput),  pLo)  \n// When a new pivot is detected, do not plot a color.  \nplot(pHi,  \"High\",  ta.change(pHi) !=  0  ?  na  :  pHiColorInput,  2,  plot.style_line)  \nplot(pLo,  \"Low\",  ta.change(pLo) !=  0  ?  na  :  pLoColorInput,  2,  plot.style_line)  \n`\n\nTo undertand how this code works, one must first know that  [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivothigh)  and  [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivotlow), used as they are here without an argument to the  `source`  parameter, will return a value when they find a  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)/[low](https://www.tradingview.com/pine-script-reference/v6/#var_low)  pivot, otherwise they return  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n\nWhen we test the value returned by the pivot function for  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  using the  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz)  function, we allow the value returned to be assigned to the  `pHi`  or  `pLo`  variables only when it is not  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), otherwise the previous value of the variable is simply reassigned to it, which has no impact on its value. Keep in mind that previous values of  `pHi`  and  `pLo`  are preserved bar to bar because we use the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword when initializing them, which causes the initialization to only occur on the first bar.\n\nAll that‚Äôs left to do next is, when we plot our lines, to insert a ternary conditional statement that will yield  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  for the color when the pivot value changes, or the color selected in the script‚Äôs inputs when the pivot level does not change.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "color.green",
      "color.maroon",
      "ta.sma",
      "ta.rising",
      "color.olive",
      "color.orange",
      "ta.pivothigh",
      "ta.pivotlow",
      "ta.change",
      "plot.style_line",
      "fun_ta.pivothigh",
      "fun_ta.pivotlow",
      "indicator",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-5",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)",
    "content": "## [Calculated  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)\n\nUsing functions like  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new),  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  and  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient), one can build colors on the fly, as the script executes bar to bar.\n\n[color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  is most useful when you need to generate different transparency levels from a base color.\n\n[color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  is useful when you need to build colors dynamically from red, green, blue, or tranparency components. While  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  creates a color, its sister functions  [color.r()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.r),  [color.g()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.g),  [color.b()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.b)  and  [color.t()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.t)  can be used to extract the red, green, blue or transparency values from a color, which can in turn be used to generate a variant.\n\n[color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  is useful to create linear gradients between two base colors. It determines which intermediary color to use by evaluating a source value against minimum and maximum values.",
    "keywords": [
      "www.tradingview",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "color.r",
      "fun_color.r",
      "color.g",
      "fun_color.g",
      "color.b",
      "fun_color.b",
      "color.t",
      "fun_color.t",
      "var",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-6",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)",
    "content": "### [color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)\n\nLet‚Äôs put  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  to use to create different transparencies for volume columns using one of two bull/bear base colors:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-1.BtEyXAO2_Z2dfpcb.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Volume\")  \n// We name our color constants to make them more readable.  \nvar  color  GOLD_COLOR  =  #CCCC00ff  \nvar  color  VIOLET_COLOR  =  #AA00FFff  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\")  \nint  levelsInput  =  input.int(10,  \"Gradient levels\",  minval  =  1)  \n// We initialize only once on bar zero with `var`, otherwise the count would reset to zero on each bar.  \nvar  float  riseFallCnt  =  0  \n// Count the rises/falls, clamping the range to: 1 to `i_levels`.  \nriseFallCnt  :=  math.max(1,  math.min(levelsInput,  riseFallCnt  +  math.sign(volume  -  nz(volume[1]))))  \n// Rescale the count on a scale of 80, reverse it and cap transparency to <80 so that colors remains visible.  \nfloat  transparency  =  80  -  math.abs(80  *  riseFallCnt  /  levelsInput)  \n// Build the correct transparency of either the bull or bear color.  \ncolor  volumeColor  =  color.new(close  >  open  ?  bullColorInput  :  bearColorInput,  transparency)  \nplot(volume,  \"Volume\",  volumeColor,  1,  plot.style_columns)  \n``\n\nNote that:\n\n-   In the next to last line of our script, we dynamically calculate the column color by varying both the base color used, depending on whether the bar is up or down,  **and**  the transparency level, which is calculated from the cumulative rises or falls of volume.\n-   We offer the script user control over not only the base bull/bear colors used, but also on the number of brightness levels we use. We use this value to determine the maximum number of rises or falls we will track. Giving users the possiblity to manage this value allows them to adapt the indicator‚Äôs visuals to the timeframe or market they use.\n-   We take care to control the maximum level of transparency we use so that it never goes higher than 80. This ensures our colors always retain some visibility.\n-   We also set the minimum value for the number of levels to 1 in the inputs. When the user selects 1, the volume columns will be either in bull or bear color of maximum brightness ‚Äî or transparency zero.",
    "keywords": [
      "color.new",
      "www.tradingview",
      "fun_color.new",
      "tradingview.com",
      "input.color",
      "input.int",
      "math.max",
      "math.min",
      "math.sign",
      "math.abs",
      "plot.style_columns",
      "indicator",
      "input",
      "plot",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-7",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)",
    "content": "### [color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)\n\nIn our next example we use  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  to build colors from RGBA values. We use the result in a holiday season gift for our friends, so they can bring their TradingView charts to parties:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-2.B7PJa61g_ZI19Ev.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Holiday candles\",  \"\",  true)  \nfloat  r  =  math.random(0,  255)  \nfloat  g  =  math.random(0,  255)  \nfloat  b  =  math.random(0,  255)  \nfloat  t  =  math.random(0,  100)  \ncolor  holidayColor  =  color.rgb(r,  g,  b,  t)  \nplotcandle(open,  high,  low,  close,  color  =  holidayColor,  wickcolor  =  holidayColor,  bordercolor  =  holidayColor)  \n`\n\nNote that:\n\n-   We generate values in the zero to 255 range for the red, green and blue channels, and in the zero to 100 range for transparency. Also note that because  [math.random()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random)  returns float values, the float 0.0-100.0 range provides access to the full 0-255 transparency values of the underlying alpha channel.\n-   We use the  [math.random(min, max, seed)](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random)  function to generate pseudo-random values. We do not use an argument for the third parameter of the function:  `seed`. Using it is handy when you want to ensure the repeatability of the function‚Äôs results. Called with the same seed, it will produce the same sequence of values.",
    "keywords": [
      "color.rgb",
      "www.tradingview",
      "fun_color.rgb",
      "tradingview.com",
      "math.random",
      "fun_math.random",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-8",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Mixing  transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)",
    "content": "### [color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)\n\nOur last examples of color calculations will use  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Let‚Äôs first use it in its simplest form, to color a CCI signal in a version of the indicator that otherwise looks like the built-in:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-3.BWe7BFsC_Zg2kjC.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(title=\"CCI line gradient\",  precision=2,  timeframe=\"\")  \nvar  color  GOLD_COLOR  =  #CCCC00  \nvar  color  VIOLET_COLOR  =  #AA00FF  \nvar  color  BEIGE_COLOR  =  #9C6E1B  \nfloat  srcInput  =  input.source(close,  title=\"Source\")  \nint  lenInput  =  input.int(20,  \"Length\",  minval  =  5)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(BEIGE_COLOR,  \"Bear\")  \nfloat  signal  =  ta.cci(srcInput,  lenInput)  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  bearColorInput,  bullColorInput)  \nplot(signal,  \"CCI\",  signalColor)  \nbandTopPlotID  =  hline(100,  \"Upper Band\",  color.silver,  hline.style_dashed)  \nbandBotPlotID  =  hline(-100,  \"Lower Band\",  color.silver,  hline.style_dashed)  \nfill(bandTopPlotID,  bandBotPlotID,  color.new(BEIGE_COLOR,  90),  \"Background\")  \n`\n\nNote that:\n\n-   To calculate the gradient,  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  requires minimum and maximum values against which the argument used for the  `value`  parameter will be compared. The fact that we want a gradient for an unbounded signal like CCI (i.e., without fixed boundaries such as RSI, which always oscillates between 0-100), does not entail we cannot use  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Here, we solve our conundrum by providing values of -200 and 200 as arguments. They do not represent the real minimum and maximum values for CCI, but they are at levels from which we do not mind the colors no longer changing, as whenever the series is outside the  `bottom_value`  and  `top_value`  limits, the colors used for  `bottom_color`  and  `top_color`  will apply.\n-   The color progression calculated by  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  is linear. If the value of the series is halfway between the  `bottom_value`  and  `top_value`  arguments, the generated color‚Äôs RGBA components will also be halfway between those of  `bottom_color`  and  `top_color`.\n-   Many common indicator calculations are available in Pine Script as built-in functions. Here we use  [ta.cci()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.cci)  instead of calculating it the long way.\n\nThe argument used for  `value`  in  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  does not necessarily have to be the value of the line we are calculating. Anything we want can be used, as long as arguments for  `bottom_value`  and  `top_value`  can be supplied. Here, we enhance our CCI indicator by coloring the band using the number of bars since the signal has been above/below the centerline:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-4.-U0l6lwc_Zd5X5K.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(title=\"CCI line gradient\",  precision=2,  timeframe=\"\")  \nvar  color  GOLD_COLOR  =  #CCCC00  \nvar  color  VIOLET_COLOR  =  #AA00FF  \nvar  color  GREEN_BG_COLOR  =  color.new(color.green,  70)  \nvar  color  RED_BG_COLOR  =  color.new(color.maroon,  70)  \nfloat  srcInput  =  input.source(close,  \"Source\")  \nint  lenInput  =  input.int(20,  \"Length\",  minval  =  5)  \nint  stepsInput  =  input.int(50,  \"Gradient levels\",  minval  =  1)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Line: Bull\",  inline  =  \"11\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\",  inline  =  \"11\")  \ncolor  bullBgColorInput  =  input.color(GREEN_BG_COLOR,  \"Background: Bull\",  inline  =  \"12\")  \ncolor  bearBgColorInput  =  input.color(RED_BG_COLOR,  \"Bear\",  inline  =  \"12\")  \n  \n// Plot colored signal line.  \nfloat  signal  =  ta.cci(srcInput,  lenInput)  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  color.new(bearColorInput,  0),  color.new(bullColorInput,  0))  \nplot(signal,  \"CCI\",  signalColor,  2)  \n  \n// Detect crosses of the centerline.  \nbool  signalX  =  ta.cross(signal,  0)  \n// Count no of bars since cross. Capping it to the no of steps from inputs.  \nint  gradientStep  =  math.min(stepsInput,  nz(ta.barssince(signalX)))  \n// Choose bull/bear end color for the gradient.  \ncolor  endColor  =  signal  >  0  ?  bullBgColorInput  :  bearBgColorInput  \n// Get color from gradient going from no color to `endColor`  \ncolor  bandColor  =  color.from_gradient(gradientStep,  0,  stepsInput,  na,  endColor)  \nbandTopPlotID  =  hline(100,  \"Upper Band\",  color.silver,  hline.style_dashed)  \nbandBotPlotID  =  hline(-100,  \"Lower Band\",  color.silver,  hline.style_dashed)  \nfill(bandTopPlotID,  bandBotPlotID,  bandColor,  title  =  \"Band\")  \n``\n\nNote that:\n\n-   The signal plot uses the same base colors and gradient as in our previous example. We have however increased the width of the line from the default 1 to 2. It is the most important component of our visuals; increasing its width is a way to give it more prominence, and ensure users are not distracted by the band, which has become busier than it was in its original, flat beige color.\n-   The fill must remain unobtrusive for two reasons. First, it is of secondary importance to the visuals, as it provides complementary information, i.e., the duration for which the signal has been in bull/bear territory. Second, since fills have a greater z-index than plots, the fill will cover the signal plot. For these reasons, we make the fill‚Äôs base colors fairly transparent, at 70, so they do not mask the plots. The gradient used for the band starts with no color at all (see the  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  used as the argument to  `bottom_color`  in the  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  call), and goes to the base bull/bear colors from the inputs, which the conditional  `endColor`  variable contains.\n-   We provide users with distinct bull/bear color selections for the line and the band.\n-   When we calculate the  `gradientStep`  variable, we use  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz)  on  [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince)  because in early bars of the dataset, when the condition tested has not occurred yet,  [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince)  will return  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Because we use  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz), the value returned is replaced with zero in those cases.",
    "keywords": [
      "color.from_gradient",
      "www.tradingview",
      "fun_color.from_gradient",
      "tradingview.com",
      "input.source",
      "input.int",
      "input.color",
      "ta.cci",
      "color.silver",
      "hline.style_dashed",
      "color.new",
      "i.e",
      "fun_ta.cci",
      "color.green",
      "color.maroon",
      "ta.cross",
      "math.min",
      "ta.barssince",
      "fun_ta.barssince",
      "indicator",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-9",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "content": "## [Mixing  transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)\n\nIn this example we take our CCI indicator in another direction. We will build dynamically adjusting extremes zone buffers using a Donchian Channel (historical highs/lows) calculated from the CCI. We build the top/bottom bands by making them 1/4 the height of the DC. We will use a dynamically adjusting lookback to calculate the DC. To modulate the lookback, we will calculate a simple measure of volatility by keeping a ratio of a short-period ATR to a long one. When that ratio is higher than 50 of its last 100 values, we consider the volatility high. When the volatility is high/low, we decrease/increase the lookback.\n\nOur aim is to provide users of our indicator with:\n\n-   The CCI line colored using a bull/bear gradient, as we illustrated in our most recent examples.\n-   The top and bottom bands of the Donchian Channel, filled in such a way that their color darkens as a historical high/low becomes older and older.\n-   A way to appreciate the state of our volatility measure, which we will do by painting the background with one color whose intensity increases when volatility increases.\n\nThis is what our indicator looks like using the light theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-1.DJ-yTBxm_1VcSbJ.webp)\n\nAnd with the dark theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-2.BJOvmETq_Z1CqQBv.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"CCI DC\",  precision  =  6)  \ncolor  GOLD_COLOR  =  #CCCC00ff  \ncolor  VIOLET_COLOR  =  #AA00FFff  \nint  lengthInput  =  input.int(20,  \"Length\",  minval  =  5)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\")  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function clamps `val` between `min` and `max`.  \nclamp(val,  min,  max) =>  \nmath.max(min,  math.min(max,  val))  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Volatility expressed as 0-100 value.  \nfloat  v  =  ta.atr(lengthInput  /  5) /  ta.atr(lengthInput  *  5)  \nfloat  vPct  =  ta.percentrank(v,  lengthInput  *  5)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Calculate dynamic lookback for DC. It increases/decreases on low/high volatility.  \nbool  highVolatility  =  vPct  >  50  \nvar  int  lookBackMin  =  lengthInput  *  2  \nvar  int  lookBackMax  =  lengthInput  *  10  \nvar  float  lookBack  =  math.avg(lookBackMin,  lookBackMax)  \nlookBack  +=  highVolatility  ?  -2  :  2  \nlookBack  :=  clamp(lookBack,  lookBackMin,  lookBackMax)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Dynamic lookback length Donchian channel of signal.  \nfloat  signal  =  ta.cci(close,  lengthInput)  \n// `lookBack` is a float; need to cast it to int to be used a length.  \nfloat  hiTop  =  ta.highest(signal,  int(lookBack))  \nfloat  loBot  =  ta.lowest( signal,  int(lookBack))  \n// Get margin of 25% of the DC height to build high and low bands.  \nfloat  margin  = (hiTop  -  loBot) /  4  \nfloat  hiBot  =  hiTop  -  margin  \nfloat  loTop  =  loBot  +  margin  \n// Center of DC.  \nfloat  center  =  math.avg(hiTop,  loBot)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Create colors.  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  bearColorInput,  bullColorInput)  \n// Bands: Calculate transparencies so the longer since the hi/lo has changed,  \n// the darker the color becomes. Cap highest transparency to 90.  \nfloat  hiTransp  =  clamp(100  - (100  *  math.max(1,  nz(ta.barssince(ta.change(hiTop) !=  0) +  1)) /  255),  60,  90)  \nfloat  loTransp  =  clamp(100  - (100  *  math.max(1,  nz(ta.barssince(ta.change(loBot) !=  0) +  1)) /  255),  60,  90)  \ncolor  hiColor  =  color.new(bullColorInput,  hiTransp)  \ncolor  loColor  =  color.new(bearColorInput,  loTransp)  \n// Background: Rescale the 0-100 range of `vPct` to 0-25 to create 75-100 transparencies.  \ncolor  bgColor  =  color.new(color.gray,  100  - (vPct  /  4))  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Plots  \n// Invisible lines for band fills.  \nhiTopPlotID  =  plot(hiTop,  color  =  na)  \nhiBotPlotID  =  plot(hiBot,  color  =  na)  \nloTopPlotID  =  plot(loTop,  color  =  na)  \nloBotPlotID  =  plot(loBot,  color  =  na)  \n// Plot signal and centerline.  \np_signal  =  plot(signal,  \"CCI\",  signalColor,  2)  \nplot(center,  \"Centerline\",  color.silver,  1)  \n  \n// Fill the bands.  \nfill(hiTopPlotID,  hiBotPlotID,  hiColor)  \nfill(loTopPlotID,  loBotPlotID,  loColor)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Background.  \nbgcolor(bgColor)  \n``\n\nNote that:\n\n-   We clamp the transparency of the background to a 100-75 range so that it doesn‚Äôt overwhelm. We also use a neutral color that will not distract too much. The darker the background is, the higher our measure of volatility.\n-   We also clamp the transparency values for the band fills between 60 and 90. We use 90 so that when a new high/low is found and the gradient resets, the starting transparency makes the color somewhat visible. We do not use a transparency lower than 60 because we don‚Äôt want those bands to hide the signal line.\n-   We use the very handy  [ta.percentrank()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.percentrank)  function to generate a 0-100 value from our ATR ratio measuring volatility. It is useful to convert values whose scale is unknown into known values that can be used to produce transparencies.\n-   Because we must clamp values three times in our script, we wrote an  `f_clamp()`  function, instead of explicitly coding the logic three times.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "math.max",
      "math.min",
      "ta.atr",
      "ta.percentrank",
      "math.avg",
      "ta.cci",
      "ta.highest",
      "ta.lowest",
      "color.from_gradient",
      "ta.barssince",
      "ta.change",
      "color.new",
      "color.gray",
      "color.silver",
      "fun_ta.percentrank",
      "indicator",
      "input",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "simple",
      "for"
    ]
  },
  {
    "id": "doc-10",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Maintaining automatic color  selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)",
    "content": "## [Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "keywords": [
      "www.tradingview"
    ]
  },
  {
    "id": "doc-11",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Designing usable colors  schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)",
    "content": "### [Maintaining automatic color  selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)\n\nUnder certain conditions, Pine Script can automatically display all of the colors used in a script‚Äôs plots in the ‚ÄúSettings/Style‚Äù menu. These plots are graphics created by all  `plot*()`  functions,  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor). The user can change the colors using a color picker. This feature allows colors in scripts to be customized without any extra code.\n\nFor example, this simple script has a  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  that is colored either teal or red, depending on the relationship between the bar‚Äôs  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  and  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open). The script does not specify that these colors should be editable, nor does it create any color-related inputs. Nevertheless, Pine Script automatically displays the colors in the ‚ÄúSettings/Style‚Äù menu and allows the user to change them, along with the style of the plot:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-1.BHISUteP_LNVpG.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  close  >  open  ?  color.teal  :  color.red  \nplot(close,  color  =  plotColor)  \n`\n\nTipTo prevent the user from changing the color or the type of a plot from a script‚Äôs ‚ÄúSettings/Style‚Äù tab, include  `editable = false`  in the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call.\n\nThe colors in the above script can be automatically displayed in this way because they are  _not dynamically calculated_  and are known as soon as the script has finished compiling. All colors of the  [‚Äúconst‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#const)  type, and all colors of type  [‚Äúinput‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#input)  that are  _not modified_  via the  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  or  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions can be automatically displayed like this.\n\nNoteIf  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  and  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions use a ‚Äúconst color‚Äù and other ‚Äúconst‚Äù parameters, color modifications are calculated during the script‚Äôs compilation, not at its runtime. As a result, they are available when the script finishes compiling and can be displayed in the ‚ÄúSettings/Style‚Äù tab.\n\nHowever, if  _even a single calculated color_  is of type ‚Äúsimple color‚Äù or ‚Äúseries color‚Äù, or if an ‚Äúinput color‚Äù is passed to  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  or  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb),  _all_  colors are calculated in the script‚Äôs runtime, and no color pickers are available in the ‚ÄúStyle‚Äù section.\n\nIn practice, the creation of  [‚Äúsimple‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#simple)  or  [‚Äúseries‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#series)  colors is also most often due to using  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  and  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions. The qualifier of the color that these functions return is the strongest qualifier of the values passed to them. If each call to these functions passes only ‚Äúconst‚Äù values, the resulting colors are also ‚Äúconst‚Äù, and the script  _does_  display them in the ‚ÄúStyle‚Äù menu.\n\nNoticeThe  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  function always returns a ‚Äúseries color‚Äù value, regardless of the parameters passed to it. If it‚Äôs used in a script, all of the script‚Äôs colors are calculated at runtime.\n\nFor example, let‚Äôs try to make the plots in the script above semi-transparent by adding a transparency of  `50`  to its colors via  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new). The easiest way to do this is to wrap the  `plotColor`  variable with  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new), like in the example below:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  color.new(close  >  open  ?  color.teal  :  color.red,  50)  \nplot(close,  color  =  plotColor)  \n`\n\nUnfortunately, with these changes the ‚ÄúStyle‚Äù tab does not display a color picker any longer. This is because we use the ‚Äúseries bool‚Äù condition  `close > open`  to decide the color, and then pass the result of this expression to a single  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  call. The qualified type of the calculated color that it returns is ‚Äúseries color‚Äù.\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-2.BO3w97fq_14utEv.webp)\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-3.B0TUMw_p_Z2hnihX.webp)\n\nTo avoid this, we can ensure that every calculated color created by  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  is a ‚Äúconst color‚Äù. Below, we wrap  [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal)  and  [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color.red)  separately with  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  ‚Äî creating two constant calculated colors in the process ‚Äî and then decide which one to assign to  `plotColor`  based on the condition. And while the  `plotColor`  variable is a ‚Äúseries color‚Äù, each  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  call returns a constant color, so the script displays a color picker in the ‚ÄúStyle‚Äù tab:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  close  >  open  ?  color.new(color.teal,  50) :  color.new(color.red,  50)  \nplot(close,  color  =  plotColor)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-4.B7QSrDzd_18UfnH.webp)\n\nTo calculate the colors at runtime, create custom color inputs for all of the colors that are to be editable. This approach requires more effort, but allows significantly more control over what the user can affect. Learn more about creating color inputs on the  [Inputs page](https://www.tradingview.com/pine-script-docs/concepts/inputs/#color-input).",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.teal",
      "color.red",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "const_color.teal",
      "const_color.red",
      "indicator",
      "input",
      "plot",
      "bgcolor",
      "barcolor",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-12",
    "type": "documentation",
    "source": "concepts/colors_and_display.md",
    "section": "concepts",
    "title": "[Customize  gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)",
    "content": "### [Designing usable colors  schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)\n\nIf you write scripts intended for other traders, try to avoid colors that will not work well in some environments, whether it be for plots, labels, tables or fills. At a minimum, test your visuals to ensure they perform satisfactorily with both the light and dark TradingView themes; they are the most commonly used. Colors such as black and white, for example, should be avoided.\n\nBuild the appropriate inputs to provide script users the flexibility to adapt your script‚Äôs visuals to their particular environments.\n\nTake care to build a visual hierarchy of the colors you use that matches the relative importance of your script‚Äôs visual components. Good designers understand how to achieve the optimal balance of color and weight so the eye is naturally drawn to the most important elements of the design. When you make everything stand out, nothing does. Make room for some elements to stand out by toning down the visuals surrounding it.\n\nProviding a selection of color presets in your inputs ‚Äî rather than a single color that can be changed ‚Äî can help color-challenged users. Our  [Technical Ratings](https://www.tradingview.com/script/Jdw7wW2g-Technical-Ratings/)  demonstrates one way of achieving this.\n\n### [Plot crisp  lines](https://www.tradingview.com/pine-script-docs/visuals/colors/#plot-crisp-lines)\n\nIt is best to use zero transparency to plot the important lines in your visuals, to keep them crisp. This way, they will show through fills more precisely. Keep in mind that fills have a higher z-index than plots, so they are placed on top of them. A slight increase of a line‚Äôs width can also go a long way in making it stand out.\n\nIf you want a special plot to stand out, you can also give it more importance by using multiple plots for the same line. These are examples where we modulate the successive width and transparency of plots to achieve this:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-PlotCrispLines-1.CJkrlPd__Z1Me4S0.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\")  \nplot(high,  \"\",  color.new(color.orange,  80),  8)  \nplot(high,  \"\",  color.new(color.orange,  60),  4)  \nplot(high,  \"\",  color.new(color.orange,  00),  1)  \n  \nplot(hl2,  \"\",  color.new(color.orange,  60),  4)  \nplot(hl2,  \"\",  color.new(color.orange,  00),  1)  \n  \nplot(low,  \"\",  color.new(color.orange,  0),  1)  \n`\n\n### [Customize  gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)\n\nWhen building gradients, adapt them to the visuals they apply to. If you are using a gradient to color candles, for example, it is usually best to limit the number of steps in the gradient to ten or less, as it is more difficult for the eye to perceive intensity variations of discrete objects. As we did in our examples, cap minimum and maximum transparency levels so your visual elements remain visible and do not overwhelm when it‚Äôs not necessary.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.new",
      "color.orange",
      "indicator",
      "input",
      "plot",
      "fill",
      "var",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-13",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "# Error  messages\n\n## The if statement is too  long\n\nThis error occurs when the indented code (local block) inside an  [`if` structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures/#if-structure)  is too large for the compiler. Because of how the compiler works, you won‚Äôt receive a message telling you exactly how many lines of code you are over the limit. The only solution now is to split the structure into smaller parts (functions or smaller  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  statements). The example below shows a reasonably lengthy  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  statement; theoretically, this would throw  `line 4: if statement is too long`:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"My script\")\n\nvar e = 0\nif barstate.islast\n    a = 1\n    b = 2\n    c = 3\n    d = 4\n    e := a + b + c + d\n\nplot(e)\n```\n\n## Script requesting too many  securities\n\nThe maximum number of securities in script is limited to 40. If you declare a variable as a  `request.security`  function call and then use that variable as input for other variables and calculations, it will not result in multiple  `request.security`  calls. But if you will declare a function that calls  `request.security`  --- every call to this function will count as a  `request.security`  call.\n\nIt is not easy to say how many securities will be called looking at the source code. Following example have exactly 3 calls to  `request.security`  after compilation:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Securities count\")\na = request.security(syminfo.tickerid, '42', close)  // (1) first unique security call\nb = request.security(syminfo.tickerid, '42', close)  // same call as above, will not produce new security call after optimizations\n\nplot(a)\nplot(a + 2)\nplot(b)\n\nsym(p) =>  // no security call on this line\n    request.security(syminfo.tickerid, p, close)\nplot(sym('D'))  // (2) one indirect call to security\nplot(sym('W'))  // (3) another indirect call to security\n\nc = request.security(syminfo.tickerid, timeframe.period, open)  // result of this line is never used, and will be optimized out\n```\n\n## Script could not be translated from:  null\n\n### Code Example\n```pine\nstudy($)\n```\n\nUsually this error occurs in version 1 Pine scripts, and means that code is incorrect. Pine Script¬Æ of version 2 (and higher) is better at explaining errors of this kind. So you can try to switch to version 2 by adding a  [special attribute](https://www.tradingview.com/pine-script-docs/language/script-structure/#version)  in the first line. You‚Äôll get  `line 2: no viable alternative at character '$'`:\n\n### Code Example\n```pine\n// @version=2\nstudy($)\n```\n\n## line 2: no viable alternative at character  ‚Äô$‚Äô\n\nThis error message gives a hint on what is wrong.  `$`  stands in place of string with script title. For example:\n\n### Code Example\n```pine\n// @version=2\nstudy(\"title\")\n```\n\n## Mismatched input <‚Ä¶> expecting <???>\n\nSame as  `no viable alternative`, but it is known what should be at that place. Example:",
    "keywords": [
      "www.tradingview",
      "barstate.islast",
      "request.security",
      "syminfo.tickerid",
      "timeframe.period",
      "indicator",
      "input",
      "plot",
      "var",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-14",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "The requested historical offset (X) is beyond the historical buffer‚Äôs limit  (Y)",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"My Script\")\n    plot(1)\n```\n\n`line 3: mismatched input 'plot' expecting 'end of line without line continuation'`\n\nTo fix this you should start line with  `plot`  on a new line without an indent:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"My Script\")\nplot(1)\n``` \n\n## Loop is too long (> 500  ms)\n\nWe limit the computation time of loop on every historical bar and realtime tick to protect our servers from infinite or very long loops. This limit also fail-fast indicators that will take too long to compute. For example, if you‚Äôll have 5000 bars, and indicator takes 500 milliseconds to compute on each of bars, it would have result in more than 16 minutes of loading:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Loop is too long\", max_bars_back = 101)\ns = 0\nfor i = 1 to 1e3  // to make it longer\n    for j = 0 to 100\n        if timestamp(2017, 02, 23, 00, 00) <= time[j] and time[j] < timestamp(2017, 02, 23, 23, 59)\n            s := s + 1\nplot(s)\n``` \n\nIt might be possible to optimize algorithm to overcome this error. In this case, algorithm may be optimized like this:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Loop is too long\", max_bars_back = 101)\nbar_back_at(t) =>\n    i = 0\n    step = 51\n    for j = 1 to 100\n        if i < 0\n            i := 0\n            break\n        if step == 0\n            break\n        if time[i] >= t\n            i := i + step\n            i\n        else\n            i := i - step\n            i\n        step := step / 2\n        step\n    i\n\ns = 0\nfor i = 1 to 1e3  // to make it longer\n    s := s - bar_back_at(timestamp(2017, 02, 23, 23, 59)) +\n         bar_back_at(timestamp(2017, 02, 23, 00, 00))\n    s\nplot(s)\n``` \n\n## Script has too many local  variables\n\nThis error appears if the script is too large to be compiled. A statement  `var=expression`  creates a local variable for  `var`. Apart from this, it is important to note, that auxiliary variables can be implicitly created during the process of a script compilation. The limit applies to variables created both explicitly and implicitly. The limitation of 1000 variables is applied to each function individually. In fact, the code placed in a  _global_  scope of a script also implicitly wrapped up into the main function and the limit of 1000 variables becomes applicable to it. There are few refactorings you can try to avoid this issue:\n\n### Code Example\n```pine\nvar1 = expr1\nvar2 = expr2\nvar3 = var1 + var2\n``` \n\ncan be converted into:\n\n### Code Example\n```pine\nvar3 = expr1 + expr2\n```",
    "keywords": [
      "indicator",
      "input",
      "plot",
      "var",
      "import",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-15",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "## The requested historical offset (X) is beyond the historical buffer‚Äôs limit  (Y)\n\nPine scripts calculate on every bar on the chart, sequentially, left to right, maintaining a historical buffer of values. When a script needs to use a value from a previous bar, it takes that value from the buffer. If a script tries to access a value from a bar further back than the historical buffer extends, it throws this error.\n\nAs a simple example, if your code includes a line like  `plot(myVar[500])`, the script keeps a buffer of the last 500 historical values of the  `myVar`  variable. This buffer ensures that on every execution, the  `myVar`  variable has access to its value 500 bars before the current one.\n\nPine creates the historical buffer in a way that minimizes issues:\n\n-   Initially, the script calculates the historical buffers based on the data from the first several hundred bars. If historical offsets are constant, or if future offsets are not greater than the offsets found during this calculation, the script works without issues. The example above does not cause any issues because the variable is called in the global scope with a constant offset of 500. On the first iteration of the script, it is clear that the buffer size needs to be 500.\n-   If the script requests a value outside the buffer during calculation on historical data, the script tries to adjust the buffer to a proper length automatically. The script increases the buffer and restarts. This can happen several times until either the re-run limit is reached or the script calculates without the error.\n\nThe error can still appear on historical data, but is more likely to occur on realtime data, which is not covered by automatic buffer detection. For example, the following script works when the user first adds it to the chart, but fails with an error when the first realtime tick arrives. This behaviour can be replicated consistently by turning on the Bar Replay feature and pressing Step Forward once. This happens because on historical data, we request  `close[500]`, which establishes the size of the historical buffer as 500. When we request  `close[1000]`  on the first realtime bar, the script returns an error because the requested value is outside the buffer:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Error on realtime bars\")\nmyVar = close[barstate.ishistory ? 500 : 1000]\nplot(myVar)\n``` \n\nTo fix this, we need to ensure the historical buffer of our variable (in this case,  `close`) is always large enough.\n\n> **Notice** The maximum possible buffer size for most variables is 5000, and referring further into the past causes a different runtime error. To avoid that error, programmers can limit the requested offsets by using expressions such as  `math.min(myVar, 5000)`.\n\nThe following sections describe different methods to ensure that the historical buffer is of a sufficient size.\n\n### Potential  fixes\n\n#### Use the ‚Äã`max_bars_back()`‚Äã function\n\nThe  `max_bars_back()` function sets the size of the historical buffer for a particular variable. To fix the issue in the example script above, we need to ensure the buffer for  `close`  is at least 1000:",
    "keywords": [
      "barstate.ishistory",
      "math.min",
      "indicator",
      "plot",
      "var",
      "simple",
      "const",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-16",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Error on realtime bars\")\nmyVar = close[barstate.ishistory ? 500 : 1000]\nmax_bars_back(close, 1000)\nplot(myVar)\n``` \n\n#### Use the ‚Äã`max_bars_back`‚Äã parameter of the ‚Äã`indicator()`‚Äã or ‚Äã`strategy()`‚Äã function\n\nThe  `max_bars_back`  parameter of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  and  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  functions provides a handy way to increase the historical buffer for  _all_  the variables inside of the script. However, increasing the historical buffer for all variables without a specific need for it negatively impacts performance. Using the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function is preferable because it is more precise and more performant.\n\n> **Notice** When using  `max_bars_back`, choose the  **minimum**  default buffer size that accommodates all the script‚Äôs historical references. Buffer sizes that are larger than what a script requires can significantly impact its performance. For example, using  `max_bars_back = 5000`  in a script that references up to only 700 bars back causes an excessive use of resources.\n\n#### Use the maximum value manually on history to force a proper buffer  size\n\nAnother way to set a specific historical buffer is to call the variable on historical data with the maximum buffer required, regardless of whether it‚Äôs needed or not at the moment. For example, the script below assigns the  `myVar`  variable a  `close[1000]`  value on the very first bar of the dataset. It makes no practical difference ‚Äî on the first bar, all past values are  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  ‚Äî but because of this change, the script sets the variable‚Äôs buffer to 1000 and can then work on realtime bars without issues:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Error on realtime bars\")\nmyVar = close[barstate.isfirst ? 1000 : barstate.ishistory ? 500 : 1000]\nplot(myVar)\n``` \n\n### Max bars back with Pine  drawings\n\nA common reason for the historical offset error is creating drawings that are drawn on realtime data, but extend into the past. For example, the code below runs into the runtime error as soon as the first realtime tick arrives:",
    "keywords": [
      "barstate.ishistory",
      "www.tradingview",
      "barstate.isfirst",
      "indicator",
      "strategy",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-17",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Returning collections from ‚Äã`request.*()`‚Äã functions",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Realtime error with drawings\")\n\nif barstate.isrealtime\n    line.new(bar_index[500], close, bar_index, close)\n``` \n\n> **Note** eAll Pine drawings that anchor to the chart convert their horizontal coordinates into  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  values internally, even if the programmer defines those coordinates using  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  values.\n\nWhen the example indicator above is calculating on historical data, it does not draw any lines, and so does not call the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  series at all. In this case, the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  series takes the default buffer size of 300. On realtime bars, we then request the  `bar_index[500]`  value, which is converted into  `time[500]`  by the function. But the script doesn‚Äôt have a large enough historical buffer, which causes the error to appear.\n\nIn these cases, the historical buffer for the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  series must be enlarged, even if the drawing functions use  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  exclusively. The easiest fix is to call the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function on the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  series, to ensure that its buffer is large enough:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Realtime error with drawings\")\n\nmax_bars_back(time, 500)\n\nif barstate.isrealtime\n    line.new(bar_index[500], close, bar_index, close)\n``` \n\n## Memory limits  exceeded\n\nThe most common cause of this error is the retrieval of  [objects](https://www.tradingview.com/pine-script-docs/language/objects/#objects)  and  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  from  `request.*()`  functions such as  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security). Other possible causes include unnecessary drawing updates, excess historical buffer capacity, or inefficient use of  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back).",
    "keywords": [
      "barstate.isrealtime",
      "line.new",
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "indicator",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-18",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "### Returning collections from ‚Äã`request.*()`‚Äã functions\n\nThe ‚ÄúMemory limits exceeded‚Äù error most often occurs when a script uses  `request.*()`  functions to retrieve  [objects](https://www.tradingview.com/pine-script-docs/language/objects/#objects)  or  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  from another symbol or timeframe.\n\nWhen requesting data from other contexts, the data for  _each bar_  is copied and stored in memory to allow the script to reference it later in the main context. This can use a lot of memory, depending on the data. Requesting large collections can easily lead to excessive memory consumption.\n\nThe example script below uses  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  to retrieve the result of a  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  evaluated on the ‚Äú1D‚Äù timeframe. The custom function (`dataFunction()`) creates an array and assigns its reference to a persistent variable declared  [using the `var` keyword](https://www.tradingview.com/pine-script-docs/language/arrays/#using-var-and-varip-keywords), then pushes a new  [balance of power (BOP)](https://www.tradingview.com/support/solutions/43000589100-balance-of-power-bop/)  value into the array and returns the collection‚Äôs reference on each bar. Each time that  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  evaluates the  `dataFunction()`  call on the ‚Äú1D‚Äù timeframe, the result references a  _new copy_  of that array. Retrieving a new array from a requested context on each bar consumes a lot of memory. Therefore, this script can  _exceed_  the memory limits when running on symbols with a sufficiently lengthy history:",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "var",
      "varip",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-19",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "How do I fix  this?",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"BOP array in higher timeframe context\", \"Memory limit demo\")\n\n//@variable User-input length for calculating average of BOP values. \nint avgLength = input.int(5, \"Average BOP Length\", minval = 1)\n\n//Returns a copy of the `dataArray` on every bar, which uses a lot of memory.\ndataFunction() => \n    //@variable Persistent array containing the \"balance of power\" (BOP) values for all bars from the higher timeframe.\n    var array<float> dataArray = array.new<float>(0)\n\n    //@variable The \"balance of power\" percentage calculated for the current bar.\n    float bop = (close - open) / (high - low) * 100\n    dataArray.push(bop)\n\n    //Return the full collection.\n    dataArray\n\n// Request the full BOP array from the 1D timeframe.\narray<float> reqData = request.security(syminfo.tickerid, \"1D\", dataFunction())\n\n// Plot zero line.\nhline(0, \"Zero line\", color.gray, hline.style_dotted)\n\n// Latest BOP value and average BOP are calculated in the main context if `reqData` is not `na`.\n//@variable The latest BOP value from the `reqData` array.\nfloat latestValue = na\n//@variable The average of the last `avgLength` BOP values.\nfloat avgBOP = na\n\nif not na(reqData)\n    // Retrieve BOP value for the current main context bar.\n    latestValue := reqData.last()\n\n    // Calculate the average BOP for the most-recent values from the higher timeframe array.\n    //@variable Size of the `reqData` array returned from the higher timeframe.\n    int dataSize = reqData.size()\n    //@variable A subset of the latest values from the `reqData` array. Its size is determined by the `avgLength` set.\n    array<float> lastValues = dataSize >= avgLength ? reqData.slice(dataSize - avgLength, dataSize): reqData\n    avgBOP := lastValues.avg()\n\n// Plot the BOP value and average line.\ncolor plotColor = latestValue >= 0 ? color.aqua : color.orange\nplot(latestValue, \"BOP\", plotColor, style = plot.style_columns)\nplot(avgBOP, \"Avg\", color.purple, linewidth = 3)\n```",
    "keywords": [
      "input.int",
      "array.new",
      "request.security",
      "syminfo.tickerid",
      "color.gray",
      "hline.style_dotted",
      "color.aqua",
      "color.orange",
      "plot.style_columns",
      "color.purple",
      "indicator",
      "input",
      "plot",
      "hline",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-20",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "### How do I fix  this?\n\nOptimize requests and limit the data returned to the main context to ensure that only the  _minimum necessary_  data is stored in memory.\n\nIf possible, try to return  _calculated results_  directly rather than returning the collections themselves, or only return collections  _conditionally_, when they are necessary in the main context.\n\nLet‚Äôs consider a few common scenarios where scripts need specific data in the main context.\n\n#### Return last state  only\n\nIf a script requires only the  _latest_  state of a requested collection, use a  [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  or expression with  [barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.islast)  as the condition to limit retrieving a copy of that collection to the last available bar.\n\nHere, we modified our script to display only the  _latest_  average BOP (a single value), rather than plotting an average line. The updated request function now returns the calculated BOP values directly for each bar, and returns the higher timeframe‚Äôs array only on the last bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Errors-Return-last-state-only.B7DlHDxT_1Srw3K.webp)",
    "keywords": [
      "www.tradingview",
      "barstate.islast",
      "var_barstate.islast",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-21",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"BOP array on last bar\", \"Memory limit demo\")\n\n//@variable User-input length for calculating average of BOP values. \nint avgLength = input.int(5, \"Average BOP Length\", minval = 1)\n\n// Returns the calculated `bop` each bar, and a copy of the `dataArray` on the last bar or `na` otherwise.\ndataFunction() => \n    //@variable Persistent array containing the \"balance of power\" (BOP) values for all higher timeframe bars.\n    var array<float> dataArray = array.new<float>(0)\n\n    //@variable The \"balance of power\" percentage calculated for the current higher timeframe bar.\n    float bop = (close - open) / (high - low) * 100\n    dataArray.push(bop)\n\n    // Return the collection on the last bar only.\n    if barstate.islast\n        [bop, dataArray]\n    else \n        [bop, na]\n\n// Request calculated BOP value, and BOPs array if on last bar, from the higher timeframe.\n[reqValue, reqData] = request.security(syminfo.tickerid, \"1D\", dataFunction())\n\n// Plot zero line.\nhline(0, \"Zero line\", color.gray, hline.style_dotted)\n\n// Plot the BOP value for each main context bar.\ncolor plotColor = reqValue >= 0 ? color.aqua : color.orange\nplot(reqValue, \"BOP\", plotColor, style = plot.style_columns)\n\n// Calculate the average BOP for most-recent values from the higher timeframe array, and display result in a table cell.\nif not na(reqData)\n    //@variable Size of the `reqData` array returned from the higher timeframe.\n    int dataSize = reqData.size()\n    //@variable A subset of the latest values from the `reqData` array. Its size is determined by the `avgLength` set.\n    array<float> lastValues = dataSize >= avgLength ? reqData.slice(dataSize - avgLength, dataSize): reqData\n    //@variable The average of the last `avgLength` BOP values.\n    float avgBOP = lastValues.avg()\n\n    // Display latest average value in a single-cell table.\n    var table displayTable = table.new(position.bottom_right, 1, 1, color.purple)\n    displayTable.cell(0, 0, \"Avg of last \" + str.tostring(avgLength) + \" BOPs: \" + str.tostring(avgBOP, \"##.##\") + \"%\", \n         text_color = color.white)\n``` \n\n#### Return calculated  results\n\nIf a script needs the  _result_  of a calculation on a collection, but does not need the collection itself in the main context, use a  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  as the request expression. The function can calculate on the collection in the  _requested_  context and return only the result to the main context.\n\nFor example, we can calculate the average BOP directly within our request function. Therefore, only the calculated values are stored in memory, and the request expression returns a tuple (current BOP and average BOP) to plot the results in the main context:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Errors-Return-calculated-results.Do61vtAy_Z1MO38Y.webp)",
    "keywords": [
      "input.int",
      "array.new",
      "barstate.islast",
      "request.security",
      "syminfo.tickerid",
      "color.gray",
      "hline.style_dotted",
      "color.aqua",
      "color.orange",
      "plot.style_columns",
      "table.new",
      "position.bottom_right",
      "color.purple",
      "str.tostring",
      "color.white",
      "www.tradingview",
      "indicator",
      "input",
      "plot",
      "hline",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-22",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Return BOP results only\", \"Memory limit demo\")\n\n//@variable User-input length for calculating average of BOP values. \nint avgLength = input.int(5, \"Average BOP Length\", minval = 1)\n\n// Returns the calculated `bop` and `avgBOP` values directly.\ndataFunction() => \n    //@variable Persistent array containing the \"balance of power\" (BOP) values for all higher timeframe bars.\n    var array<float> dataArray = array.new<float>(0)\n\n    //@variable The \"balance of power\" percentage calculated for the current higher timeframe bar.\n    float bop = (close - open) / (high - low) * 100\n    dataArray.push(bop)\n\n    // Calculate the average BOP for the `avgLength` most-recent values.\n    //@variable Size of the `dataArray`.\n    int dataSize = dataArray.size()\n    //@variable A subset of the latest values from the `dataArray`. Its size is determined by the `avgLength` set.\n    array<float> lastValues = dataSize >= avgLength ? dataArray.slice(dataSize - avgLength, dataSize): dataArray\n    //@variable The average of the last `avgLength` BOP values.\n    float avgBOP = lastValues.avg()\n\n    //Return the calculated results.\n    [bop, avgBOP]\n\n// Request BOP and average BOP values from the higher timeframe.\n[reqValue, reqAverage] = request.security(syminfo.tickerid, \"1D\", dataFunction())\n\n// Plot zero line.\nhline(0, \"Zero line\", color.gray, hline.style_dotted)\n\n// Plot the BOP value and average line.\ncolor plotColor = reqValue >= 0 ? color.aqua : color.orange\nplot(reqValue, \"BOP\", plotColor, style = plot.style_columns)\nplot(reqAverage, \"Avg\", color.purple, linewidth = 3)\n``` \n\n#### Return the collection on some  bars\n\nIf a script needs to retrieve a collection in the main context, but  _not_  on  _every bar_, use  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  or expressions that return collection references only the necessary bars, and  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  on other bars. The logic in the main context can then handle the  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  gaps in the series and perform necessary actions on the reduced collections.\n\nFor example, if we want to calculate the average BOP for each  _month_  instead of using a user-input length, we can return the array reference from the requested context only when there is a change to a new month;  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  otherwise. We can then maintain the previous month‚Äôs values in the main context to keep a valid array for all intra-month bars:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Errors-Return-the-collection-on-some-bars.CQvTHovc_iqEih.webp)",
    "keywords": [
      "input.int",
      "array.new",
      "request.security",
      "syminfo.tickerid",
      "color.gray",
      "hline.style_dotted",
      "color.aqua",
      "color.orange",
      "plot.style_columns",
      "color.purple",
      "www.tradingview",
      "indicator",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-23",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Other possible error sources and their  fixes",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Monthly BOP array\", \"Memory limit demo\")\n\n// Returns the calculated `bop`, and a copy of the `dataArray` on a month's first trading day only, or `na` otherwise.\ndataFunction() => \n    //@variable Persistent array containing the \"balance of power\" (BOP) values for all higher timeframe bars.\n    var array<float> dataArray = array.new<float>(0)\n\n    // When a new month starts, return monthly data array to calculate average BOP for completed month.\n    //@variable Array is `na` except on first trading day of each month, when it contains completed month's BOP values. \n    array<float> returnArray = na\n    //@variable Is `true` on the first bar of each month, `false` otherwise.\n    bool isNewMonth = timeframe.change(\"1M\")\n    if isNewMonth\n        returnArray := dataArray\n    //Clear persistent array to start storing new month's data.\n    if isNewMonth[1]\n        dataArray.clear()\n\n    //@variable The \"balance of power\" percentage calculated for the current higher timeframe bar.\n    float bop = (close - open) / (high - low) * 100\n    dataArray.push(bop)\n\n    //Return the calculated result and the `returnArray`.\n    [bop, returnArray]\n\n// Request BOP data from the higher timeframe. (Returns calculated BOP and array of BOP values if new month starts)\n[reqValue, reqData] = request.security(syminfo.tickerid, \"1D\", dataFunction())\n\n// Calculate the average BOP for the most-recent completed month.\n//@variable Persistent array that holds the BOP values for the most-recent completed month.\nvar array<float> completedMonthBOPs = array.new<float>(0)\n// If new month starts (i.e., `reqData` is not returned as `na`), then `completedMonthBOPs` is updated with new values.\n// Otherwise, it persists the last valid values for the rest of the month to adjust for `na` gaps.\ncompletedMonthBOPs := na(reqData) ? completedMonthBOPs : reqData\n//@variable The average BOP for the most-recent completed month.\nfloat avgBOP = completedMonthBOPs.avg()\n\n// Plot the BOP value and average line.\ncolor plotColor = reqValue >= 0 ? color.aqua : color.orange\nplot(reqValue, \"BOP\", plotColor, style = plot.style_columns)\nplot(avgBOP, \"Avg\", color.purple, linewidth = 3)\n```",
    "keywords": [
      "array.new",
      "timeframe.change",
      "request.security",
      "syminfo.tickerid",
      "i.e",
      "color.aqua",
      "color.orange",
      "plot.style_columns",
      "color.purple",
      "indicator",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-24",
    "type": "documentation",
    "source": "concepts/common_errors.md",
    "section": "concepts",
    "title": "Other possible error sources and their  fixes",
    "content": "### Other possible error sources and their  fixes\n\nThere are a few other ways to optimize scripts to consume less memory.\n\n#### Minimize ‚Äã`request.*()`‚Äã calls\n\nThe  `request.*()`  functions can be computationally expensive to call, because they retrieve data from additional datasets. Data requests often require significant usage of runtime and memory resources. Excessive or inefficient requests can easily cause scripts to reach the memory limit.\n\nThis memory consumption is especially substantial for scripts requesting data from  [lower timeframes](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#lower-timeframes), because the  [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf)  function returns  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  of intrabar data for  _each_  bar in the script‚Äôs main dataset. For example, requesting data from the ‚Äú1‚Äù (one-minute) timeframe on a ‚Äú1D‚Äù chart returns hundreds of minute bars for each ‚Äú1D‚Äù bar where the request executes. In the process, the script must allocate memory to store each requested array so that it can access them later in the main context. Maintaining that much data in memory requires a significant amount of resources.\n\nProgrammers can reduce the memory requirements of a script‚Äôs requests by:\n\n-   Removing  _unnecessary_  `request.*()`  function calls.\n-   Changing the timeframe of a request to a higher timeframe, effectively reducing the number of retrieved data points.\n-   Condensing multiple requests to the  _same_  context into a single  `request.*()`  call.\n-   Using the  `request.*()`  function‚Äôs  `calc_bars_count`  parameter to restrict the historical bars in the requested dataset.\n\nSee the  [Minimizing `request.*()` calls](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-request-calls)  section of the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page to learn more about optimizing data requests.\n\n#### [Use ‚Äã`max_bars_back`‚Äã only when necessary](https://www.tradingview.com/pine-script-docs/error-messages/#use-max_bars_back-only-when-necessary)\n\nThe  `max_bars_back`  parameter of an  [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  sets the size of the  _historical buffers_  for all series in a script. Each buffer defines the number of historical data points  _maintained in memory_  for the script‚Äôs variables and expressions.\n\nBy default, the Pine Script runtime system automatically allocates an appropriate buffer for each variable and expression. Therefore, using the  `max_bars_back`  parameter or  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function is necessary only when Pine  [cannot determine the referencing length of a series](https://www.tradingview.com/support/solutions/43000587849-i-see-pine-cannot-determine-the-referencing-length-of-a-series-try-using-max-bars-back-error/).\n\nIf you encounter the referencing length error and must manually set the size of a historical buffer using the  `max_bars_back`  parameter or the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function, ensure that you select the  _minimum size_  that accommodates your script‚Äôs historical references. Historical buffers that contain more data points than a script requires use excessive memory resources. Read up on how to optimize using  `max_bars_back`  in  [this Help Center article](https://www.tradingview.com/chart/?solution=43000587849).\n\n#### [Minimize historical buffer  calculations](https://www.tradingview.com/pine-script-docs/error-messages/#minimize-historical-buffer-calculations)\n\nThe Pine Script runtime system automatically creates historical buffers for all variables and expressions in a script. It determines the size of each buffer based on the  _historical references_  that the script performs via the  [[] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  or the functions that reference history internally.\n\nAs a script loads on a dataset, historical references to distant points in the dataset can cause the system to reload the script and increase the size of necessary historical buffers. Each increase to historical buffer sizes leads to increased memory consumption. In some cases, buffer resizing can cause the script to exceed the memory limits. Therefore, ensure a script references only  _necessary_  historical data in its calculations. When possible, modify the script‚Äôs logic to avoid referencing very distant points in history.\n\nSpecifying a  `calc_bars_count`  argument in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement can help reduce memory issues, because it restricts the number of historical bars that the script can use for its calculations. Similarly, using  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  to manually define the appropriate size for a buffer can help reduce buffer calculations. When using this function to specify the size of historical buffers, choose the  **smallest**  possible size that accommodates the script‚Äôs historical references to avoid unnecessary memory use.\n\nTo learn more about historical buffer calculations and how to optimize them, see the  [Minimizing historical buffer calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-historical-buffer-calculations)  section of the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page.\n\n#### Reduce drawing updates for  tables\n\n[Tables](https://www.tradingview.com/pine-script-docs/visuals/tables/)  only display their  _last state_  on a chart. Any updates to a table on historical bars are redundant, because they are not visible. To use the least memory, draw the table  _once_, and fill it on the last bar.\n\nTo create a table object only once, assign the result of the  [table.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.new)  call to a variable declared with the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword. When using  [table.cell()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.cell)  or the available setter functions to modify the table‚Äôs contents, execute those function calls only on the  _last_  available bar ‚Äî where the table‚Äôs latest state is visible ‚Äî by placing the calls in a  [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  that uses  [barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.islast)  as the condition. See the  [Tables](https://www.tradingview.com/pine-script-docs/visuals/tables/)  page to learn more.\n\n#### Do not update drawings on historical  bars\n\nSimilar to tables, any updates to other drawing objects such as  [lines](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#lines)  and  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  on historical bars are never visible to the user. The user sees only the drawing updates executed on  _realtime_  bars.\n\nEliminate updates to historical drawings during executions on historical bars wherever possible. Refer to the  [Reducing drawing updates](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-drawing-updates)  section of the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page for more information.\n\n#### Minimize total drawings stored for a  chart\n\n[Drawing objects](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  such as  [lines](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#lines)  and  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  can consume a lot of memory, especially if a script  _recreates_  drawings unnecessarily.\n\nFor example, if a script draws a line from point  `x1`  to  `x2`, then needs to update the line‚Äôs endpoint (`x2`), it‚Äôs more computationally expensive to delete the existing line and redraw a new line from  `x1`  to  `x3`. Instead, using the  _setter_  function  [line.set_x2()](https://www.tradingview.com/pine-script-reference/v6/#fun_line.set_x2)  to update the existing line‚Äôs endpoint is more efficient.\n\nLook for ways to optimize drawing objects in a script:\n\n-   Reduce unnecessary redrawing by assigning a single drawing object‚Äôs reference to a variable declared with the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword, then modifying that object‚Äôs properties with the available setter functions.\n    \n-   Remove unnecessary chart drawings with the  `*.delete()`  functions (e.g.,  [line.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_line.delete)  and  [label.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.delete)).\n    \n-   Reduce a script‚Äôs drawing limits by specifying values for the  `max_lines_count`,  `max_labels_count`,  `max_boxes_count`, or  `max_polylines_count`  parameters of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement.\n    \n\n#### Filter dates in  strategies\n\nThe total number of trades or orders simulated by  [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  can impact memory consumption. When running strategy scripts that generate frequent orders on large datasets, reduce the number of unnecessary historical orders stored in memory by limiting the  _starting point_  of your strategy.\n\nTo limit the starting point of a strategy, a simple and effective approach is to use a  [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures)  that activates the strategy‚Äôs  [order placement commands](https://www.tradingview.com/pine-script-docs/concepts/strategies/#order-placement-and-cancellation)  only when the bar‚Äôs opening or closing time comes after a specified date.\n\nSee the  [How do I filter trades by a date or time range?](https://www.tradingview.com/pine-script-docs/faq/strategies/#how-do-i-filter-trades-by-a-date-or-time-range)  portion of our  [Strategies FAQ page](https://www.tradingview.com/pine-script-docs/faq/strategies/)  for an example of this technique.",
    "keywords": [
      "www.tradingview",
      "request.security_lower_tf",
      "fun_request.security_lower_tf",
      "table.new",
      "fun_table.new",
      "table.cell",
      "fun_table.cell",
      "barstate.islast",
      "var_barstate.islast",
      "line.set_x",
      "fun_line.set_x",
      "e.g",
      "line.delete",
      "fun_line.delete",
      "label.delete",
      "fun_label.delete",
      "line.set_x2",
      "indicator",
      "strategy",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-25",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Bar-by-bar  execution](https://www.tradingview.com/pine-script-docs/language/execution-model/#bar-by-bar-execution)",
    "content": "# [Execution  model](https://www.tradingview.com/pine-script-docs/language/execution-model/#execution-model)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/language/execution-model/#introduction)\n\nPine Script¬Æ relies on an event-driven, sequential execution model to control how a script‚Äôs compiled source code runs in charts,  [alerts](https://www.tradingview.com/pine-script-docs/concepts/alerts/),  [Deep Backtesting](https://www.tradingview.com/support/solutions/43000666199-what-is-deep-backtesting/)  mode, and the  [Pine Screener](https://www.tradingview.com/support/solutions/43000742436-tradingview-pine-screener-key-features-and-requirements/).\n\nIn contrast to the traditional execution model of most programming languages, Pine‚Äôs runtime system executes a script  _repeatedly_  on the sequence of  _historical bars_  and  _realtime ticks_  in the dataset on which it runs, performing  _separate_  calculations for  _each bar_  as it progresses. After each execution on a closed bar, the necessary data from that execution becomes part of an internal  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series), and the script can use that data in its calculations on subsequent bars.\n\nThis combination of sequential executions and storage enables programmers to use minimal code to write scripts with dynamic calculations that advance across a dataset bar by bar.\n\nThe execution model and time series structure closely connect to the  [type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  ‚Äî together, they define how a script behaves as it runs on a dataset. Although it‚Äôs possible to write simple scripts without understanding these foundational topics, learning about them and their nuances is key to becoming proficient in Pine Script.\n\nThis page explains the execution model in two parts:  [The basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics)  and  [The details](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-details). The first part provides quick, actionable information about the model for beginners. The second part offers an  _advanced_, in-depth breakdown of the model‚Äôs workings and unique behaviors. To make the most of the information on this page, we recommend that newcomers to Pine Script start with  [The basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics), learn about other topics in this manual, and then come back to this page for the advanced details.\n\n## [The  basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics)\n\nThe following sections outline core principles of the execution model for beginners. If you are new to Pine Script, start here.",
    "keywords": [
      "www.tradingview",
      "alert",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-26",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Storing and using data from previous  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#storing-and-using-data-from-previous-bars)",
    "content": "### [Bar-by-bar  execution](https://www.tradingview.com/pine-script-docs/language/execution-model/#bar-by-bar-execution)\n\nThe dataset for a symbol on a given timeframe, as shown on a chart, consists of a sequence of bars representing a  _time series_. Each bar in the sequence represents the price and volume for a specific time period. The first (leftmost) bar on a chart corresponds to the  _earliest_  period, and the last (rightmost) bar corresponds to the  _most recent_  period.\n\nMuch of the power of Pine Script stems from its ability to process this time series data efficiently. When a user runs a script, its code does  _not_  execute just once; it executes from start to end on  _each bar_  in the symbol‚Äôs dataset individually, progressing from the first available bar to the most recent bar. Each separate script execution performs calculations or generates outputs (e.g.,  [plots](https://www.tradingview.com/pine-script-docs/concepts/plots/)) for a  _specific bar_  using the data available on that bar.\n\nA script can retrieve price, volume, and other essential data for each bar on which it executes by using the  [built-in variables](https://www.tradingview.com/pine-script-docs/language/built-ins/#built-in-variables)  that hold bar information, such as  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low),  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume). These variables automatically  _update_  before each new execution to store the values for the  _current bar_.\n\nFor example, the simple script below uses the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  function to display the series of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values (i.e., the closing price of each bar) on the chart:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Bar-by-bar execution demo\",  overlay  =  true,  behind_chart  =  false)  \n  \n// Plot the `close` series on the chart.  \n// This call defines the plotted point for the current bar on each execution.  \nplot(close,  \"Close price\",  chart.fg_color,  5)  \n``\n\nWhen a user first adds this script to their chart, its code executes  _once_  for  _every bar_  in the available dataset. As the script runs on the data, two primary steps occur on each bar:\n\n1.  The  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  variable automatically updates to hold the current bar‚Äôs latest price.\n2.  The  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  function call plots the updated  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value at the current bar‚Äôs position.\n\nWhen the script finishes its run from the first bar to the most recent bar, the result is a simple  _line plot_  showing the progression of closing prices across the chart‚Äôs history:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-1.D5nkQfFJ_1oCMgX.webp)\n\nNote that the above script evaluates the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  function call once for every bar on the chart, not just once in total. On each separate execution, the call defines the plotted point for the current bar: the chart‚Äôs first bar during the first execution, the second bar during the next, and so on.\n\nThis pattern illustrates a key principle of Pine‚Äôs execution model: on each successive execution, a script  _re-evaluates_  function calls and other expressions within its required  _scopes_  to perform separate calculations for the current bar.\n\nNoteThe  [scope](https://www.tradingview.com/pine-script-docs/faq/programming/#what-does-scope-mean)  of an expression is the part of the code where the script can access it. A script evaluates its  _global_  scope  _once_  per execution, i.e., on  _every bar_. In contrast, it evaluates  _local_  scopes ‚Äî such as the code inside  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/),  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/), and  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  ‚Äî  _zero_,  _one_, or  _several_  times per execution, depending on the logic.\n\nRepeated code evaluation also applies to  [variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/). By default, a script does not declare a variable only once throughout its runtime; the script  _re-declares_  that variable and assigns an initial value based on the current bar‚Äôs data during  _each_  new evaluation of its scope.\n\nLet‚Äôs look at a simple example. The following script declares an  `x`  variable of the ‚Äúint‚Äù  [type](https://www.tradingview.com/pine-script-docs/language/type-system/#types)  with an initial value of 0. Then, it increases the variable‚Äôs value by 10 with the addition assignment operator ([+=](https://www.tradingview.com/pine-script-reference/v6/#op_+=)). The script calls  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  to display the value of  `x`  on each bar in a separate pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-2.CYV_XhNc_fPGku.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Repeated declarations demo\")  \n  \n//@variable A user-defined variable. The script declares this variable and initializes it to 0 on *every* execution.  \nint  x  =  0  \n  \n// Increase the value of `x` by 10 on every bar.  \nx  +=  10  \n  \n// Plot the value of `x`.  \n// Because `x` begins at 0 on every execution, and the script adds 10 to that value, the plotted value is always 10.  \nplot(x,  \"`x` value\",  color.blue,  3)  \n``\n\nAs shown above, the script plots a value of 10 on every bar, because the  `x`  variable  _does not_  carry over from bar to bar; the script declares the variable  _repeatedly_. On each bar, the script re-declares  `x`  with an initial value of 0, then adds 10 to that value, resulting in a final value of 10 for every plotted point.\n\nProgrammers can change the behavior of a variable, enabling it to  _persist_  and preserve updates to its value  _across bars_, by including the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword in its declaration, as described in the  [Declaration modes](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes)  section of the  [Variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  page.\n\nBelow, we modify the previous script by adding  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  to the  `x`  declaration. Now, the script declares and initializes  `x`  only  _once_  ‚Äî on the  _first bar_  ‚Äî and that variable persists across  _all_  bars that follow. The script now plots a line that  _increases_  by 10 on each bar, because  `x`  preserves the result from each addition across the chart‚Äôs history. The value changes from 0 to 10 on the first bar, then to 20 on the second, and so on:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-3.2eRg8rX8_ZUqlGK.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Persistent declarations demo\")  \n  \n//@variable A *persistent* variable. The script initializes this variable only on the *first execution*.  \n// The variable preserves all changes to its value on each closed bar.  \nvar  int  x  =  0  \n  \n// Increase the value of `x` by 10 on every bar.  \nx  +=  10  \n  \n// Plot the `x` series on the chart.  \n// Because the script declares `x` using `var` and then increments its value, the value never resets to 0.  \n// The plotted value is 10 on the first bar, 20 on the next, and so on.  \nplot(x,  \"`x` series\",  color.blue,  3)  \n``",
    "keywords": [
      "www.tradingview",
      "e.g",
      "i.e",
      "tradingview.com",
      "chart.fg_color",
      "color.blue",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-27",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Realtime  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#realtime-bars)",
    "content": "### [Storing and using data from previous  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#storing-and-using-data-from-previous-bars)\n\nAs a script runs on a dataset, the states of its variables, function calls, and other expressions are automatically  _committed (saved)_  to an internal  _time series_  on each bar, creating historical trails of previous bar values that the script can access during its calculations on the current bar. The script can use these previous values by doing either of the following:\n\n-   Using the  [[] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator). The number in the square brackets represents how many  _bars back_  from the current bar the script looks to retrieve a past value. For instance,  `close[1]`  retrieves the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value from  _one bar before_  the current bar, and  `close[100]`  retrieves the value from  _100 bars back_.\n-   Calling the  [built-in functions](https://www.tradingview.com/pine-script-docs/language/built-ins/#built-in-functions)  that calculate on past values internally, such as  `ta.*()`  functions. For instance,  `ta.change(close, 10)`  calculates the difference between the current value of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  and its value from 10 bars back.\n\nThe example below uses both of the above techniques to perform calculations based on data from previous bars. The script calculates a series of bar-by-bar price returns and plots the result as color-coded columns. It declares two global variables on each bar:  `priceReturn`  for the calculated returns, and  `returnColor`  for the plot‚Äôs color. The  `priceReturn`  value is the result of dividing the current one-bar change in closing prices (`ta.change(close, 1)`) by the previous bar‚Äôs closing price (`close[1]`). The  `returnColor`  value is  [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal)  if the current value of  `priceReturn`  is higher than the value from the previous bar (`priceReturn[1]`), and  [color.maroon](https://www.tradingview.com/pine-script-reference/v6/#const_color.maroon)  otherwise:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Storing-and-using-data-from-previous-bars-1.CZbtEkeL_Z28dT9i.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Storing and using data from previous bars demo\")  \n  \n//@variable The one-bar price return, based on the current and *previous* bars' `close` values.  \n// This variable's final value on each bar automatically becomes part of the internal time series.  \nfloat  priceReturn  =  ta.change(close,  1) /  close[1]  \n  \n//@variable Is `color.teal` if the `priceReturn` value is above the value on the previous bar; `color.maroon` otherwise.  \ncolor  returnColor  =  priceReturn  >  priceReturn[1] ?  color.teal  :  color.maroon  \n  \n// Plot the current `priceReturn` value as a column, colored using the value of `returnColor`.  \nplot(priceReturn,  \"Price return\",  returnColor,  1,  plot.style_columns)  \n``\n\nNote that:\n\n-   This script does  _not_  plot a column on bar 0 (the  _first_  bar). The  `priceReturn`  value is  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  on that bar, because there is  _no previous bar_  available for the script to reference at that point.\n\nNoticeFor consistency, use historical references only on variables or expressions that the script evaluates on  **every bar**, in the  _global_  scope. A script that references the history of variables or expressions defined in  _local_  scopes ‚Äî such as the code inside an  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  statement ‚Äî can cause  _unintended results_. The compiler warns users about this behavior directly inside the Pine Editor. For  _advanced_  details on this behavior, see the  [Time series in scopes](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series-in-scopes)  section.",
    "keywords": [
      "www.tradingview",
      "ta.change",
      "color.teal",
      "const_color.teal",
      "color.maroon",
      "const_color.maroon",
      "tradingview.com",
      "plot.style_columns",
      "indicator",
      "plot",
      "var",
      "series",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-28",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[The  details](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-details)",
    "content": "### [Realtime  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#realtime-bars)\n\nWhen a script first runs on a chart, all  _closed_  bars in the accessed dataset are  _historical bars_. These bars represent data for elapsed time periods where the final price and volume are  _confirmed_. All indicators execute  **once**  per historical bar.\n\nWhen the rightmost bar on the chart is  _open_, it is a  _realtime bar_. Unlike a historical bar, whose values are final, a realtime bar  _updates_  its values as new price or volume data becomes available. After the bar closes, it becomes an  _elapsed realtime bar_, which is then no longer subject to change as the script runs.\n\nBecause the final values for a realtime bar are  _unknown_  until the bar closes, an indicator executes differently on that bar than it does on historical bars. The script executes not once, but  **repeatedly**  on the realtime bar ‚Äî once for each new  _update (tick)_  ‚Äî to  _recalculate_  its results using the latest data.\n\nNote\n\nOn the open realtime bar, variables such as  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low),  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume)  hold the  _latest_  available values for the bar. These values  **do not**  represent  _confirmed_  data for the bar until the script executes on that bar‚Äôs  _closing tick_.\n\n  \n\nScripts can identify historical and realtime bars, and whether a realtime bar‚Äôs data is confirmed, by using the  [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory),  [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime), and  [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed)  variables. See the  [Bar states](https://www.tradingview.com/pine-script-docs/concepts/bar-states/)  page to learn more.\n\nBefore each recalculation on the realtime bar, the data for a script‚Äôs variables, expressions, and outputs on that bar is  _cleared_, or  _reset_. We refer to this process as  _rollback_. The purpose of rollback is to revert the script to the same confirmed state it had when the realtime bar opened. This process ensures that the script‚Äôs calculations for the bar operate only on the latest available data, without relying on  _temporary data_  from the bar‚Äôs  _previous ticks_.\n\nNoticeA variable can  _escape_  rollback and persist across  _all ticks_  within a bar if its declaration includes the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword. This behavior is helpful for calculations that require data from before a bar‚Äôs closing tick. However, it can also cause  [repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/), because the ticks that occur before a realtime bar‚Äôs close become  **unavailable**  after the script reloads. Refer to the  [Declaration modes](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes)  section of the  [Variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  page to learn more about this keyword.\n\nLet‚Äôs look at rollback and recalculation in action. The following script uses  [ta.stoch()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.stoch)  to calculate the  [Stochastic oscillator](https://www.tradingview.com/support/solutions/43000502332-stochastic-stoch/)  based on the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low)  values over a specified number of bars, then plots the result in a separate pane. It also calls  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  to highlight the background on each realtime bar ‚Äî where  [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime)  is  `true`  ‚Äî for visual reference:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Recalculation on realtime bars demo\")  \n  \n//@variable The number of bars in the Stochastic calculation. Users can change this value in the \"Settings/Inputs\" tab.  \nint  lengthInput  =  input.int(10,  \"Length\",  1)  \n  \n//@variable The Stochastic oscillator, based on the `close`, `high`, and `low` values over `lengthInput` bars.  \nfloat  stochastic  =  ta.stoch(close,  high,  low,  lengthInput)  \n  \n// Plot the `stochastic` value for each bar.  \nplot(stochastic,  \"Stochastic %K\",  color.teal,  3)  \n// Highlight the background of each realtime bar.  \nbgcolor(barstate.isrealtime  ?  color.new(color.purple,  80) :  na,  title  =  \"Realtime background highlight\")  \n``\n\nWhen we add the script to our chart, it executes once per bar in the chart‚Äôs history, from the leftmost bar to the rightmost bar. However, the rightmost bar on our chart is still  _open_. Therefore, it is a  _realtime bar_, not a historical bar. After the script reaches that bar, it begins executing once for  _every new update_  to the bar‚Äôs data. Each new script execution calculates on the latest available prices and  _replaces_  the bar‚Äôs previous result.\n\nFor instance, in the initial image below, the oscillator‚Äôs value 10 seconds into the open realtime bar (the one with the purple background) is 32.08:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-1.AOvj4-Z1_1svjXm.webp)\n\nEvery time the bar updates, rollback  _resets_  the script‚Äôs data for that bar, and the script  _recalculates_  its result using the latest  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), and  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values. Here, halfway through the realtime bar‚Äôs period, the oscillator‚Äôs plot now shows a value of 16.71:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-2.C780uf5g_1ywlee.webp)\n\nRecalculation continues for each successive update to the bar. Then, the script reaches the bar‚Äôs closing tick, where the prices become  _confirmed_. On that tick, the script calculates the oscillator‚Äôs final value of 19.35. Afterward, another realtime bar opens, and the pattern of rollback and recalculation continues on that bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-3.rq8kAEPJ_Z2sy82e.webp)\n\nNote that:\n\n-   Only the values for a realtime bar‚Äôs  _final tick_  become part of the internal time series. The values from ticks  _before_  the bar‚Äôs close are  **not**  saved.\n-   The  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int)  function returns a value of the ‚Äúinput int‚Äù  _qualified type_. Values qualified as ‚Äúinput‚Äù are established  _before_  the first script execution, and they remain consistent throughout the script‚Äôs runtime. If the user changes the ‚ÄúLength‚Äù input to a new value, the script  _restarts_  to perform new calculations across the dataset using that value. See the  [Inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/)  page and the  [Qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)  section of the  [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  page to learn more about script inputs and the ‚Äúinput‚Äù qualifier.\n-   If the script restarts, all the realtime bars from the previous script run become  _historical bars_  in the new run. Therefore, after restarting, the script executes only  **once**  on each of those bars and does  _not_  highlight their background.\n\nNote_Strategy_  scripts do not execute in the same way as indicators by default; they execute only  _once_  on  _every bar_, including all  _realtime bars_. Calculations occur on each realtime bar only after the bar  **closes**. Users can change this behavior with the  `calc_on_every_tick`  and  `calc_on_order_fills`  parameters of the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  function. See the  [Strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  page to learn more about strategy scripts and how they differ from indicators.",
    "keywords": [
      "www.tradingview",
      "barstate.ishistory",
      "var_barstate.ishistory",
      "barstate.isrealtime",
      "var_barstate.isrealtime",
      "barstate.isconfirmed",
      "var_barstate.isconfirmed",
      "ta.stoch",
      "fun_ta.stoch",
      "tradingview.com",
      "input.int",
      "color.teal",
      "color.new",
      "color.purple",
      "fun_input.int",
      "indicator",
      "strategy",
      "input",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "varip",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-29",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Executions on historical  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars)",
    "content": "## [The  details](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-details)\n\nThe following sections provide in-depth details about Pine‚Äôs execution model, including the mechanics of executions on  [historical bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars)  and  [realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars), which  [events](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions)  trigger script executions, and how the runtime system maintains data across executions in a  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)  format.\n\nTipNew to Pine Script? To make the most of the  _advanced_  information below, start by learning  [The basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics)  and understanding other core concepts ‚Äî such as the  [type system](https://www.tradingview.com/pine-script-docs/language/type-system/),  [variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/),  [operators](https://www.tradingview.com/pine-script-docs/language/operators/),  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/), and  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  ‚Äî before venturing further.",
    "keywords": [
      "www.tradingview",
      "var",
      "series",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-30",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Executions on realtime  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars)",
    "content": "### [Executions on historical  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars)\n\nWhen a script loads on the chart or in another location after an  [execution-triggering event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions), its compiled source code executes on  _every_  accessible bar in the current dataset in order, starting with the first bar.\n\nNoteThe first bar that a script accesses depends on the  `calc_bars_count`  parameter of its  [declaration statement](https://www.tradingview.com/pine-script-docs/language/script-structure/#declaration-statement)  and the limits of the user‚Äôs  _plan_. If the  `calc_bars_count`  argument is a non-zero value that is less than or equal to the plan‚Äôs  [bar limit](https://www.tradingview.com/pine-script-docs/writing/limitations/#chart-bars), script executions begin at the specified number of bars  _before_  the latest bar. Otherwise, executions start at the  _earliest_  available bar.\n\nWhile the script loads, the runtime system performs the following steps for  _each bar_  that it accesses:\n\n1.  It updates the built-in variables that hold bar information. For instance, the system sets the  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), and  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  variables to hold the OHLC price values of the bar  _before_  each execution.\n2.  It executes the script‚Äôs compiled code from start to end using the data available as of the current bar.\n3.  After the execution ends, the system commits (saves) all necessary data for the current bar to the  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series). The script can then access that data from  [historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers)  during its executions on subsequent bars by using the  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  or the built-in functions that reference past bars internally.\n\nThese steps repeat for every successive bar up to the most recent bar. After the runtime system completes this process across the dataset, the script‚Äôs committed  _outputs_  ‚Äî such as  [plots](https://www.tradingview.com/pine-script-docs/concepts/plots/),  [drawings](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types),  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs), and  [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester)  results ‚Äî become available to the user.\n\nAll the closed bars on which the script executes while loading are  _historical_, because they represent data points that were confirmed before the  [event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions)  that triggered the loading process. By default, all scripts execute  **once**  for each historical bar.\n\nTipScripts can identify which bars have a historical state with the  [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory)  variable. Its value is  `true`  for every closed bar accessed during the script‚Äôs loading time and  `false`  for all bars that close afterward. See the  [Bar states](https://www.tradingview.com/pine-script-docs/concepts/bar-states/)  page to learn more about  `barstate.*`  variables.\n\nLet‚Äôs examine a simple indicator to understand how script executions work on historical bars.\n\nThe script below calculates the 20-bar moving average of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values and plots the result on the chart. The color of the plot depends on whether the average is above or below the value on the previous bar. The script also increments an  `executionNum`  variable to count code executions, then plots the result alongside  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  for comparison. Additionally, it highlights the background of historical bars in orange for visual reference:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Executions on historical bars demo\")  \n  \n//@variable The average of the latest 20 `close` values.  \nfloat  sma  =  ta.sma(close,  20)  \n  \n//@variable Is `color.green` if the `sma` value is above the value on the previous bar; `color.red` otherwise.  \ncolor  plotColor  =  sma  >  sma[1] ?  color.green  :  color.red  \n  \n//@variable Tracks the current execution number, where 0 represents the first execution.  \nvarip  int  executionNum  =  -1  \n// Add 1 to the `executionNum` value.  \nexecutionNum  +=  1  \n  \n// Display the `sma` as a line plot on the main chart pane, colored by the `plotColor`.  \nplot(sma,  \"SMA\",  plotColor,  3,  force_overlay  =  true)  \n  \n// Display the `executionNum` and `bar_index` series in a separate pane.  \nplot(executionNum,  \"Execution number\",  color.purple,  5)  \nplot(bar_index,  \"Bar index\",  color.aqua,  2)  \n  \n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.  \nbgcolor(barstate.ishistory  ?  color.new(color.orange,  70) :  na,  title  =  \"Historical highlight\",  force_overlay  =  true)  \n``\n\nThe statements and expressions in this source code might appear static at first glance. However, they have  _dynamic_  behavior across bars because the system executes the script  _repeatedly_  ‚Äî once for each successive data point. Below, we inspect the code step by step to explain how the script works during its historical executions.\n\nThe  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  call at the top of the code is a  [declaration statement](https://www.tradingview.com/pine-script-docs/language/script-structure/#declaration-statement)  that defines the script‚Äôs type and properties once, at  _compile time_. This statement does not execute as the script runs on the dataset:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`indicator(\"Executions on historical bars demo\")  \n`\n\n_Before_  each script execution on a bar, the runtime system updates the built-in  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  and  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  variables required in the calculations. The  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  value is the bar‚Äôs global  _time series index_, where 0 represents the first bar, 1 represents the second, and so on. The  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  variable holds the bar‚Äôs  _latest price_. For historical bars, its value is the  _final price_  at the bar‚Äôs closing time.\n\nEach time that the script executes, it declares and initializes a global  `sma`  variable of the ‚Äúfloat‚Äù  [type](https://www.tradingview.com/pine-script-docs/language/type-system/#types). This  [variable declaration](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  happens on  _every_  execution because the code line does not specify a  [declaration mode](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes). The variable‚Äôs assigned value is the result of a  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  function call. The call returns the average of the latest 20  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values as of the current bar, or  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  if fewer than 20 bars are available. After the execution ends, the system commits the new value of  `sma`  to the  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@variable The average of the latest 20 `close` values.  \nfloat  sma  =  ta.sma(close,  20)  \n``\n\nNote that:\n\n-   The  `//@variable`  comment above the  `sma`  declaration is an  [annotation](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations)  that  _documents_  the variable in the code. The Pine Editor displays the comment in a pop-up window when the user hovers the mouse pointer over the variable.\n\nDuring each execution, the script also initializes a  `plotColor`  variable of the ‚Äúcolor‚Äù type. The script uses a  [ternary operation](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator)  that compares the current  `sma`  value to  `sma[1]`  ‚Äî the  _last committed value_  for  `sma`  as of the  _previous bar_  ‚Äî to determine the  `plotColor`  variable‚Äôs assigned value. If the current  `sma`  value is higher than the last committed value, the  `plotColor`  value is  [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green). Otherwise, it is  [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color.red):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@variable Is `color.green` if the `sma` value is above the value on the previous bar; `color.red` otherwise.  \ncolor  plotColor  =  sma  >  sma[1] ?  color.green  :  color.red  \n``\n\nIn contrast to the variables above, the script  _does not_  initialize the  `executionNum`  variable on every execution. Instead, initialization happens only  _once_  ‚Äî on the  _first_  bar ‚Äî because the variable declaration is in the  _global scope_  and uses the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword. Once initialized, the variable  _persists_  across all subsequent bars and the ticks within those bars. Only the reassignment or compound assignment  [operators](https://www.tradingview.com/pine-script-docs/language/operators/)  can change its value:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@variable Tracks the current execution number, where 0 represents the first execution.  \nvarip  int  executionNum  =  -1  \n`\n\nThe code following the  `executionNum`  declaration uses the addition assignment operator ([+=](https://www.tradingview.com/pine-script-reference/v6/#op_+=)) to increase the variable‚Äôs value by one on each new execution. Starting from -1, the value increases to 0 on the first execution after initialization, then 1 on the second, and so on:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``// Add 1 to the `executionNum` value.  \nexecutionNum  +=  1  \n``\n\nThe script evaluates the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  calls on every execution. Each  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call creates a new point on a line plot at the bar‚Äôs location on the time axis. The  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  call creates a background color for the bar based on a ternary expression. The background is translucent orange if  [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory)  is  `true`. Otherwise, it is  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  (no color):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``// Display the `sma` as a line plot on the main chart pane, colored by the `plotColor`.  \nplot(sma,  \"SMA\",  plotColor,  3,  force_overlay  =  true)  \n  \n// Display the `executionNum` and `bar_index` series in a separate pane.  \nplot(executionNum,  \"Execution number\",  color.purple,  5)  \nplot(bar_index,  \"Bar index\",  color.aqua,  2)  \n  \n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.  \nbgcolor(barstate.ishistory  ?  color.new(color.orange,  70) :  na,  title  =  \"Historical highlight\",  force_overlay  =  true)  \n``\n\nNote that:\n\n-   The  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  calls that include  `force_overlay = true`  display their visuals on the main chart pane. The other  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  calls output visuals in a separate pane, because the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  call does not include  `overlay = true`.\n\nAfter the system executes the script on all available data points and finishes loading, the script‚Äôs outputs then become visible on the chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-1.CbmTx9jr_Z1leWpo.webp)\n\nNote that:\n\n-   When the script first loads,  _all_  bars, including the latest one, have an orange background because they initially represent  _historical_  data. However, the latest bar on our chart is still open, meaning it is a  _realtime bar_. After a new tick arrives from the realtime data feed, the bar‚Äôs values update, and the script executes  _again_  on that bar. The orange background for the bar then  _disappears_  because the system sets the value of  [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory)  to  `false`.\n-   The  `executionNum`  and  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  values are identical on historical bars because the script executes  _once per bar_  on that part of the dataset. However, they begin to differ on the realtime bar. On that bar, the script executes after  _every new update_  to recalculate its results, and the  `executionNum`  value increases each time. See the  [Executions on realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars)  section to learn more.\n-   An alternative, more robust method to track code executions is to use the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler). The profiler analyzes the total runtime and execution count of every significant part of the source code. To learn more about this feature, see the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page.\n\nIt‚Äôs important to note that, unlike indicators,  [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  can execute  _more than once_  per historical bar, depending on the specified  [calculation behavior](https://www.tradingview.com/pine-script-docs/concepts/strategies/#altering-calculation-behavior). If the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement includes  `calc_on_order_fills = true`, or if the user selects the ‚ÄúAfter order is filled‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab, the runtime system executes the script on  _each available tick_  where the  [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator)  fills an order, or once per bar when there is no order to fill.\n\nLet‚Äôs look at a simple example. The following strategy changes the direction of its simulated position on each execution. If there is an open short position or no position, the strategy places a  [market order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders)  to close all short trades and enter a long trade. If a long position is open, the strategy places a market order to close it and open a short trade.\n\nAs with the previous example, this script increments an  `executionNum`  variable declared with  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  to count new executions, plots the result alongside  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  for comparison, and highlights the background of historical bars in orange with  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-2.DpP1JZmD_2lzKqv.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nstrategy(\"Default strategy behavior on historical bars demo\")  \n  \n// Place a market order to close short trades and enter a long trade when there is a short position or no position.  \n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.  \nif  strategy.position_size  <=  0  \nstrategy.entry(\"Long\",  strategy.long)  \nelse  \nstrategy.entry(\"Short\",  strategy.short)  \n  \n//@variable Tracks the current execution number, where 0 represents the first execution.  \nvarip  int  executionNum  =  -1  \n// Add 1 to the `executionNum` value.  \nexecutionNum  +=  1  \n  \n// Display the `executionNum` and `bar_index` series in a separate pane.  \nplot(executionNum,  \"Execution number\",  color.purple,  5)  \nplot(bar_index,  \"Bar index\",  color.aqua,  2)  \n  \n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.  \nbgcolor(barstate.ishistory  ?  color.new(color.orange,  70) :  na,  title  =  \"Historical highlight\",  force_overlay  =  true)  \n``\n\nNote that:\n\n-   The  [strategy.entry()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy.entry)  command creates entry orders. By default, a long entry using this command reverses an open short position, and a short entry reverses an open long position. See the  [Reversing positions](https://www.tradingview.com/pine-script-docs/concepts/strategies/#reversing-positions)  section of the  [Strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  page to learn more.\n\nThe script above uses the default calculation behavior: it places a new order only at the close of each bar. The broker emulator fills the order at the next bar‚Äôs opening price, as the trade markers on the chart above indicate. The  `executionNum`  and  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  plots show the same values because the script executes only once per bar.\n\nIf we include  `calc_on_order_fills = true`  in the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement, the runtime system  _re-executes_  the script on a bar after each new order fill to update the calculations. Our script‚Äôs logic generates a new order on  _every_  execution, and the broker emulator considers historical bars to have  _four ticks_  for filling orders by default (the open, high, low, and close). Therefore, with this change, the script executes  **four times**  per historical bar instead of only once. As shown below, the strategy now shows four trade markers on each historical bar, and the  `executionNum`  value is four times that of the  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  variable:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-3.C3-PPUqF_Z9LtnE.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nstrategy(\"Calculation after order fill on historical bars demo\",  calc_on_order_fills  =  true)  \n  \n// Place a market order to close short trades and enter a long trade when there is a short position or no position.  \n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.  \nif  strategy.position_size  <=  0  \nstrategy.entry(\"Long\",  strategy.long)  \nelse  \nstrategy.entry(\"Short\",  strategy.short)  \n  \n//@variable Tracks the current execution number, where 0 represents the first execution.  \nvarip  int  executionNum  =  -1  \n// Add 1 to the `executionNum` value.  \nexecutionNum  +=  1  \n  \n// Display the `executionNum` and `bar_index` series in a separate pane.  \nplot(executionNum,  \"Execution number\",  color.purple,  5)  \nplot(bar_index,  \"Bar index\",  color.aqua,  2)  \n  \n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.  \nbgcolor(barstate.ishistory  ?  color.new(color.orange,  70) :  na,  title  =  \"Historical highlight\",  force_overlay  =  true)  \n``\n\nNote that:\n\n-   This script can execute  _more than four_  times per bar if it uses  [Bar Magnifier](https://www.tradingview.com/pine-script-docs/concepts/strategies/#bar-magnifier)  mode, because this mode enables the broker emulator to fill orders on historical bars using intrabar prices from a  _lower timeframe_.\n-   The script can execute numerous times on a  _realtime_  bar, depending on the updates from the data feed, because  _each new update_  to the bar is a valid tick for filling the strategy‚Äôs orders.\n-   An alternative way to confirm the script‚Äôs increased execution count is to select and clear the ‚ÄúAfter order is filled‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab while  [profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  the code.",
    "keywords": [
      "www.tradingview",
      "barstate.ishistory",
      "var_barstate.ishistory",
      "tradingview.com",
      "ta.sma",
      "color.green",
      "color.red",
      "color.purple",
      "color.aqua",
      "color.new",
      "color.orange",
      "fun_ta.sma",
      "const_color.green",
      "const_color.red",
      "strategy.position_size",
      "strategy.entry",
      "strategy.long",
      "strategy.short",
      "fun_strategy.entry",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "varip",
      "series",
      "simple",
      "const",
      "import",
      "method",
      "type",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-31",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Events that trigger script  executions](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions)",
    "content": "### [Executions on realtime  bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars)\n\nAfter a script running on the chart or in an alert executes across all historical bars in a dataset, the runtime system continues to execute the script on the current bar, if it is open, and on any new bars that form later. We refer to these bars as  _realtime bars_, because they represent incoming data from a separate data feed that the script can access only  _after_  it finishes loading.\n\nAs explained in the previous section, historical bars represent confirmed data points. By contrast, a realtime bar represents an initially  _unconfirmed_  data point that evolves as new updates (ticks) arrive from the realtime data feed. With each new tick, the bar‚Äôs  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low),  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close),  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume), and other values update to represent the latest data while the bar remains open. After the bar closes, it becomes an  _elapsed realtime bar_, whose values no longer change. Then, a new realtime bar opens after another tick arrives, and that bar updates as new data becomes available.\n\nTipScripts can identify which bars have a realtime state with the  [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime)  variable. Its value is  `true`  for every bar that closes  _after_  the script‚Äôs loading time and  `false`  for all previous bars. Additionally, scripts can detect  _closed bars_  with the  [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed)  variable. To learn more about these and other  `barstate.*`  variables, refer to the  [Bar states](https://www.tradingview.com/pine-script-docs/concepts/bar-states/)  page.\n\nAs an  [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library)  script runs on an open realtime bar, its compiled code executes once after  **every new update**  from the data feed. With each new execution, the script recalculates its results for that bar using the latest data. Consequently, the states of the script‚Äôs variables, expressions, and objects can  _change_  with each new execution while the bar remains open. The system  _commits_  the script‚Äôs data for the realtime bar only after the bar closes.\n\nAfter each script execution that occurs  _before_  a bar‚Äôs closing tick, the runtime engine executes a  _rollback_  process. Rollback  _resets_  applicable script data to the latest committed states in the  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series). This process enables the script to recalculate the bar‚Äôs results using only the latest available data ‚Äî without the influence of  _temporary_  data from executions on the bar‚Äôs previous ticks.\n\nBelow, we explain how recalculation and rollback affect a script‚Äôs data and outputs, along with some notable exceptions to this process:\n\n**Reinitialize variables**\n\nThe runtime system erases the states of any variables that the script initializes during its executions before a bar‚Äôs close, excluding those declared using the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword. When the script executes again after rollback, it  _reinitializes_  the variables with new values or references based on the latest available data.\n\nLikewise, the system does not preserve the  _temporary_  states of built-in variables that hold values for the current bar. Before the new script execution, it sets the variables to use the bar‚Äôs most recent data. For instance, the system updates  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low)  with the latest, highest, and lowest prices reported since the bar‚Äôs opening time.\n\n**Reset changes to  `var`  variables**\n\nVariables that use the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword in their declaration are initialized only  _once_  ‚Äî during the  _first_  execution of their scopes on a  _closed bar_. Variables that use the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword in their declaration remain initialized after the  _first_  time that their scopes execute on a bar‚Äôs  _closing tick_. Their assigned values or references  _persist_  across subsequent bars, changing only after  [reassignment](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#variable-reassignment)  or compound assignment operations.\n\nAlthough these variables preserve data across successive bars, they  **do not**  preserve data across executions on the  _ticks_  of an open bar. Rollback reverts all variables declared with  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  before the current bar to the last committed states in the time series as of the previous bar.\n\nFor instance, if a variable declared with  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  has a value of 20 on the open bar and 19 on the previous bar, the variable‚Äôs value reverts to 19 before the script executes on the next tick of the same bar. The temporary value of 20 does not persist.\n\n**Replace plotted outputs**\n\nThe  `plot*()`,  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor),  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), and  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill)  functions create visual outputs on  _every bar_. These outputs are  _temporary_  on the open realtime bar. When the script executes again after rollback, the new outputs for the bar from calls to these functions  _replace_  the ones from the previous tick.\n\nFor example, when the expression  `plot(close)`  executes on the open bar, it displays the bar‚Äôs latest  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value as of the current execution. However, the plotted result is  **temporary**  until the bar closes. After rollback, the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  variable updates, then the script calls  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  again on the next execution to replace the output from the previous tick and display the new value.\n\n**Remove and revert objects**\n\n[User-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  and special types such as  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  and  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  are  _reference types_. They define structures from which scripts create  _objects_  ‚Äî independent entities that store data elsewhere in memory. Variables of these types hold  _references_  that provide access to specific objects and their data; the variables do  **not**  store objects directly.\n\nIf a script creates objects on an open bar and does not assign their references to variables declared with the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword, the rollback process  _removes_  those objects. During the next execution on the open bar, the script creates  _new objects_  if the updated logic allows it.\n\nFor example, if a script calls  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  to create a  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  object on the open bar, the system  _deletes_  that object during rollback. On the next execution, the script evaluates  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  again, creating a  _new_  label that replaces the output. The label created on the previous tick no longer exists.\n\nSimilarly, for objects of built-in or user-defined types with references assigned to  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  variables, the rollback process reverts any changes to those objects that occur on the open bar. The only exception is for  [UDTs](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  with  _fields_  that include the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword. See the  [Objects](https://www.tradingview.com/pine-script-docs/language/objects/)  page for more information.\n\n**Exceptions**\n\nThe runtime system does not revert  _all_  the data from script executions on an open bar. The following are notable exceptions to the rollback process:\n\n-   Variables or fields declared with the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword  **do not**  revert to a previously committed state. They persist across  _all_  script executions after initialization, even those on the ticks of an open realtime bar.\n-   Logged messages in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane do not disappear after rollback. The messages from any  `log.*()`  calls during executions on the ticks of realtime bars remain in the pane until the script reloads.\n-   The data from  [strategy orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#orders-and-trades)  placed or filled on the ticks within a bar is not subject to rollback. If a strategy script creates orders or the  [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator)  fills orders on an open bar, the data from those events persists.\n-   Rollback does not erase logs for  [alerts](https://www.tradingview.com/pine-script-docs/concepts/alerts/)  from the ‚ÄúAlerts‚Äù menu. All messages from a script alert remain visible until the user restarts the alert.\n-   Runtime errors from the system or the  [runtime.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_runtime.error)  function completely  _stop_  script executions. If an error occurs at any point while a script executes on an open bar, the system halts the script and does not revert the error after new updates from the data feed.\n\nLet‚Äôs inspect the behavior of a simple indicator on realtime bars. The following script calculates an  [RSI](https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/)  of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values using  [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi)  and displays the result with a  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call. To track the number of executions that occur  _per bar_, the script increments an  `executions`  variable declared with  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  and calculates its one-bar change using  [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change). The script converts each bar‚Äôs execution count to a string with  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring), then displays the result in a color-coded  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  at the bar‚Äôs  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high). The label is purple if the bar is open. Otherwise, it is gray. The script also highlights the background of realtime bars in orange using  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Executions on realtime bars demo\")  \n  \n//@variable The 14-bar RSI of `close` prices.  \nfloat  rsi  =  ta.rsi(close,  14)  \n  \n//@variable Tracks the number of script executions, where 1 represents the first execution.  \nvarip  int  executions  =  0  \n// Add 1 to the `executions` value.  \nexecutions  +=  1  \n  \n//@variable Is `color.gray` if the bar is confirmed (closed); `color.purple` otherwise.  \ncolor  labelColor  =  barstate.isconfirmed  ?  color.gray  :  color.purple  \n  \n// Calculate the one-bar change in `executions`, then convert the value to a string and display the result in a label.  \n// Each call to `label.new()` creates a *new* `label` object.  \nlabel.new(  \nbar_index,  high,  str.tostring(ta.change(executions)),  \ncolor  =  labelColor,  textcolor  =  color.white,  size  =  20,  force_overlay  =  true  \n)  \n  \n// Plot the `rsi` value with colors based on whether the value is above 50 or not.  \nplot(rsi,  \"RSI\",  rsi  >  50  ?  color.teal  :  color.maroon,  3)  \n  \n// Highlight the chart's background in translucent orange when `barstate.isrealtime` is `true`.  \nbgcolor(barstate.isrealtime  ?  color.new(color.orange,  70) :  na,  title  =  \"Realtime highlight\",  force_overlay  =  true)  \n``\n\nWhen we first add the script to the chart, it does  _not_  add an orange background to any bar because it calculates only on data that exists at the script‚Äôs loading time. This data is  _historical_. Each bar‚Äôs label shows a value of 1 because indicators always execute  _once_  per historical bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-1.C6ZIpkKC_Z1DmFI2.webp)\n\nNotice the countdown timer and the  _purple_  label for the latest bar in the chart above. These both indicate that the bar is  _open_  and subject to changes. A new update from the data feed affects the bar‚Äôs values, triggering rollback and a new script execution to recalculate the results.\n\nWhen rollback occurs, the runtime system reverts the internal data of the  [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi)  call to its last committed state, erases the state of the  `rsi`  variable, and deletes the latest  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  object. However, the system does not revert the  `executions`  variable because it uses the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword.\n\nAfter rollback, the system updates the built-in  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and  `barstate.*`  variables using the current bar‚Äôs latest data, and the new execution begins. The script evaluates the  [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi)  call using the new  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price and reinitializes the  `rsi`  variable with the returned value. Then, it increases the  `executions`  value by one, evaluates  [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change)  again, and creates a new label at the bar‚Äôs current high price to show the updated result. Lastly, it evaluates the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  calls to replace the bar‚Äôs plotted visuals. The last bar‚Äôs label remains purple because the bar is still open, but the background color is now  _orange_  because  [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime)  is  `true`:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-2.DkBtTFWJ_wi3cQ.webp)\n\nAs subsequent updates become available from the data feed, the pattern of rollback and re-execution continues, and the script‚Äôs outputs for the bar update with each new execution:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-3.5O5RsfWP_2oucrw.webp)\n\nThe last time that rollback and another execution occur on this bar is after the  _closing tick_, when the bar becomes an  _elapsed_  realtime bar. After the final execution, the bar‚Äôs label is  _gray_  because  [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed)  is  `true`. The runtime system then  _commits_  necessary data from this execution to the  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)  for calculations on future bars.\n\nThen, a new realtime bar opens after another update from the data feed, and the execution pattern continues:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-4.C8UTIyzZ_1eXV6W.webp)\n\nNote that:\n\n-   Although the previous bar is now confirmed, it still has an orange background corresponding to a  _realtime_  state because it closed  **after**  the script‚Äôs loading time. When the script later reloads after an  [execution-triggering event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions), that bar becomes  _historical_.\n\nIt‚Äôs important to note that  [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  often execute differently than indicators on realtime bars. By default, they execute only  **once**  per bar at each  _closing tick_  without undergoing rollback. However, users can modify a strategy‚Äôs  [calculation behavior](https://www.tradingview.com/pine-script-docs/concepts/strategies/#altering-calculation-behavior)  to allow rollback and re-execution on a bar before its closing tick.\n\nIf the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  statement includes  `calc_on_every_tick = true`, or if the user selects the ‚ÄúOn every tick‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab, the script executes on a realtime bar after  _each new update_  from the data feed, similar to an indicator.\n\nAdditionally, if the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  statement includes  `calc_on_order_fills = true`  or the user selects ‚ÄúAfter order is filled‚Äù in the ‚ÄúSettings/Properties‚Äù tab, the script executes on  _each tick_  where the  [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator)  fills an order. With this behavior, the system can execute the script multiple times on the open bar, but only on the ticks where an  _order fill_  occurs.\n\nNoteRollback typically occurs only after script executions on realtime bars. However, it can also happen on  _historical bars_  for strategies that recalculate after an order fills, because such scripts can execute  _more than once_  on  _any_  bar.\n\nTo summarize the general process for script executions on realtime bars:\n\n-   An  [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library)  script executes on the  _first available tick_  in an open realtime bar, then  _once per update_  to recalculate the results for the bar using the latest data. A  [strategy](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  script executes only on the bar‚Äôs  _closing tick_  by default, but users can modify its calculation behavior to allow executions while the bar is open.\n-   Before each new script execution on an open bar, the runtime system executes a  _rollback_  process, which  _reverts_  all applicable variables, expressions, and objects to their  _last committed states_  as of the previous bar‚Äôs close.\n-   After the script executes on an  _elapsed_  realtime bar‚Äôs closing tick, the system  _commits_  necessary data from that execution to the  [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)  for access on later bars. It does  **not**  commit the data from executions on the bar‚Äôs  _unconfirmed_  values from previous ticks.",
    "keywords": [
      "www.tradingview",
      "barstate.isrealtime",
      "var_barstate.isrealtime",
      "barstate.isconfirmed",
      "var_barstate.isconfirmed",
      "label.new",
      "fun_label.new",
      "runtime.error",
      "fun_runtime.error",
      "ta.rsi",
      "fun_ta.rsi",
      "ta.change",
      "fun_ta.change",
      "str.tostring",
      "fun_str.tostring",
      "tradingview.com",
      "color.gray",
      "color.purple",
      "color.white",
      "color.teal",
      "color.maroon",
      "color.new",
      "color.orange",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "barcolor",
      "alert",
      "var",
      "varip",
      "series",
      "simple",
      "import",
      "type",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-32",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Time  series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)",
    "content": "### [Events that trigger script  executions](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions)\n\nSeveral events cause a script to load and execute across all the available bars in a dataset. The specific events that trigger the loading process depend on where the script runs.\n\nFor a script on the  [chart](https://www.tradingview.com/chart/), the following events always cause the script to load and perform  _new executions_  on every bar:\n\n-   The user adds the script to the chart for the first time from the Pine Editor or the ‚ÄúIndicators, metrics, and strategies‚Äù menu.\n-   The user saves an update to the script while it is active on the chart.\n-   The chart is refreshed while the script is active.\n\nOther events also trigger the loading process for a script on the chart. However, these events do not  _always_  cause new script executions on past bars. The results from running a script with a unique combination of settings are often temporarily  _cached_. If cached data exists for a selected combination of settings, the system loads the script using that data. See the  [Caching](https://www.tradingview.com/pine-script-docs/language/execution-model/#caching)  section for more information.\n\nBelow are the additional events that cause a script to load on the chart, either by performing new executions across the dataset or by using available cached data:\n\n-   The user selects new values for the  [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/)  or  [strategy properties](https://www.tradingview.com/support/solutions/43000628599-strategy-properties/)  in the script‚Äôs ‚ÄúSettings‚Äù menu.\n-   The script uses the  [chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time)  or  [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time)  variable, and the visible chart range changes.\n-   The script uses the  [chart.fg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.fg_color)  or  [chart.bg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color)  variable, and the user changes the chart‚Äôs background color.\n-   The chart loads a new dataset with a different  _timeframe_  or  _ticker identifier_. Several user actions affect a chart‚Äôs ticker ID, such as selecting a symbol from the ‚ÄúSymbol Search‚Äù menu, changing the chart type, toggling data modifications in the chart‚Äôs settings, and activating  [Bar Replay](https://www.tradingview.com/support/solutions/43000712747-bar-replay-how-and-why-to-test-a-strategy-in-the-past/)  mode.\n-   The user opens or closes the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane.\n-   The user activates or deactivates the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler).\n\nFor scripts used in other locations, the following events trigger the loading process:\n\n-   The user creates a new script  [alert](https://www.tradingview.com/pine-script-docs/concepts/alerts/)  from the ‚ÄúCreate Alert‚Äù dialog box.\n-   The user pauses and restarts an alert instance from the ‚ÄúAlerts‚Äù menu.\n-   The user clicks the ‚ÄúGenerate report‚Äù button in the  [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester)  while  [Deep Backtesting](https://www.tradingview.com/support/solutions/43000666199-what-is-deep-backtesting/)  mode is enabled.\n-   The user clicks the ‚ÄúScan‚Äù button in the  [Pine Screener](https://www.tradingview.com/support/solutions/43000742436-tradingview-pine-screener-key-features-and-requirements/)  to run the script on the datasets from a chosen watchlist.\n\n_After_  a script loads, either of the following causes new script executions on an  _open bar_:\n\n-   One of the events above causes the script to load again and execute across the  _entire dataset_  up to the bar.\n-   The script runs on the chart or in an alert, and the bar updates after new data becomes available. The system performs  _rollback_  and re-executes the script on that bar using the latest data. The only exception is if the script is a strategy that does not allow recalculation on the new tick.\n\nWhen a script completely reloads on the chart or in an alert after an applicable event, all the  [elapsed realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars)  from the script‚Äôs previous run become  [historical bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars)  in the new run, because they represent  _confirmed_  data points that the script accesses from  _a different data feed_  as it loads.\n\nThe bars in a symbol‚Äôs dataset come from two distinct data feeds: the  _historical_  feed and the  _realtime_  feed. The historical feed reports only the  _final_  values for each bar, whereas the realtime feed includes the  _temporary_  values from all available ticks. When a realtime bar becomes historical after a script restarts, the values from the bar‚Äôs previous ticks are no longer accessible; only the  **final**  price, volume, and other values remain. Therefore, if a script relies on temporary data from realtime bars in its calculations, it might behave differently after reloading.\n\nFor example, the following script calculates the one-bar arithmetic return of the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  series and displays the result as a line plot. On each realtime bar, the script updates three variables declared with  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  to track the first, highest, and lowest return values calculated during executions across the bar‚Äôs ticks, then calls  [plotcandle()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotcandle)  to plot a candle showing the values. Additionally, it uses  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  to highlight the background of realtime bars in orange:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reloading a script demo\",  precision  =  5)  \n  \n//@variable The one-bar arithmetic return of the `close` series.  \nfloat  priceReturn  =  ta.change(close,  1) /  close[1]  \n  \n// Declare persistent variables to track the first, highest, and lowest `priceReturn` values across ticks in  \n// each realtime bar.  \nvarip  float  o  =  na  \nvarip  float  h  =  na  \nvarip  float  l  =  na  \n  \nif  barstate.isrealtime  \n// On the first tick in the realtime bar, reassign `o`, `h`, and `l` to hold the value of `priceReturn`.  \nif  barstate.isnew  \no  :=  priceReturn  \nh  :=  priceReturn  \nl  :=  priceReturn  \n// Otherwise, reassign `h` and `l` to the bar's highest and lowest `priceReturn` value as of the current tick.  \nelse  \nh  :=  math.max(h,  priceReturn)  \nl  :=  math.min(l,  priceReturn)  \n  \n// Plot candles to display the `o`, `h`, `l`, and `priceReturn` values for each realtime bar.  \n// The candles do not appear on historical bars, because `o`, `h`, and `l` are `na` on those bars.  \nplotcandle(o,  h,  l,  priceReturn,  \"Return candles\",  color.blue,  chart.fg_color,  bordercolor  =  chart.fg_color)  \n// Dispaly the `priceReturn` series as a purple line plot.  \nplot(priceReturn,  \"Return plot\",  color.purple,  3)  \n// Highlight the background of all realtime bars in orange.  \nbgcolor(barstate.isrealtime  ?  color.new(color.orange,  70) :  na,  title  =  \"Realtime highlight\")  \n``\n\nAfter the script loads on the chart and executes on several realtime bars, all the elapsed realtime bars, as well as the open realtime bar, include plotted return candles and an orange background color:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-1.Bu_ElpOQ_Z25zgpA.webp)\n\nAfter an applicable event, such as a chart refresh, the script  _reloads_  and executes across the dataset again. All the closed bars with a realtime state in the previous run become  _historical_  bars in the new run. The results thus change because our script relies on realtime data. As shown below, the script does not display candles or background colors for previous bars after we refresh the chart. Those outputs appear only for the latest bar, after new ticks become available, because that bar is now the  **only**  one with a realtime state:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-2.CbIdk5sI_W8NUw.webp)\n\nNote that:\n\n-   The  [barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isnew)  variable has a value of  `true`  when a realtime bar opens, and  `false`  on all subsequent updates to the bar. If the script reloads midway through a realtime bar‚Äôs progression, only the background color appears on that bar. The script does not show a candle on the first realtime bar in that case, because its  `o`,  `h`, and  `l`  variables hold  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  until the first time that  [barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isnew)  is  `true`.\n\nNote\n\nA script might also behave differently after reloading due to differences between bars constructed from realtime data and those retrieved from historical data feeds. Occasionally, a data provider must adjust the values of a closed bar originally built from realtime updates. In such cases, the script accesses the adjusted values only after  _restarting_  and retrieving the bar from the  _historical_  feed. Although such adjustments are typically minor and infrequent, they can cause slight variations in a script‚Äôs calculations on former realtime bars.\n\n  \n\nRefer to the  [Repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)  page to learn more about potential differences between historical and realtime script behaviors and their causes.\n\n#### [Caching](https://www.tradingview.com/pine-script-docs/language/execution-model/#caching)\n\nWhen a script runs on a chart for the  _first time_  using a  _unique configuration_, the data from that run is often temporarily cached for reuse. The cached data is erased after the chart is refreshed or the user updates the script‚Äôs source code.\n\nIn this context, the configuration refers to the combined state of all script, chart, and developer tool settings that can affect the script‚Äôs executions. This combination includes:\n\n-   The values of  [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/)  in the script‚Äôs ‚ÄúSettings/Inputs‚Äù tab.\n-   The values of the  [strategy properties](https://www.tradingview.com/support/solutions/43000628599-strategy-properties/)  in the ‚ÄúSettings/Properties‚Äù tab.\n-   The values of the  `chart.*`  variables whose  [qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)  are ‚Äúinput‚Äù ([chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time),  [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time),  [chart.fg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.fg_color), and  [chart.bg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color)).\n-   The chart‚Äôs timeframe.\n-   The chart‚Äôs ticker identifier.\n-   Whether the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane is open or closed.\n-   Whether the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  is active or not.\n\nEach time that a script runs using a unique combination of settings, it executes from start to end on each bar in the dataset to perform new calculations. If possible, the script‚Äôs data from the run is then cached. If cached data is available on past bars for a selected combination of settings, the runtime system loads the script using that data.\n\nThis behavior enables users to change a script‚Äôs inputs, alter the chart, and toggle developer tools without losing information ‚Äî including  [bar states](https://www.tradingview.com/pine-script-docs/concepts/bar-states/)  ‚Äî from previous script runs using different settings. Additionally, caching helps reduce loading times and resource requirements when switching between settings or adding multiple instances of the same script to the chart.\n\nTo understand this behavior, let‚Äôs revisit the script from the  [previous section](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions). The script has different behaviors on historical and realtime bars. In the version below, we‚Äôve added a  `lengthInput`  variable that holds the value from an  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int)  call. The script uses this variable to define the length of the  [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change)  calculation and the offset of the  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Caching demo\",  precision  =  5)  \n  \n//@variable The bar span of the `priceReturn` calculation.  \nint  lengthInput  =  input.int(5,  \"Length\",  1)  \n  \n//@variable The arithmetic return of the `close` series across `lengthInput` bars.  \nfloat  priceReturn  =  ta.change(close,  lengthInput) /  close[lengthInput]  \n  \n// Declare persistent variables to track the first, highest, and lowest `priceReturn` values across ticks in  \n// each realtime bar.  \nvarip  float  o  =  na  \nvarip  float  h  =  na  \nvarip  float  l  =  na  \n  \nif  barstate.isrealtime  \n// On the first tick in the realtime bar, reassign `o`, `h`, and `l` to hold the value of `priceReturn`.  \nif  barstate.isnew  \no  :=  priceReturn  \nh  :=  priceReturn  \nl  :=  priceReturn  \n// Otherwise, reassign `h` and `l` to the bar's highest and lowest `priceReturn` value as of the current tick.  \nelse  \nh  :=  math.max(h,  priceReturn)  \nl  :=  math.min(l,  priceReturn)  \n  \n// Plot candles to display the `o`, `h`, `l`, and `priceReturn` values for each realtime bar.  \n// The candles do not appear on historical bars, because `o`, `h`, and `l` are `na` on those bars.  \nplotcandle(o,  h,  l,  priceReturn,  \"Return candles\",  color.blue,  chart.fg_color,  bordercolor  =  chart.fg_color)  \n// Dispaly the `priceReturn` series as a purple line plot.  \nplot(priceReturn,  \"Return plot\",  color.purple,  3)  \n// Highlight the background of all realtime bars in orange.  \nbgcolor(barstate.isrealtime  ?  color.new(color.orange,  70) :  na,  title  =  \"Realtime highlight\")  \n``\n\nAfter we add the script to our 1m chart and let it run for a few minutes with a ‚ÄúLength‚Äù input value of 5, the script plots candles and highlights the background for the latest few bars, because  [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime)  is  `true`  on those bars:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-1.BY9-bg_Z_Z1h9UoE.webp)\n\nLet‚Äôs change the ‚ÄúLength‚Äù input to a new value, causing the script to reload and execute across the dataset again. Here, we changed the value from 5 to 10 and let the script execute on some new ticks. The script no longer displays candles and background colors for the same bars after restarting, because it now accesses the data for those formerly realtime bars from the  _historical_  data feed:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-2.DyVd2t5m_Z1wVpJs.webp)\n\nAs shown above, the realtime bar information from the first run is  _not available_  when we change the script‚Äôs input to a new value. However, the data from that previous run still exists in memory. If we revert the ‚ÄúLength‚Äù input‚Äôs value to 5, the candle plot and background colors start on the same bar as the first run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-3.ByASZdF6_Z1Va6dx.webp)\n\nIf we add a second instance of the script to the chart, using the same settings, the runtime system loads the new instance using the cached data instead of executing it entirely from scratch. As such, its outputs are  _identical_  to those from the first script instance, even though we added it to the chart a few bars later:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-4.CGwk5hPj_ZgkqEL.webp)\n\nSimilarly, cached data usually remains available even if we remove the script from our chart and add it again.\n\nTipYou can clear cached data for a script on the chart at any time by simply reloading the chart.",
    "keywords": [
      "www.tradingview",
      "chart.left_visible_bar_time",
      "var_chart.left_visible_bar_time",
      "chart.right_visible_bar_time",
      "var_chart.right_visible_bar_time",
      "chart.fg_color",
      "var_chart.fg_color",
      "chart.bg_color",
      "var_chart.bg_color",
      "tradingview.com",
      "ta.change",
      "barstate.isrealtime",
      "barstate.isnew",
      "math.max",
      "math.min",
      "color.blue",
      "color.purple",
      "color.new",
      "color.orange",
      "var_barstate.isnew",
      "input.int",
      "fun_input.int",
      "fun_ta.change",
      "var_barstate.isrealtime",
      "indicator",
      "strategy",
      "input",
      "plot",
      "bgcolor",
      "alert",
      "var",
      "varip",
      "series",
      "const",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-33",
    "type": "documentation",
    "source": "concepts/execution_model.md",
    "section": "concepts",
    "title": "[Time  series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)",
    "content": "### [Time  series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)\n\nA symbol‚Äôs dataset is a form of  _time series_  ‚Äî a sequence of collected values indexed by time. Each bar represents a distinct data point, anchored to a specific time, that contains price and volume data for a particular period. This data format thus shows how a symbol‚Äôs values progress across time in successive periodic steps.\n\nPine Script‚Äôs internal time series structure follows a similar format. After executing a script on a closed bar‚Äôs confirmed values, the runtime system  _commits (saves)_  the results of the script‚Äôs statements and expressions to internal time series for later use. Each bar with committed data has an assigned  _index_  in the series, where 0 represents the first bar, 1 represents the second, and so on. Scripts can retrieve this index with the  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  variable.\n\nScripts can access the data committed to the time series on past bars by using the  [[] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator). The value between the operator‚Äôs square brackets specifies the position of the referenced bar in the time series as a  _relative offset_  behind the current bar. For variables and expressions in the global scope, an offset value of 1 refers to the previous bar at  `bar_index - 1`  (one bar back), a value of 2 refers to the bar at  `bar_index - 2`  (two bars back), and so on. An offset of 0 always refers to the  _current bar_.\n\nFor example, consider the  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  variable, which holds the opening price of the current bar on which the script executes. Before each script execution on a new bar, the runtime system commits the  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  value from the last execution on the previous bar. Then, it updates the variable to hold the current bar‚Äôs opening price. To access the committed  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  value for the previous bar, we can use the expression  `open[1]`. To access the committed value from 10 bars back, we use  `open[10]`.\n\nThe script below performs three history-referencing operations to retrieve the current bar‚Äôs  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  value, the value from one bar back, and the value from a user-specified number of bars back. Then, it plots the retrieved values on the chart for comparison:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-1.CzCPjlKh_1P3h3k.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"History referencing demo\",  overlay  =  true,  behind_chart  =  false)  \n  \n//@variable The number of bars back from which to retrieve the `open` price for `pastOpen`.  \nint  offsetInput  =  input.int(10,  \"Bar offset\",  0)  \n  \n//@variable The current bar's opening price. `open[0]` is equivalent to using `open` without the `[]` operator.  \nfloat  currOpen  =  open[0]  \n//@variable The last committed `open` value. Represents the previous bar's value, or `na` if no previous bar exists.  \nfloat  prevOpen  =  open[1]  \n//@variable The `open` value committed `offsetInput` bars back, or `na` if no bar exists at that offset.  \nfloat  pastOpen  =  open[offsetInput]  \n  \n// Plot `currOpen`, `prevOpen`, and `pastOpen` for comparison.  \nplot(currOpen,  \"Current `open`\",  color.blue,  2)  \nplot(prevOpen,  \"Previous bar `open`\",  color.purple,  3)  \nplot(pastOpen,  \"Past `open` from custom offset\",  color.orange,  4)  \n``\n\nNote that:\n\n-   The expression  `open[0]`  is equivalent to using  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  without the history-referencing operator, because an offset of 0 refers to the current bar.\n-   At the beginning of the chart‚Äôs dataset, the expressions  `open[1]`  and  `open[offsetInput]`  return  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  because they refer to previous bars that are unavailable.\n-   Each history-referencing expression also leaves a trail of values in the time series. Therefore, it is possible to retrieve past states of the expression using another history-referencing operation, e.g.,  `(open[offsetInput])[1]`.\n-   Internally, the system maintains a  _limited amount_  of time series data for variables and expressions in fixed-length  _historical buffers_. These buffers define the  _maximum offsets_  allowed for history-referencing operations. See the next section,  [Historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers), to learn more.\n\nAnother way that scripts use committed values from a time series is by calling the built-in functions that reference history internally, such as those in the  `ta.*`  namespace. For example, the expression  `ta.highest(high, 20)`  calculates the highest value from the  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  series over a 20-bar window. It compares the series‚Äô current value to the committed values from the previous 19 bars to determine the result. The script below executes this call on each bar and plots the resulting series on the chart. Additionally, the script colors the background of the last 20 bars on the chart to highlight the bars used in the latest execution‚Äôs  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-2.tycqzMI6_AVJD9.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"History referencing in functions demo\",  overlay  =  true,  behind_chart  =  false)  \n  \n//@variable The highest value from the `high` series across the 20 most recent bars.  \n// The `ta.highest()` call compares the current `high` to the last 19 committed values.  \nfloat  highest  =  ta.highest(high,  20)  \n  \n// Plot the `highest` series on the chart.  \nplot(highest,  \"20-bar high\",  color.purple,  3)  \n  \n// Color the background of the last 20 bars, i.e., the bars used by the latest execution's `ta.highest()` call.  \nbgcolor(color.new(color.blue,  70),  show_last  =  20,  title  =  \"Last 20 bar highlight\")  \n``\n\nNote that:\n\n-   The first 19 bars of the chart have a plotted value of  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), because the  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  function call requires the  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  values from the current bar and 19 previous bars to calculate the result.\n-   All function calls and expressions that do not return ‚Äúvoid‚Äù leave historical trails in the time series, just like variables. Therefore, scripts can use an expression such as  `ta.highest(high, 20)[10]`  to retrieve the 20-bar high from 10 bars back.\n-   The  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  function and other functions that access past values from a time series must execute in the  **global scope**  for consistent calculations. Time series storage for variables and expressions in local scopes works  _differently_  than that for global values. See the  [Time series in scopes](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series-in-scopes)  section for more information.\n\nNote\n\nProgrammers should not confuse time series with the ‚Äúseries‚Äù qualifier. The time series concept describes how Pine‚Äôs runtime system stores and retrieves data across successive script executions. In contrast, the ‚Äúseries‚Äù qualifier describes variables and expressions whose values can change from bar to bar, such as  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open).\n\n  \n\nTo understand this distinction, consider the  [timeframe.period](https://www.tradingview.com/pine-script-reference/v6/#var_timeframe.period)  variable, which is of the ‚Äúsimple string‚Äù  _qualified type_. The variable‚Äôs value cannot change because its  _qualifier_  is ‚Äúsimple‚Äù, but it still leaves a trail of successive values in the time series. It is possible, though not very useful, to retrieve the value from 10 bars back using an expression such as  `timeframe.period[10]`. The returned value equals the  [timeframe.period](https://www.tradingview.com/pine-script-reference/v6/#var_timeframe.period)  value for all bars with a  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  of 10 and above. However, the expression‚Äôs result is ‚Äúseries string‚Äù, because the expression returns a  _different_  value ([na](https://www.tradingview.com/pine-script-reference/v6/#var_na)) on the first 10 bars.\n\n  \n\nSee the  [Qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)  section of the  [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  page to learn more about ‚Äúseries‚Äù and other qualifiers.\n\n#### [Historical  buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers)\n\nTo promote efficiency and help ensure computing resources remain available for all users, the Pine Script runtime system uses fixed-length  _historical buffers_  to maintain a  _limited amount_  of time series data for all variables and expressions. These historical buffers define the  _maximum_  number of committed data points that a script can access on any bar via the  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  or the built-in functions that reference past bars internally.\n\nFor most series, the underlying historical buffer can contain data from up to  **5000**  past bars. The only exception is for some built-in series such as  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open),  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time), whose buffers can store data for  _more_  than 5000 bars.\n\nAlthough these buffers can contain thousands of data points at their maximum size, a script might not  _require_  that much past data for its calculations on any bar. Therefore, the runtime system automatically optimizes the size of each series‚Äô historical buffer based on the historical references that the script performs as it loads on the dataset. Each resulting buffer contains  _only_  the amount of past data required by the script‚Äôs calculations and  _not more_.\n\nFor instance, if the maximum number of bars back for which a script references the value of a variable on historical bars is 500, the system maintains a historical buffer that includes only the latest 500 committed values of that variable. The buffer does not store 5000 committed values, because the script  _does not_  require all that extra data. This behavior thus helps to minimize a script‚Äôs resource requirements while preserving the integrity of its calculations.\n\nTo determine the sufficient buffer size for each variable and expression in a script, the runtime system performs the following process during the script‚Äôs loading time:\n\n1.  It analyzes all the historical references that occur while executing the script on the dataset‚Äôs first  **244 bars**, then sets the initial size of each buffer to the minimum size that accommodates those references.\n2.  While executing the script on subsequent bars, it checks if the script attempts to access data from previous bars that are beyond the limits of the defined buffers. If the script‚Äôs historical references exceed the buffer limits on any bar, the system restarts the loading process and tries a larger buffer size.\n3.  In the rare case that a historical buffer‚Äôs size remains insufficient after several calculation attempts, the system stops the script and raises a runtime error.\n\nIt‚Äôs crucial to emphasize that the runtime system defines the sizes of all historical buffers only while executing a script on  _historical bars_. It does  **not**  adjust any historical buffers during executions on  _new bars_  from the realtime data feed. If a script references past data from beyond a historical buffer‚Äôs limits while executing on a realtime bar, it causes a  [runtime error](https://www.tradingview.com/pine-script-docs/error-messages/#the-requested-historical-offset-x-is-beyond-the-historical-buffers-limit-y).\n\nFor example, the script below retrieves a past value from the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  series using the  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  with an offset of 100 bars back on historical bars and 150 bars back on realtime bars. Because the script references data from 100 bars back during all  [historical executions](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars), the system sets the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  buffer‚Äôs size to include only 100 past values. Consequently, an error occurs when the script executes on the open realtime bar, because a historical offset of 150 is  _beyond_  the buffer‚Äôs limit:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Max bars back error demo\",  overlay  =  true)  \n  \n// @variable The historical offset for retrieving past values from the `close` series.  \n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.  \nint  offset  =  barstate.ishistory  ?  100  :  150  \n  \n// @variable The value of `close` from `offset` bars back.  \n// This code causes a *runtime error* on a realtime bar. During all code executions on historical bars,  \n// the script requires only the latest 100 past values of `close`, so the system sets the buffer size to  \n// include only the past 100 values. The offset of 150 is thus *out of bounds*.  \nfloat  pastClose  =  close[offset]  \n  \n// Plot the `pastClose` series.  \nplot(pastClose,  \"Past `close`\",  chart.fg_color,  3)  \n  \n// Highlight the background of all realtime bars in orange.  \nbgcolor(barstate.isrealtime  ?  color.new(color.orange,  70) :  na,  title  =  \"Realtime highlight\")  \n``\n\nFor cases like these, programmers can  _manually_  set the size of a historical buffer to ensure it contains a sufficient amount of data by doing any of the following:\n\n-   Modify the script to reference the maximum required number of bars back with the  [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D)  operator during its execution on the  _first bar_.\n-   Call the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function to explicitly set the historical buffer size for a  _specific_  series.\n-   Include a  `max_bars_back`  argument in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement to set the initial size of  _all_  historical buffers.\n\nNoticeThe larger the size of a historical buffer, the more memory resources it requires. A script with buffers that are too large can cause the  [‚ÄúMemory limits exceeded‚Äù error](https://www.tradingview.com/pine-script-docs/error-messages/#memory-limits-exceeded). Therefore, when manually setting the buffer size for a series, use the  **smallest**  possible size that accommodates  _all_  required historical references to that series.\n\nBelow, we modified the script by including the expression  `max_bars_back(close, 150)`, which sets the size of the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  buffer to include 150 past values. With the appropriate buffer size manually defined, the script‚Äôs history-referencing operation no longer causes an error on realtime bars:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Historical-buffers-1.BRNlhWd3_p17Kq.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Manual buffer sizing demo\",  overlay  =  true)  \n  \n// @variable The historical offset for retrieving past values from the `close` series.  \n// If the bar is historical, the offset is 100. Otherwise, the offset is 150.  \nint  offset  =  barstate.ishistory  ?  100  :  150  \n  \n// Set the size of the `close` historical buffer to include 150 past values, ensuring the script has exactly  \n// the amount of history that it requires on realtime bars.  \nmax_bars_back(close,  150)  \n  \n// @variable The value of `close` from `offset` bars back.  \n// This code no longer causes an error when it executes on a realtime bar, because the historical  \n// buffer has an appropriate size defined in advance.  \nfloat  pastClose  =  close[offset]  \n  \n// Plot the `pastClose` series.  \nplot(pastClose,  \"Past `close`\",  chart.fg_color,  3)  \n  \n// Highlight the background of all realtime bars in orange.  \nbgcolor(barstate.isrealtime  ?  color.new(color.orange,  70) :  na,  title  =  \"Realtime highlight\")  \n``\n\nTipManually setting historical buffer sizes can also improve a script‚Äôs resource efficiency in some cases. As explained above, the runtime system  _restarts_  a script to recalculate its buffers if any historical reference exceeds a buffer‚Äôs limit after the first  **244 bars**. This process increases the script‚Äôs loading time and memory use. Setting the appropriate buffer size in advance with  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  prevents the script from restarting for buffer calculations. See the  [Minimizing historical buffer calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-historical-buffer-calculations)  section of the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page for more information.\n\n#### [Time series in  scopes](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series-in-scopes)\n\nThe  _scope_  of a variable or expression refers to the part of the script where it is defined and accessible in the code. Every script has one  _global_  scope and zero or more  _local_  scopes.\n\nAll variables and expressions in a script that are outside  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods),  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/),  [loops](https://www.tradingview.com/pine-script-docs/language/loops/), and  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  or  [enum type](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types)  declarations belong to the  _global scope_. The script evaluates variables and expressions from this scope  _once_  for  _every execution_  across bars and ticks in the dataset.\n\nAll functions, methods, conditional structures, and loops create their own  _local scopes_. The variables and expressions defined within a local scope belong exclusively to that scope. In contrast to the global scope, a script does  _not_  always evaluate a local scope once per execution; the script might evaluate the scope  _zero_,  _one_, or  _several_  times per execution, depending on its logic.\n\nFor the runtime system to commit data from a variable or expression and queue that data into a  [historical buffer](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers)  on any bar, a script must evaluate the scope of that code  _once_  when it executes on the bar‚Äôs  _closing tick_. If the script does not evaluate the scope, the runtime system  _cannot_  add new data to the historical buffer. Similarly, if the script evaluates the scope repeatedly within a loop, the historical buffer cannot store series data for  _each_  separate iteration, because each entry in the time series corresponds to a single bar.\n\nTherefore, time series behave differently in global and local scopes: the historical buffers for global variables and expressions  _always_  contain committed data for  _consecutive_  past bars, whereas the buffers for local variables often contain an  **inconsistent**  history of committed data.\n\nNoteFunction and method  _parameters_  have the same historical buffer behaviors as  _local variables_. Each parameter in a function call has a  _unique buffer_, and the system can add new data to that buffer only on a bar‚Äôs closing tick. If the script does not evaluate the function call on every closing tick, the buffers for its parameters contain an inconsistent history. This behavior applies even if the argument supplied to a parameter is a  _global variable_.\n\nIf a script references the history of a global variable using an expression such as  `myVariable[1]`, the historical offset of 1 always refers to the confirmed  `myVariable`  value from the  _previous bar_. Likewise, an expression such as  `myVariable[9]`  retrieves the variable‚Äôs value from  _nine bars back_. Either expression consistently accesses the value corresponding to a  _specific_  number of bars back, because the runtime system commits a new value for that global variable on  _every bar_.\n\nIn contrast, the result of using the  [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D)  operator on a  _local_  variable  **does not**  represent the value from a specific number of bars back. Instead, it represents the variable‚Äôs  _last committed value_  as of the bar at the specified offset. For instance, suppose  `myVariable`  is a local variable, and the script last evaluated the variable‚Äôs scope 10 bars before the current bar. A history-referencing operation with any offset from  _1 to 9_  on that variable ‚Äî such as  `myVariable[1]`,  `myVariable[5]`, or  `myVariable[9]`  ‚Äî returns the variable‚Äôs value from  **10 bars back**, because there is not a recent committed value after that point for the operator to access. This behavior often leads to  _unintended results_. Therefore, to ensure consistency, we recommend using historical references only on variables or expressions that the script evaluates on  _every bar_.\n\nThe following example demonstrates how a simple history-referencing operation behaves inside a user-defined function‚Äôs scope when a script does  _not_  call the function on every bar. The script below defines a custom  `upDownColor()`  function, which compares the current value of its  `source`  parameter to the last committed value (`source[1]`) on each call. The function returns  [color.blue](https://www.tradingview.com/pine-script-reference/v6/#const_color.blue)  if the current  `source`  value is higher than the previous value. Otherwise, it returns  [color.orange](https://www.tradingview.com/pine-script-reference/v6/#const_color.orange).\n\nThe script uses this function  _conditionally_, inside a  [ternary operation](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator), to determine the color of a plot that shows the remainder from dividing  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  by a specified value. If the  `remainder`  variable‚Äôs value is nonzero, the operation calls  `upDownColor(remainder)`  to calculate the color (blue or orange). If the value is 0, the operation does  _not_  use the call and instead returns  [color.gray](https://www.tradingview.com/pine-script-reference/v6/#const_color.gray). The  `remainder`  value  _increases_  on each bar, except for when it returns to 0 ‚Äî causing the gray color. Therefore, a user might expect the plot‚Äôs color to be only blue or gray on every bar. However, the color changes to  _orange_  on each bar after the one where the color is gray, even though the  `remainder`  value on that bar is  _higher_  than the value on the previous bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-1.D_JOArZO_2tWKEC.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Local historical references demo\")  \n  \n//@function Returns `color.blue` if `source` is above its last committed value; `color.orange` otherwise.  \n// For consistent results, this function should execute on *every bar*, because it uses the  \n// history-referencing operator on the `source` series.  \n//  \n// Even if the argument supplied to `source` comes from a global variable, the `source` parameter remains  \n// part of the function's *local scope*. The system maintains a *separate historical buffer* for the `source`  \n// series in each function call instance. The buffer contains only the committed `source` values from the bars  \n// where the function call occurs. If the call does not occur on a bar, the buffer for `source` contains  \n// **no new data** for that bar.  \nupDownColor(float  source) =>  \nsource  >  source[1] ?  color.blue  :  color.orange  \n  \n//@variable The value by which to divide the `bar_index` value.  \nint  divisorInput  =  input.int(5,  \"Divisor\",  1)  \n  \n//@variable The remainder of dividing `bar_index` by `divisorInput`.  \nfloat  remainder  =  bar_index  %  divisorInput  \n  \n//@variable Is `color.gray` if `remainder` equals 0, and the result of `upDownColor(remainder)` otherwise.  \n// The `upDownColor()` call does not execute on every bar. Therefore, it does *not* always compare the  \n// `remainder` value from one bar back to calculate the color. Instead, the function compares the current  \n// `remainder` to the value from the last bar where `remainder` is nonzero.  \ncolor  plotColor  =  remainder  ==  0  ?  color.gray  :  upDownColor(remainder)  \n  \n// Plot the `remainder` series and color it using `plotColor`. The plot is orange after each bar where `remainder == 0`,  \n// because the `upDownColor()` function call does not have data for that bar to use in its logic.  \nplot(remainder,  \"Remainder\",  plotColor,  5)  \n``\n\nThe script behaves this way because  `upDownColor()`  uses the  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  on the  `source`  series, which is  _local_  to the function‚Äôs scope, and the script does not call the function on  _every_  execution. When the value of  `remainder`  is zero, the  _first_  expression in the ternary condition evaluates to  `true`, and therefore the second branch of the ternary expression, which contains the function call, does  _not_  execute.\n\nThe compiler issues the following warning about the function directly in the Pine Editor:\n\n```\n\n```\n\nThe runtime system maintains a separate  [historical buffer](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers)  for the local  `source`  series, but it cannot update that buffer unless the script  _calls_  the function. On each bar where  `remainder`  is 0, the call does not occur, and the system has no new value to commit to the time series. Therefore, the  `source`  buffer does  _not_  contain a value for that bar. On the bar that follows, the local expression  `source[1]`  refers to the  `source`  value from the  _last bar_  where the  `upDownColor()`  call occured ‚Äî  _two bars back_  ‚Äî and  **not**  the value of  `remainder`  from the previous bar. Because the value from two bars back is  _higher_  than the current value, the returned color is  [color.orange](https://www.tradingview.com/pine-script-reference/v6/#const_color.orange)  instead of  [color.blue](https://www.tradingview.com/pine-script-reference/v6/#const_color.blue).\n\nWe can fix this script‚Äôs behavior by following the instructions in the compiler warning. Below, we modified the script by moving the  `upDownColor()`  call  _outside_  the ternary expression, enabling the script to execute it on  _every bar_. The historical buffer for the function‚Äôs  `source`  series now contains  `remainder`  values from  _consecutive_  bars. With this change, an orange color does not appear because the function consistently compares values from  _one_  bar back:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-2.DnGQwjrs_Z2gROjb.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Consistent historical references demo\")  \n  \n//@function Returns `color.blue` if `source` is above its last committed value; `color.orange` otherwise.  \n// For consistent results, this function should execute on *every bar*, because it uses the  \n// history-referencing operator on the `source` series.  \nupDownColor(float  source) =>  \nsource  >  source[1] ?  color.blue  :  color.orange  \n  \n//@variable The value by which to divide the `bar_index` value.  \nint  divisorInput  =  input.int(5,  \"Divisor\",  1)  \n  \n//@variable The remainder of dividing `bar_index` by `divisorInput`.  \nfloat  remainder  =  bar_index  %  divisorInput  \n  \n//@variable Is `color.blue` if `remainder` is above its previous value, and `color.orange` otherwise.  \ncolor  secondColor  =  upDownColor(remainder)  \n  \n//@variable Is `color.gray` if `remainder` equals 0, and `secondColor` otherwise.  \n// This ternary operation no longer causes a warning. The scope of the `upDownColor()` call executes on  \n// every bar, meaning its historical buffer consistently includes data for consecutive past bars.  \ncolor  plotColor  =  remainder  ==  0  ?  color.gray  :  secondColor  \n  \n// Plot the `remainder` series and color it using `plotColor`. The plot is now blue or gray, but never orange.  \nplot(remainder,  \"Remainder\",  plotColor,  5)  \n``\n\nA similar behavior applies to all built-in functions that reference past values internally, such as those in the  `ta`  namespace. For example, the  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  function uses the current value of a  `source`  series and  `length - 1`  past values from that series to calculate a  [moving average](https://www.tradingview.com/support/solutions/43000696841-simple-moving-average/). If a script calls this function only on  _some_  bars instead of on  _every_  bar, the historical buffer for  `source`  does not contain values for consecutive past bars. Therefore, such a call can cause unintended results, because the call calculates the returned average using an inconsistent history of previous values.\n\nThe script below demonstrates how the results of the  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  function can vary with the scope in which the function call occurs. The script declares three global variables to hold calculated SMA values:  `controlSMA`,  `localSMA`, and  `globalSMA`. The script initializes  `controlSMA`  using the result of a  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  function call, and it initializes the other two variables with  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Within the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure, the script updates the value of  `globalSMA`  using  `controlSMA`, and it updates  `localSMA`  using the result of another  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  call with the same arguments as the first call.\n\nAs shown below, the  `controlSMA`  and  `globalSMA`  variables have the same value. Both hold the result of the  _global_  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  call, which executes on  _every bar_. The internal historical buffer for  `source`  in that call thus includes committed values for consecutive past bars. In contrast, the  `localSMA`  value differs, because the  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  call for that variable does  _not_  execute on every bar. The buffer for that call‚Äôs local  `source`  series contains only the values from bars with an  _even_  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  value:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-3.H3TNziJy_1gEv1o.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"`ta.*()` functions in scopes demo\",  overlay  =  true,  behind_chart  =  false)  \n  \n//@variable Is `true` if the `bar_index` is divisible by 2, and `false` otherwise.  \nbool  condition  =  bar_index  %  2  ==  0  \n  \n//@variable The 20-bar moving average of `close` values.  \n// This `ta.sma()` call executes in the global scope, so the script evaluates it on every bar.  \nfloat  controlSMA  =  ta.sma(close,  20)  \n  \n// Declare two additional variables to modify later within the `if` structure's scope.  \nfloat  globalSMA  =  na  \nfloat  localSMA  =  na  \n  \nif  condition  \n// Assign the `controlSMA` value to `globalSMA`. This code does not cause a warning.  \nglobalSMA  :=  controlSMA  \n  \n// Call `ta.sma()` with the same arguments as before within this block and assign the result to `localSMA`.  \n// The function call causes a warning, because it does not execute in the global scope.  \n// The historical buffers for this `ta.sma()` call contain data only for the bars where `condition` is `true`,  \n// thus leading to a *different* result.  \nlocalSMA  :=  ta.sma(close,  20)  \n  \n// Plot `controlSMA`, `globalSMA`, and `localSMA` for comparison.  \nplot(controlSMA,  \"Control SMA\",  color.blue,  2)  \nplot(globalSMA,  \"Global SMA\",  color.purple,  3,  style  =  plot.style_circles)  \nplot(localSMA,  \"Local SMA\",  color.gray,  3,  style  =  plot.style_circles)  \n``\n\nTo summarize the behavior of time series in a script‚Äôs scopes:\n\n-   A script evaluates its global scope once on  _every execution_. After each script execution on a bar‚Äôs closing tick, the system commits the data for variables and expressions in the global scope and updates their  [historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers). The resulting buffers thus include data for consecutive past bars, ensuring consistent results for operations and functions that rely on past data.\n-   A script evaluates local scopes  _zero_,  _one_, or  _several_  times per execution. The runtime system  **cannot**  maintain consistent bar-by-bar historical buffers for scopes that a script does  _not_  evaluate on every bar, or for scopes that the script evaluates  _more than once_  on a bar‚Äôs closing tick. Therefore, using the  [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D)  operator on local variables and expressions, or not calling functions that access past data once on each closing tick, can cause  **unintended results**.\n\nNote\n\nNot all built-in functions use past data from historical buffers in their calculations. For example, most functions in the  `math`  namespace, excluding  [math.sum()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.sum), operate only on the  _current_  arguments of the function call. Functions that do not interact with their history in any way do not require special treatment to ensure intended results.\n\n  \n\nIf the use of a function call within a local block does  _not_  cause a compiler warning, it is typically safe to use in that block without affecting the result. However, if the warning occurs, it is usually best to move the call to the  _global scope_  ‚Äî outside the operands of the  [or](https://www.tradingview.com/pine-script-reference/v6/#kw_or),  [and](https://www.tradingview.com/pine-script-reference/v6/#kw_and), or  [?:](https://www.tradingview.com/pine-script-reference/v6/#op_?:)  operators ‚Äî to ensure consistent calculations.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "color.blue",
      "color.purple",
      "color.orange",
      "e.g",
      "ta.highest",
      "fun_ta.highest",
      "i.e",
      "color.new",
      "timeframe.period",
      "var_timeframe.period",
      "barstate.ishistory",
      "chart.fg_color",
      "barstate.isrealtime",
      "const_color.blue",
      "const_color.orange",
      "color.gray",
      "const_color.gray",
      "ta.sma",
      "fun_ta.sma",
      "plot.style_circles",
      "math.sum",
      "fun_math.sum",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "const",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-34",
    "type": "documentation",
    "source": "concepts/methods.md",
    "section": "concepts",
    "title": "[Built-in  methods](https://www.tradingview.com/pine-script-docs/language/methods/#built-in-methods)",
    "content": "# [Methods](https://www.tradingview.com/pine-script-docs/language/methods/#methods)\n\nTipThis page contains  _advanced_  material. If you‚Äôre new to Pine Script¬Æ, start by learning about core language components ‚Äî such as the  [type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  and  [the basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics)  of the  [execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/)  ‚Äî and explore other, more accessible features before venturing further.\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/language/methods/#introduction)\n\nPine Script methods are specialized functions associated with values of specific  [built-in types](https://www.tradingview.com/pine-script-docs/language/type-system/#types),  [user-defined types](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types), or  [enum types](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types). They behave the same as regular functions in most regards while offering a shorter, more convenient syntax. Users can access methods using  _dot notation_  syntax on variables of the associated type, similar to accessing the fields of a Pine Script  [object](https://www.tradingview.com/pine-script-docs/language/objects/).",
    "keywords": [
      "www.tradingview",
      "var",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-35",
    "type": "documentation",
    "source": "concepts/methods.md",
    "section": "concepts",
    "title": "[User-defined  methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)",
    "content": "## [Built-in  methods](https://www.tradingview.com/pine-script-docs/language/methods/#built-in-methods)\n\nPine Script includes built-in methods for all  _special types_, including  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array),  [matrix](https://www.tradingview.com/pine-script-reference/v6/#type_matrix),  [map](https://www.tradingview.com/pine-script-reference/v6/#type_map),  [line](https://www.tradingview.com/pine-script-reference/v6/#type_line),  [linefill](https://www.tradingview.com/pine-script-reference/v6/#type_linefill),  [box](https://www.tradingview.com/pine-script-reference/v6/#type_box),  [polyline](https://www.tradingview.com/pine-script-reference/v6/#type_polyline),  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label), and  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table). These methods provide users with a more concise way to call specialized routines for these types within their scripts.\n\nWhen using these special types, the expressions:\n\n```\n\n```\n\nand:\n\n```\n\n```\n\nare equivalent. For example, rather than using:\n\n\n\n`array.get(id,  index)  \n`\n\nto get the value from an array  `id`  at the specified  `index`, we can simply use:\n\n\n\n`id.get(index)  \n`\n\nto achieve the same effect. This notation eliminates the need for users to reference the function‚Äôs namespace, as  [get()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.get)  is a method of  `id`  in this context.\n\nWritten below is a practical example to demonstrate the usage of built-in methods in place of functions.\n\nThe following script computes Bollinger Bands over a specified number of prices sampled once every  `n`  bars. It calls  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  and  [array.shift()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.shift)  to queue  `sourceInput`  values through the  `sourceArray`, then  [array.avg()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.avg)  and  [array.stdev()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.stdev)  to compute the  `sampleMean`  and  `sampleDev`. The script then uses these values to calculate the  `highBand`  and  `lowBand`, which it plots on the chart along with the  `sampleMean`:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Methods_custom_bb.DR1SlFGg_2tQfSW.webp)\n\n\n\n``//@version=6  \nindicator(\"Custom Sample BB\",  overlay  =  true)  \n  \nfloat  sourceInput  =  input.source(close,  \"Source\")  \nint  samplesInput  =  input.int(20,  \"Samples\")  \nint  n  =  input.int(10,  \"Bars\")  \nfloat  multiplier  =  input.float(2.0,  \"StdDev\")  \n  \nvar  array<float> sourceArray  =  array.new<float>(samplesInput)  \nvar  float  sampleMean  =  na  \nvar  float  sampleDev  =  na  \n  \n// Identify if `n` bars have passed.  \nif  bar_index  %  n  ==  0  \n// Update the queue.  \narray.push(sourceArray,  sourceInput)  \narray.shift(sourceArray)  \n// Update the mean and standard deviation values.  \nsampleMean  :=  array.avg(sourceArray)  \nsampleDev  :=  array.stdev(sourceArray) *  multiplier  \n  \n// Calculate bands.  \nfloat  highBand  =  sampleMean  +  sampleDev  \nfloat  lowBand  =  sampleMean  -  sampleDev  \n  \nplot(sampleMean,  \"Basis\",  color.orange)  \nplot(highBand,  \"Upper\",  color.lime)  \nplot(lowBand,  \"Lower\",  color.red)  \n``\n\nLet‚Äôs rewrite this code to utilize methods rather than built-in functions. In this version, we have replaced all built-in  `array.*()`  function calls in the script with equivalent method calls:\n\n\n\n``//@version=6  \nindicator(\"Custom Sample BB\",  overlay  =  true)  \n  \nfloat  sourceInput  =  input.source(close,  \"Source\")  \nint  samplesInput  =  input.int(20,  \"Samples\")  \nint  n  =  input.int(10,  \"Bars\")  \nfloat  multiplier  =  input.float(2.0,  \"StdDev\")  \n  \nvar  array<float> sourceArray  =  array.new<float>(samplesInput)  \nvar  float  sampleMean  =  na  \nvar  float  sampleDev  =  na  \n  \n// Identify if `n` bars have passed.  \nif  bar_index  %  n  ==  0  \n// Update the queue.  \nsourceArray.push(sourceInput)  \nsourceArray.shift()  \n// Update the mean and standard deviation values.  \nsampleMean  :=  sourceArray.avg()  \nsampleDev  :=  sourceArray.stdev() *  multiplier  \n  \n// Calculate band values.  \nfloat  highBand  =  sampleMean  +  sampleDev  \nfloat  lowBand  =  sampleMean  -  sampleDev  \n  \nplot(sampleMean,  \"Basis\",  color.orange)  \nplot(highBand,  \"Upper\",  color.lime)  \nplot(lowBand,  \"Lower\",  color.red)  \n``\n\nNote that:\n\n-   We call the array methods using  `sourceArray.*`  rather than referencing the  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  namespace.\n-   We do not include  `sourceArray`  as a parameter when we call the methods since they already reference the object.",
    "keywords": [
      "www.tradingview",
      "array.get",
      "id.get",
      "fun_array.get",
      "array.push",
      "fun_array.push",
      "array.shift",
      "fun_array.shift",
      "array.avg",
      "fun_array.avg",
      "array.stdev",
      "fun_array.stdev",
      "input.source",
      "input.int",
      "input.float",
      "array.new",
      "color.orange",
      "color.lime",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-36",
    "type": "documentation",
    "source": "concepts/methods.md",
    "section": "concepts",
    "title": "[Method  overloading](https://www.tradingview.com/pine-script-docs/language/methods/#method-overloading)",
    "content": "## [User-defined  methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)\n\nPine Script allows users to define custom methods for use with objects of any built-in or user-defined type. Defining a method is essentially the same as defining a function, but with two key differences:\n\n-   The  [method](https://www.tradingview.com/pine-script-reference/v6/#kw_method)  keyword must be included before the function name.\n-   The type of the first parameter in the signature must be explicitly declared, as it represents the type of object that the method will be associated with.\n\n```\n\n```\n\nLet‚Äôs apply user-defined methods to our previous Bollinger Bands example to encapsulate operations from the global scope, which will simplify the code and promote reusability. See this portion from the example:\n\n\n\n``// Identify if `n` bars have passed.  \nif  bar_index  %  n  ==  0  \n// Update the queue.  \nsourceArray.push(sourceInput)  \nsourceArray.shift()  \n// Update the mean and standard deviation values.  \nsampleMean  :=  sourceArray.avg()  \nsampleDev  :=  sourceArray.stdev() *  multiplier  \n  \n// Calculate band values.  \nfloat  highBand  =  sampleMean  +  sampleDev  \nfloat  lowBand  =  sampleMean  -  sampleDev  \n``\n\nWe will start by defining a simple method to queue values through an array in a single call.\n\nThis  `maintainQueue()`  method invokes the  [push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  and  [shift()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.shift)  methods on a  `srcArray`  when  `takeSample`  is true and returns the object:\n\n\n\n``// @function Maintains a queue of the size of `srcArray`.  \n// It appends a `value` to the array and removes its oldest element at position zero.  \n// @param srcArray (array<float>) The array where the queue is maintained.  \n// @param value (float) The new value to be added to the queue.  \n// The queue's oldest value is also removed, so its size is constant.  \n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.  \n// @returns (array<float>) `srcArray` object.  \nmethod  maintainQueue(array<float> srcArray,  float  value,  bool  takeSample  =  true) =>  \nif  takeSample  \nsrcArray.push(value)  \nsrcArray.shift()  \nsrcArray  \n``\n\nNote that:\n\n-   Just as with user-defined functions, we use the  `@function`  [compiler annotation](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations)  to document method descriptions.\n\nNow we can replace  `sourceArray.push()`  and  `sourceArray.shift()`  with  `sourceArray.maintainQueue()`  in our example:\n\n\n\n``// Identify if `n` bars have passed.  \nif  bar_index  %  n  ==  0  \n// Update the queue.  \nsourceArray.maintainQueue(sourceInput)  \n// Update the mean and standard deviation values.  \nsampleMean  :=  sourceArray.avg()  \nsampleDev  :=  sourceArray.stdev() *  multiplier  \n  \n// Calculate band values.  \nfloat  highBand  =  sampleMean  +  sampleDev  \nfloat  lowBand  =  sampleMean  -  sampleDev  \n``\n\nFrom here, we will further simplify our code by defining a method that handles all Bollinger Band calculations within its scope.\n\nThis  `calcBB()`  method invokes the  [avg()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.avg)  and  [stdev()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.stdev)  methods on a  `srcArray`  to update  `mean`  and  `dev`  values when  `calculate`  is true. The method uses these values to return a tuple containing the basis, upper band, and lower band values respectively:\n\n\n\n`// @function Computes Bollinger Band values from an array of data.  \n// @param srcArray (array<float>) The array where the queue is maintained.  \n// @param multiplier (float) Standard deviation multiplier.  \n// @param calcuate (bool) The method will only calculate new values when this is true.  \n// @returns A tuple containing the basis, upper band, and lower band respectively.  \nmethod  calcBB(array<float> srcArray,  float  mult,  bool  calculate  =  true) =>  \nvar  float  mean  =  na  \nvar  float  dev  =  na  \nif  calculate  \n// Compute the mean and standard deviation of the array.  \nmean  :=  srcArray.avg()  \ndev  :=  srcArray.stdev() *  mult  \n[mean,  mean  +  dev,  mean  -  dev]  \n`\n\nWith this method, we can now remove Bollinger Band calculations from the global scope and improve code readability:\n\n\n\n``// Identify if `n` bars have passed.  \nbool  newSample  =  bar_index  %  n  ==  0  \n  \n// Update the queue and compute new BB values on each new sample.  \n[sampleMean,  highBand,  lowBand] =  sourceArray.maintainQueue(sourceInput,  newSample).calcBB(multiplier,  newSample)  \n``\n\nNote that:\n\n-   Rather than using an  `if`  block in the global scope, we have defined a  `newSample`  variable that is only true once every  `n`  bars. The  `maintainQueue()`  and  `calcBB()`  methods use this value for their respective  `takeSample`  and  `calculate`  parameters.\n-   Since the  `maintainQueue()`  method returns the object that it references, we‚Äôre able to call  `calcBB()`  from the same line of code, as both methods apply to  `array<float>`  instances.\n\nHere is how the full script example looks now that we‚Äôve applied our user-defined methods:\n\n\n\n``//@version=6  \nindicator(\"Custom Sample BB\",  overlay  =  true)  \n  \nfloat  sourceInput  =  input.source(close,  \"Source\")  \nint  samplesInput  =  input.int(20,  \"Samples\")  \nint  n  =  input.int(10,  \"Bars\")  \nfloat  multiplier  =  input.float(2.0,  \"StdDev\")  \n  \nvar  array<float> sourceArray  =  array.new<float>(samplesInput)  \n  \n// @function Maintains a queue of the size of `srcArray`.  \n// It appends a `value` to the array and removes its oldest element at position zero.  \n// @param srcArray (array<float>) The array where the queue is maintained.  \n// @param value (float) The new value to be added to the queue.  \n// The queue's oldest value is also removed, so its size is constant.  \n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.  \n// @returns (array<float>) `srcArray` object.  \nmethod  maintainQueue(array<float> srcArray,  float  value,  bool  takeSample  =  true) =>  \nif  takeSample  \nsrcArray.push(value)  \nsrcArray.shift()  \nsrcArray  \n  \n// @function Computes Bollinger Band values from an array of data.  \n// @param srcArray (array<float>) The array where the queue is maintained.  \n// @param multiplier (float) Standard deviation multiplier.  \n// @param calcuate (bool) The method will only calculate new values when this is true.  \n// @returns A tuple containing the basis, upper band, and lower band respectively.  \nmethod  calcBB(array<float> srcArray,  float  mult,  bool  calculate  =  true) =>  \nvar  float  mean  =  na  \nvar  float  dev  =  na  \nif  calculate  \n// Compute the mean and standard deviation of the array.  \nmean  :=  srcArray.avg()  \ndev  :=  srcArray.stdev() *  mult  \n[mean,  mean  +  dev,  mean  -  dev]  \n  \n// Identify if `n` bars have passed.  \nbool  newSample  =  bar_index  %  n  ==  0  \n  \n// Update the queue and compute new BB values on each new sample.  \n[sampleMean,  highBand,  lowBand] =  sourceArray.maintainQueue(sourceInput,  newSample).calcBB(multiplier,  newSample)  \n  \nplot(sampleMean,  \"Basis\",  color.orange)  \nplot(highBand,  \"Upper\",  color.lime)  \nplot(lowBand,  \"Lower\",  color.red)  \n``",
    "keywords": [
      "www.tradingview",
      "fun_array.push",
      "fun_array.shift",
      "fun_array.avg",
      "fun_array.stdev",
      "input.source",
      "input.int",
      "input.float",
      "array.new",
      "color.orange",
      "color.lime",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-37",
    "type": "documentation",
    "source": "concepts/methods.md",
    "section": "concepts",
    "title": "[Advanced  example](https://www.tradingview.com/pine-script-docs/language/methods/#advanced-example)",
    "content": "## [Method  overloading](https://www.tradingview.com/pine-script-docs/language/methods/#method-overloading)\n\nUser-defined methods can override and overload existing built-in and user-defined methods with the same identifier. This capability allows users to define multiple routines associated with different parameter signatures under the same method name.\n\nAs a simple example, suppose we want to define a method to identify a variable‚Äôs type. Since we must explicitly specify the type of object associated with a user-defined method, we will need to define overloads for each type that we want it to recognize.\n\nBelow, we have defined a  `getType()`  method that returns a string representation of a variable‚Äôs type with overloads for the five primitive types:\n\n\n\n``// @function Identifies an object's type.  \n// @param this Object to inspect.  \n// @returns (string) A string representation of the type.  \nmethod  getType(int  this) =>  \nna(this) ?  \"int(na)\"  :  \"int\"  \n  \nmethod  getType(float  this) =>  \nna(this) ?  \"float(na)\"  :  \"float\"  \n  \nmethod  getType(bool  this) =>  \n// \"bool\" values only have two states, `true` and `false`, but never `na`.  \n\"bool\"  \n  \nmethod  getType(color  this) =>  \nna(this) ?  \"color(na)\"  :  \"color\"  \n  \nmethod  getType(string  this) =>  \nna(this) ?  \"string(na)\"  :  \"string\"  \n``\n\nNow we can use these overloads to inspect some variables. This script uses  [str.format()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.format)  to format the results from calling the  `getType()`  method on five different variables into a single  `results`  string, then displays the string in the  `lbl`  label using the built-in  [set_text()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_text)  method:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Methods_overloads_type_inspection.BxAK0zpG_2p2qvn.webp)\n\n\n\n`//@version=6  \nindicator(\"Type Inspection\")  \n  \n// @function Identifies an object's type.  \n// @param this Object to inspect.  \n// @returns (string) A string representation of the type.  \nmethod  getType(int  this) =>  \nna(this) ?  \"int(na)\"  :  \"int\"  \n  \nmethod  getType(float  this) =>  \nna(this) ?  \"float(na)\"  :  \"float\"  \n  \nmethod  getType(bool  this) =>  \nna(this) ?  \"bool(na)\"  :  \"bool\"  \n  \nmethod  getType(color  this) =>  \nna(this) ?  \"color(na)\"  :  \"color\"  \n  \nmethod  getType(string  this) =>  \nna(this) ?  \"string(na)\"  :  \"string\"  \n  \na  =  1  \nb  =  1.0  \nc  =  true  \nd  =  color.white  \ne  =  \"1\"  \n  \n// Inspect variables and format results.  \nresults  =  str.format(  \n\"a: {0}\\nb: {1}\\nc: {2}\\nd: {3}\\ne: {4}\",  \na.getType(),  b.getType(),  c.getType(),  d.getType(),  e.getType()  \n)  \n  \nvar  label  lbl  =  label.new(0,  0)  \nlbl.set_x(bar_index)  \nlbl.set_text(results)  \n`\n\nNote that:\n\n-   The underlying type of each variable determines which overload of  `getType()`  the compiler will use.\n-   The method will append ‚Äú(na)‚Äù to the output string when a variable is  `na`  to demarcate that it is empty.",
    "keywords": [
      "www.tradingview",
      "str.format",
      "fun_str.format",
      "fun_label.set_text",
      "color.white",
      "a.get",
      "b.get",
      "c.get",
      "d.get",
      "e.get",
      "label.new",
      "lbl.set_x",
      "lbl.set_text",
      "indicator",
      "var",
      "simple",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-38",
    "type": "documentation",
    "source": "concepts/methods.md",
    "section": "concepts",
    "title": "[Advanced  example](https://www.tradingview.com/pine-script-docs/language/methods/#advanced-example)",
    "content": "## [Advanced  example](https://www.tradingview.com/pine-script-docs/language/methods/#advanced-example)\n\nLet‚Äôs apply what we‚Äôve learned to construct a script that estimates the cumulative distribution of elements in an array, meaning the fraction of elements in the array that are less than or equal to any given value.\n\nThere are many ways in which we could choose to tackle this objective. For this example, we will start by defining a method to replace elements of an array, which will help us count the occurrences of elements within a range of values.\n\nWritten below is an overload of the built-in  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.fill)  method for  `array<float>`  instances. This overload replaces elements in a  `srcArray`  within the range between the  `lowerBound`  and  `upperBound`  with an  `innerValue`, and replaces all elements outside the range with an  `outerValue`:\n\n\n\n``// @function Replaces elements in a `srcArray` between `lowerBound` and `upperBound` with an `innerValue`,  \n// and replaces elements outside the range with an `outerValue`.  \n// @param srcArray (array<float>) Array to modify.  \n// @param innerValue (float) Value to replace elements within the range with.  \n// @param outerValue (float) Value to replace elements outside the range with.  \n// @param lowerBound (float) Lowest value to replace with `innerValue`.  \n// @param upperBound (float) Highest value to replace with `innerValue`.  \n// @returns (array<float>) `srcArray` object.  \nmethod  fill(array<float> srcArray,  float  innerValue,  float  outerValue,  float  lowerBound,  float  upperBound) =>  \nfor [i,  element] in  srcArray  \nif (element  >=  lowerBound  or  na(lowerBound)) and (element  <=  upperBound  or  na(upperBound))  \nsrcArray.set(i,  innerValue)  \nelse  \nsrcArray.set(i,  outerValue)  \nsrcArray  \n``\n\nWith this method, we can filter an array by value ranges to produce an array of occurrences. For example, the expression:\n\n\n\n`srcArray.copy().fill(1.0,  0.0,  min,  val)  \n`\n\ncopies the  `srcArray`  object, replaces all elements between  `min`  and  `val`  with 1.0, then replaces all elements above  `val`  with 0.0. From here, it‚Äôs easy to estimate the output of the cumulative distribution function at the  `val`, as it‚Äôs simply the average of the resulting array:\n\n\n\n`srcArray.copy().fill(1.0,  0.0,  min,  val).avg()  \n`\n\nNote that:\n\n-   The compiler will only use this  `fill()`  overload instead of the built-in when the user provides  `innerValue`,  `outerValue`,  `lowerBound`, and  `upperBound`  arguments in the call.\n-   If either  `lowerBound`  or  `upperBound`  is  `na`, its value is ignored while filtering the fill range.\n-   We are able to call  `copy()`,  `fill()`, and  `avg()`  successively on the same line of code because the first two methods return an  `array<float>`  instance.\n\nWe can now use this to define a method that will calculate our empirical distribution values. The following  `eCDF()`  method estimates a number of evenly spaced ascending  `steps`  from the cumulative distribution function of a  `srcArray`  and pushes the results into a  `cdfArray`:\n\n\n\n``// @function Estimates the empirical CDF of a `srcArray`.  \n// @param srcArray (array<float>) Array to calculate on.  \n// @param steps (int) Number of steps in the estimation.  \n// @returns (array<float>) Array of estimated CDF ratios.  \nmethod  eCDF(array<float> srcArray,  int  steps) =>  \nfloat  min  =  srcArray.min()  \nfloat  rng  =  srcArray.range() /  steps  \narray<float> cdfArray  =  array.new<float>()  \n// Add averages of `srcArray` filtered by value region to the `cdfArray`.  \nfloat  val  =  min  \nfor  i  =  1  to  steps  \nval  +=  rng  \ncdfArray.push(srcArray.copy().fill(1.0,  0.0,  min,  val).avg())  \ncdfArray  \n``\n\nLastly, to ensure that our  `eCDF()`  method functions properly for arrays containing small and large values, we will define a method to normalize our arrays.\n\nThis  `featureScale()`  method uses array  [min()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.min)  and  [range()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.range)  methods to produce a rescaled copy of a  `srcArray`. We will use this to normalize our arrays prior to invoking the  `eCDF()`  method:\n\n\n\n``// @function Rescales the elements within a `srcArray` to the interval [0, 1].  \n// @param srcArray (array<float>) Array to normalize.  \n// @returns (array<float>) Normalized copy of the `srcArray`.  \nmethod  featureScale(array<float> srcArray) =>  \nfloat  min  =  srcArray.min()  \nfloat  rng  =  srcArray.range()  \narray<float> scaledArray  =  array.new<float>()  \n// Push normalized `element` values into the `scaledArray`.  \nfor  element  in  srcArray  \nscaledArray.push((element  -  min) /  rng)  \nscaledArray  \n``\n\nNote that:\n\n-   This method does not include special handling for divide by zero conditions. If  `rng`  is 0, the value of the array element will be  `na`.\n\nThe full example below queues a  `sourceArray`  of size  `length`  with  `sourceInput`  values using our previous  `maintainQueue()`  method, normalizes the array‚Äôs elements using the  `featureScale()`  method, then calls the  `eCDF()`  method to get an array of estimates for  `n`  evenly spaced steps on the distribution. The script then calls a user-defined  `makeLabel()`  function to display the estimates and prices in a label on the right side of the chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Methods_empirical_distribution.BdS9hiv6_Z1t1cl8.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Empirical Distribution\",  overlay  =  true)  \n  \nfloat  sourceInput  =  input.source(close,  \"Source\")  \nint  length  =  input.int(20,  \"Length\")  \nint  n  =  input.int(20,  \"Steps\")  \n  \n// @function Maintains a queue of the size of `srcArray`.  \n// It appends a `value` to the array and removes its oldest element at position zero.  \n// @param srcArray (array<float>) The array where the queue is maintained.  \n// @param value (float) The new value to be added to the queue.  \n// The queue's oldest value is also removed, so its size is constant.  \n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.  \n// @returns (array<float>) `srcArray` object.  \nmethod  maintainQueue(array<float> srcArray,  float  value,  bool  takeSample  =  true) =>  \nif  takeSample  \nsrcArray.push(value)  \nsrcArray.shift()  \nsrcArray  \n  \n// @function Replaces elements in a `srcArray` between `lowerBound` and `upperBound` with an `innerValue`,  \n// and replaces elements outside the range with an `outerValue`.  \n// @param srcArray (array<float>) Array to modify.  \n// @param innerValue (float) Value to replace elements within the range with.  \n// @param outerValue (float) Value to replace elements outside the range with.  \n// @param lowerBound (float) Lowest value to replace with `innerValue`.  \n// @param upperBound (float) Highest value to replace with `innerValue`.  \n// @returns (array<float>) `srcArray` object.  \nmethod  fill(array<float> srcArray,  float  innerValue,  float  outerValue,  float  lowerBound,  float  upperBound) =>  \nfor [i,  element] in  srcArray  \nif (element  >=  lowerBound  or  na(lowerBound)) and (element  <=  upperBound  or  na(upperBound))  \nsrcArray.set(i,  innerValue)  \nelse  \nsrcArray.set(i,  outerValue)  \nsrcArray  \n  \n// @function Estimates the empirical CDF of a `srcArray`.  \n// @param srcArray (array<float>) Array to calculate on.  \n// @param steps (int) Number of steps in the estimation.  \n// @returns (array<float>) Array of estimated CDF ratios.  \nmethod  eCDF(array<float> srcArray,  int  steps) =>  \nfloat  min  =  srcArray.min()  \nfloat  rng  =  srcArray.range() /  steps  \narray<float> cdfArray  =  array.new<float>()  \n// Add averages of `srcArray` filtered by value region to the `cdfArray`.  \nfloat  val  =  min  \nfor  i  =  1  to  steps  \nval  +=  rng  \ncdfArray.push(srcArray.copy().fill(1.0,  0.0,  min,  val).avg())  \ncdfArray  \n  \n// @function Rescales the elements within a `srcArray` to the interval [0, 1].  \n// @param srcArray (array<float>) Array to normalize.  \n// @returns (array<float>) Normalized copy of the `srcArray`.  \nmethod  featureScale(array<float> srcArray) =>  \nfloat  min  =  srcArray.min()  \nfloat  rng  =  srcArray.range()  \narray<float> scaledArray  =  array.new<float>()  \n// Push normalized `element` values into the `scaledArray`.  \nfor  element  in  srcArray  \nscaledArray.push((element  -  min) /  rng)  \nscaledArray  \n  \n// @function Draws a label containing eCDF estimates in the format \"{price}: {percent}%\"  \n// @param srcArray (array<float>) Array of source values.  \n// @param cdfArray (array<float>) Array of CDF estimates.  \n// @returns (void)  \nmakeLabel(array<float> srcArray,  array<float> cdfArray) =>  \nfloat  max  =  srcArray.max()  \nfloat  rng  =  srcArray.range() /  cdfArray.size()  \nstring  results  =  \"\"  \nvar  label  lbl  =  label.new(0,  0,  \"\",  style  =  label.style_label_left,  text_font_family  =  font.family_monospace)  \n// Add percentage strings to `results` starting from the `max`.  \ncdfArray.reverse()  \nfor [i,  element] in  cdfArray  \nresults  +=  str.format(\"{0}: {1}%\\n\",  max  -  i  *  rng,  element  *  100)  \n// Update `lbl` attributes.  \nlbl.set_xy(bar_index  +  1,  srcArray.avg())  \nlbl.set_text(results)  \n  \nvar  array<float> sourceArray  =  array.new<float>(length)  \n  \n// Add background color for the last `length` bars.  \nbgcolor(bar_index  >  last_bar_index  -  length  ?  color.new(color.orange,  80) :  na)  \n  \n// Queue `sourceArray`, feature scale, then estimate the distribution over `n` steps.  \narray<float> distArray  =  sourceArray.maintainQueue(sourceInput).featureScale().eCDF(n)  \n// Draw label.  \nmakeLabel(sourceArray,  distArray)``",
    "keywords": [
      "www.tradingview",
      "fun_array.fill",
      "array.new",
      "fun_array.min",
      "fun_array.range",
      "tradingview.com",
      "input.source",
      "input.int",
      "label.new",
      "label.style_label_left",
      "font.family_monospace",
      "str.format",
      "lbl.set_xy",
      "lbl.set_text",
      "color.new",
      "color.orange",
      "indicator",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "const",
      "method",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-39",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "Creating  objects",
    "content": "# Objects\n\nTipThis page contains  _advanced_  material. If you‚Äôre new to Pine Script¬Æ, start by learning about core language components ‚Äî such as the  `type system`  and  `the basics`  of the  `execution model`  ‚Äî and explore other, more accessible features before venturing further.\n\n## Introduction\n\nPine Script objects are instances of  _user-defined types_  (UDTs). They are the equivalent of variables containing parts called  _fields_, each able to hold independent values that can be of various types.\n\nExperienced programmers can think of UDTs as method less classes. They allow users to create custom types that organize different values under one logical entity.",
    "keywords": [
      "var",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-40",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "[Changing field  values](https://www.tradingview.com/pine-script-docs/language/objects/#changing-field-values)",
    "content": "## Creating  objects\nBefore an object can be created, its type must be defined. The  [User-defined types](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  section of the  [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  page explains how to do so.\n\nLet‚Äôs define a  `pivotPoint`  type to hold pivot information:\n\n\n`type  pivotPoint  \nint  x  \nfloat  y  \nstring  xloc  =  xloc.bar_time  \n`\n\n\n\nNote that:\n\n-   We use the  [type](https://www.tradingview.com/pine-script-reference/v6/#kw_type)  keyword to declare the creation of a UDT.\n-   We name our new UDT  `pivotPoint`.\n-   After the first line, we create a local block containing the type and name of each field.\n-   The  `x`  field will hold the x-coordinate of the pivot. It is declared as an ‚Äúint‚Äù because it will hold either a timestamp or a bar index of ‚Äúint‚Äù type.\n-   `y`  is a ‚Äúfloat‚Äù because it will hold the pivot‚Äôs price.\n-   `xloc`  is a field that will specify the units of  `x`:  [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v6/#const_xloc%7Bdot%7Dbar_index)  or  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc%7Bdot%7Dbar_time). We set its default value to  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc%7Bdot%7Dbar_time)  by using the  `=`  operator. When an object is created from that UDT, its  `xloc`  field will thus be set to that value.\n\nNow that our  `pivotPoint`  UDT is defined, we can proceed to create objects from it. We create objects using the UDT‚Äôs  `new()`  built-in method. To create a new  `foundPoint`  object from our  `pivotPoint`  UDT, we use:\n\n\n\n`foundPoint  =  pivotPoint.new()  \n`\n\nWe can also specify field values for the created object using the following:\n\n\n\n`foundPoint  =  pivotPoint.new(time,  high)  \n`\n\nOr the equivalent:\n\n\n\n`foundPoint  =  pivotPoint.new(x  =  time,  y  =  high)  \n`\n\nAt this point, the  `foundPoint`  object‚Äôs  `x`  field will contain the value of the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  built-in when it is created,  `y`  will contain the value of  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  and the  `xloc`  field will contain its default value of  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc%7Bdot%7Dbar_time)  because no value was defined for it when creating the object.\n\nObject placeholders can also be created by declaring  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  object names using the following:\n\n\n`pivotPoint  foundPoint  =  na  \n`\n\nThis example displays a label where high pivots are detected. The pivots are detected  `legsInput`  bars after they occur, so we must plot the label in the past for it to appear on the pivot:\n\n\n\n``//@version=6  \nindicator(\"Pivot labels\",  overlay  =  true)  \nint  legsInput  =  input(10)  \n  \n// Define the `pivotPoint` UDT.  \ntype  pivotPoint  \nint  x  \nfloat  y  \nstring  xloc  =  xloc.bar_time  \n  \n// Detect high pivots.  \npivotHighPrice  =  ta.pivothigh(legsInput,  legsInput)  \nif  not  na(pivotHighPrice)  \n// A new high pivot was found; display a label where it occurred `legsInput` bars back.  \nfoundPoint  =  pivotPoint.new(time[legsInput],  pivotHighPrice)  \nlabel.new(  \nfoundPoint.x,  \nfoundPoint.y,  \nstr.tostring(foundPoint.y,  format.mintick),  \nfoundPoint.xloc,  \ntextcolor  =  color.white)  \n``\n\nTake note of this line from the above example:\n\n\n\n`foundPoint  =  pivotPoint.new(time[legsInput],  pivotHighPrice)  \n`\n\nThis could also be written using the following:\n\n\n\n`pivotPoint  foundPoint  =  na  \nfoundPoint  :=  pivotPoint.new(time[legsInput],  pivotHighPrice)  \n`\n\nWhen using the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword while declaring a variable assigned to an object of a  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types), the keyword automatically applies to all the object‚Äôs fields:\n\n\n\n``//@version=6  \nindicator(\"Objects using `var` demo\")  \n  \n//@type A custom type to hold index, price, and volume information.  \ntype  BarInfo  \nint  index  =  bar_index  \nfloat  price  =  close  \nfloat  vol  =  volume  \n  \n//@variable A `BarInfo` instance whose fields persist through all iterations, starting from the first bar.  \nvar  BarInfo  firstBar  =  BarInfo.new()  \n//@variable A `BarInfo` instance declared on every bar.  \nBarInfo  currentBar  =  BarInfo.new()  \n  \n// Plot the `index` fields of both instances to compare the difference.  \nplot(firstBar.index)  \nplot(currentBar.index)  \n``\n\nIt‚Äôs important to note that assigning an object to a variable that uses the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword does  _not_  automatically allow the object‚Äôs fields to persist without rolling back on each  _intrabar_  update. One must apply the keyword to each desired field in the type declaration to achieve this behavior. For example:\n\n\n\n``//@version=6  \nindicator(\"Objects using `varip` fields demo\")  \n  \n//@type A custom type that counts the bars and ticks in the script's execution.  \ntype  Counter  \nint  bars  =  0  \nvarip  int  ticks  =  0  \n  \n//@variable A `Counter` object whose reference persists throughout all bars.  \nvar  Counter  counter  =  Counter.new()  \n  \n// Add 1 to the `bars` and `ticks` fields. The `ticks` field is not subject to rollback on unconfirmed bars.  \ncounter.bars  +=  1  \ncounter.ticks  +=  1  \n  \n// Plot both fields for comparison.  \nplot(counter.bars,  \"Bar counter\",  color.blue,  3)  \nplot(counter.ticks,  \"Tick counter\",  color.purple,  3)  \n``\n\nNote that:\n\n-   We used the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword to specify that the  `Counter`  object assigned to the  `counter`  variable persists throughout the script‚Äôs execution.\n-   The  `bars`  field rolls back on realtime bars, whereas the  `ticks`  field does not since we included  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  in its declaration.",
    "keywords": [
      "www.tradingview",
      "xloc.bar_time",
      "xloc.bar_index",
      "ta.pivothigh",
      "label.new",
      "str.tostring",
      "format.mintick",
      "color.white",
      "counter.bars",
      "counter.ticks",
      "color.blue",
      "color.purple",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "varip",
      "const",
      "import",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-41",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "[Collecting  objects](https://www.tradingview.com/pine-script-docs/language/objects/#collecting-objects)",
    "content": "## [Changing field  values](https://www.tradingview.com/pine-script-docs/language/objects/#changing-field-values)\n\nThe value of an object‚Äôs fields can be changed using the  [:=](https://www.tradingview.com/pine-script-docs/language/operators/#-reassignment-operator)  reassignment operator.\n\nThis line of our previous example:\n\n\n\n`foundPoint  =  pivotPoint.new(time[legsInput],  pivotHighPrice)  \n`\n\nCould be written using the following:\n\n\n\n`foundPoint  =  pivotPoint.new()  \nfoundPoint.x  :=  time[legsInput]  \nfoundPoint.y  :=  pivotHighPrice  \n`",
    "keywords": [
      "www.tradingview",
      "input"
    ]
  },
  {
    "id": "doc-42",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "[Copying  objects](https://www.tradingview.com/pine-script-docs/language/objects/#copying-objects)",
    "content": "## [Collecting  objects](https://www.tradingview.com/pine-script-docs/language/objects/#collecting-objects)\n\nPine Script  _collections_  ([arrays](https://www.tradingview.com/pine-script-docs/language/arrays/),  [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/), and  [maps](https://www.tradingview.com/pine-script-docs/language/maps/)) can contain references to UDT objects, enabling programmers to add virtual dimensions to their data structures. To create a collection of a user-defined type, call the collection type‚Äôs  `*.new*()`  function with the UDT name in the function‚Äôs  _type template_.\n\nThe following line of code declares a variable that holds the ID of an empty  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  that can store references to objects of a  `pivotPoint`  user-defined type:\n\n\n\n`pivotHighArray  =  array.new<pivotPoint>()  \n`\n\nTo explicitly declare the type of a variable as an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array),  [matrix](https://www.tradingview.com/pine-script-reference/v6/#type_matrix), or  [map](https://www.tradingview.com/pine-script-reference/v6/#type_map)  of a  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types), prefix the variable declaration with collection‚Äôs  _type keyword_  followed by its  _type template_. For example:\n\n\n\n`var  array<pivotPoint> pivotHighArray  =  na  \npivotHighArray  :=  array.new<pivotPoint>()  \n`\n\nSee the  [Collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  section of the  [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/)  page to learn about type templates.\n\nLet‚Äôs use what we have learned to create a script that detects high pivot points. The script first collects historical pivot information in an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array). It then loops through the array on the last historical bar, creating a label for each pivot and connecting the pivots with lines:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Objects-CollectingObjects-1.Or5ovJGC_Zw2Kvh.webp)\n\n\n\n``//@version=6  \nindicator(\"Pivot Points High\",  overlay  =  true)  \n  \nint  legsInput  =  input(10)  \n  \n// Define the `pivotPoint` UDT containing the time and price of pivots.  \ntype  pivotPoint  \nint  openTime  \nfloat  level  \n  \n// Create an empty `pivotPoint` array.  \nvar  pivotHighArray  =  array.new<pivotPoint>()  \n  \n// Detect new pivots (`na` is returned when no pivot is found).  \npivotHighPrice  =  ta.pivothigh(legsInput,  legsInput)  \n  \n// Add a new `pivotPoint` object to the end of the array for each detected pivot.  \nif  not  na(pivotHighPrice)  \n// A new pivot is found; create a new object of `pivotPoint` type, setting its `openTime` and `level` fields.  \nnewPivot  =  pivotPoint.new(time[legsInput],  pivotHighPrice)  \n// Add the new pivot object to the array.  \narray.push(pivotHighArray,  newPivot)  \n  \n// On the last historical bar, draw pivot labels and connecting lines.  \nif  barstate.islastconfirmedhistory  \nvar  pivotPoint  previousPoint  =  na  \nfor  eachPivot  in  pivotHighArray  \n// Display a label at the pivot point.  \nlabel.new(eachPivot.openTime,  eachPivot.level,  str.tostring(eachPivot.level,  format.mintick),  xloc.bar_time,  textcolor  =  color.white)  \n// Create a line between pivots.  \nif  not  na(previousPoint)  \n// Only create a line starting at the loop's second iteration because lines connect two pivots.  \nline.new(previousPoint.openTime,  previousPoint.level,  eachPivot.openTime,  eachPivot.level,  xloc  =  xloc.bar_time)  \n// Save the pivot for use in the next iteration.  \npreviousPoint  :=  eachPivot  \n``",
    "keywords": [
      "www.tradingview",
      "array.new",
      "ta.pivothigh",
      "array.push",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "format.mintick",
      "xloc.bar_time",
      "color.white",
      "line.new",
      "indicator",
      "overlay",
      "input",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-43",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "[Shadowing](https://www.tradingview.com/pine-script-docs/language/objects/#shadowing)",
    "content": "## [Copying  objects](https://www.tradingview.com/pine-script-docs/language/objects/#copying-objects)\n\nIn Pine, objects are assigned by reference. When an existing object is assigned to a new variable, both point to the same object.\n\nIn the example below, we create a  `pivot1`  object and set its  `x`  field to 1000. Then, we declare a  `pivot2`  variable containing the reference to the  `pivot1`  object, so both point to the same instance. Changing  `pivot2.x`  will thus also change  `pivot1.x`, as both refer to the  `x`  field of the same object:\n\n\n\n`//@version=6  \nindicator(\"\")  \ntype  pivotPoint  \nint  x  \nfloat  y  \npivot1  =  pivotPoint.new()  \npivot1.x  :=  1000  \npivot2  =  pivot1  \npivot2.x  :=  2000  \n// Both plot the value 2000.  \nplot(pivot1.x)  \nplot(pivot2.x)  \n`\n\nTo create a copy of an object that is independent of the original, we can use the built-in  `copy()`  method in this case.\n\nIn this example, we declare the  `pivot2`  variable referring to a copied instance of the  `pivot1`  object. Now, changing  `pivot2.x`  will not change  `pivot1.x`, as it refers to the  `x`  field of a separate object:\n\n\n\n`//@version=6  \nindicator(\"\")  \ntype  pivotPoint  \nint  x  \nfloat  y  \npivot1  =  pivotPoint.new()  \npivot1.x  :=  1000  \npivot2  =  pivotPoint.copy(pivot1)  \npivot2.x  :=  2000  \n// Plots 1000 and 2000.  \nplot(pivot1.x)  \nplot(pivot2.x)  \n`\n\nIt‚Äôs important to note that the built-in  `copy()`  method produces a  _shallow copy_  of an object. If an object has fields with  _special types_  ([array](https://www.tradingview.com/pine-script-reference/v6/#type_array),  [matrix](https://www.tradingview.com/pine-script-reference/v6/#type_matrix),  [map](https://www.tradingview.com/pine-script-reference/v6/#type_map),  [line](https://www.tradingview.com/pine-script-reference/v6/#type_line),  [linefill](https://www.tradingview.com/pine-script-reference/v6/#type_linefill),  [box](https://www.tradingview.com/pine-script-reference/v6/#type_box),  [polyline](https://www.tradingview.com/pine-script-reference/v6/#type_polyline),  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label),  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table), or  [chart.point](https://www.tradingview.com/pine-script-reference/v6/#type_chart.point)), those fields in a shallow copy of the object will point to the same instances as the original.\n\nIn the following example, we have defined an  `InfoLabel`  type with a label as one of its fields. The script instantiates a  `shallow`  copy of the  `parent`  object, then calls a user-defined  `set()`  [method](https://www.tradingview.com/pine-script-docs/language/methods/)  to update the  `info`  and  `lbl`  fields of each object. Since the  `lbl`  field of both objects points to the same label instance, changes to this field in either object affect the other:\n\n\n\n`//@version=6  \nindicator(\"Shallow Copy\")  \n  \ntype  InfoLabel  \nstring  info  \nlabel  lbl  \n  \nmethod  set(InfoLabel  this,  int  x  =  na,  int  y  =  na,  string  info  =  na) =>  \nif  not  na(x)  \nthis.lbl.set_x(x)  \nif  not  na(y)  \nthis.lbl.set_y(y)  \nif  not  na(info)  \nthis.info  :=  info  \nthis.lbl.set_text(this.info)  \n  \nvar  parent  =  InfoLabel.new(\"\",  label.new(0,  0))  \nvar  shallow  =  parent.copy()  \n  \nparent.set(bar_index,  0,  \"Parent\")  \nshallow.set(bar_index,  1,  \"Shallow Copy\")  \n`\n\nTo produce a  _deep copy_  of an object with all of its special type fields pointing to independent instances, we must explicitly copy those fields as well.\n\nIn this example, we have defined a  `deepCopy()`  method that instantiates a new  `InfoLabel`  object with its  `lbl`  field pointing to a copy of the original‚Äôs field. Changes to the  `deep`  copy‚Äôs  `lbl`  field will not affect the  `parent`  object, as it points to a separate instance:\n\n\n\n`//@version=6  \nindicator(\"Deep Copy\")  \n  \ntype  InfoLabel  \nstring  info  \nlabel  lbl  \n  \nmethod  set(InfoLabel  this,  int  x  =  na,  int  y  =  na,  string  info  =  na) =>  \nif  not  na(x)  \nthis.lbl.set_x(x)  \nif  not  na(y)  \nthis.lbl.set_y(y)  \nif  not  na(info)  \nthis.info  :=  info  \nthis.lbl.set_text(this.info)  \n  \nmethod  deepCopy(InfoLabel  this) =>  \nInfoLabel.new(this.info,  this.lbl.copy())  \n  \nvar  parent  =  InfoLabel.new(\"\",  label.new(0,  0))  \nvar  deep  =  parent.deepCopy()  \n  \nparent.set(bar_index,  0,  \"Parent\")  \ndeep.set(bar_index,  1,  \"Deep Copy\")  \n`",
    "keywords": [
      "www.tradingview",
      "chart.point",
      "type_chart.point",
      "this.lbl",
      "this.info",
      "label.new",
      "parent.copy",
      "parent.set",
      "shallow.set",
      "parent.deep",
      "deep.set",
      "indicator",
      "plot",
      "fill",
      "var",
      "import",
      "method",
      "type",
      "if"
    ]
  },
  {
    "id": "doc-44",
    "type": "documentation",
    "source": "concepts/objects.md",
    "section": "concepts",
    "title": "[Shadowing](https://www.tradingview.com/pine-script-docs/language/objects/#shadowing)",
    "content": "## [Shadowing](https://www.tradingview.com/pine-script-docs/language/objects/#shadowing)\n\nTo avoid potential conflicts in the eventuality where namespaces added to Pine Script in the future would collide with UDT names in existing scripts; as a rule, UDT names shadow the language‚Äôs namespaces. For example, a UDT can have the same name as some built-in types, such as  [line](https://www.tradingview.com/pine-script-reference/v6/#type_line)  or  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table).\n\nHowever, scripts cannot use the following keywords for  [fundamental types](https://www.tradingview.com/pine-script-docs/language/type-system/#types)  as names for UDTs:  [int](https://www.tradingview.com/pine-script-reference/v6/#type_int),  [float](https://www.tradingview.com/pine-script-reference/v6/#type_float),  [string](https://www.tradingview.com/pine-script-reference/v6/#type_string),  [bool](https://www.tradingview.com/pine-script-reference/v6/#type_bool), and  [color](https://www.tradingview.com/pine-script-reference/v6/#type_color).",
    "keywords": [
      "www.tradingview",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-45",
    "type": "documentation",
    "source": "concepts/timeframes.md",
    "section": "concepts",
    "title": "[Timeframe string  specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications)",
    "content": "# [Timeframes](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframes)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#introduction)\n\nThe  _timeframe_  of a chart is sometimes also referred to as its  _interval_  or  _resolution_. It is the unit of time represented by one bar on the chart. All standard chart types use a timeframe: ‚ÄúBars‚Äù, ‚ÄúCandles‚Äù, ‚ÄúHollow Candles‚Äù, ‚ÄúLine‚Äù, ‚ÄúArea‚Äù and ‚ÄúBaseline‚Äù. One non-standard chart type also uses timeframes: ‚ÄúHeikin Ashi‚Äù.\n\nProgrammers interested in accessing data from multiple timeframes will need to become familiar with how timeframes are expressed in Pine Script¬Æ, and how to use them.\n\n**Timeframe strings**  come into play in different contexts:\n\n-   They must be used in  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  when requesting data from another symbol and/or timeframe. See the page on  [Other timeframes and data](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/)  to explore the use of  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security).\n-   They can be used as an argument to  [time()](https://www.tradingview.com/pine-script-reference/v6/#fun_time)  and  [time_close()](https://www.tradingview.com/pine-script-reference/v6/#fun_time_close)  functions, to return the time of a higher timeframe bar. This, in turn, can be used to detect changes in higher timeframes from the chart‚Äôs timeframe without using  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security). See the  [Testing for changes in higher timeframes](https://www.tradingview.com/pine-script-docs/concepts/time/#testing-for-changes-in-higher-timeframes)  section to see how to do this.\n-   The  [input.timeframe()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.timeframe)  function provides a way to allow script users to define a timeframe through a script‚Äôs ‚ÄúInputs‚Äù tab (see the  [Timeframe input](https://www.tradingview.com/pine-script-docs/concepts/inputs/#timeframe-input)  section for more information).\n-   The  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  declaration statement has an optional  `timeframe`  parameter that can be used to provide multi-timeframe capabilities to simple scripts without using  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security).\n-   Many built-in variables provide information on the timeframe used by the chart the script is running on. See the  [Chart timeframe](https://www.tradingview.com/pine-script-docs/concepts/chart-information/#chart-timeframe)  section for more information on them, including  [timeframe.period](https://www.tradingview.com/pine-script-reference/v6/#var_timeframe.period)  which returns a string in Pine Script‚Äôs timeframe specification format.",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "input.timeframe",
      "fun_input.timeframe",
      "timeframe.period",
      "var_timeframe.period",
      "indicator",
      "input",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-46",
    "type": "documentation",
    "source": "concepts/timeframes.md",
    "section": "concepts",
    "title": "[Comparing  timeframes](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#comparing-timeframes)",
    "content": "## [Timeframe string  specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications)\n\nTimeframe strings follow these rules:\n\n-   They are composed of the multiplier and the timeframe unit, e.g., ‚Äú1S‚Äù, ‚Äú30‚Äù (30 minutes), ‚Äú1D‚Äù (one day), ‚Äú3M‚Äù (three months).\n    \n-   The unit is represented by a single letter, with no letter used for minutes: ‚ÄúT‚Äù for ticks, ‚ÄúS‚Äù for seconds, ‚ÄúD‚Äù for days, ‚ÄúW‚Äù for weeks, and ‚ÄúM‚Äù for months.\n    \n-   When no multiplier is used, 1 is assumed: ‚ÄúS‚Äù is equivalent to ‚Äú1S‚Äù, ‚ÄúD‚Äù to ‚Äú1D‚Äù, etc. If only ‚Äú1‚Äù is used, it is interpreted as 1 minute, since no unit letter identifier is used for minutes.\n    \n-   There is no ‚Äúhour‚Äù unit; ‚Äú1H‚Äù is  **not**  valid. The correct format for one hour is ‚Äú60‚Äù (remember no unit letter is specified for minutes).\n    \n-   The valid multipliers vary for each timeframe unit:\n    \n    -   For ticks, only the discrete 1, 10, 100, and 1000 multipliers are valid.\n    -   For seconds, only the discrete 1, 5, 10, 15, 30, and 45 multipliers are valid.\n    -   For minutes, 1 to 1440.\n    -   For days, 1 to 365.\n    -   For weeks, 1 to 52.\n    -   For months, 1 to 12.",
    "keywords": [
      "www.tradingview",
      "e.g",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-47",
    "type": "documentation",
    "source": "concepts/timeframes.md",
    "section": "concepts",
    "title": "[Comparing  timeframes](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#comparing-timeframes)",
    "content": "## [Comparing  timeframes](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#comparing-timeframes)\n\nIt can be useful to compare different timeframe strings to determine, for example, if the timeframe used on the chart is lower than the higher timeframes used in the script.\n\nConverting timeframe strings to a representation in fractional minutes provides a way to compare them using a universal unit. This script uses the  [timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.in_seconds)  function to convert a timeframe into float seconds and then converts the result into minutes:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Timeframe in minutes example\",  \"\",  true)  \nstring  tfInput  =  input.timeframe(defval  =  \"\",  title  =  \"Input TF\")  \n  \nfloat  chartTFInMinutes  =  timeframe.in_seconds() /  60  \nfloat  inputTFInMinutes  =  timeframe.in_seconds(tfInput) /  60  \n  \nvar  table  t  =  table.new(position.top_right,  1,  1)  \nstring  txt  =  \"Chart TF: \"  +  str.tostring(chartTFInMinutes,  \"#.##### minutes\") +  \n\"\\nInput TF: \"  +  str.tostring(inputTFInMinutes,  \"#.##### minutes\")  \nif  barstate.isfirst  \ntable.cell(t,  0,  0,  txt,  bgcolor  =  color.yellow)  \nelse  if  barstate.islast  \ntable.cell_set_text(t,  0,  0,  txt)  \n  \nif  chartTFInMinutes  >  inputTFInMinutes  \nruntime.error(\"The chart's timeframe must not be higher than the input's timeframe.\")  \n`\n\nNote that:\n\n-   We use the built-in  [timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.in_seconds)  function to convert the chart timeframe and the timeframe selected by the user into seconds, then divide by 60 to convert into minutes.\n-   We use two calls to the  [timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v6/#fun_timeframe.in_seconds)  function in the initialization of the  `chartTFInMinutes`  and  `inputTFInMinutes`  variables. In the first instance, we do not supply an argument for its  `timeframe`  parameter, so the function returns the chart‚Äôs timeframe in seconds. In the second call, we supply the timeframe selected in the  [timeframe input](https://www.tradingview.com/pine-script-docs/concepts/inputs/#timeframe-input).\n-   Next, we validate the timeframes to ensure that the input timeframe is equal to or higher than the chart‚Äôs timeframe. If it is not, the script generates a custom runtime error.\n-   We finally print the two timeframe values converted to minutes.",
    "keywords": [
      "www.tradingview",
      "timeframe.in_seconds",
      "fun_timeframe.in_seconds",
      "tradingview.com",
      "input.timeframe",
      "table.new",
      "position.top_right",
      "str.tostring",
      "barstate.isfirst",
      "table.cell",
      "color.yellow",
      "barstate.islast",
      "table.cell_set_text",
      "runtime.error",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-48",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Bar-by-bar execution](https://www.tradingview.com/pine-script-docs/language#bar-by-bar-execution)",
    "content": "## Language / Execution model\r\nURL Source: https://www.tradingview.com/pine-script-docs/language\r\n\r\n## [Introduction](https://www.tradingview.com/pine-script-docs/language#introduction)\r\n----------------------------------------------------------------------------------\r\n### Pine Script¬Æ relies on an event-driven, sequential execution model to control how a script‚Äôs compiled source code runs in charts, [alerts], [Deep Backtesting] mode, and the [Pine Screener].\r\n### In contrast to the traditional execution model of most programming languages, Pine‚Äôs runtime system executes a script _repeatedly_ on the sequence of _historical bars_ and _realtime ticks_ in the dataset on which it runs, performing _separate_ calculations for _each bar_ as it progresses. After each execution on a closed bar, the necessary data from that execution becomes part of an internal [time series] , and the script can use that data in its calculations on subsequent bars.\r\nThis combination of sequential executions and storage enables programmers to use minimal code to write scripts with dynamic calculations that advance across a dataset bar by bar.\r\nThe execution model and time series structure closely connect to the [type system](https://www.tradingview.com/pine-script-docs/language/type-system/) ‚Äî together, they define how a script behaves as it runs on a dataset. Although it‚Äôs possible to write simple scripts without understanding these foundational topics, learning about them and their nuances is key to becoming proficient in Pine Script.\r\nThis page explains the execution model in two parts: [The basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics) and [The details](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-details). The first part provides quick, actionable information about the model for beginners. The second part offers an _advanced_, in-depth breakdown of the model‚Äôs workings and unique behaviors. To make the most of the information on this page, we recommend that newcomers to Pine Script start with [The basics](https://www.tradingview.com/pine-script-docs/language/execution-model/#the-basics), learn about other topics in this manual, and then come back to this page for the advanced details.\r\n[The basics](https://www.tradingview.com/pine-script-docs/language#the-basics)\r\n------------------------------------------------------------------------------\r\nThe following sections outline core principles of the execution model for beginners. If you are new to Pine Script, start here.",
    "keywords": [
      "www.tradingview",
      "alert",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-49",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Storing and using data from previous bars](https://www.tradingview.com/pine-script-docs/language#storing-and-using-data-from-previous-bars)",
    "content": "### [Bar-by-bar execution](https://www.tradingview.com/pine-script-docs/language#bar-by-bar-execution)\r\nThe dataset for a symbol on a given timeframe, as shown on a chart, consists of a sequence of bars representing a _time series_. Each bar in the sequence represents the price and volume for a specific time period. The first (leftmost) bar on a chart corresponds to the _earliest_ period, and the last (rightmost) bar corresponds to the _most recent_ period.\r\nMuch of the power of Pine Script stems from its ability to process this time series data efficiently. When a user runs a script, its code does _not_ execute just once; it executes from start to end on _each bar_ in the symbol‚Äôs dataset individually, progressing from the first available bar to the most recent bar. Each separate script execution performs calculations or generates outputs (e.g., [plots](https://www.tradingview.com/pine-script-docs/concepts/plots/)) for a _specific bar_ using the data available on that bar.\r\nA script can retrieve price, volume, and other essential data for each bar on which it executes by using the [built-in variables](https://www.tradingview.com/pine-script-docs/language/built-ins/#built-in-variables) that hold bar information, such as [open](https://www.tradingview.com/pine-script-reference/v6/#var_open), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume). These variables automatically _update_ before each new execution to store the values for the _current bar_.\r\nFor example, the simple script below uses the [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) function to display the series of [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) values (i.e., the closing price of each bar) on the chart:\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Bar-by-bar execution demo\", overlay = true, behind_chart = false)\r\n// Plot the `close` series on the chart.\r\n// This call defines the plotted point for the current bar on each execution.\r\nplot(close, \"Close price\", chart.fg_color, 5)\r\n```\r\n\r\nWhen a user first adds this script to their chart, its code executes _once_ for _every bar_ in the available dataset. As the script runs on the data, two primary steps occur on each bar:\r\n1.   The [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) variable automatically updates to hold the current bar‚Äôs latest price.\r\n2.   The [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) function call plots the updated [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) value at the current bar‚Äôs position.\r\nWhen the script finishes its run from the first bar to the most recent bar, the result is a simple _line plot_ showing the progression of closing prices across the chart‚Äôs history:\r\n![Image 1: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-1.D5nkQfFJ_1oCMgX.webp)\r\nNote that the above script evaluates the [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) function call once for every bar on the chart, not just once in total. On each separate execution, the call defines the plotted point for the current bar: the chart‚Äôs first bar during the first execution, the second bar during the next, and so on.\r\nThis pattern illustrates a key principle of Pine‚Äôs execution model: on each successive execution, a script _re-evaluates_ function calls and other expressions within its required _scopes_ to perform separate calculations for the current bar.\r\nRepeated code evaluation also applies to [variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/). By default, a script does not declare a variable only once throughout its runtime; the script _re-declares_ that variable and assigns an initial value based on the current bar‚Äôs data during _each_ new evaluation of its scope.\r\nLet‚Äôs look at a simple example. The following script declares an `x` variable of the ‚Äúint‚Äù [type](https://www.tradingview.com/pine-script-docs/language/type-system/#types) with an initial value of 0. Then, it increases the variable‚Äôs value by 10 with the addition assignment operator ([+=](https://www.tradingview.com/pine-script-reference/v6/#op_+=)). The script calls [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) to display the value of `x` on each bar in a separate pane:\r\n![Image 2: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-2.CYV_XhNc_fPGku.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Repeated declarations demo\")\r\n//@variable A user-defined variable. The script declares this variable and initializes it to 0 on *every* execution.\r\nint x = 0\r\n// Increase the value of `x` by 10 on every bar.\r\nx += 10\r\n// Plot the value of `x`.\r\n// Because `x` begins at 0 on every execution, and the script adds 10 to that value, the plotted value is always 10.\r\nplot(x, \"`x` value\", color.blue, 3)\r\n```\r\n\r\nAs shown above, the script plots a value of 10 on every bar, because the `x` variable _does not_ carry over from bar to bar; the script declares the variable _repeatedly_. On each bar, the script re-declares `x` with an initial value of 0, then adds 10 to that value, resulting in a final value of 10 for every plotted point.\r\nProgrammers can change the behavior of a variable, enabling it to _persist_ and preserve updates to its value _across bars_, by including the [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) keyword in its declaration, as described in the [Declaration modes](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes) section of the [Variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/) page.\r\nBelow, we modify the previous script by adding [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) to the `x` declaration. Now, the script declares and initializes `x` only _once_ ‚Äî on the _first bar_ ‚Äî and that variable persists across _all_ bars that follow. The script now plots a line that _increases_ by 10 on each bar, because `x` preserves the result from each addition across the chart‚Äôs history. The value changes from 0 to 10 on the first bar, then to 20 on the second, and so on:\r\n![Image 3: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Bar-by-bar-execution-3.2eRg8rX8_ZUqlGK.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Persistent declarations demo\")\r\n//@variable A *persistent* variable. The script initializes this variable only on the *first execution*.\r\n//          The variable preserves all changes to its value on each closed bar.\r\nvar int x = 0\r\n// Increase the value of `x` by 10 on every bar.\r\nx += 10\r\n// Plot the `x` series on the chart.\r\n// Because the script declares `x` using `var` and then increments its value, the value never resets to 0.\r\n// The plotted value is 10 on the first bar, 20 on the next, and so on.\r\nplot(x, \"`x` series\", color.blue, 3)\r\n```",
    "keywords": [
      "www.tradingview",
      "e.g",
      "i.e",
      "chart.fg_color",
      "color.blue",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-50",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Realtime bars](https://www.tradingview.com/pine-script-docs/language#realtime-bars)",
    "content": "### [Storing and using data from previous bars](https://www.tradingview.com/pine-script-docs/language#storing-and-using-data-from-previous-bars)\r\nAs a script runs on a dataset, the states of its variables, function calls, and other expressions are automatically _committed (saved)_ to an internal _time series_ on each bar, creating historical trails of previous bar values that the script can access during its calculations on the current bar. The script can use these previous values by doing either of the following:\r\n*   Using the [[] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator). The number in the square brackets represents how many _bars back_ from the current bar the script looks to retrieve a past value. For instance, `close[1]` retrieves the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) value from _one bar before_ the current bar, and `close[100]` retrieves the value from _100 bars back_.\r\n*   Calling the [built-in functions](https://www.tradingview.com/pine-script-docs/language/built-ins/#built-in-functions) that calculate on past values internally, such as `ta.*()` functions. For instance, `ta.change(close, 10)` calculates the difference between the current value of [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) and its value from 10 bars back.\r\nThe example below uses both of the above techniques to perform calculations based on data from previous bars. The script calculates a series of bar-by-bar price returns and plots the result as color-coded columns. It declares two global variables on each bar: `priceReturn` for the calculated returns, and `returnColor` for the plot‚Äôs color. The `priceReturn` value is the result of dividing the current one-bar change in closing prices (`ta.change(close, 1)`) by the previous bar‚Äôs closing price (`close[1]`). The `returnColor` value is [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal) if the current value of `priceReturn` is higher than the value from the previous bar (`priceReturn[1]`), and [color.maroon](https://www.tradingview.com/pine-script-reference/v6/#const_color.maroon) otherwise:\r\n![Image 4: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Storing-and-using-data-from-previous-bars-1.CZbtEkeL_Z28dT9i.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Storing and using data from previous bars demo\")\r\n//@variable The one-bar price return, based on the current and *previous* bars' `close` values.\r\n//          This variable's final value on each bar automatically becomes part of the internal time series.\r\nfloat priceReturn = ta.change(close, 1) / close[1]\r\n//@variable Is `color.teal` if the `priceReturn` value is above the value on the previous bar; `color.maroon` otherwise.\r\ncolor returnColor = priceReturn > priceReturn[1] ? color.teal : color.maroon\r\n// Plot the current `priceReturn` value as a column, colored using the value of `returnColor`.\r\nplot(priceReturn, \"Price return\", returnColor, 1, plot.style_columns)\r\n```\r\n\r\nNote that:\r\n*   This script does _not_ plot a column on bar 0 (the _first_ bar). The `priceReturn` value is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) on that bar, because there is _no previous bar_ available for the script to reference at that point.",
    "keywords": [
      "www.tradingview",
      "ta.change",
      "color.teal",
      "const_color.teal",
      "color.maroon",
      "const_color.maroon",
      "plot.style_columns",
      "indicator",
      "plot",
      "var",
      "series",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-51",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Executions on historical bars](https://www.tradingview.com/pine-script-docs/language#executions-on-historical-bars)",
    "content": "### [Realtime bars](https://www.tradingview.com/pine-script-docs/language#realtime-bars)\r\nWhen a script first runs on a chart, all _closed_ bars in the accessed dataset are _historical bars_. These bars represent data for elapsed time periods where the final price and volume are _confirmed_. All indicators execute **once** per historical bar.\r\nWhen the rightmost bar on the chart is _open_, it is a _realtime bar_. Unlike a historical bar, whose values are final, a realtime bar _updates_ its values as new price or volume data becomes available. After the bar closes, it becomes an _elapsed realtime bar_, which is then no longer subject to change as the script runs.\r\nBecause the final values for a realtime bar are _unknown_ until the bar closes, an indicator executes differently on that bar than it does on historical bars. The script executes not once, but **repeatedly** on the realtime bar ‚Äî once for each new _update (tick)_ ‚Äî to _recalculate_ its results using the latest data.\r\nBefore each recalculation on the realtime bar, the data for a script‚Äôs variables, expressions, and outputs on that bar is _cleared_, or _reset_. We refer to this process as _rollback_. The purpose of rollback is to revert the script to the same confirmed state it had when the realtime bar opened. This process ensures that the script‚Äôs calculations for the bar operate only on the latest available data, without relying on _temporary data_ from the bar‚Äôs _previous ticks_.\r\nLet‚Äôs look at rollback and recalculation in action. The following script uses [ta.stoch()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.stoch) to calculate the [Stochastic oscillator](https://www.tradingview.com/support/solutions/43000502332-stochastic-stoch/) based on the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and [low](https://www.tradingview.com/pine-script-reference/v6/#var_low) values over a specified number of bars, then plots the result in a separate pane. It also calls [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) to highlight the background on each realtime bar ‚Äî where [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime) is `true` ‚Äî for visual reference:\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Recalculation on realtime bars demo\")\r\n//@variable The number of bars in the Stochastic calculation. Users can change this value in the \"Settings/Inputs\" tab.\r\nint lengthInput = input.int(10, \"Length\", 1)\r\n//@variable The Stochastic oscillator, based on the `close`, `high`, and `low` values over `lengthInput` bars.\r\nfloat stochastic = ta.stoch(close, high, low, lengthInput)\r\n// Plot the `stochastic` value for each bar.\r\nplot(stochastic, \"Stochastic %K\", color.teal, 3)\r\n// Highlight the background of each realtime bar.\r\nbgcolor(barstate.isrealtime ? color.new(color.purple, 80) : na, title = \"Realtime background highlight\")\r\n```\r\n\r\nWhen we add the script to our chart, it executes once per bar in the chart‚Äôs history, from the leftmost bar to the rightmost bar. However, the rightmost bar on our chart is still _open_. Therefore, it is a _realtime bar_, not a historical bar. After the script reaches that bar, it begins executing once for _every new update_ to the bar‚Äôs data. Each new script execution calculates on the latest available prices and _replaces_ the bar‚Äôs previous result.\r\nFor instance, in the initial image below, the oscillator‚Äôs value 10 seconds into the open realtime bar (the one with the purple background) is 32.08:\r\n![Image 5: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-1.AOvj4-Z1_1svjXm.webp)\r\nEvery time the bar updates, rollback _resets_ the script‚Äôs data for that bar, and the script _recalculates_ its result using the latest [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), and [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) values. Here, halfway through the realtime bar‚Äôs period, the oscillator‚Äôs plot now shows a value of 16.71:\r\n![Image 6: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-2.C780uf5g_1ywlee.webp)\r\nRecalculation continues for each successive update to the bar. Then, the script reaches the bar‚Äôs closing tick, where the prices become _confirmed_. On that tick, the script calculates the oscillator‚Äôs final value of 19.35. Afterward, another realtime bar opens, and the pattern of rollback and recalculation continues on that bar:\r\n![Image 7: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-The-basics-Realtime-bars-3.rq8kAEPJ_Z2sy82e.webp)\r\nNote that:\r\n*   Only the values for a realtime bar‚Äôs _final tick_ become part of the internal time series. The values from ticks _before_ the bar‚Äôs close are **not** saved.\r\n*   The [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int) function returns a value of the ‚Äúinput int‚Äù _qualified type_. Values qualified as ‚Äúinput‚Äù are established _before_ the first script execution, and they remain consistent throughout the script‚Äôs runtime. If the user changes the ‚ÄúLength‚Äù input to a new value, the script _restarts_ to perform new calculations across the dataset using that value. See the [Inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/) page and the [Qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers) section of the [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/) page to learn more about script inputs and the ‚Äúinput‚Äù qualifier.\r\n*   If the script restarts, all the realtime bars from the previous script run become _historical bars_ in the new run. Therefore, after restarting, the script executes only **once** on each of those bars and does _not_ highlight their background.\r\n[The details](https://www.tradingview.com/pine-script-docs/language#the-details)\r\n--------------------------------------------------------------------------------\r\nThe following sections provide in-depth details about Pine‚Äôs execution model, including the mechanics of executions on [historical bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars) and [realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars), which [events](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions) trigger script executions, and how the runtime system maintains data across executions in a [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series) format.",
    "keywords": [
      "www.tradingview",
      "ta.stoch",
      "fun_ta.stoch",
      "barstate.isrealtime",
      "var_barstate.isrealtime",
      "input.int",
      "color.teal",
      "color.new",
      "color.purple",
      "fun_input.int",
      "indicator",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-52",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Executions on realtime bars](https://www.tradingview.com/pine-script-docs/language#executions-on-realtime-bars)",
    "content": "### [Executions on historical bars](https://www.tradingview.com/pine-script-docs/language#executions-on-historical-bars)\r\nWhen a script loads on the chart or in another location after an [execution-triggering event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions), its compiled source code executes on _every_ accessible bar in the current dataset in order, starting with the first bar.\r\nWhile the script loads, the runtime system performs the following steps for _each bar_ that it accesses:\r\n1.   It updates the built-in variables that hold bar information. For instance, the system sets the [open](https://www.tradingview.com/pine-script-reference/v6/#var_open), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), and [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) variables to hold the OHLC price values of the bar _before_ each execution.\r\n2.   It executes the script‚Äôs compiled code from start to end using the data available as of the current bar.\r\n3.   After the execution ends, the system commits (saves) all necessary data for the current bar to the [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series). The script can then access that data from [historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers) during its executions on subsequent bars by using the [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator) or the built-in functions that reference past bars internally.\r\nThese steps repeat for every successive bar up to the most recent bar. After the runtime system completes this process across the dataset, the script‚Äôs committed _outputs_ ‚Äî such as [plots](https://www.tradingview.com/pine-script-docs/concepts/plots/), [drawings](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs), and [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester) results ‚Äî become available to the user.\r\nAll the closed bars on which the script executes while loading are _historical_, because they represent data points that were confirmed before the [event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions) that triggered the loading process. By default, all scripts execute **once** for each historical bar.\r\nLet‚Äôs examine a simple indicator to understand how script executions work on historical bars.\r\nThe script below calculates the 20-bar moving average of [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) values and plots the result on the chart. The color of the plot depends on whether the average is above or below the value on the previous bar. The script also increments an `executionNum` variable to count code executions, then plots the result alongside [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) for comparison. Additionally, it highlights the background of historical bars in orange for visual reference:\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Executions on historical bars demo\")\r\n//@variable The average of the latest 20 `close` values.\r\nfloat sma = ta.sma(close, 20)\r\n//@variable Is `color.green` if the `sma` value is above the value on the previous bar; `color.red` otherwise.\r\ncolor plotColor = sma > sma[1] ? color.green : color.red\r\n//@variable Tracks the current execution number, where 0 represents the first execution.\r\nvarip int executionNum = -1\r\n// Add 1 to the `executionNum` value.\r\nexecutionNum += 1\r\n// Display the `sma` as a line plot on the main chart pane, colored by the `plotColor`.\r\nplot(sma, \"SMA\", plotColor, 3, force_overlay = true)\r\n// Display the `executionNum` and `bar_index` series in a separate pane.\r\nplot(executionNum, \"Execution number\", color.purple, 5)\r\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\r\n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.\r\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\r\n```\r\n\r\nThe statements and expressions in this source code might appear static at first glance. However, they have _dynamic_ behavior across bars because the system executes the script _repeatedly_ ‚Äî once for each successive data point. Below, we inspect the code step by step to explain how the script works during its historical executions.\r\nThe [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator) call at the top of the code is a [declaration statement](https://www.tradingview.com/pine-script-docs/language/script-structure/#declaration-statement) that defines the script‚Äôs type and properties once, at _compile time_. This statement does not execute as the script runs on the dataset:\r\n`indicator(\"Executions on historical bars demo\")`\r\n_Before_ each script execution on a bar, the runtime system updates the built-in [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) and [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) variables required in the calculations. The [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) value is the bar‚Äôs global _time series index_, where 0 represents the first bar, 1 represents the second, and so on. The [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) variable holds the bar‚Äôs _latest price_. For historical bars, its value is the _final price_ at the bar‚Äôs closing time.\r\nEach time that the script executes, it declares and initializes a global `sma` variable of the ‚Äúfloat‚Äù [type](https://www.tradingview.com/pine-script-docs/language/type-system/#types). This [variable declaration](https://www.tradingview.com/pine-script-docs/language/variable-declarations/) happens on _every_ execution because the code line does not specify a [declaration mode](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#declaration-modes). The variable‚Äôs assigned value is the result of a [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) function call. The call returns the average of the latest 20 [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) values as of the current bar, or [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) if fewer than 20 bars are available. After the execution ends, the system commits the new value of `sma` to the [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series):\r\n`//@variable The average of the latest 20 `close` values.float sma = ta.sma(close, 20)`\r\nNote that:\r\n*   The `//@variable` comment above the `sma` declaration is an [annotation](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations) that _documents_ the variable in the code. The Pine Editor displays the comment in a pop-up window when the user hovers the mouse pointer over the variable.\r\nDuring each execution, the script also initializes a `plotColor` variable of the ‚Äúcolor‚Äù type. The script uses a [ternary operation](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator) that compares the current `sma` value to `sma[1]` ‚Äî the _last committed value_ for `sma` as of the _previous bar_ ‚Äî to determine the `plotColor` variable‚Äôs assigned value. If the current `sma` value is higher than the last committed value, the `plotColor` value is [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green). Otherwise, it is [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color.red):\r\n`//@variable Is `color.green` if the `sma` value is above the value on the previous bar; `color.red` otherwise.color plotColor = sma > sma[1] ? color.green : color.red`\r\nIn contrast to the variables above, the script _does not_ initialize the `executionNum` variable on every execution. Instead, initialization happens only _once_ ‚Äî on the _first_ bar ‚Äî because the variable declaration is in the _global scope_ and uses the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword. Once initialized, the variable _persists_ across all subsequent bars and the ticks within those bars. Only the reassignment or compound assignment [operators](https://www.tradingview.com/pine-script-docs/language/operators/) can change its value:\r\n`//@variable Tracks the current execution number, where 0 represents the first execution.varip int executionNum = -1`\r\nThe code following the `executionNum` declaration uses the addition assignment operator ([+=](https://www.tradingview.com/pine-script-reference/v6/#op_+=)) to increase the variable‚Äôs value by one on each new execution. Starting from -1, the value increases to 0 on the first execution after initialization, then 1 on the second, and so on:\r\n`// Add 1 to the `executionNum` value.executionNum += 1`\r\nThe script evaluates the [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) and [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) calls on every execution. Each [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) call creates a new point on a line plot at the bar‚Äôs location on the time axis. The [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) call creates a background color for the bar based on a ternary expression. The background is translucent orange if [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory) is `true`. Otherwise, it is [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) (no color):\r\n`// Display the `sma` as a line plot on the main chart pane, colored by the `plotColor`.plot(sma, \"SMA\", plotColor, 3, force_overlay = true)// Display the `executionNum` and `bar_index` series in a separate pane.plot(executionNum, \"Execution number\", color.purple, 5)plot(bar_index,    \"Bar index\",        color.aqua,   2)// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.bgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)`\r\nNote that:\r\n*   The [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) and [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) calls that include `force_overlay = true` display their visuals on the main chart pane. The other [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) calls output visuals in a separate pane, because the [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator) call does not include `overlay = true`.\r\nAfter the system executes the script on all available data points and finishes loading, the script‚Äôs outputs then become visible on the chart:\r\n![Image 8: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-1.CbmTx9jr_Z1leWpo.webp)\r\nNote that:\r\n*   When the script first loads, _all_ bars, including the latest one, have an orange background because they initially represent _historical_ data. However, the latest bar on our chart is still open, meaning it is a _realtime bar_. After a new tick arrives from the realtime data feed, the bar‚Äôs values update, and the script executes _again_ on that bar. The orange background for the bar then _disappears_ because the system sets the value of [barstate.ishistory](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.ishistory) to `false`.\r\n*   The `executionNum` and [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) values are identical on historical bars because the script executes _once per bar_ on that part of the dataset. However, they begin to differ on the realtime bar. On that bar, the script executes after _every new update_ to recalculate its results, and the `executionNum` value increases each time. See the [Executions on realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars) section to learn more.\r\n*   An alternative, more robust method to track code executions is to use the [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler). The profiler analyzes the total runtime and execution count of every significant part of the source code. To learn more about this feature, see the [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/) page.\r\nIt‚Äôs important to note that, unlike indicators, [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/) can execute _more than once_ per historical bar, depending on the specified [calculation behavior](https://www.tradingview.com/pine-script-docs/concepts/strategies/#altering-calculation-behavior). If the [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) declaration statement includes `calc_on_order_fills = true`, or if the user selects the ‚ÄúAfter order is filled‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab, the runtime system executes the script on _each available tick_ where the [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator) fills an order, or once per bar when there is no order to fill.\r\nLet‚Äôs look at a simple example. The following strategy changes the direction of its simulated position on each execution. If there is an open short position or no position, the strategy places a [market order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders) to close all short trades and enter a long trade. If a long position is open, the strategy places a market order to close it and open a short trade.\r\nAs with the previous example, this script increments an `executionNum` variable declared with [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) to count new executions, plots the result alongside [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) for comparison, and highlights the background of historical bars in orange with [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor):\r\n![Image 9: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-2.DpP1JZmD_2lzKqv.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nstrategy(\"Default strategy behavior on historical bars demo\")\r\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\r\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\r\nif strategy.position_size <= 0\r\n    strategy.entry(\"Long\", strategy.long)\r\nelse\r\n    strategy.entry(\"Short\", strategy.short)\r\n//@variable Tracks the current execution number, where 0 represents the first execution.\r\nvarip int executionNum = -1\r\n// Add 1 to the `executionNum` value.\r\nexecutionNum += 1\r\n// Display the `executionNum` and `bar_index` series in a separate pane.\r\nplot(executionNum, \"Execution number\", color.purple, 5)\r\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\r\n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.\r\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\r\n```\r\n\r\nNote that:\r\n*   The [strategy.entry()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy.entry) command creates entry orders. By default, a long entry using this command reverses an open short position, and a short entry reverses an open long position. See the [Reversing positions](https://www.tradingview.com/pine-script-docs/concepts/strategies/#reversing-positions) section of the [Strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/) page to learn more.\r\nThe script above uses the default calculation behavior: it places a new order only at the close of each bar. The broker emulator fills the order at the next bar‚Äôs opening price, as the trade markers on the chart above indicate. The `executionNum` and [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) plots show the same values because the script executes only once per bar.\r\nIf we include `calc_on_order_fills = true` in the [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) declaration statement, the runtime system _re-executes_ the script on a bar after each new order fill to update the calculations. Our script‚Äôs logic generates a new order on _every_ execution, and the broker emulator considers historical bars to have _four ticks_ for filling orders by default (the open, high, low, and close). Therefore, with this change, the script executes **four times** per historical bar instead of only once. As shown below, the strategy now shows four trade markers on each historical bar, and the `executionNum` value is four times that of the [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) variable:\r\n![Image 10: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-historical-bars-3.C3-PPUqF_Z9LtnE.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nstrategy(\"Calculation after order fill on historical bars demo\", calc_on_order_fills = true)\r\n// Place a market order to close short trades and enter a long trade when there is a short position or no position.\r\n// Otherwise, if a long position is open, place a market order to close the long trades and enter a short trade.\r\nif strategy.position_size <= 0\r\n    strategy.entry(\"Long\", strategy.long)\r\nelse\r\n    strategy.entry(\"Short\", strategy.short)\r\n//@variable Tracks the current execution number, where 0 represents the first execution.\r\nvarip int executionNum = -1\r\n// Add 1 to the `executionNum` value.\r\nexecutionNum += 1\r\n// Display the `executionNum` and `bar_index` series in a separate pane.\r\nplot(executionNum, \"Execution number\", color.purple, 5)\r\nplot(bar_index,    \"Bar index\",        color.aqua,   2)\r\n// Highlight the chart's background in translucent orange when `barstate.ishistory` is `true`.\r\nbgcolor(barstate.ishistory ? color.new(color.orange, 70) : na, title = \"Historical highlight\", force_overlay = true)\r\n```\r\n\r\nNote that:\r\n*   This script can execute _more than four_ times per bar if it uses [Bar Magnifier](https://www.tradingview.com/pine-script-docs/concepts/strategies/#bar-magnifier) mode, because this mode enables the broker emulator to fill orders on historical bars using intrabar prices from a _lower timeframe_.\r\n*   The script can execute numerous times on a _realtime_ bar, depending on the updates from the data feed, because _each new update_ to the bar is a valid tick for filling the strategy‚Äôs orders.\r\n*   An alternative way to confirm the script‚Äôs increased execution count is to select and clear the ‚ÄúAfter order is filled‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab while [profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script) the code.",
    "keywords": [
      "www.tradingview",
      "ta.sma",
      "color.green",
      "color.red",
      "color.purple",
      "color.aqua",
      "barstate.ishistory",
      "color.new",
      "color.orange",
      "fun_ta.sma",
      "values.float",
      "const_color.green",
      "const_color.red",
      "otherwise.color",
      "execution.varip",
      "value.execution",
      "var_barstate.ishistory",
      "pane.plot",
      "strategy.position_size",
      "strategy.entry",
      "strategy.long",
      "strategy.short",
      "fun_strategy.entry",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "varip",
      "series",
      "simple",
      "const",
      "import",
      "method",
      "type",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-53",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Events that trigger script executions](https://www.tradingview.com/pine-script-docs/language#events-that-trigger-script-executions)",
    "content": "### [Executions on realtime bars](https://www.tradingview.com/pine-script-docs/language#executions-on-realtime-bars)\r\nAfter a script running on the chart or in an alert executes across all historical bars in a dataset, the runtime system continues to execute the script on the current bar, if it is open, and on any new bars that form later. We refer to these bars as _realtime bars_, because they represent incoming data from a separate data feed that the script can access only _after_ it finishes loading.\r\nAs explained in the previous section, historical bars represent confirmed data points. By contrast, a realtime bar represents an initially _unconfirmed_ data point that evolves as new updates (ticks) arrive from the realtime data feed. With each new tick, the bar‚Äôs [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), [low](https://www.tradingview.com/pine-script-reference/v6/#var_low), [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume), and other values update to represent the latest data while the bar remains open. After the bar closes, it becomes an _elapsed realtime bar_, whose values no longer change. Then, a new realtime bar opens after another tick arrives, and that bar updates as new data becomes available.\r\nAs an [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator) or [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library) script runs on an open realtime bar, its compiled code executes once after **every new update** from the data feed. With each new execution, the script recalculates its results for that bar using the latest data. Consequently, the states of the script‚Äôs variables, expressions, and objects can _change_ with each new execution while the bar remains open. The system _commits_ the script‚Äôs data for the realtime bar only after the bar closes.\r\nAfter each script execution that occurs _before_ a bar‚Äôs closing tick, the runtime engine executes a _rollback_ process. Rollback _resets_ applicable script data to the latest committed states in the [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series). This process enables the script to recalculate the bar‚Äôs results using only the latest available data ‚Äî without the influence of _temporary_ data from executions on the bar‚Äôs previous ticks.\r\nBelow, we explain how recalculation and rollback affect a script‚Äôs data and outputs, along with some notable exceptions to this process:\r\n**Reinitialize variables**\r\nThe runtime system erases the states of any variables that the script initializes during its executions before a bar‚Äôs close, excluding those declared using the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword. When the script executes again after rollback, it _reinitializes_ the variables with new values or references based on the latest available data.\r\nLikewise, the system does not preserve the _temporary_ states of built-in variables that hold values for the current bar. Before the new script execution, it sets the variables to use the bar‚Äôs most recent data. For instance, the system updates [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and [low](https://www.tradingview.com/pine-script-reference/v6/#var_low) with the latest, highest, and lowest prices reported since the bar‚Äôs opening time.\r\n**Reset changes to `var` variables**\r\nVariables that use the [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) keyword in their declaration are initialized only _once_ ‚Äî during the _first_ execution of their scopes on a _closed bar_. Variables that use the [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) keyword in their declaration remain initialized after the _first_ time that their scopes execute on a bar‚Äôs _closing tick_. Their assigned values or references _persist_ across subsequent bars, changing only after [reassignment](https://www.tradingview.com/pine-script-docs/language/variable-declarations/#variable-reassignment) or compound assignment operations.\r\nAlthough these variables preserve data across successive bars, they **do not** preserve data across executions on the _ticks_ of an open bar. Rollback reverts all variables declared with [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) before the current bar to the last committed states in the time series as of the previous bar.\r\nFor instance, if a variable declared with [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) has a value of 20 on the open bar and 19 on the previous bar, the variable‚Äôs value reverts to 19 before the script executes on the next tick of the same bar. The temporary value of 20 does not persist.\r\n**Replace plotted outputs**\r\nThe `plot*()`, [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor), [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), and [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill) functions create visual outputs on _every bar_. These outputs are _temporary_ on the open realtime bar. When the script executes again after rollback, the new outputs for the bar from calls to these functions _replace_ the ones from the previous tick.\r\nFor example, when the expression `plot(close)` executes on the open bar, it displays the bar‚Äôs latest [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) value as of the current execution. However, the plotted result is **temporary** until the bar closes. After rollback, the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) variable updates, then the script calls [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) again on the next execution to replace the output from the previous tick and display the new value.\r\n**Remove and revert objects**\r\n[User-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types) and special types such as [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections) and [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types) are _reference types_. They define structures from which scripts create _objects_ ‚Äî independent entities that store data elsewhere in memory. Variables of these types hold _references_ that provide access to specific objects and their data; the variables do **not** store objects directly.\r\nIf a script creates objects on an open bar and does not assign their references to variables declared with the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword, the rollback process _removes_ those objects. During the next execution on the open bar, the script creates _new objects_ if the updated logic allows it.\r\nFor example, if a script calls [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new) to create a [label](https://www.tradingview.com/pine-script-reference/v6/#type_label) object on the open bar, the system _deletes_ that object during rollback. On the next execution, the script evaluates [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new) again, creating a _new_ label that replaces the output. The label created on the previous tick no longer exists.\r\nSimilarly, for objects of built-in or user-defined types with references assigned to [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) variables, the rollback process reverts any changes to those objects that occur on the open bar. The only exception is for [UDTs](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types) with _fields_ that include the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword. See the [Objects](https://www.tradingview.com/pine-script-docs/language/objects/) page for more information.\r\n**Exceptions**\r\nThe runtime system does not revert _all_ the data from script executions on an open bar. The following are notable exceptions to the rollback process:\r\n*   Variables or fields declared with the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword **do not** revert to a previously committed state. They persist across _all_ script executions after initialization, even those on the ticks of an open realtime bar.\r\n*   Logged messages in the [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs) pane do not disappear after rollback. The messages from any `log.*()` calls during executions on the ticks of realtime bars remain in the pane until the script reloads.\r\n*   The data from [strategy orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#orders-and-trades) placed or filled on the ticks within a bar is not subject to rollback. If a strategy script creates orders or the [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator) fills orders on an open bar, the data from those events persists.\r\n*   Rollback does not erase logs for [alerts](https://www.tradingview.com/pine-script-docs/concepts/alerts/) from the ‚ÄúAlerts‚Äù menu. All messages from a script alert remain visible until the user restarts the alert.\r\n*   Runtime errors from the system or the [runtime.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_runtime.error) function completely _stop_ script executions. If an error occurs at any point while a script executes on an open bar, the system halts the script and does not revert the error after new updates from the data feed.\r\nLet‚Äôs inspect the behavior of a simple indicator on realtime bars. The following script calculates an [RSI](https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/) of [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) values using [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi) and displays the result with a [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) call. To track the number of executions that occur _per bar_, the script increments an `executions` variable declared with [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) and calculates its one-bar change using [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change). The script converts each bar‚Äôs execution count to a string with [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring), then displays the result in a color-coded [label](https://www.tradingview.com/pine-script-reference/v6/#type_label) at the bar‚Äôs [high](https://www.tradingview.com/pine-script-reference/v6/#var_high). The label is purple if the bar is open. Otherwise, it is gray. The script also highlights the background of realtime bars in orange using [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor):\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Executions on realtime bars demo\")\r\n//@variable The 14-bar RSI of `close` prices.\r\nfloat rsi = ta.rsi(close, 14)\r\n//@variable Tracks the number of script executions, where 1 represents the first execution.\r\nvarip int executions = 0\r\n// Add 1 to the `executions` value.\r\nexecutions += 1\r\n//@variable Is `color.gray` if the bar is confirmed (closed); `color.purple` otherwise.\r\ncolor labelColor = barstate.isconfirmed ? color.gray : color.purple\r\n// Calculate the one-bar change in `executions`, then convert the value to a string and display the result in a label.\r\n// Each call to `label.new()` creates a *new* `label` object.\r\nlabel.new(\r\n     bar_index, high, str.tostring(ta.change(executions)),\r\n     color = labelColor, textcolor = color.white, size = 20, force_overlay = true\r\n )\r\n// Plot the `rsi` value with colors based on whether the value is above 50 or not.\r\nplot(rsi, \"RSI\", rsi > 50 ? color.teal : color.maroon, 3)\r\n// Highlight the chart's background in translucent orange when `barstate.isrealtime` is `true`.\r\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\", force_overlay = true)\r\n```\r\n\r\nWhen we first add the script to the chart, it does _not_ add an orange background to any bar because it calculates only on data that exists at the script‚Äôs loading time. This data is _historical_. Each bar‚Äôs label shows a value of 1 because indicators always execute _once_ per historical bar:\r\n![Image 11: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-1.C6ZIpkKC_Z1DmFI2.webp)\r\nNotice the countdown timer and the _purple_ label for the latest bar in the chart above. These both indicate that the bar is _open_ and subject to changes. A new update from the data feed affects the bar‚Äôs values, triggering rollback and a new script execution to recalculate the results.\r\nWhen rollback occurs, the runtime system reverts the internal data of the [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi) call to its last committed state, erases the state of the `rsi` variable, and deletes the latest [label](https://www.tradingview.com/pine-script-reference/v6/#type_label) object. However, the system does not revert the `executions` variable because it uses the [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) keyword.\r\nAfter rollback, the system updates the built-in [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), [high](https://www.tradingview.com/pine-script-reference/v6/#var_high), and `barstate.*` variables using the current bar‚Äôs latest data, and the new execution begins. The script evaluates the [ta.rsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.rsi) call using the new [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) price and reinitializes the `rsi` variable with the returned value. Then, it increases the `executions` value by one, evaluates [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change) again, and creates a new label at the bar‚Äôs current high price to show the updated result. Lastly, it evaluates the [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) and [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) calls to replace the bar‚Äôs plotted visuals. The last bar‚Äôs label remains purple because the bar is still open, but the background color is now _orange_ because [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime) is `true`:\r\n![Image 12: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-2.DkBtTFWJ_wi3cQ.webp)\r\nAs subsequent updates become available from the data feed, the pattern of rollback and re-execution continues, and the script‚Äôs outputs for the bar update with each new execution:\r\n![Image 13: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-3.5O5RsfWP_2oucrw.webp)\r\nThe last time that rollback and another execution occur on this bar is after the _closing tick_, when the bar becomes an _elapsed_ realtime bar. After the final execution, the bar‚Äôs label is _gray_ because [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed) is `true`. The runtime system then _commits_ necessary data from this execution to the [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series) for calculations on future bars.\r\nThen, a new realtime bar opens after another update from the data feed, and the execution pattern continues:\r\n![Image 14: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Executions-on-realtime-bars-4.C8UTIyzZ_1eXV6W.webp)\r\nNote that:\r\n*   Although the previous bar is now confirmed, it still has an orange background corresponding to a _realtime_ state because it closed **after** the script‚Äôs loading time. When the script later reloads after an [execution-triggering event](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions), that bar becomes _historical_.\r\nIt‚Äôs important to note that [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/) often execute differently than indicators on realtime bars. By default, they execute only **once** per bar at each _closing tick_ without undergoing rollback. However, users can modify a strategy‚Äôs [calculation behavior](https://www.tradingview.com/pine-script-docs/concepts/strategies/#altering-calculation-behavior) to allow rollback and re-execution on a bar before its closing tick.\r\nIf the [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) statement includes `calc_on_every_tick = true`, or if the user selects the ‚ÄúOn every tick‚Äù checkbox in the ‚ÄúSettings/Properties‚Äù tab, the script executes on a realtime bar after _each new update_ from the data feed, similar to an indicator.\r\nAdditionally, if the [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) statement includes `calc_on_order_fills = true` or the user selects ‚ÄúAfter order is filled‚Äù in the ‚ÄúSettings/Properties‚Äù tab, the script executes on _each tick_ where the [broker emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator) fills an order. With this behavior, the system can execute the script multiple times on the open bar, but only on the ticks where an _order fill_ occurs.\r\nTo summarize the general process for script executions on realtime bars:\r\n*   An [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator) or [library](https://www.tradingview.com/pine-script-reference/v6/#fun_library) script executes on the _first available tick_ in an open realtime bar, then _once per update_ to recalculate the results for the bar using the latest data. A [strategy](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) script executes only on the bar‚Äôs _closing tick_ by default, but users can modify its calculation behavior to allow executions while the bar is open.\r\n*   Before each new script execution on an open bar, the runtime system executes a _rollback_ process, which _reverts_ all applicable variables, expressions, and objects to their _last committed states_ as of the previous bar‚Äôs close.\r\n*   After the script executes on an _elapsed_ realtime bar‚Äôs closing tick, the system _commits_ necessary data from that execution to the [time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series) for access on later bars. It does **not** commit the data from executions on the bar‚Äôs _unconfirmed_ values from previous ticks.",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "runtime.error",
      "fun_runtime.error",
      "ta.rsi",
      "fun_ta.rsi",
      "ta.change",
      "fun_ta.change",
      "str.tostring",
      "fun_str.tostring",
      "color.gray",
      "color.purple",
      "barstate.isconfirmed",
      "color.white",
      "color.teal",
      "color.maroon",
      "barstate.isrealtime",
      "color.new",
      "color.orange",
      "var_barstate.isrealtime",
      "var_barstate.isconfirmed",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "barcolor",
      "alert",
      "var",
      "varip",
      "series",
      "simple",
      "import",
      "type",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-54",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Time series](https://www.tradingview.com/pine-script-docs/language#time-series)",
    "content": "### [Events that trigger script executions](https://www.tradingview.com/pine-script-docs/language#events-that-trigger-script-executions)\r\nSeveral events cause a script to load and execute across all the available bars in a dataset. The specific events that trigger the loading process depend on where the script runs.\r\nFor a script on the [chart](https://www.tradingview.com/chart/), the following events always cause the script to load and perform _new executions_ on every bar:\r\n*   The user adds the script to the chart for the first time from the Pine Editor or the ‚ÄúIndicators, metrics, and strategies‚Äù menu.\r\n*   The user saves an update to the script while it is active on the chart.\r\n*   The chart is refreshed while the script is active.\r\nOther events also trigger the loading process for a script on the chart. However, these events do not _always_ cause new script executions on past bars. The results from running a script with a unique combination of settings are often temporarily _cached_. If cached data exists for a selected combination of settings, the system loads the script using that data. See the [Caching](https://www.tradingview.com/pine-script-docs/language/execution-model/#caching) section for more information.\r\nBelow are the additional events that cause a script to load on the chart, either by performing new executions across the dataset or by using available cached data:\r\n*   The user selects new values for the [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/) or [strategy properties](https://www.tradingview.com/support/solutions/43000628599-strategy-properties/) in the script‚Äôs ‚ÄúSettings‚Äù menu.\r\n*   The script uses the [chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time) or [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time) variable, and the visible chart range changes.\r\n*   The script uses the [chart.fg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.fg_color) or [chart.bg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color) variable, and the user changes the chart‚Äôs background color.\r\n*   The chart loads a new dataset with a different _timeframe_ or _ticker identifier_. Several user actions affect a chart‚Äôs ticker ID, such as selecting a symbol from the ‚ÄúSymbol Search‚Äù menu, changing the chart type, toggling data modifications in the chart‚Äôs settings, and activating [Bar Replay](https://www.tradingview.com/support/solutions/43000712747-bar-replay-how-and-why-to-test-a-strategy-in-the-past/) mode.\r\n*   The user opens or closes the [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs) pane.\r\n*   The user activates or deactivates the [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler).\r\nFor scripts used in other locations, the following events trigger the loading process:\r\n*   The user creates a new script [alert](https://www.tradingview.com/pine-script-docs/concepts/alerts/) from the ‚ÄúCreate Alert‚Äù dialog box.\r\n*   The user pauses and restarts an alert instance from the ‚ÄúAlerts‚Äù menu.\r\n*   The user clicks the ‚ÄúGenerate report‚Äù button in the [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester) while [Deep Backtesting](https://www.tradingview.com/support/solutions/43000666199-what-is-deep-backtesting/) mode is enabled.\r\n*   The user clicks the ‚ÄúScan‚Äù button in the [Pine Screener](https://www.tradingview.com/support/solutions/43000742436-tradingview-pine-screener-key-features-and-requirements/) to run the script on the datasets from a chosen watchlist.\r\n_After_ a script loads, either of the following causes new script executions on an _open bar_:\r\n*   One of the events above causes the script to load again and execute across the _entire dataset_ up to the bar.\r\n*   The script runs on the chart or in an alert, and the bar updates after new data becomes available. The system performs _rollback_ and re-executes the script on that bar using the latest data. The only exception is if the script is a strategy that does not allow recalculation on the new tick.\r\nWhen a script completely reloads on the chart or in an alert after an applicable event, all the [elapsed realtime bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars) from the script‚Äôs previous run become [historical bars](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars) in the new run, because they represent _confirmed_ data points that the script accesses from _a different data feed_ as it loads.\r\nThe bars in a symbol‚Äôs dataset come from two distinct data feeds: the _historical_ feed and the _realtime_ feed. The historical feed reports only the _final_ values for each bar, whereas the realtime feed includes the _temporary_ values from all available ticks. When a realtime bar becomes historical after a script restarts, the values from the bar‚Äôs previous ticks are no longer accessible; only the **final** price, volume, and other values remain. Therefore, if a script relies on temporary data from realtime bars in its calculations, it might behave differently after reloading.\r\nFor example, the following script calculates the one-bar arithmetic return of the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) series and displays the result as a line plot. On each realtime bar, the script updates three variables declared with [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip) to track the first, highest, and lowest return values calculated during executions across the bar‚Äôs ticks, then calls [plotcandle()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotcandle) to plot a candle showing the values. Additionally, it uses [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor) to highlight the background of realtime bars in orange:\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Reloading a script demo\", precision = 5)\r\n//@variable The one-bar arithmetic return of the `close` series.\r\nfloat priceReturn = ta.change(close, 1) / close[1]\r\n// Declare persistent variables to track the first, highest, and lowest `priceReturn` values across ticks in\r\n// each realtime bar.\r\nvarip float o = na\r\nvarip float h = na\r\nvarip float l = na\r\nif barstate.isrealtime\r\n    // On the first tick in the realtime bar, reassign `o`, `h`, and `l` to hold the value of `priceReturn`.\r\n    if barstate.isnew\r\n        o := priceReturn\r\n        h := priceReturn\r\n        l := priceReturn\r\n    // Otherwise, reassign `h` and `l` to the bar's highest and lowest `priceReturn` value as of the current tick.\r\n    else\r\n        h := math.max(h, priceReturn)\r\n        l := math.min(l, priceReturn)\r\n// Plot candles to display the `o`, `h`, `l`, and `priceReturn` values for each realtime bar.\r\n// The candles do not appear on historical bars, because `o`, `h`, and `l` are `na` on those bars.\r\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg_color, bordercolor = chart.fg_color)\r\n// Dispaly the `priceReturn` series as a purple line plot.\r\nplot(priceReturn, \"Return plot\", color.purple, 3)\r\n// Highlight the background of all realtime bars in orange.\r\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\r\n```\r\n\r\nAfter the script loads on the chart and executes on several realtime bars, all the elapsed realtime bars, as well as the open realtime bar, include plotted return candles and an orange background color:\r\n![Image 15: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-1.Bu_ElpOQ_Z25zgpA.webp)\r\nAfter an applicable event, such as a chart refresh, the script _reloads_ and executes across the dataset again. All the closed bars with a realtime state in the previous run become _historical_ bars in the new run. The results thus change because our script relies on realtime data. As shown below, the script does not display candles or background colors for previous bars after we refresh the chart. Those outputs appear only for the latest bar, after new ticks become available, because that bar is now the **only** one with a realtime state:\r\n![Image 16: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-2.CbIdk5sI_W8NUw.webp)\r\nNote that:\r\n*   The [barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isnew) variable has a value of `true` when a realtime bar opens, and `false` on all subsequent updates to the bar. If the script reloads midway through a realtime bar‚Äôs progression, only the background color appears on that bar. The script does not show a candle on the first realtime bar in that case, because its `o`, `h`, and `l` variables hold [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) until the first time that [barstate.isnew](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isnew) is `true`.\r\n#### [Caching](https://www.tradingview.com/pine-script-docs/language#caching)\r\nWhen a script runs on a chart for the _first time_ using a _unique configuration_, the data from that run is often temporarily cached for reuse. The cached data is erased after the chart is refreshed or the user updates the script‚Äôs source code.\r\nIn this context, the configuration refers to the combined state of all script, chart, and developer tool settings that can affect the script‚Äôs executions. This combination includes:\r\n*   The values of [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/) in the script‚Äôs ‚ÄúSettings/Inputs‚Äù tab.\r\n*   The values of the [strategy properties](https://www.tradingview.com/support/solutions/43000628599-strategy-properties/) in the ‚ÄúSettings/Properties‚Äù tab.\r\n*   The values of the `chart.*` variables whose [qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers) are ‚Äúinput‚Äù ([chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time), [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time), [chart.fg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.fg_color), and [chart.bg_color](https://www.tradingview.com/pine-script-reference/v6/#var_chart.bg_color)).\r\n*   The chart‚Äôs timeframe.\r\n*   The chart‚Äôs ticker identifier.\r\n*   Whether the [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs) pane is open or closed.\r\n*   Whether the [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler) is active or not.\r\nEach time that a script runs using a unique combination of settings, it executes from start to end on each bar in the dataset to perform new calculations. If possible, the script‚Äôs data from the run is then cached. If cached data is available on past bars for a selected combination of settings, the runtime system loads the script using that data.\r\nThis behavior enables users to change a script‚Äôs inputs, alter the chart, and toggle developer tools without losing information ‚Äî including [bar states](https://www.tradingview.com/pine-script-docs/concepts/bar-states/) ‚Äî from previous script runs using different settings. Additionally, caching helps reduce loading times and resource requirements when switching between settings or adding multiple instances of the same script to the chart.\r\nTo understand this behavior, let‚Äôs revisit the script from the [previous section](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions). The script has different behaviors on historical and realtime bars. In the version below, we‚Äôve added a `lengthInput` variable that holds the value from an [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int) call. The script uses this variable to define the length of the [ta.change()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.change) calculation and the offset of the [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator):\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Caching demo\", precision = 5)\r\n//@variable The bar span of the `priceReturn` calculation.\r\nint lengthInput = input.int(5, \"Length\", 1)\r\n//@variable The arithmetic return of the `close` series across `lengthInput` bars.\r\nfloat priceReturn = ta.change(close, lengthInput) / close[lengthInput]\r\n// Declare persistent variables to track the first, highest, and lowest `priceReturn` values across ticks in\r\n// each realtime bar.\r\nvarip float o = na\r\nvarip float h = na\r\nvarip float l = na\r\nif barstate.isrealtime\r\n    // On the first tick in the realtime bar, reassign `o`, `h`, and `l` to hold the value of `priceReturn`.\r\n    if barstate.isnew\r\n        o := priceReturn\r\n        h := priceReturn\r\n        l := priceReturn\r\n    // Otherwise, reassign `h` and `l` to the bar's highest and lowest `priceReturn` value as of the current tick.\r\n    else\r\n        h := math.max(h, priceReturn)\r\n        l := math.min(l, priceReturn)\r\n// Plot candles to display the `o`, `h`, `l`, and `priceReturn` values for each realtime bar.\r\n// The candles do not appear on historical bars, because `o`, `h`, and `l` are `na` on those bars.\r\nplotcandle(o, h, l, priceReturn, \"Return candles\", color.blue, chart.fg_color, bordercolor = chart.fg_color)\r\n// Dispaly the `priceReturn` series as a purple line plot.\r\nplot(priceReturn, \"Return plot\", color.purple, 3)\r\n// Highlight the background of all realtime bars in orange.\r\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\r\n```\r\n\r\nAfter we add the script to our 1m chart and let it run for a few minutes with a ‚ÄúLength‚Äù input value of 5, the script plots candles and highlights the background for the latest few bars, because [barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isrealtime) is `true` on those bars:\r\n![Image 17: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-1.BY9-bg_Z_Z1h9UoE.webp)\r\nLet‚Äôs change the ‚ÄúLength‚Äù input to a new value, causing the script to reload and execute across the dataset again. Here, we changed the value from 5 to 10 and let the script execute on some new ticks. The script no longer displays candles and background colors for the same bars after restarting, because it now accesses the data for those formerly realtime bars from the _historical_ data feed:\r\n![Image 18: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-2.DyVd2t5m_Z1wVpJs.webp)\r\nAs shown above, the realtime bar information from the first run is _not available_ when we change the script‚Äôs input to a new value. However, the data from that previous run still exists in memory. If we revert the ‚ÄúLength‚Äù input‚Äôs value to 5, the candle plot and background colors start on the same bar as the first run:\r\n![Image 19: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-3.ByASZdF6_Z1Va6dx.webp)\r\nIf we add a second instance of the script to the chart, using the same settings, the runtime system loads the new instance using the cached data instead of executing it entirely from scratch. As such, its outputs are _identical_ to those from the first script instance, even though we added it to the chart a few bars later:\r\n![Image 20: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Events-that-trigger-script-executions-Caching-4.CGwk5hPj_ZgkqEL.webp)\r\nSimilarly, cached data usually remains available even if we remove the script from our chart and add it again.",
    "keywords": [
      "www.tradingview",
      "chart.left_visible_bar_time",
      "var_chart.left_visible_bar_time",
      "chart.right_visible_bar_time",
      "var_chart.right_visible_bar_time",
      "chart.fg_color",
      "var_chart.fg_color",
      "chart.bg_color",
      "var_chart.bg_color",
      "ta.change",
      "barstate.isrealtime",
      "barstate.isnew",
      "math.max",
      "math.min",
      "color.blue",
      "color.purple",
      "color.new",
      "color.orange",
      "var_barstate.isnew",
      "input.int",
      "fun_input.int",
      "fun_ta.change",
      "var_barstate.isrealtime",
      "indicator",
      "strategy",
      "input",
      "plot",
      "bgcolor",
      "alert",
      "var",
      "varip",
      "series",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-55",
    "type": "documentation",
    "source": "pine_script_execution_model.md",
    "section": "root",
    "title": "[Time series](https://www.tradingview.com/pine-script-docs/language#time-series)",
    "content": "### [Time series](https://www.tradingview.com/pine-script-docs/language#time-series)\r\nA symbol‚Äôs dataset is a form of _time series_ ‚Äî a sequence of collected values indexed by time. Each bar represents a distinct data point, anchored to a specific time, that contains price and volume data for a particular period. This data format thus shows how a symbol‚Äôs values progress across time in successive periodic steps.\r\nPine Script‚Äôs internal time series structure follows a similar format. After executing a script on a closed bar‚Äôs confirmed values, the runtime system _commits (saves)_ the results of the script‚Äôs statements and expressions to internal time series for later use. Each bar with committed data has an assigned _index_ in the series, where 0 represents the first bar, 1 represents the second, and so on. Scripts can retrieve this index with the [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) variable.\r\nScripts can access the data committed to the time series on past bars by using the [[] history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator). The value between the operator‚Äôs square brackets specifies the position of the referenced bar in the time series as a _relative offset_ behind the current bar. For variables and expressions in the global scope, an offset value of 1 refers to the previous bar at `bar_index - 1` (one bar back), a value of 2 refers to the bar at `bar_index - 2` (two bars back), and so on. An offset of 0 always refers to the _current bar_.\r\nFor example, consider the [open](https://www.tradingview.com/pine-script-reference/v6/#var_open) variable, which holds the opening price of the current bar on which the script executes. Before each script execution on a new bar, the runtime system commits the [open](https://www.tradingview.com/pine-script-reference/v6/#var_open) value from the last execution on the previous bar. Then, it updates the variable to hold the current bar‚Äôs opening price. To access the committed [open](https://www.tradingview.com/pine-script-reference/v6/#var_open) value for the previous bar, we can use the expression `open[1]`. To access the committed value from 10 bars back, we use `open[10]`.\r\nThe script below performs three history-referencing operations to retrieve the current bar‚Äôs [open](https://www.tradingview.com/pine-script-reference/v6/#var_open) value, the value from one bar back, and the value from a user-specified number of bars back. Then, it plots the retrieved values on the chart for comparison:\r\n![Image 21: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-1.CzCPjlKh_1P3h3k.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"History referencing demo\", overlay = true, behind_chart = false)\r\n//@variable The number of bars back from which to retrieve the `open` price for `pastOpen`.\r\nint offsetInput = input.int(10, \"Bar offset\", 0)\r\n//@variable The current bar's opening price. `open[0]` is equivalent to using `open` without the `[]` operator.\r\nfloat currOpen = open[0]\r\n//@variable The last committed `open` value. Represents the previous bar's value, or `na` if no previous bar exists.\r\nfloat prevOpen = open[1]\r\n//@variable The `open` value committed `offsetInput` bars back, or `na` if no bar exists at that offset.\r\nfloat pastOpen = open[offsetInput]\r\n// Plot `currOpen`, `prevOpen`, and `pastOpen` for comparison.\r\nplot(currOpen, \"Current `open`\",                 color.blue,    2)\r\nplot(prevOpen, \"Previous bar `open`\",            color.purple,  3)\r\nplot(pastOpen, \"Past `open` from custom offset\", color.orange,  4)\r\n```\r\n\r\nNote that:\r\n*   The expression `open[0]` is equivalent to using [open](https://www.tradingview.com/pine-script-reference/v6/#var_open) without the history-referencing operator, because an offset of 0 refers to the current bar.\r\n*   At the beginning of the chart‚Äôs dataset, the expressions `open[1]` and `open[offsetInput]` return [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) because they refer to previous bars that are unavailable.\r\n*   Each history-referencing expression also leaves a trail of values in the time series. Therefore, it is possible to retrieve past states of the expression using another history-referencing operation, e.g., `(open[offsetInput])[1]`.\r\n*   Internally, the system maintains a _limited amount_ of time series data for variables and expressions in fixed-length _historical buffers_. These buffers define the _maximum offsets_ allowed for history-referencing operations. See the next section, [Historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers), to learn more.\r\nAnother way that scripts use committed values from a time series is by calling the built-in functions that reference history internally, such as those in the `ta.*` namespace. For example, the expression `ta.highest(high, 20)` calculates the highest value from the [high](https://www.tradingview.com/pine-script-reference/v6/#var_high) series over a 20-bar window. It compares the series‚Äô current value to the committed values from the previous 19 bars to determine the result. The script below executes this call on each bar and plots the resulting series on the chart. Additionally, the script colors the background of the last 20 bars on the chart to highlight the bars used in the latest execution‚Äôs [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest) call:\r\n![Image 22: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-2.tycqzMI6_AVJD9.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"History referencing in functions demo\", overlay = true, behind_chart = false)\r\n//@variable The highest value from the `high` series across the 20 most recent bars.\r\n//          The `ta.highest()` call compares the current `high` to the last 19 committed values.\r\nfloat highest = ta.highest(high, 20)\r\n// Plot the `highest` series on the chart.\r\nplot(highest, \"20-bar high\", color.purple, 3)\r\n// Color the background of the last 20 bars, i.e., the bars used by the latest execution's `ta.highest()` call.\r\nbgcolor(color.new(color.blue, 70), show_last = 20, title = \"Last 20 bar highlight\")\r\n```\r\n\r\nNote that:\r\n*   The first 19 bars of the chart have a plotted value of [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), because the [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest) function call requires the [high](https://www.tradingview.com/pine-script-reference/v6/#var_high) values from the current bar and 19 previous bars to calculate the result.\r\n*   All function calls and expressions that do not return ‚Äúvoid‚Äù leave historical trails in the time series, just like variables. Therefore, scripts can use an expression such as `ta.highest(high, 20)[10]` to retrieve the 20-bar high from 10 bars back.\r\n*   The [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest) function and other functions that access past values from a time series must execute in the **global scope** for consistent calculations. Time series storage for variables and expressions in local scopes works _differently_ than that for global values. See the [Time series in scopes](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series-in-scopes) section for more information.\r\n#### [Historical buffers](https://www.tradingview.com/pine-script-docs/language#historical-buffers)\r\nTo promote efficiency and help ensure computing resources remain available for all users, the Pine Script runtime system uses fixed-length _historical buffers_ to maintain a _limited amount_ of time series data for all variables and expressions. These historical buffers define the _maximum_ number of committed data points that a script can access on any bar via the [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator) or the built-in functions that reference past bars internally.\r\nFor most series, the underlying historical buffer can contain data from up to **5000** past bars. The only exception is for some built-in series such as [open](https://www.tradingview.com/pine-script-reference/v6/#var_open), [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and [time](https://www.tradingview.com/pine-script-reference/v6/#var_time), whose buffers can store data for _more_ than 5000 bars.\r\nAlthough these buffers can contain thousands of data points at their maximum size, a script might not _require_ that much past data for its calculations on any bar. Therefore, the runtime system automatically optimizes the size of each series‚Äô historical buffer based on the historical references that the script performs as it loads on the dataset. Each resulting buffer contains _only_ the amount of past data required by the script‚Äôs calculations and _not more_.\r\nFor instance, if the maximum number of bars back for which a script references the value of a variable on historical bars is 500, the system maintains a historical buffer that includes only the latest 500 committed values of that variable. The buffer does not store 5000 committed values, because the script _does not_ require all that extra data. This behavior thus helps to minimize a script‚Äôs resource requirements while preserving the integrity of its calculations.\r\nTo determine the sufficient buffer size for each variable and expression in a script, the runtime system performs the following process during the script‚Äôs loading time:\r\n1.   It analyzes all the historical references that occur while executing the script on the dataset‚Äôs first **244 bars**, then sets the initial size of each buffer to the minimum size that accommodates those references.\r\n2.   While executing the script on subsequent bars, it checks if the script attempts to access data from previous bars that are beyond the limits of the defined buffers. If the script‚Äôs historical references exceed the buffer limits on any bar, the system restarts the loading process and tries a larger buffer size.\r\n3.   In the rare case that a historical buffer‚Äôs size remains insufficient after several calculation attempts, the system stops the script and raises a runtime error.\r\nIt‚Äôs crucial to emphasize that the runtime system defines the sizes of all historical buffers only while executing a script on _historical bars_. It does **not** adjust any historical buffers during executions on _new bars_ from the realtime data feed. If a script references past data from beyond a historical buffer‚Äôs limits while executing on a realtime bar, it causes a [runtime error](https://www.tradingview.com/pine-script-docs/error-messages/#the-requested-historical-offset-x-is-beyond-the-historical-buffers-limit-y).\r\nFor example, the script below retrieves a past value from the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) series using the [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator) with an offset of 100 bars back on historical bars and 150 bars back on realtime bars. Because the script references data from 100 bars back during all [historical executions](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-historical-bars), the system sets the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) buffer‚Äôs size to include only 100 past values. Consequently, an error occurs when the script executes on the open realtime bar, because a historical offset of 150 is _beyond_ the buffer‚Äôs limit:\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Max bars back error demo\", overlay = true)\r\n// @variable The historical offset for retrieving past values from the `close` series.\r\n//           If the bar is historical, the offset is 100. Otherwise, the offset is 150.\r\nint offset = barstate.ishistory ? 100 : 150\r\n// @variable The value of `close` from `offset` bars back.\r\n//           This code causes a *runtime error* on a realtime bar. During all code executions on historical bars,\r\n//           the script requires only the latest 100 past values of `close`, so the system sets the buffer size to\r\n//           include only the past 100 values. The offset of 150 is thus *out of bounds*.\r\nfloat pastClose = close[offset]\r\n// Plot the `pastClose` series.\r\nplot(pastClose, \"Past `close`\", chart.fg_color, 3)\r\n// Highlight the background of all realtime bars in orange.\r\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\r\n```\r\n\r\nFor cases like these, programmers can _manually_ set the size of a historical buffer to ensure it contains a sufficient amount of data by doing any of the following:\r\n*   Modify the script to reference the maximum required number of bars back with the [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D) operator during its execution on the _first bar_.\r\n*   Call the [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back) function to explicitly set the historical buffer size for a _specific_ series.\r\n*   Include a `max_bars_back` argument in the [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator) or [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy) declaration statement to set the initial size of _all_ historical buffers.\r\nBelow, we modified the script by including the expression `max_bars_back(close, 150)`, which sets the size of the [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) buffer to include 150 past values. With the appropriate buffer size manually defined, the script‚Äôs history-referencing operation no longer causes an error on realtime bars:\r\n![Image 23: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Historical-buffers-1.BRNlhWd3_p17Kq.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Manual buffer sizing demo\", overlay = true)\r\n// @variable The historical offset for retrieving past values from the `close` series.\r\n//           If the bar is historical, the offset is 100. Otherwise, the offset is 150.\r\nint offset = barstate.ishistory ? 100 : 150\r\n// Set the size of the `close` historical buffer to include 150 past values, ensuring the script has exactly\r\n// the amount of history that it requires on realtime bars.\r\nmax_bars_back(close, 150)\r\n// @variable The value of `close` from `offset` bars back.\r\n//           This code no longer causes an error when it executes on a realtime bar, because the historical\r\n//           buffer has an appropriate size defined in advance.\r\nfloat pastClose = close[offset]\r\n// Plot the `pastClose` series.\r\nplot(pastClose, \"Past `close`\", chart.fg_color, 3)\r\n// Highlight the background of all realtime bars in orange.\r\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime highlight\")\r\n```\r\n\r\n#### [Time series in scopes](https://www.tradingview.com/pine-script-docs/language#time-series-in-scopes)\r\nThe _scope_ of a variable or expression refers to the part of the script where it is defined and accessible in the code. Every script has one _global_ scope and zero or more _local_ scopes.\r\nAll variables and expressions in a script that are outside [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/) or [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods), [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/), [loops](https://www.tradingview.com/pine-script-docs/language/loops/), and [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types) or [enum type](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types) declarations belong to the _global scope_. The script evaluates variables and expressions from this scope _once_ for _every execution_ across bars and ticks in the dataset.\r\nAll functions, methods, conditional structures, and loops create their own _local scopes_. The variables and expressions defined within a local scope belong exclusively to that scope. In contrast to the global scope, a script does _not_ always evaluate a local scope once per execution; the script might evaluate the scope _zero_, _one_, or _several_ times per execution, depending on its logic.\r\nFor the runtime system to commit data from a variable or expression and queue that data into a [historical buffer](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers) on any bar, a script must _evaluate_ the scope of that variable or expression once when it executes on the bar‚Äôs _closing tick_. If the script does not evaluate the scope, the runtime system _cannot_ update the historical buffer for the variable or expression. Similarly, if the script evaluates the scope repeatedly within a loop, the historical buffer cannot store series data for _each_ separate iteration, because each entry in the time series corresponds to a single bar.\r\nTherefore, time series behave differently in global and local scopes: the historical buffers for global variables and expressions _always_ contain committed data for _consecutive_ past bars, whereas the buffers for local variables often contain an **inconsistent** history of committed data.\r\nWhen a script references the history of a global variable using an expression such as `myVariable[1]`, the historical offset of 1 always refers to the confirmed `myVariable` value from the _previous bar_. In contrast, when using such an expression with a local variable, the offset of 1 refers to the most recent bar where the script executed the scope. It **does not** represent a specific number of bars back. Therefore, referencing the history of a local variable can cause _unintended results_.\r\nThe following example demonstrates how the historical buffers for a user-defined function‚Äôs local scope behave when a script does not call the function on _every_ bar. The script below contains a custom `upDownColor()` function, which compares the current value of its `source` parameter to the last committed value (`source[1]`). The function returns [color.blue](https://www.tradingview.com/pine-script-reference/v6/#const_color.blue) if the current `source` value is higher than the previous value. Otherwise, it returns [color.orange](https://www.tradingview.com/pine-script-reference/v6/#const_color.orange).\r\nThe script uses this function _conditionally_, inside a [ternary operation](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator), to determine the color of a plot that shows the remainder from dividing [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) by a specified value. If the `remainder` variable‚Äôs value is nonzero, the operation calls `upDownColor(remainder)` to calculate the color (blue or orange). If the value is 0, the operation does _not_ use the call and instead returns [color.gray](https://www.tradingview.com/pine-script-reference/v6/#const_color.gray). The `remainder` value _increases_ on each bar, except for when it returns to 0 ‚Äî causing the gray color. Therefore, a user might expect the plot‚Äôs color to be only blue or gray on every bar. However, the color changes to _orange_ on each bar after the one where the color is gray, even though the `remainder` value on that bar is _higher_ than the value on the previous bar:\r\n![Image 24: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-1.D_JOArZO_2tWKEC.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Local historical references demo\")\r\n//@function  Returns `color.blue` if `source` is above its last committed value; `color.orange` otherwise.\r\n//           For consistent results, this function should execute on *every bar*, because it uses the\r\n//           history-referencing operator on the `source` series.\r\n//\r\n//           Even if the argument supplied to `source` comes from a global variable, the `source` parameter remains\r\n//           part of the function's *local scope*. The system maintains a *separate historical buffer* for the `source`\r\n//           series in each function call instance. The buffer contains only the committed `source` values from the bars\r\n//           where the function call occurs. If the call does not occur on a bar, the buffer for `source` contains\r\n//           **no data** for that bar.\r\nupDownColor(float source) =>\r\n    source > source[1] ? color.blue : color.orange\r\n//@variable The value by which to divide the `bar_index` value.\r\nint divisorInput = input.int(5, \"Divisor\", 1)\r\n//@variable The remainder of dividing `bar_index` by `divisorInput`.\r\nfloat remainder = bar_index % divisorInput\r\n//@variable Is `color.orange` if `remainder` equals 0, and the result of `upDownColor(remainder)` otherwise.\r\n//          The `upDownColor()` call does not execute on every bar. Therefore, it does *not* always compare the\r\n//          `remainder` value from one bar back to calculate the color. Instead, the function compares the current\r\n//          `remainder` to the value from the last bar where `remainder` is nonzero.\r\ncolor plotColor = remainder == 0 ? color.gray : upDownColor(remainder)\r\n// Plot the `remainder` series and color it using `plotColor`. The plot is orange after each bar where `remainder == 0`,\r\n// because the `upDownColor()` function call does not have data for that bar to use in its logic.\r\nplot(remainder, \"Remainder\", plotColor, 5)\r\n```\r\n\r\nThe script behaves this way because `upDownColor()` uses the [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator) on the `source` series, which is _local_ to the function‚Äôs scope, and the script does not call the function on _every_ execution. When the value of `remainder` is zero, the _first_ expression in the ternary condition evaluates to `true`, and therefore the second branch of the ternary expression, which contains the function call, does _not_ execute.\r\nThe compiler issues the following warning about the function directly in the Pine Editor:\r\n`The function `upDownColor()` should be called on each calculation for consistency. It is recommended to extract the call from the ternary operator or from the scope.`\r\nThe runtime system maintains a separate [historical buffer](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers) for the local `source` series, but it cannot update that buffer unless the script _calls_ the function. On each bar where `remainder` is 0, the call does not occur, and the system has no new value to commit to the time series. Therefore, the `source` buffer does _not_ contain the value of `remainder`, or even an [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) value, for that bar. On the bar that follows, the local expression `source[1]` refers to the `source` value from the last bar where the `upDownColor()` call occurs ‚Äî _two bars back_ ‚Äî and not the value of `remainder` from the previous bar. Because the value from two bars back is _higher_ than the current value, the returned color is [color.orange](https://www.tradingview.com/pine-script-reference/v6/#const_color.orange) instead of [color.blue](https://www.tradingview.com/pine-script-reference/v6/#const_color.blue).\r\nWe can fix this script‚Äôs behavior by following the instructions in the compiler warning. Below, we modified the script by moving the `upDownColor()` call _outside_ the ternary expression, enabling the script to execute it on _every bar_. The historical buffer for the function‚Äôs `source` series now contains `remainder` values from _consecutive_ bars. With this change, an orange color does not appear because the function consistently compares values from _one_ bar back:\r\n![Image 25: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-2.DnGQwjrs_Z2gROjb.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"Consistent historical references demo\")\r\n//@function  Returns `color.blue` if `source` is above its last committed value; `color.orange` otherwise.\r\n//           For consistent results, this function should execute on *every bar*, because it uses the\r\n//           history-referencing operator on the `source` series.\r\nupDownColor(float source) =>\r\n    source > source[1] ? color.blue : color.orange\r\n//@variable The value by which to divide the `bar_index` value.\r\nint divisorInput = input.int(5, \"Divisor\", 1)\r\n//@variable The remainder of dividing `bar_index` by `divisorInput`.\r\nfloat remainder = bar_index % divisorInput\r\n//@variable Is `color.blue` if `remainder` is above its previous value, and `color.orange` otherwise.\r\ncolor secondColor = upDownColor(remainder)\r\n//@variable `color.orange` if `remainder` equals 0, and `secondColor` otherwise.\r\n//          This ternary operation no longer causes a warning. The scope of the `upDownColor()` call executes on\r\n//          every bar, meaning its historical buffer consistently includes data for consecutive past bars.\r\ncolor plotColor = remainder == 0 ? color.gray : secondColor\r\n// Plot the `remainder` series and color it using `plotColor`. The plot is now blue or gray, but never orange.\r\nplot(remainder, \"Remainder\", plotColor, 5)\r\n```\r\n\r\nThis behavior also applies to all built-in functions that reference past values internally, such as those in the `ta.*` namespace. For example, the [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) function uses the current value of a `source` series and `length - 1` past values from that series to calculate a [moving average](https://www.tradingview.com/support/solutions/43000696841-simple-moving-average/). If a script calls this function only on _some_ bars instead of on _every_ bar, the historical buffer for `source` does not contain values for consecutive past bars. Therefore, such a call can cause unintended results, because the call calculates the returned average using an inconsistent history of values from previous bars.\r\nThe script below demonstrates how the results of the [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) function can vary with the scope in which the function call occurs. The script declares three global variables to hold calculated SMA values: `controlSMA`, `localSMA`, and `globalSMA`. The script initializes `controlSMA` using the result of a [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) function call, and it initializes the other two variables with [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Within the [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if) structure, the script updates the value of `globalSMA`, and it updates `localSMA` using the result of another [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) call with the same arguments as the first call.\r\nAs shown below, the `controlSMA` and `globalSMA` have the same value. Both use the result of the _global_[ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) call, which executes on _every bar_. The internal historical buffer for `source` in that call thus includes committed values for consecutive past bars. In contrast, the `localSMA` value differs, because the [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma) call for that variable does _not_ execute on every bar. The buffer for that call‚Äôs local `source` series contains only the values from bars with an _even_[bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index) value:\r\n![Image 26: image](https://www.tradingview.com/pine-script-docs/_astro/Execution-model-Time-series-Time-series-in-scopes-3.H3TNziJy_1gEv1o.webp)\r\n\r\n```pinescript\r\n//@version=6\r\nindicator(\"`ta.*()` functions in scopes demo\", overlay = true, behind_chart = false)\r\n//@variable Is `true` if the `bar_index` is divisible by 2, and `false` otherwise.\r\nbool condition = bar_index % 2 == 0\r\n//@variable The 20-bar moving average of `close` values.\r\n//          This `ta.sma()` call executes in the global scope, so the script evaluates it on every bar.\r\nfloat controlSMA = ta.sma(close, 20)\r\n// Declare two additional variables to modify later within the `if` structure's scope.\r\nfloat globalSMA = na\r\nfloat localSMA  = na\r\nif condition\r\n    // Assign the `controlSMA` value to `globalSMA`. This code does not cause a warning.\r\n    globalSMA := controlSMA\r\n    // Call `ta.sma()` with the same arguments as before within this block and assign the result to `localSMA`.\r\n    // The function call causes a warning, because it does not execute in the global scope.\r\n    // The historical buffers for this `ta.sma()` call contain data only for the bars where `condition` is `true`,\r\n    // thus leading to a *different* result.\r\n    localSMA := ta.sma(close, 20)\r\n// Plot `controlSMA`, `globalSMA`, and `localSMA` for comparison.\r\nplot(controlSMA, \"Control SMA\", color.blue,   2)\r\nplot(globalSMA,  \"Global SMA\",  color.purple, 3, style = plot.style_circles)\r\nplot(localSMA,   \"Local SMA\",   color.gray,   3, style = plot.style_circles)\r\n```\r\n\r\nTo summarize the behavior of time series in a script‚Äôs scopes:\r\n*   A script evaluates its global scope once on _every execution_. After each script execution on a bar‚Äôs closing tick, the system commits the data for variables and expressions in the global scope and updates their [historical buffers](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers). The resulting buffers thus include data for consecutive past bars, ensuring consistent results for operations and functions that rely on past data.\r\n*   A script evaluates local scopes _zero_, _one_, or _several_ times per execution. The runtime system **cannot** maintain consistent bar-by-bar historical buffers for scopes that a script does _not_ evaluate on every bar, or for scopes that the script evaluates _more than once_ on a bar‚Äôs closing tick. Therefore, using the [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D) operator on local variables and expressions, or not calling functions that access past data once on each closing tick, can cause **unintended results**.\r\n```",
    "keywords": [
      "www.tradingview",
      "input.int",
      "color.blue",
      "color.purple",
      "color.orange",
      "e.g",
      "ta.highest",
      "fun_ta.highest",
      "i.e",
      "color.new",
      "barstate.ishistory",
      "chart.fg_color",
      "barstate.isrealtime",
      "const_color.blue",
      "const_color.orange",
      "color.gray",
      "const_color.gray",
      "ta.sma",
      "fun_ta.sma",
      "plot.style_circles",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "const",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-56",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "barstate.isnew",
    "content": "# Pine Script¬Æ language reference manual\n\n# Variables \n\n---\n\n## ask\n\nThe ask price at the time of the current tick, which represents the lowest price an active seller will accept for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is na.\n\n**Type:** series float\n\n\n### Remarks\nIf the bid/ask values change since the last tick but no new trades are made, these changes will not be reflected in the value of this variable. It is only updated on new ticks.\n\n---\n\n## bar_index\n\n**Type:** series int\n\nCurrent bar index. Numbering is zero-based, index of the first bar is 0.\n\n### Remarks\nNote that bar_index has replaced n variable in version 4. Note that bar indexing starts from 0 on the first historical bar. Please note that using this variable/function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"bar_index\")\nplot(bar_index)\nplot(bar_index > 5000 ? close : 0)\n```\n\n---\n\n## barstate.isconfirmed\n\n**Type:** series bool\n\nReturns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. It is NOT recommended to use barstate.isconfirmed in request.security expression. Its value requested from request.security is unpredictable. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.isfirst\n\n**Type:** series bool\n\nReturns true if current bar is first bar in barset, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.ishistory\n\n**Type:** series bool\n\nReturns true if current bar is a historical bar, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.islast\n\n**Type:** series bool\n\nReturns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.islastconfirmedhistory\n\n**Type:** series bool\n\nReturns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---",
    "keywords": [
      "barstate.isconfirmed",
      "request.security",
      "barstate.isfirst",
      "barstate.ishistory",
      "barstate.islast",
      "barstate.islastconfirmedhistory",
      "indicator",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-57",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "## barstate.isnew\n\n**Type:** series bool\n\nReturns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.isrealtime\n\n**Type:** series bool\n\nReturns true if current bar is a real-time bar, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## bid\n\n**Type:** series float\n\nThe bid price at the time of the current tick, which represents the highest price an active buyer is willing to pay for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is na.\n\n### Remarks\nIf the bid/ask values change since the last tick but no new trades are made, these changes will not be reflected in the value of this variable. It is only updated on new ticks.\n\n---\n\n## box.all\n\n**Type:** array<box>\n\nReturns an array filled with all the current boxes drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"box.all\")\n//delete all boxes\nbox.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\na_allBoxes = box.all\nif array.size(a_allBoxes) > 0\n    for i = 0 to array.size(a_allBoxes) - 1\n        box.delete(array.get(a_allBoxes, i))\n```\n\n---\n\n## chart.bg_color\n\n**Type:** input color\n\nReturns the color of the chart's background from the \"Chart settings/Appearance/Background\" field. When a gradient is selected, the middle point of the gradient is returned.\n\n---\n\n## chart.fg_color\n\n**Type:** input color\n\nReturns a color providing optimal contrast with chart.bg_color.\n\n---\n\n## chart.is_heikinashi\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Heikin Ashi, false otherwise.\n\n---\n\n## chart.is_kagi\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Kagi, false otherwise.\n\n---\n\n## chart.is_linebreak\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Line break, false otherwise.\n\n---\n\n## chart.is_pnf\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Point & figure, false otherwise.\n\n---\n\n## chart.is_range\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Range, false otherwise.\n\n---\n\n## chart.is_renko\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Renko, false otherwise.\n\n---\n\n## chart.is_standard\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is not one of the following: Renko, Kagi, Line break, Point & figure, Range, Heikin Ashi; false otherwise.\n\n---\n\n## chart.left_visible_bar_time\n\n**Type:** input int\n\nThe time of the leftmost bar currently visible on the chart.",
    "keywords": [
      "barstate.isnew",
      "barstate.isrealtime",
      "box.all",
      "box.new",
      "xloc.bar_time",
      "line.style_dashed",
      "array.size",
      "box.delete",
      "array.get",
      "chart.bg_color",
      "chart.fg_color",
      "chart.is_heikinashi",
      "chart.is_kagi",
      "chart.is_linebreak",
      "chart.is_pnf",
      "chart.is_range",
      "chart.is_renko",
      "chart.is_standard",
      "chart.left_visible_bar_time",
      "indicator",
      "input",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-58",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "dividends.future_pay_date",
    "content": "### Remarks\nScripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars. Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting.\n\n---\n\n## chart.right_visible_bar_time\n\n**Type:** input int\n\nThe time of the rightmost bar currently visible on the chart.\n\n### Remarks\nScripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars. Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting.\n\n---\n\n## close\n\n**Type:** series float\n\nClose price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. close[1], close[2].\n\n---\n\n## dayofmonth\n\n**Type:** series int\n\nDate of current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.\n\n---\n\n## dayofweek\n\n**Type:** series int\n\nDay of week for current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day. You can use dayofweek.sunday, dayofweek.monday, dayofweek.tuesday, dayofweek.wednesday, dayofweek.thursday, dayofweek.friday and dayofweek.saturday variables for comparisons.\n\n---\n\n## dividends.future_amount\n\n**Type:** series float\n\nReturns the payment amount of the upcoming dividend in the currency of the current instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---\n\n## dividends.future_ex_date\n\n**Type:** series int\n\nReturns the Ex-dividend date (Ex-date) of the current instrument's next dividend payment, or na if this data isn't available. Ex-dividend date signifies when investors are no longer entitled to a payout from the most recent dividend. Only those who purchased shares before this day are entitled to the dividend payment.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---",
    "keywords": [
      "chart.right_visible_bar_time",
      "e.g",
      "dayofweek.sunday",
      "dayofweek.monday",
      "dayofweek.tuesday",
      "dayofweek.wednesday",
      "dayofweek.thursday",
      "dayofweek.friday",
      "dayofweek.saturday",
      "dividends.future_amount",
      "dividends.future_ex_date",
      "input",
      "alert",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-59",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## dividends.future_pay_date\n\n**Type:** series int\n\nReturns the Payment date (Pay date) of the current instrument's next dividend payment, or na if this data isn't available. Payment date signifies the day when eligible investors will receive the dividend payment.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---\n\n## earnings.future_eps\n\n**Type:** series float\n\nReturns the estimated Earnings per Share of the next earnings report in the currency of the instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_period_end_time\n\n**Type:** series int\n\nChecks the data for the next earnings report and returns the UNIX timestamp of the day when the financial period covered by those earnings ends, or na if this data isn't available.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_revenue\n\n**Type:** series float\n\nReturns the estimated Revenue of the next earnings report in the currency of the instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_time\n\n**Type:** series int\n\nReturns a UNIX timestamp indicating the expected time of the next earnings report, or na if this data isn't available.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## high\n\n**Type:** series float\n\nCurrent high price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. high[1], high[2].\n\n---\n\n## hl2\n\n**Type:** series float\n\nIs a shortcut for (high + low)/2\n\n---\n\n## hlc3\n\n**Type:** series float\n\nIs a shortcut for (high + low + close)/3\n\n---\n\n## hlcc4\n\n**Type:** series float\n\nIs a shortcut for (high + low + close + close)/4\n\n---\n\n## hour\n\n**Type:** series int\n\nCurrent bar hour in exchange timezone.\n\n---\n\n## label.all\n\n**Type:** array<label>\n\nReturns an array filled with all the current labels drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
    "keywords": [
      "dividends.future_pay_date",
      "earnings.future_eps",
      "earnings.future_period_end_time",
      "earnings.future_revenue",
      "earnings.future_time",
      "e.g",
      "label.all",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-60",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"label.all\")\n//delete all labels\nlabel.new(bar_index, close)\na_allLabels = label.all\nif array.size(a_allLabels) > 0\n    for i = 0 to array.size(a_allLabels) - 1\n        label.delete(array.get(a_allLabels, i))\n```\n\n---\n\n## last_bar_index\n\n**Type:** series int\n\nBar index of the last chart bar. Bar indices begin at zero on the first bar.\n\n### Returns\nLast historical bar index for closed markets, or the real-time bar index for open markets.\n\n### Remarks\nPlease note that using this variable can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)\nlastBarsFilterInput = input.int(100, \"Bars Count:\")\n// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.\n// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.\nvar lastbar = last_bar_index\n// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.\nallowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime\nbgcolor(allowedToTrade ? color.new(color.green, 80) : na)\n```\n\n---\n\n## last_bar_time\n\n**Type:** series int\n\nTime in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nPlease note that using this variable/function can cause indicator repainting. Note that this variable returns the timestamp based on the time of the bar's open.\n\n---\n\n## line.all\n\n**Type:** array<line>\n\nReturns an array filled with all the current lines drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line.all\")\n//delete all lines\nline.new(bar_index - 10, close, bar_index, close)\na_allLines = line.all\nif array.size(a_allLines) > 0\n    for i = 0 to array.size(a_allLines) - 1\n        line.delete(array.get(a_allLines, i))\n```\n\n---\n\n## linefill.all\n\n**Type:** array<linefill>\n\nReturns an array filled with all the current linefill objects drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n---\n\n## low\n\n**Type:** series float\n\nCurrent low price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. low[1], low[2].\n\n---\n\n## minute\n\n**Type:** series int\n\nCurrent bar minute in exchange timezone.\n\n---\n\n## month\n\n**Type:** series int\n\nCurrent bar month in exchange timezone.\n\n### Remarks\nNote that this variable returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day.\n\n---\n\n## na\n\n**Type:** simple na\n\nA keyword signifying \"not available\", indicating that a variable has no assigned value.",
    "keywords": [
      "label.all",
      "label.new",
      "array.size",
      "label.delete",
      "array.get",
      "input.int",
      "barstate.isrealtime",
      "color.new",
      "color.green",
      "line.all",
      "line.new",
      "line.delete",
      "linefill.all",
      "e.g",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-61",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "session.islastbar",
    "content": "### Remarks\nDo not use this variable with comparison operators to test values for na, as it might lead to unexpected behavior. Instead, use the na function. Note that na can be used to initialize variables when the initialization statement also specifies the variable's type.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"na\")\n// CORRECT\n// Plot no value when on bars zero to nine. Plot `close` on other bars.\nplot(bar_index < 10 ? na : close)\n// CORRECT ALTERNATIVE\n// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.\nfloat a = na\nif bar_index >= 10\n    a := close\nplot(a)\n\n// INCORRECT\n// Trying to test the preceding bar's `close` for `na`.\n// The next line, if uncommented, will cause a compilation error, because direct comparison with `na` is not allowed.\n// plot(close[1] == na ? close : close[1])\n// CORRECT\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// CORRECT ALTERNATIVE\n// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))\n```\n\n---\n\n## ohlc4\n\n**Type:** series float\n\nIs a shortcut for (open + high + low + close)/4\n\n---\n\n## open\n\n**Type:** series float\n\nCurrent open price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. open[1], open[2].\n\n---\n\n## polyline.all\n\n**Type:** array<polyline>\n\nReturns an array containing all current polyline instances drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array references the ID of the oldest polyline object on the chart.\n\n---\n\n## second\n\n**Type:** series int\n\nCurrent bar second in exchange timezone.\n\n---\n\n## session.isfirstbar\n\n**Type:** series bool\n\nReturns true if the current bar is the first bar of the day's session, false otherwise. If extended session information is used, only returns true on the first bar of the pre-market bars.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.isfirstbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition \n    strategy.entry(\"Long\", strategy.long)\n\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.isfirstbar_regular\n\n**Type:** series bool\n\nReturns true on the first regular session bar of the day, false otherwise. The result is the same whether extended session information is used or not.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.isfirstbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---",
    "keywords": [
      "e.g",
      "polyline.all",
      "session.isfirstbar",
      "strategy.entry",
      "strategy.long",
      "session.islastbar",
      "barstate.isconfirmed",
      "strategy.close",
      "session.isfirstbar_regular",
      "session.islastbar_regular",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-62",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.avg_trade",
    "content": "## session.islastbar\n\n**Type:** series bool\n\nReturns true if the current bar is the last bar of the day's session, false otherwise. If extended session information is used, only returns true on the last bar of the post-market bars.\n\n### Remarks\nThis variable is not guaranteed to return true once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar. This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.islastbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's last bar.\n// The position will enter on the `open` of next session's first bar.\nif session.islastbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n // Close 'Long' position at the close of the last bar of the trading session\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.islastbar_regular\n\n**Type:** series bool\n\nReturns true on the last regular session bar of the day, false otherwise. The result is the same whether extended session information is used or not.\n\n### Remarks\nThis variable is not guaranteed to return true once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar. This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.islastbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.ismarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise.\n\n---\n\n## session.ispostmarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false.\n\n---\n\n## session.ispremarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false.\n\n---\n\n## strategy.account_currency\n\n**Type:** simple string\n\nReturns the currency used to calculate results, which can be set in the strategy's properties.\n\n---\n\n## strategy.avg_losing_trade\n\n**Type:** series float\n\nReturns the average amount of money lost per losing trade. Calculated as the sum of losses divided by the number of losing trades.\n\n---\n\n## strategy.avg_losing_trade_percent\n\n**Type:** series float\n\nReturns the average percentage loss per losing trade. Calculated as the sum of loss percentages divided by the number of losing trades.\n\n---",
    "keywords": [
      "session.islastbar",
      "e.g",
      "strategy.entry",
      "strategy.long",
      "barstate.isconfirmed",
      "strategy.close",
      "session.islastbar_regular",
      "session.isfirstbar",
      "session.ismarket",
      "i.e",
      "session.ispostmarket",
      "session.ispremarket",
      "strategy.account_currency",
      "strategy.avg_losing_trade",
      "strategy.avg_losing_trade_percent",
      "strategy",
      "overlay",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-63",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.avg_trade\n\n**Type:** series float\n\nReturns the average amount of money gained or lost per trade. Calculated as the sum of all profits and losses divided by the number of closed trades.\n\n---\n\n## strategy.avg_trade_percent\n\n**Type:** series float\n\nReturns the average percentage gain or loss per trade. Calculated as the sum of all profit and loss percentages divided by the number of closed trades.\n\n---\n\n## strategy.avg_winning_trade\n\n**Type:** series float\n\nReturns the average amount of money gained per winning trade. Calculated as the sum of profits divided by the number of winning trades.\n\n---\n\n## strategy.avg_winning_trade_percent\n\n**Type:** series float\n\nReturns the average percentage gain per winning trade. Calculated as the sum of profit percentages divided by the number of winning trades.\n\n---\n\n## strategy.closedtrades\n\n**Type:** series int\n\nNumber of trades, which were closed for the whole trading range.\n\n---\n\n## strategy.closedtrades.first_index\n\n**Type:** series int\n\nThe index, or trade number, of the first (oldest) trade listed in the List of Trades. This number is usually zero. If more trades than the allowed limit have been closed, the oldest trades are removed, and this number is the index of the oldest remaining trade.\n\n---\n\n## strategy.equity\n\n**Type:** series float\n\nCurrent equity (strategy.initial_capital + strategy.netprofit + strategy.openprofit).\n\n---\n\n## strategy.eventrades\n\n**Type:** series int\n\nNumber of breakeven trades for the whole trading range.\n\n---\n\n## strategy.grossloss\n\n**Type:** series float\n\nTotal currency value of all completed losing trades.\n\n---\n\n## strategy.grossloss_percent\n\n**Type:** series float\n\nThe total value of all completed losing trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.grossprofit\n\n**Type:** series float\n\nTotal currency value of all completed winning trades.\n\n---\n\n## strategy.grossprofit_percent\n\n**Type:** series float\n\nThe total currency value of all completed winning trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.initial_capital\n\n**Type:** series float\n\nThe amount of initial capital set in the strategy properties.\n\n---\n\n## strategy.losstrades\n\n**Type:** series int\n\nNumber of unprofitable trades for the whole trading range.\n\n---\n\n## strategy.margin_liquidation_price\n\n**Type:** series float\n\nWhen margin is used in a strategy, returns the price point where a simulated margin call will occur and liquidate enough of the position to meet the margin requirements.\n\n### Remarks\nThe variable returns na if the strategy does not use margin, i.e., the strategy declaration statement does not specify an argument for the margin_long or margin_short parameter.",
    "keywords": [
      "strategy.avg_trade",
      "strategy.avg_trade_percent",
      "strategy.avg_winning_trade",
      "strategy.avg_winning_trade_percent",
      "strategy.closedtrades",
      "strategy.equity",
      "strategy.initial_capital",
      "strategy.netprofit",
      "strategy.openprofit",
      "strategy.eventrades",
      "strategy.grossloss",
      "strategy.grossloss_percent",
      "strategy.grossprofit",
      "strategy.grossprofit_percent",
      "strategy.losstrades",
      "strategy.margin_liquidation_price",
      "i.e",
      "strategy",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-64",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25, \n  default_qty_type = strategy.percent_of_equity, default_qty_value = 395)\n\nfloat maFast = ta.sma(close, 14)\nfloat maSlow = ta.sma(close, 28)\n\nif ta.crossover(maFast, maSlow)\n    strategy.entry(\"Long\", strategy.long)\n\nif ta.crossunder(maFast, maSlow)\n    strategy.entry(\"Short\", strategy.short)\n\nchangePercent(v1, v2) => \n    float result = (v1 - v2) * 100 / math.abs(v2)\n\n// exit when we're 10% away from a margin call, to prevent it.\nif math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10\n    strategy.close(\"Long\")\n    strategy.close(\"Short\")\n```\n\n---\n\n## strategy.max_contracts_held_all\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one trade for the whole trading range.\n\n---\n\n## strategy.max_contracts_held_long\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one long trade for the whole trading range.\n\n---\n\n## strategy.max_contracts_held_short\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one short trade for the whole trading range.\n\n---\n\n## strategy.max_drawdown\n\n**Type:** series float\n\nMaximum equity drawdown value for the whole trading range.\n\n---\n\n## strategy.max_drawdown_percent\n\n**Type:** series float\n\nThe maximum equity drawdown value for the whole trading range, expressed as a percentage and calculated by formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.max_runup\n\n**Type:** series float\n\nMaximum equity run-up value for the whole trading range.\n\n---\n\n## strategy.max_runup_percent\n\n**Type:** series float\n\nThe maximum equity run-up value for the whole trading range, expressed as a percentage and calculated by formula: Highest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.netprofit\n\n**Type:** series float\n\nTotal currency value of all completed trades.\n\n---\n\n## strategy.netprofit_percent\n\n**Type:** series float\n\nThe total value of all completed trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.openprofit\n\n**Type:** series float\n\nCurrent unrealized profit or loss for all open positions.\n\n---\n\n## strategy.openprofit_percent\n\n**Type:** series float\n\nThe current unrealized profit or loss for all open positions, expressed as a percentage and calculated by formula: openPL / realizedEquity * 100.\n\n---\n\n## strategy.opentrades\n\n**Type:** series int\n\nNumber of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned.\n\n---\n\n## strategy.opentrades.capital_held\n\n**Type:** series float\n\nReturns the capital amount currently held by open trades.\n\n### Remarks\nThis variable returns na if the strategy does not simulate funding trades with a portion of the hypothetical account, i.e., if the strategy function does not include nonzero margin_long or margin_short arguments.",
    "keywords": [
      "strategy.percent_of_equity",
      "ta.sma",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "ta.crossunder",
      "strategy.short",
      "math.abs",
      "strategy.margin_liquidation_price",
      "strategy.close",
      "strategy.max_contracts_held_all",
      "strategy.max_contracts_held_long",
      "strategy.max_contracts_held_short",
      "strategy.max_drawdown",
      "strategy.max_drawdown_percent",
      "strategy.max_runup",
      "strategy.max_runup_percent",
      "strategy.netprofit",
      "strategy.netprofit_percent",
      "strategy.openprofit",
      "strategy.openprofit_percent",
      "strategy.opentrades",
      "i.e",
      "strategy",
      "overlay",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-65",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\n   \"strategy.opentrades.capital_held example\", overlay=false, margin_long=50, margin_short=50, \n   default_qty_type = strategy.percent_of_equity, default_qty_value = 100\n )\n\n// Enter a short position on the first bar.\nif barstate.isfirst\n    strategy.entry(\"Short\", strategy.short)\n\n// Plot the capital held by the short position.\nplot(strategy.opentrades.capital_held, \"Capital held\")\n// Highlight the chart background if the position is completely closed by margin calls.\nbgcolor(bar_index > 0 and strategy.opentrades.capital_held == 0 ? color.new(color.red, 60) : na)\n```\n\n---\n\n## strategy.position_avg_price\n\n**Type:** series float\n\nAverage entry price of current market position. If the market position is flat, 'NaN' is returned.\n\n---\n\n## strategy.position_entry_name\n\n**Type:** series string\n\nName of the order that initially opened current market position.\n\n---\n\n## strategy.position_size\n\n**Type:** series float\n\nDirection and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size).\n\n---\n\n## strategy.wintrades\n\n**Type:** series int\n\nNumber of profitable trades for the whole trading range.\n\n---\n\n## syminfo.basecurrency\n\n**Type:** simple string\n\nReturns a string containing the code representing the symbol's base currency (i.e., the traded currency or coin) if the instrument is a Forex or Crypto pair or a derivative based on such a pair. Otherwise, it returns an empty string. For example, this variable returns \"EUR\" for \"EURJPY\", \"BTC\" for \"BTCUSDT\", \"CAD\" for \"CME:6C1!\", and \"\" for \"NASDAQ:AAPL\".\n\n---\n\n## syminfo.country\n\n**Type:** simple string\n\nReturns the two-letter code of the country where the symbol is traded, in the ISO 3166-1 alpha-2 format, or na if the exchange is not directly tied to a specific country. For example, on \"NASDAQ:AAPL\" it will return \"US\", on \"LSE:AAPL\" it will return \"GB\", and on \"BITSTAMP:BTCUSD it will return na.\n\n---\n\n## syminfo.currency\n\n**Type:** simple string\n\nReturns a string containing the code representing the currency of the symbol's prices. For example, this variable returns \"USD\" for \"NASDAQ:AAPL\" and \"JPY\" for \"EURJPY\".\n\n---\n\n## syminfo.current_contract\n\n**Type:** simple string\n\nThe ticker identifier of the underlying contract, if the current symbol is a continuous futures contract; na otherwise.\n\n---\n\n## syminfo.description\n\n**Type:** simple string\n\nDescription for the current symbol.\n\n---\n\n## syminfo.employees\n\n**Type:** simple int\n\nThe number of employees the company has.",
    "keywords": [
      "strategy.opentrades",
      "strategy.percent_of_equity",
      "barstate.isfirst",
      "strategy.entry",
      "strategy.short",
      "color.new",
      "color.red",
      "strategy.position_avg_price",
      "strategy.position_entry_name",
      "strategy.position_size",
      "strategy.wintrades",
      "syminfo.basecurrency",
      "i.e",
      "syminfo.country",
      "syminfo.currency",
      "syminfo.current_contract",
      "syminfo.description",
      "syminfo.employees",
      "strategy",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-66",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "syminfo.minmove",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.expiration_date\n\n**Type:** simple int\n\nA UNIX timestamp representing the start of the last day of the current futures contract. This variable is only compatible with non-continuous futures symbols. On other symbols, it returns na.\n\n---\n\n## syminfo.industry\n\n**Type:** simple string\n\nReturns the industry of the symbol, or na if the symbol has no industry. Example: \"Internet Software/Services\", \"Packaged software\", \"Integrated Oil\", \"Motor Vehicles\", etc. These are the same values one can see in the chart's \"Symbol info\" window.\n\n### Remarks\nA sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.\n\n---\n\n## syminfo.main_tickerid\n\n**Type:** simple string\n\nA ticker identifier representing the current chart's symbol. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc. Unlike syminfo.tickerid, this variable's value does not change when used in the expression argument of a request.*() function call.\n\n---\n\n## syminfo.mincontract\n\n**Type:** simple float\n\nThe smallest amount of the current symbol that can be traded. This limit is set by the exchange. For cryptocurrencies, it is often less than 1 token. For most other types of asset, it is often 1.\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shareholders",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "syminfo.expiration_date",
      "syminfo.industry",
      "syminfo.main_tickerid",
      "e.g",
      "syminfo.tickerid",
      "syminfo.mincontract",
      "indicator",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-67",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## syminfo.minmove\n\n**Type:** simple int\n\nReturns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the numerator in the syminfo.mintick formula: syminfo.minmove / syminfo.pricescale = syminfo.mintick.\n\n---\n\n## syminfo.mintick\n\n**Type:** simple float\n\nMin tick value for the current symbol.\n\n---\n\n## syminfo.pointvalue\n\n**Type:** simple float\n\nPoint value for the current symbol.\n\n---\n\n## syminfo.prefix\n\n**Type:** simple string\n\nPrefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD').\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.prefix\")\n\n// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text=syminfo.prefix)\n```\n\n---\n\n## syminfo.pricescale\n\n**Type:** simple int\n\nReturns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the denominator in the syminfo.mintick formula: syminfo.minmove / syminfo.pricescale = syminfo.mintick.\n\n---\n\n## syminfo.recommendations_buy\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Buy\" rating.",
    "keywords": [
      "syminfo.minmove",
      "syminfo.mintick",
      "syminfo.pricescale",
      "syminfo.pointvalue",
      "syminfo.prefix",
      "i.e",
      "barstate.islastconfirmedhistory",
      "label.new",
      "syminfo.recommendations_buy",
      "indicator",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-68",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_buy_strong\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Strong Buy\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-69",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_date\n\n**Type:** series int\n\nThe starting date of the last set of recommendations for the current symbol.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-70",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_hold\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Hold\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-71",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_sell\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Sell\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-72",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_sell_strong\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Strong Sell\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-73",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_total\n\n**Type:** series int\n\nThe total number of recommendations for the current symbol.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-74",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "syminfo.sector",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.root\n\n**Type:** simple string\n\nRoot for derivatives like futures contract. For other symbols returns the same value as syminfo.ticker.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.root\")\n\n// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, syminfo.root)\n```\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "syminfo.root",
      "syminfo.ticker",
      "label.new",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-75",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## syminfo.sector\n\n**Type:** simple string\n\nReturns the sector of the symbol, or na if the symbol has no sector. Example: \"Electronic Technology\", \"Technology services\", \"Energy Minerals\", \"Consumer Durables\", etc. These are the same values one can see in the chart's \"Symbol info\" window.\n\n### Remarks\nA sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.\n\n---\n\n## syminfo.session\n\n**Type:** simple string\n\nSession type of the chart main series. Possible values are session.regular, session.extended.\n\n---\n\n## syminfo.shareholders\n\n**Type:** simple int\n\nThe number of shareholders the company has.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.shares_outstanding_float\n\n**Type:** simple float\n\nThe total number of shares outstanding a company has available, excluding any of its restricted shares.",
    "keywords": [
      "syminfo.sector",
      "syminfo.session",
      "session.regular",
      "session.extended",
      "syminfo.shareholders",
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "indicator",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-76",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "syminfo.target_price_average",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.shares_outstanding_total\n\n**Type:** simple int\n\nThe total number of shares outstanding a company has available, including restricted shares held by insiders, major shareholders, and employees.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shareholders",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "indicator",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-77",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## syminfo.target_price_average\n\n**Type:** series float\n\nThe average of the last yearly price targets for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_date\n\n**Type:** series int\n\nThe starting date of the last price target prediction for the current symbol.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "syminfo.target_price_average",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-78",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_estimates\n\n**Type:** series float\n\nThe latest total number of price target predictions for the current symbol.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-79",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_high\n\n**Type:** series float\n\nThe last highest yearly price target for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-80",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_low\n\n**Type:** series float\n\nThe last lowest yearly price target for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-81",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_median\n\n**Type:** series float\n\nThe median of the last yearly price targets for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-82",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "syminfo.volumetype",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.ticker\n\n**Type:** simple string\n\nSymbol name without exchange prefix, e.g. 'MSFT'.\n\n---\n\n## syminfo.tickerid\n\n**Type:** simple string\n\nA ticker identifier representing the chart's symbol or a requested symbol, depending on how the script uses it. The variable's value represents a requested dataset's ticker ID when used in the expression argument of a request.*() function call. Otherwise, it represents the chart's ticker ID. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc.\n\n### Remarks\nBecause the value of this variable does not always use a simple \"prefix:ticker\" format, it is a poor candidate for use in boolean comparisons or string manipulation functions. In those contexts, run the variable's result through ticker.standard to purify it. This will remove any extraneous information and return a ticker ID consistently formatted using the \"prefix:ticker\" structure. To always access the script's main ticker ID, even within another context, use the syminfo.main_tickerid variable.\n\n---\n\n## syminfo.timezone\n\n**Type:** simple string\n\nTimezone of the exchange of the chart main series. Possible values see in timestamp.\n\n---\n\n## syminfo.type\n\n**Type:** simple string\n\nThe type of market the symbol belongs to. The values are \"stock\", \"fund\", \"dr\", \"right\", \"bond\", \"warrant\", \"structured\", \"index\", \"forex\", \"futures\", \"spread\", \"economic\", \"fundamental\", \"crypto\", \"spot\", \"swap\", \"option\", \"commodity\".\n\n---",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "syminfo.ticker",
      "e.g",
      "syminfo.tickerid",
      "ticker.standard",
      "syminfo.main_tickerid",
      "syminfo.timezone",
      "syminfo.type",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-83",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "ta.wvad",
    "content": "## syminfo.volumetype\n\n**Type:** simple string\n\nVolume type of the current symbol. Possible values are: \"base\" for base currency, \"quote\" for quote currency, \"tick\" for the number of transactions, and \"n/a\" when there is no volume or its type is not specified.\n\n### Remarks\nOnly some data feed suppliers provide information qualifying volume. As a result, the variable will return a value on some symbols only, mostly in the crypto sector.\n\n---\n\n## ta.accdist\n\n**Type:** series float\n\nAccumulation/distribution index.\n\n---\n\n## ta.iii\n\n**Type:** series float\n\nIntraday Intensity Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Intraday Intensity Index\")\nplot(ta.iii, color=color.yellow)\n\n// the same on pine\nf_iii() =>\n    (2 * close - high - low) / ((high - low) * volume)\n\nplot(f_iii())\n```\n\n---\n\n## ta.nvi\n\n**Type:** series float\n\nNegative Volume Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Negative Volume Index\")\n\nplot(ta.nvi, color=color.yellow)\n\n// the same on pine\nf_nvi() =>\n    float ta_nvi = 1.0\n    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0) ? 1.0 : ta_nvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_nvi := prevNvi\n    else\n        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi\n    result = ta_nvi\n\nplot(f_nvi())\n```\n\n---\n\n## ta.obv\n\n**Type:** series float\n\nOn Balance Volume.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"On Balance Volume\")\nplot(ta.obv, color=color.yellow)\n\n// the same on pine\nf_obv() =>\n    ta.cum(math.sign(ta.change(close)) * volume)\n\nplot(f_obv())\n```\n\n---\n\n## ta.pvi\n\n**Type:** series float\n\nPositive Volume Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Positive Volume Index\")\n\nplot(ta.pvi, color=color.yellow)\n\n// the same on pine\nf_pvi() =>\n    float ta_pvi = 1.0\n    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0) ? 1.0 : ta_pvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_pvi := prevPvi\n    else\n        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi\n    result = ta_pvi\n\nplot(f_pvi())\n```\n\n---\n\n## ta.pvt\n\n**Type:** series float\n\nPrice-Volume Trend.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Price-Volume Trend\")\nplot(ta.pvt, color=color.yellow)\n\n// the same on pine\nf_pvt() =>\n    ta.cum((ta.change(close) / close[1]) * volume)\n\nplot(f_pvt())\n```\n\n---\n\n## ta.tr\n\n**Type:** series float\n\nTrue range, equivalent to ta.tr(handle_na = false). It is calculated as math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).\n\n---\n\n## ta.vwap\n\n**Type:** series float\n\nVolume Weighted Average Price. It uses hlc3 as its source series.\n\n---\n\n## ta.wad\n\n**Type:** series float\n\nWilliams Accumulation/Distribution.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams Accumulation/Distribution\")\nplot(ta.wad, color=color.yellow)\n\n// the same on pine\nf_wad() =>\n    trueHigh = math.max(high, close[1])\n    trueLow = math.min(low, close[1])\n    mom = ta.change(close)\n    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0\n    ta.cum(gain)\n\nplot(f_wad())\n```\n\n---",
    "keywords": [
      "syminfo.volumetype",
      "ta.accdist",
      "ta.iii",
      "color.yellow",
      "ta.nvi",
      "ta.obv",
      "ta.cum",
      "math.sign",
      "ta.change",
      "ta.pvi",
      "ta.pvt",
      "ta.tr",
      "math.max",
      "math.abs",
      "ta.vwap",
      "ta.wad",
      "math.min",
      "indicator",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-84",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "timeframe.isminutes",
    "content": "## ta.wvad\n\n**Type:** series float\n\nWilliams Variable Accumulation/Distribution.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams Variable Accumulation/Distribution\")\nplot(ta.wvad, color=color.yellow)\n\n// the same on pine\nf_wvad() =>\n    (close - open) / (high - low) * volume\n\nplot(f_wvad())\n```\n\n---\n\n## table.all\n\n**Type:** array<table>\n\nReturns an array filled with all the current tables drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table.all\")\n//delete all tables\ntable.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\na_allTables = table.all\nif array.size(a_allTables) > 0\n    for i = 0 to array.size(a_allTables) - 1\n        table.delete(array.get(a_allTables, i))\n```\n\n---\n\n## time\n\n**Type:** series int\n\nCurrent bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nNote that this variable returns the timestamp based on the time of the bar's open. Because of that, for overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day. For example, on EURUSD, dayofmonth(time) can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior.\n\n---\n\n## time_close\n\n**Type:** series int\n\nThe time of the current bar's close in UNIX format. It represents the number of milliseconds elapsed since 00:00:00 UTC, 1 January 1970. On tick charts and price-based charts such as Renko, line break, Kagi, point & figure, and range, this variable's series holds an na timestamp for the latest realtime bar (because the future closing time is unpredictable), but valid timestamps for all previous bars.\n\n---\n\n## time_tradingday\n\n**Type:** series int\n\nThe beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970).\n\n### Remarks\nThe variable is useful for overnight sessions, where the current day's session can start on the previous calendar day (e.g., on FXCM:EURUSD the Monday session will start on Sunday, 17:00 in the exchange timezone). Unlike time, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, time_tradingday will return the timestamp for Monday, 00:00 UTC. When used on timeframes higher than 1D, time_tradingday returns the trading day of the last day inside the bar (e.g. on 1W, it will return the last trading day of the week).\n\n---\n\n## timeframe.isdaily\n\n**Type:** simple bool\n\nReturns true if current resolution is a daily resolution, false otherwise.\n\n---\n\n## timeframe.isdwm\n\n**Type:** simple bool\n\nReturns true if current resolution is a daily or weekly or monthly resolution, false otherwise.\n\n---\n\n## timeframe.isintraday\n\n**Type:** simple bool\n\nReturns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise.\n\n---",
    "keywords": [
      "ta.wvad",
      "color.yellow",
      "table.all",
      "table.new",
      "position.top_right",
      "array.size",
      "table.delete",
      "array.get",
      "e.g",
      "timeframe.isdaily",
      "timeframe.isdwm",
      "timeframe.isintraday",
      "indicator",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-85",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "adjustment.splits",
    "content": "## timeframe.isminutes\n\n**Type:** simple bool\n\nReturns true if current resolution is a minutes resolution, false otherwise.\n\n---\n\n## timeframe.ismonthly\n\n**Type:** simple bool\n\nReturns true if current resolution is a monthly resolution, false otherwise.\n\n---\n\n## timeframe.isseconds\n\n**Type:** simple bool\n\nReturns true if current resolution is a seconds resolution, false otherwise.\n\n---\n\n## timeframe.isticks\n\n**Type:** simple bool\n\nReturns true if current resolution is a ticks resolution, false otherwise.\n\n---\n\n## timeframe.isweekly\n\n**Type:** simple bool\n\nReturns true if current resolution is a weekly resolution, false otherwise.\n\n---\n\n## timeframe.main_period\n\n**Type:** simple string\n\nA string representation of the script's main timeframe. If the script is an indicator that specifies a timeframe value in its declaration statement, this variable holds that value. Otherwise, its value represents the chart's timeframe. Unlike timeframe.period, this variable's value does not change when used in the expression argument of a request.*() function call.\n\n---\n\n## timeframe.multiplier\n\n**Type:** simple int\n\nMultiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12.\n\n---\n\n## timeframe.period\n\n**Type:** simple string\n\nA string representation of the script's main timeframe or a requested timeframe, depending on how the script uses it. The variable's value represents the timeframe of a requested dataset when used in the expression argument of a request.*() function call. Otherwise, its value represents the script's main timeframe (timeframe.main_period), which equals either the timeframe argument of the indicator declaration statement or the chart's timeframe.\n\n### Remarks\nTo always access the script's main timeframe, even within another context, use the timeframe.main_period variable.\n\n---\n\n## timenow\n\n**Type:** series int\n\nCurrent time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nPlease note that using this variable/function can cause indicator repainting.\n\n---\n\n## volume\n\n**Type:** series float\n\nCurrent bar volume.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. volume[1], volume[2].\n\n---\n\n## weekofyear\n\n**Type:** series int\n\nWeek number of current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.\n\n---\n\n## year\n\n**Type:** series int\n\nCurrent bar year in exchange timezone.\n\n### Remarks\nNote that this variable returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day.\n\n# Constants\n---\n\n## adjustment.dividends\n\n**Type:** const string\n\nConstant for dividends adjustment type (dividends adjustment is applied).\n\n---\n\n## adjustment.none\n\n**Type:** const string\n\nConstant for none adjustment type (no adjustment is applied).\n\n---",
    "keywords": [
      "timeframe.isminutes",
      "timeframe.ismonthly",
      "timeframe.isseconds",
      "timeframe.isticks",
      "timeframe.isweekly",
      "timeframe.main_period",
      "timeframe.period",
      "timeframe.multiplier",
      "e.g",
      "adjustment.dividends",
      "adjustment.none",
      "indicator",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-86",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "color.silver",
    "content": "## adjustment.splits\n\n**Type:** const string\n\nConstant for splits adjustment type (splits adjustment is applied).\n\n---\n\n## alert.freq_all\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## alert.freq_once_per_bar\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## alert.freq_once_per_bar_close\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## backadjustment.inherit\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## backadjustment.off\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## backadjustment.on\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## barmerge.gaps_off\n\n**Type:** const barmerge_gaps\n\nMerge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value.\n\n---\n\n## barmerge.gaps_on\n\n**Type:** const barmerge_gaps\n\nMerge strategy for requested data. Data is merged with possible gaps (na values).\n\n---\n\n## barmerge.lookahead_off\n\n**Type:** const barmerge_lookahead\n\nMerge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from \"future\" on calculation on history.\n\n---\n\n## barmerge.lookahead_on\n\n**Type:** const barmerge_lookahead\n\nMerge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from \"future\" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators.\n\n---\n\n## color.aqua\n\n**Type:** const color\n\nIs a named constant for #00BCD4 color.\n\n---\n\n## color.black\n\n**Type:** const color\n\nIs a named constant for #363A45 color.\n\n---\n\n## color.blue\n\n**Type:** const color\n\nIs a named constant for #2962ff color.\n\n---\n\n## color.fuchsia\n\n**Type:** const color\n\nIs a named constant for #E040FB color.\n\n---\n\n## color.gray\n\n**Type:** const color\n\nIs a named constant for #787B86 color.\n\n---\n\n## color.green\n\n**Type:** const color\n\nIs a named constant for #4CAF50 color.\n\n---\n\n## color.lime\n\n**Type:** const color\n\nIs a named constant for #00E676 color.\n\n---\n\n## color.maroon\n\n**Type:** const color\n\nIs a named constant for #880E4F color.\n\n---\n\n## color.navy\n\n**Type:** const color\n\nIs a named constant for #311B92 color.\n\n---\n\n## color.olive\n\n**Type:** const color\n\nIs a named constant for #808000 color.\n\n---\n\n## color.orange\n\n**Type:** const color\n\nIs a named constant for #FF9800 color.\n\n---\n\n## color.purple\n\n**Type:** const color\n\nIs a named constant for #9C27B0 color.\n\n---\n\n## color.red\n\n**Type:** const color\n\nIs a named constant for #F23645 color.\n\n---",
    "keywords": [
      "adjustment.splits",
      "alert.freq_all",
      "alert.freq_once_per_bar",
      "alert.freq_once_per_bar_close",
      "backadjustment.inherit",
      "ticker.new",
      "ticker.modify",
      "backadjustment.off",
      "backadjustment.on",
      "barmerge.gaps_off",
      "barmerge.gaps_on",
      "barmerge.lookahead_off",
      "barmerge.lookahead_on",
      "color.aqua",
      "color.black",
      "color.blue",
      "color.fuchsia",
      "color.gray",
      "color.green",
      "color.lime",
      "color.maroon",
      "color.navy",
      "color.olive",
      "color.orange",
      "color.purple",
      "color.red",
      "indicator",
      "strategy",
      "fill",
      "alert",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-87",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "display.data_window",
    "content": "## color.silver\n\n**Type:** const color\n\nIs a named constant for #B2B5BE color.\n\n---\n\n## color.teal\n\n**Type:** const color\n\nIs a named constant for #089981 color.\n\n---\n\n## color.white\n\n**Type:** const color\n\nIs a named constant for #FFFFFF color.\n\n---\n\n## color.yellow\n\n**Type:** const color\n\nIs a named constant for #FDD835 color.\n\n---\n\n## currency.AUD\n\n**Type:** const string\n\nAustralian dollar.\n\n---\n\n## currency.BTC\n\n**Type:** const string\n\nBitcoin.\n\n---\n\n## currency.CAD\n\n**Type:** const string\n\nCanadian dollar.\n\n---\n\n## currency.CHF\n\n**Type:** const string\n\nSwiss franc.\n\n---\n\n## currency.EGP\n\n**Type:** const string\n\nEgyptian pound.\n\n---\n\n## currency.ETH\n\n**Type:** const string\n\nEthereum.\n\n---\n\n## currency.EUR\n\n**Type:** const string\n\nEuro.\n\n---\n\n## currency.GBP\n\n**Type:** const string\n\nPound sterling.\n\n---\n\n## currency.HKD\n\n**Type:** const string\n\nHong Kong dollar.\n\n---\n\n## currency.INR\n\n**Type:** const string\n\nIndian rupee.\n\n---\n\n## currency.JPY\n\n**Type:** const string\n\nJapanese yen.\n\n---\n\n## currency.KRW\n\n**Type:** const string\n\nSouth Korean won.\n\n---\n\n## currency.MYR\n\n**Type:** const string\n\nMalaysian ringgit.\n\n---\n\n## currency.NOK\n\n**Type:** const string\n\nNorwegian krone.\n\n---\n\n## currency.NONE\n\n**Type:** const string\n\nUnspecified currency.\n\n---\n\n## currency.NZD\n\n**Type:** const string\n\nNew Zealand dollar.\n\n---\n\n## currency.PKR\n\n**Type:** const string\n\nPakistani rupee.\n\n---\n\n## currency.PLN\n\n**Type:** const string\n\nPolish zloty.\n\n---\n\n## currency.RUB\n\n**Type:** const string\n\nRussian ruble.\n\n---\n\n## currency.SEK\n\n**Type:** const string\n\nSwedish krona.\n\n---\n\n## currency.SGD\n\n**Type:** const string\n\nSingapore dollar.\n\n---\n\n## currency.TRY\n\n**Type:** const string\n\nTurkish lira.\n\n---\n\n## currency.USD\n\n**Type:** const string\n\nUnited States dollar.\n\n---\n\n## currency.USDT\n\n**Type:** const string\n\nTether.\n\n---\n\n## currency.ZAR\n\n**Type:** const string\n\nSouth African rand.\n\n---\n\n## dayofweek.friday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.monday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.saturday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.sunday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.thursday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.tuesday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.wednesday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## display.all\n\n**Type:** const plot_simple_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in all possible locations.\n\n---",
    "keywords": [
      "color.silver",
      "color.teal",
      "color.white",
      "color.yellow",
      "dayofweek.friday",
      "dayofweek.monday",
      "dayofweek.saturday",
      "dayofweek.sunday",
      "dayofweek.thursday",
      "dayofweek.tuesday",
      "dayofweek.wednesday",
      "display.all",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-88",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "font.family_monospace",
    "content": "## display.data_window\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in the Data Window, a menu accessible from the chart's right sidebar.\n\n---\n\n## display.none\n\n**Type:** const plot_simple_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. plot*() functions using this will not display their plotted values anywhere. However, alert template messages and fill functions can still use the values, and they will appear in exported chart data. input*() functions using this constant will only display their values within the script's settings.\n\n---\n\n## display.pane\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() functions. Displays plotted values in the chart pane used by the script.\n\n---\n\n## display.price_scale\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() functions. Displays the plot‚Äôs label and value on the price scale if the chart's settings allow it.\n\n---\n\n## display.status_line\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in the status line next to the script's name on the chart if the chart's settings allow it.\n\n---\n\n## dividends.gross\n\n**Type:** const string\n\nA named constant for the request.dividends function. Is used to request the dividends return on a stock before deductions.\n\n---\n\n## dividends.net\n\n**Type:** const string\n\nA named constant for the request.dividends function. Is used to request the dividends return on a stock after deductions.\n\n---\n\n## earnings.actual\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the earnings value as it was reported.\n\n---\n\n## earnings.estimate\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the estimated earnings value.\n\n---\n\n## earnings.standardized\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the standardized earnings value.\n\n---\n\n## extend.both\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.left\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.none\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.right\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## false\n\nLiteral representing a bool value, and result of a comparison operation.\n\n### Remarks\nSee the User Manual for comparison operators and logical operators.\n\n---\n\n## font.family_default\n\n**Type:** const string\n\nDefault text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions.\n\n---",
    "keywords": [
      "display.data_window",
      "display.none",
      "display.pane",
      "display.price_scale",
      "display.status_line",
      "dividends.gross",
      "request.dividends",
      "dividends.net",
      "earnings.actual",
      "request.earnings",
      "earnings.estimate",
      "earnings.standardized",
      "extend.both",
      "line.new",
      "line.set_extend",
      "extend.left",
      "extend.none",
      "extend.right",
      "font.family_default",
      "box.new",
      "box.set_text_font_family",
      "label.new",
      "label.set_text_font_family",
      "table.cell",
      "table.cell_set_text_font_family",
      "input",
      "plot",
      "fill",
      "alert",
      "simple",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-89",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "label.style_label_lower_right",
    "content": "## font.family_monospace\n\n**Type:** const string\n\nMonospace text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions.\n\n---\n\n## format.inherit\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values from the parent series in the indicator function.\n\n---\n\n## format.mintick\n\n**Type:** const string\n\nIs a named constant to use with the str.tostring function. Passing a number to str.tostring with this argument rounds the number to the nearest value that can be divided by syminfo.mintick, without the remainder, with ties rounding up, and returns the string version of said value with trailing zeros.\n\n---\n\n## format.percent\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values.\n\n### Remarks\nThe default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the indicator function.\n\n---\n\n## format.price\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as prices in the indicator function.\n\n### Remarks\nIf format is format.price, default precision value is set. You can use the precision argument of indicator function to change the precision value.\n\n---\n\n## format.volume\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as volume in the indicator function, e.g. '5183' will be formatted as '5.183K'.\n\n---\n\n## hline.style_dashed\n\n**Type:** const hline_style\n\nIs a named constant for dashed linestyle of hline function.\n\n---\n\n## hline.style_dotted\n\n**Type:** const hline_style\n\nIs a named constant for dotted linestyle of hline function.\n\n---\n\n## hline.style_solid\n\n**Type:** const hline_style\n\nIs a named constant for solid linestyle of hline function.\n\n---\n\n## label.style_arrowdown\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_arrowup\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_circle\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_cross\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_diamond\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_flag\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_center\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_down\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_lower_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---",
    "keywords": [
      "font.family_monospace",
      "box.new",
      "box.set_text_font_family",
      "label.new",
      "label.set_text_font_family",
      "table.cell",
      "table.cell_set_text_font_family",
      "format.inherit",
      "format.mintick",
      "str.tostring",
      "syminfo.mintick",
      "format.percent",
      "format.price",
      "format.volume",
      "e.g",
      "hline.style_dashed",
      "hline.style_dotted",
      "hline.style_solid",
      "label.style_arrowdown",
      "label.set_style",
      "label.style_arrowup",
      "label.style_circle",
      "label.style_cross",
      "label.style_diamond",
      "label.style_flag",
      "label.style_label_center",
      "label.style_label_down",
      "label.style_label_left",
      "label.style_label_lower_left",
      "indicator",
      "hline",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-90",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "math.rphi",
    "content": "## label.style_label_lower_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_up\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_upper_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_upper_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_none\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_square\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_text_outline\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_triangledown\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_triangleup\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_xcross\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## line.style_arrow_both\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrows on both points.\n\n---\n\n## line.style_arrow_left\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrow on the first point.\n\n---\n\n## line.style_arrow_right\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrow on the second point.\n\n---\n\n## line.style_dashed\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## line.style_dotted\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## line.style_solid\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## location.abovebar\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted above main series bars.\n\n---\n\n## location.absolute\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted on chart using indicator value as a price coordinate.\n\n---\n\n## location.belowbar\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted below main series bars.\n\n---\n\n## location.bottom\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted near the bottom chart border.\n\n---\n\n## location.top\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted near the top chart border.\n\n---\n\n## math.e\n\n**Type:** const float\n\nIs a named constant for Euler's number. It is equal to 2.7182818284590452.\n\n---\n\n## math.phi\n\n**Type:** const float\n\nIs a named constant for the golden ratio. It is equal to 1.6180339887498948.\n\n---\n\n## math.pi\n\n**Type:** const float\n\nIs a named constant for Archimedes' constant. It is equal to 3.1415926535897932.\n\n---",
    "keywords": [
      "label.style_label_lower_right",
      "label.new",
      "label.set_style",
      "label.style_label_right",
      "label.style_label_up",
      "label.style_label_upper_left",
      "label.style_label_upper_right",
      "label.style_none",
      "label.style_square",
      "label.style_text_outline",
      "label.style_triangledown",
      "label.style_triangleup",
      "label.style_xcross",
      "line.style_arrow_both",
      "line.new",
      "line.set_style",
      "line.style_arrow_left",
      "line.style_arrow_right",
      "line.style_dashed",
      "line.style_dotted",
      "line.style_solid",
      "location.abovebar",
      "location.absolute",
      "location.belowbar",
      "location.bottom",
      "location.top",
      "math.e",
      "math.phi",
      "math.pi",
      "indicator",
      "plot",
      "series",
      "const",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-91",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "position.middle_right",
    "content": "## math.rphi\n\n**Type:** const float\n\nIs a named constant for the golden ratio conjugate. It is equal to 0.6180339887498948.\n\n---\n\n## order.ascending\n\n**Type:** const sort_order\n\nDetermines the sort order of the array from the smallest to the largest value.\n\n---\n\n## order.descending\n\n**Type:** const sort_order\n\nDetermines the sort order of the array from the largest to the smallest value.\n\n---\n\n## plot.style_area\n\n**Type:** const plot_style\n\nA named constant for the 'Area' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_areabr\n\n**Type:** const plot_style\n\nA named constant for the 'Area With Breaks' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_area, except the gaps in the data are not filled.\n\n---\n\n## plot.style_circles\n\n**Type:** const plot_style\n\nA named constant for the 'Circles' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_columns\n\n**Type:** const plot_style\n\nA named constant for the 'Columns' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_cross\n\n**Type:** const plot_style\n\nA named constant for the 'Cross' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_histogram\n\n**Type:** const plot_style\n\nA named constant for the 'Histogram' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_line\n\n**Type:** const plot_style\n\nA named constant for the 'Line' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_linebr\n\n**Type:** const plot_style\n\nA named constant for the 'Line With Breaks' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_line, except the gaps in the data are not filled.\n\n---\n\n## plot.style_stepline\n\n**Type:** const plot_style\n\nA named constant for the 'Step Line' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_stepline_diamond\n\n**Type:** const plot_style\n\nA named constant for the 'Step Line With Diamonds' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_stepline, except the data changes are also marked with the Diamond shapes.\n\n---\n\n## plot.style_steplinebr\n\n**Type:** const plot_style\n\nA named constant for the 'Step line with Breaks' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## position.bottom_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.bottom_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.bottom_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.middle_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.middle_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---",
    "keywords": [
      "math.rphi",
      "order.ascending",
      "order.descending",
      "plot.style_area",
      "plot.style_areabr",
      "plot.style_circles",
      "plot.style_columns",
      "plot.style_cross",
      "plot.style_histogram",
      "plot.style_line",
      "plot.style_linebr",
      "plot.style_stepline",
      "plot.style_stepline_diamond",
      "plot.style_steplinebr",
      "position.bottom_center",
      "table.new",
      "table.cell",
      "position.bottom_left",
      "position.bottom_right",
      "position.middle_center",
      "position.middle_left",
      "plot",
      "fill",
      "const",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-92",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "size.small",
    "content": "## position.middle_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## scale.left\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added to the left price scale.\n\n---\n\n## scale.none\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'.\n\n---\n\n## scale.right\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added to the right price scale.\n\n---\n\n## session.extended\n\n**Type:** const string\n\nConstant for extended session type (with extended hours data).\n\n---\n\n## session.regular\n\n**Type:** const string\n\nConstant for regular session type (no extended hours data).\n\n---\n\n## settlement_as_close.inherit\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## settlement_as_close.off\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## settlement_as_close.on\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## shape.arrowdown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.arrowup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.circle\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.cross\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.diamond\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.flag\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.labeldown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.labelup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.square\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.triangledown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.triangleup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.xcross\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## size.auto\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape automatically adapts to the size of the bars.\n\n---\n\n## size.huge\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly huge.\n\n---\n\n## size.large\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly large.\n\n---\n\n## size.normal\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly normal.\n\n---",
    "keywords": [
      "position.middle_right",
      "table.new",
      "table.cell",
      "position.top_center",
      "position.top_left",
      "position.top_right",
      "scale.left",
      "scale.none",
      "scale.right",
      "session.extended",
      "session.regular",
      "settlement_as_close.inherit",
      "ticker.new",
      "ticker.modify",
      "settlement_as_close.off",
      "settlement_as_close.on",
      "shape.arrowdown",
      "shape.arrowup",
      "shape.circle",
      "shape.cross",
      "shape.diamond",
      "shape.flag",
      "shape.labeldown",
      "shape.labelup",
      "shape.square",
      "shape.triangledown",
      "shape.triangleup",
      "shape.xcross",
      "size.auto",
      "size.huge",
      "size.large",
      "size.normal",
      "indicator",
      "overlay",
      "plot",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-93",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## size.small\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly small.\n\n---\n\n## size.tiny\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly tiny.\n\n---\n\n## splits.denominator\n\n**Type:** const string\n\nA named constant for the request.splits function. Is used to request the denominator (the number below the line in a fraction) of a splits.\n\n---\n\n## splits.numerator\n\n**Type:** const string\n\nA named constant for the request.splits function. Is used to request the numerator (the number above the line in a fraction) of a splits.\n\n---\n\n## strategy.cash\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that an amount of cash in the strategy.account_currency will be used to enter trades.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.\n    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.commission.cash_per_contract\n\n**Type:** const string\n\nCommission type for an order. Money displayed in the account currency per contract.\n\n---\n\n## strategy.commission.cash_per_order\n\n**Type:** const string\n\nCommission type for an order. Money displayed in the account currency per order.\n\n---\n\n## strategy.commission.percent\n\n**Type:** const string\n\nCommission type for an order. A percentage of the cash volume of order.\n\n---\n\n## strategy.direction.all\n\n**Type:** const string\n\nIt allows strategy to open both long and short positions.\n\n---\n\n## strategy.direction.long\n\n**Type:** const string\n\nIt allows strategy to open only long positions.\n\n---\n\n## strategy.direction.short\n\n**Type:** const string\n\nIt allows strategy to open only short positions.\n\n---\n\n## strategy.fixed\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that a number of contracts/shares/lots will be used to enter trades.",
    "keywords": [
      "size.small",
      "size.tiny",
      "splits.denominator",
      "request.splits",
      "splits.numerator",
      "strategy.cash",
      "strategy.entry",
      "strategy.order",
      "strategy.account_currency",
      "strategy.long",
      "strategy.close",
      "strategy.commission",
      "strategy.direction",
      "strategy.fixed",
      "strategy",
      "overlay",
      "plot",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-94",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.\n    // qty = 50\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.long\n\n**Type:** const strategy_direction\n\nA named constant for use with the direction parameter of the strategy.entry and strategy.order commands. It specifies that the command creates a buy order.\n\n---\n\n## strategy.oca.cancel\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that the strategy cancels the unfilled order when another order with the same oca_name and oca_type executes.\n\n### Remarks\nStrategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from strategy.order calls with the same oca_* arguments, the strategy cannot fully or partially cancel either one.\n\n---\n\n## strategy.oca.none\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that the order executes independently of all other orders, including those with the same oca_name.\n\n---\n\n## strategy.oca.reduce\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that when another order with the same oca_name and oca_type executes, the strategy reduces the unfilled order by that order's size. If the unfilled order's size reaches 0 after reduction, it is the same as canceling the order entirely.\n\n### Remarks\nStrategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from strategy.order calls with the same oca_* arguments, the strategy cannot fully or partially cancel either one. Orders from strategy.exit automatically use this OCA type, and they belong to the same OCA group by default.\n\n---\n\n## strategy.percent_of_equity\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that a percentage (0-100) of equity will be used to enter trades.",
    "keywords": [
      "strategy.fixed",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.order",
      "strategy.oca",
      "strategy.exit",
      "strategy.percent_of_equity",
      "strategy",
      "overlay",
      "fill",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-95",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "xloc.bar_time",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)\n\n// As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.\nif bar_index == 0\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\nplot(strategy.equity)\n\n // The ‚Äòqty‚Äô parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).\nif bar_index == 4\n    strategy.entry(\"EN\", strategy.long, qty = 10)\nif bar_index == 6\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.short\n\n**Type:** const strategy_direction\n\nA named constant for use with the direction parameter of the strategy.entry and strategy.order commands. It specifies that the command creates a sell order.\n\n---\n\n## text.align_bottom\n\n**Type:** const string\n\nVertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions.\n\n---\n\n## text.align_center\n\n**Type:** const string\n\nText alignment for box.new, box.set_text_halign, box.set_text_valign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_left\n\n**Type:** const string\n\nHorizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_right\n\n**Type:** const string\n\nHorizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_top\n\n**Type:** const string\n\nVertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions.\n\n---\n\n## text.format_bold\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Makes the text bold.\n\n---\n\n## text.format_italic\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Italicizes the text.\n\n---\n\n## text.format_none\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Signifies no special text formatting.\n\n---\n\n## text.wrap_auto\n\n**Type:** const string\n\nAutomatic wrapping mode for box.new and box.set_text_wrap functions.\n\n---\n\n## text.wrap_none\n\n**Type:** const string\n\nDisabled wrapping mode for box.new and box.set_text_wrap functions.\n\n---\n\n## true\n\nLiteral representing one of the values a bool variable can hold, or an expression can evaluate to when it uses comparison or logical operators.\n\n### Remarks\nSee the User Manual for comparison operators and logical operators.\n\n---\n\n## xloc.bar_index\n\n**Type:** const string\n\nA constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_index, the drawing object treats each x-coordinate as a bar_index value.\n\n---",
    "keywords": [
      "strategy.percent_of_equity",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.equity",
      "strategy.short",
      "strategy.order",
      "text.align_bottom",
      "box.new",
      "box.set_text_valign",
      "table.cell",
      "table.cell_set_text_valign",
      "text.align_center",
      "box.set_text_halign",
      "label.new",
      "label.set_textalign",
      "text.align_left",
      "text.align_right",
      "text.align_top",
      "text.format_bold",
      "text.format_italic",
      "text.format_none",
      "text.wrap_auto",
      "box.set_text_wrap",
      "text.wrap_none",
      "xloc.bar_index",
      "strategy",
      "overlay",
      "plot",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-96",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "## xloc.bar_time\n\n**Type:** const string\n\nA constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_time, the drawing object treats each x-coordinate as a UNIX timestamp, expressed in milliseconds.\n\n---\n\n## yloc.abovebar\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---\n\n## yloc.belowbar\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---\n\n## yloc.price\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---\n\n# Functions\n\n## alert()\n\nCreates an alert trigger for an indicator or strategy, with a specified frequency, when called on the latest realtime bar. To activate alerts for a script containing calls to this function, open the \"Create Alert\" dialog box, then select the script name and \"Any alert() function call\" in the \"Condition\" section.\n\n### Remarks\nThe alert() function does not display information on the chart. In contrast to alertcondition, calls to this function do not count toward a script's plot count. Additionally, alert() calls are allowed in local scopes, including the scopes of exported library functions. See this article in our Help Center to learn more about activating alerts from alert() calls.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`alert()` example\", \"\", true)\nma = ta.sma(close, 14)\nxUp = ta.crossover(close, ma)\nif xUp\n    // Trigger the alert the first time a cross occurs during the real-time bar.\n    alert(\"Price (\" + str.tostring(close) + \") crossed over MA (\" + str.tostring(ma) + \").\", alert.freq_once_per_bar)\nplot(ma)\nplotchar(xUp, \"xUp\", \"‚ñ≤\", location.top, size = size.tiny)\n```\n\n---\n\n## alertcondition()\n\nCreates alert condition, that is available in Create Alert dialog. Please note, that alertcondition does NOT create an alert, it just gives you more options in Create Alert dialog. Also, alertcondition effect is invisible on chart.\n\n### Remarks\nPlease note that an alertcondition call generates an additional plot. All such calls are taken into account when we calculate the number of the output series per script.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"alertcondition\", overlay=true)\nalertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')\n```\n\n---\n\n## array.abs()\n\nReturns an array containing the absolute value of each element in the original array.\n\n---\n\n## array.avg()\n\nThe function returns the mean of an array's elements.\n\n### Returns\nMean of array's elements.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.avg example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.avg(a))\n```\n\n---\n\n## array.binary_search()\n\nThe function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order.",
    "keywords": [
      "xloc.bar_time",
      "yloc.abovebar",
      "label.new",
      "yloc.belowbar",
      "yloc.price",
      "ta.sma",
      "ta.crossover",
      "str.tostring",
      "alert.freq_once_per_bar",
      "location.top",
      "size.tiny",
      "array.abs",
      "array.avg",
      "array.new_float",
      "array.push",
      "array.binary_search",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "alert",
      "alertcondition",
      "series",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-97",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Remarks\nA binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.binary_search\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search(a, 0) // 1\nplot(position)\n```\n\n---\n\n## array.binary_search_leftmost()\n\nThe function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order.\n\n### Remarks\nA binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.binary_search_leftmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_leftmost(a, 3) // 2\nplot(position)\n\n//@version=6\nindicator(\"array.binary_search_leftmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the first instance.\nposition = array.binary_search_leftmost(a, 5) \nplot(position) // Plots 1\n```\n\n---\n\n## array.binary_search_rightmost()\n\nThe function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order.\n\n### Remarks\nA binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie.",
    "keywords": [
      "array.binary_search",
      "array.from",
      "array.sort",
      "array.binary_search_leftmost",
      "array.binary_search_rightmost",
      "indicator",
      "plot",
      "if"
    ]
  },
  {
    "id": "doc-98",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "array.from()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"array.binary_search_rightmost\")\na = array.from(5, -2, 0, 9, 1)\narray.sort(a) // [-2, 0, 1, 5, 9]\nposition = array.binary_search_rightmost(a, 3) // 3\nplot(position)\n\n//@version=6\nindicator(\"array.binary_search_rightmost, repetitive elements\")\na = array.from(4, 5, 5, 5)\n// Returns the index of the last instance.\nposition = array.binary_search_rightmost(a, 5) \nplot(position) // Plots 3\n```\n\n---\n\n## array.clear()\n\nThe function removes all elements from an array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.clear example\")\na = array.new_float(5,high)\narray.clear(a)\narray.push(a, close)\nplot(array.get(a,0))\nplot(array.size(a))\n```\n\n---\n\n## array.concat()\n\nThe function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array.\n\n### Returns\nThe first array with merged elements from the second array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.concat example\")\na = array.new_float(0,0)\nb = array.new_float(0,0)\nfor i = 0 to 4\n    array.push(a, high[i])\n    array.push(b, low[i])\nc = array.concat(a,b)\nplot(array.size(a))\nplot(array.size(b))\nplot(array.size(c))\n```\n\n---\n\n## array.copy()\n\nThe function creates a copy of an existing array.\n\n### Returns\nA copy of an array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.copy example\")\nlength = 5\na = array.new_float(length, close)\nb = array.copy(a)\na := array.new_float(length, open)\nplot(array.sum(a) / length)\nplot(array.sum(b) / length)\n```\n\n---\n\n## array.covariance()\n\nThe function returns the covariance of two arrays.\n\n### Returns\nThe covariance of two arrays.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.covariance example\")\na = array.new_float(0)\nb = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\n    array.push(b, open[i])\nplot(array.covariance(a, b))\n```\n\n---\n\n## array.every()\n\nReturns true if all elements of the id array are true, false otherwise.\n\n### Remarks\nThis function also works with arrays of int and float types, in which case zero values are considered false, and all others true.\n\n---\n\n## array.fill()\n\nThe function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.fill example\")\na = array.new_float(10)\narray.fill(a, close)\nplot(array.sum(a))\n```\n\n---\n\n## array.first()\n\nReturns the array's first element. Throws a runtime error if the array is empty.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.first example\")\narr = array.new_int(3, 10)\nplot(array.first(arr))\n```\n\n---",
    "keywords": [
      "array.binary_search_rightmost",
      "array.from",
      "array.sort",
      "array.clear",
      "array.new_float",
      "array.push",
      "array.get",
      "array.size",
      "array.concat",
      "array.copy",
      "array.sum",
      "array.covariance",
      "array.every",
      "array.fill",
      "array.first",
      "array.new_int",
      "indicator",
      "plot",
      "fill",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-99",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## array.from()\n\nThe function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type.\n\n### Returns\nThe array element's value.\n\n### Remarks\nThis function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.from_example\", overlay = false)\narr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.\nplot(close)\n```\n\n---\n\n## array.get()\n\nThe function returns the value of the element at the specified index.\n\n### Returns\nThe array element's value.\n\n### Remarks\nIf the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is array.size() - 1. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative array.size(). For example, for an array that contains three elements, all of the following are valid arguments for the index parameter: 0, 1, 2, -1, -2, -3.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.get example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i] - open[i])\nplot(array.get(a, 9))\n```\n\n---\n\n## array.includes()\n\nThe function returns true if the value was found in an array, false otherwise.\n\n### Returns\nTrue if the value was found in the array, false otherwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.includes example\")\na = array.new_float(5,high)\np = close\nif array.includes(a, high)\n    p := open\nplot(p)\n```\n\n---\n\n## array.indexof()\n\nThe function returns the index of the first occurrence of the value, or -1 if the value is not found.\n\n### Returns\nThe index of an element.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.indexof example\")\na = array.new_float(5,high)\nindex = array.indexof(a, high)\nplot(index)\n```\n\n---\n\n## array.insert()\n\nThe function changes the contents of an array by adding new elements in place.\n\n### Remarks\nIf the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is array.size() - 1. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative array.size(). For example, for an array that contains three elements, all of the following are valid arguments for the index parameter: 0, 1, 2, -1, -2, -3.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.insert example\")\na = array.new_float(5, close)\narray.insert(a, 0, open)\nplot(array.get(a, 5))\n```\n\n---\n\n## array.join()\n\nThe function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string.",
    "keywords": [
      "array.from",
      "array.from_example",
      "array.get",
      "array.size",
      "array.new_float",
      "array.push",
      "array.includes",
      "array.indexof",
      "array.insert",
      "array.join",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-100",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"array.join example\")\na = array.new_float(5, 5)\nlabel.new(bar_index, close, array.join(a, \",\"))\n```\n\n---\n\n## array.last()\n\nReturns the array's last element. Throws a runtime error if the array is empty.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.last example\")\narr = array.new_int(3, 10)\nplot(array.last(arr))\n```\n\n---\n\n## array.lastindexof()\n\nThe function returns the index of the last occurrence of the value, or -1 if the value is not found.\n\n### Returns\nThe index of an element.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.lastindexof example\")\na = array.new_float(5,high)\nindex = array.lastindexof(a, high)\nplot(index)\n```\n\n---\n\n## array.max()\n\nThe function returns the greatest value, or the nth greatest value in a given array.\n\n### Returns\nThe greatest or the nth greatest value in the array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.max\")\na = array.from(5, -2, 0, 9, 1)\nthirdHighest = array.max(a, 2) // 1\nplot(thirdHighest)\n```\n\n---\n\n## array.median()\n\nThe function returns the median of an array's elements.\n\n### Returns\nThe median of the array's elements.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.median example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.median(a))\n```\n\n---\n\n## array.min()\n\nThe function returns the smallest value, or the nth smallest value in a given array.\n\n### Returns\nThe smallest or the nth smallest value in the array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.min\")\na = array.from(5, -2, 0, 9, 1)\nsecondLowest = array.min(a, 1) // 0\nplot(secondLowest)\n```\n\n---\n\n## array.mode()\n\nThe function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value.\n\n### Returns\nThe most frequently occurring value from the id array. If none exists, returns the smallest value instead.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.mode example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.mode(a))\n```\n\n---\n\n## array.new_bool()\n\nThe function creates a new array object of bool type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_bool example\")\nlength = 5\na = array.new_bool(length, close > open)\nplot(array.get(a, 0) ? close : open)\n```\n\n---\n\n## array.new_box()\n\nThe function creates a new array object of box type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_box example\")\nboxes = array.new_box()\narray.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))\nplot(1)\n```\n\n---\n\n## array.new_color()\n\nThe function creates a new array object of color type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.",
    "keywords": [
      "array.join",
      "array.new_float",
      "label.new",
      "array.last",
      "array.new_int",
      "array.lastindexof",
      "array.max",
      "array.from",
      "array.median",
      "array.push",
      "array.min",
      "array.mode",
      "array.new_bool",
      "array.get",
      "array.new_box",
      "box.new",
      "xloc.bar_time",
      "array.new_color",
      "indicator",
      "plot",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-101",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "array.new_string()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"array.new_color example\")\nlength = 5\na = array.new_color(length, color.red)\nplot(close, color = array.get(a, 0))\n```\n\n---\n\n## array.new_float()\n\nThe function creates a new array object of float type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_float example\")\nlength = 5\na = array.new_float(length, close)\nplot(array.sum(a) / length)\n```\n\n---\n\n## array.new_int()\n\nThe function creates a new array object of int type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_int example\")\nlength = 5\na = array.new_int(length, int(close))\nplot(array.sum(a) / length)\n```\n\n---\n\n## array.new_label()\n\nThe function creates a new array object of label type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_label example\", overlay = true, max_labels_count = 500)\n\n//@variable The number of labels to show on the chart.\nint labelCount = input.int(50, \"Labels to show\", 1, 500)\n\n//@variable An array of `label` objects.\nvar array<label> labelArray = array.new_label()\n\n//@variable A `chart.point` for the new label.\nlabelPoint = chart.point.from_index(bar_index, close)\n//@variable The text in the new label.\nstring labelText = na\n//@variable The color of the new label.\ncolor labelColor = na\n//@variable The style of the new label.\nstring labelStyle = na\n\n// Set the label attributes for rising bars.\nif close > open\n    labelText  := \"Rising\"\n    labelColor := color.green\n    labelStyle := label.style_label_down\n// Set the label attributes for falling bars.\nelse if close < open\n    labelText  := \"Falling\"\n    labelColor := color.red\n    labelStyle := label.style_label_up\n\n// Add a new label to the `labelArray` when the chart bar closed at a new value.\nif close != open\n    labelArray.push(label.new(labelPoint, labelText, color = labelColor, style = labelStyle))\n// Remove the first element and delete its label when the size of the `labelArray` exceeds the `labelCount`.\nif labelArray.size() > labelCount\n    label.delete(labelArray.shift())\n```\n\n---\n\n## array.new_line()\n\nThe function creates a new array object of line type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_line example\")\n// draw last 15 lines\nvar a = array.new_line()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n    ln = array.shift(a)\n    line.delete(ln)\n```\n\n---\n\n## array.new_linefill()\n\nThe function creates a new array object of linefill type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n---",
    "keywords": [
      "array.new_color",
      "color.red",
      "array.get",
      "array.new_float",
      "array.sum",
      "array.new_int",
      "array.new_label",
      "input.int",
      "chart.point",
      "color.green",
      "label.style_label_down",
      "label.style_label_up",
      "label.new",
      "label.delete",
      "array.new_line",
      "array.push",
      "line.new",
      "array.size",
      "array.shift",
      "line.delete",
      "array.new_linefill",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-102",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "array.pop()",
    "content": "## array.new_string()\n\nThe function creates a new array object of string type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new_string example\")\nlength = 5\na = array.new_string(length, \"text\")\nlabel.new(bar_index, close, array.get(a, 0))\n```\n\n---\n\n## array.new_table()\n\nThe function creates a new array object of table type elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table array\")\ntables = array.new_table()\narray.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))\nplot(1)\n```\n\n---\n\n## array.new<type>()\n\nThe function creates a new array object of <type> elements.\n\n### Returns\nThe ID of an array object which may be used in other array.*() functions.\n\n### Remarks\nAn array index starts from 0. If you want to initialize an array and specify all its elements at the same time, then use the function array.from.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.new<string> example\")\na = array.new<string>(1, \"Hello, World!\")\nlabel.new(bar_index, close, array.get(a, 0))\n\n//@version=6\nindicator(\"array.new<color> example\")\na = array.new<color>()\narray.push(a, color.red)\narray.push(a, color.green)\nplot(close, color = array.get(a, close > open ? 1 : 0))\n\n//@version=6\nindicator(\"array.new<float> example\")\nlength = 5\nvar a = array.new<float>(length, close)\nif array.size(a) == length\n    array.remove(a, 0)\n    array.push(a, close)\nplot(array.sum(a) / length, \"SMA\")\n\n//@version=6\nindicator(\"array.new<line> example\")\n// draw last 15 lines\nvar a = array.new<line>()\narray.push(a, line.new(bar_index - 1, close[1], bar_index, close))\nif array.size(a) > 15\n    ln = array.shift(a)\n    line.delete(ln)\n```\n\n---\n\n## array.percentile_linear_interpolation()\n\nReturns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation.\n\n### Remarks\nIn statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks.\n\n---\n\n## array.percentile_nearest_rank()\n\nReturns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method.\n\n### Remarks\nIn statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring.\n\n---\n\n## array.percentrank()\n\nReturns the percentile rank of the element at the specified index.\n\n### Remarks\nPercentile rank is the percentage of how many elements in the array are less than or equal to the reference value.\n\n---",
    "keywords": [
      "array.new_string",
      "label.new",
      "array.get",
      "array.new_table",
      "array.push",
      "table.new",
      "position.top_left",
      "color.yellow",
      "array.new",
      "array.from",
      "color.red",
      "color.green",
      "array.size",
      "array.remove",
      "array.sum",
      "line.new",
      "array.shift",
      "line.delete",
      "array.percentile_linear_interpolation",
      "array.percentile_nearest_rank",
      "array.percentrank",
      "indicator",
      "plot",
      "bgcolor",
      "var",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-103",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## array.pop()\n\nThe function removes the last element from an array and returns its value.\n\n### Returns\nThe value of the removed element.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.pop example\")\na = array.new_float(5,high)\nremovedEl = array.pop(a)\nplot(array.size(a))\nplot(removedEl)\n```\n\n---\n\n## array.push()\n\nThe function appends a value to an array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.push example\")\na = array.new_float(5, 0)\narray.push(a, open)\nplot(array.get(a, 5))\n```\n\n---\n\n## array.range()\n\nThe function returns the difference between the min and max values from a given array.\n\n### Returns\nThe difference between the min and max values in the array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.range example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.range(a))\n```\n\n---\n\n## array.remove()\n\nThe function changes the contents of an array by removing the element with the specified index.\n\n### Returns\nThe value of the removed element.\n\n### Remarks\nIf the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is array.size() - 1. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative array.size(). For example, for an array that contains three elements, all of the following are valid arguments for the index parameter: 0, 1, 2, -1, -2, -3.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.remove example\")\na = array.new_float(5,high)\nremovedEl = array.remove(a, 0)\nplot(array.size(a))\nplot(removedEl)\n```\n\n---\n\n## array.reverse()\n\nThe function reverses an array. The first array element becomes the last, and the last array element becomes the first.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.reverse example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.get(a, 0))\narray.reverse(a)\nplot(array.get(a, 0))\n```\n\n---\n\n## array.set()\n\nThe function sets the value of the element at the specified index.\n\n### Remarks\nIf the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is array.size() - 1. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative array.size(). For example, for an array that contains three elements, all of the following are valid arguments for the index parameter: 0, 1, 2, -1, -2, -3.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.set example\")\na = array.new_float(10)\nfor i = 0 to 9\n    array.set(a, i, close[i])\nplot(array.sum(a) / 10)\n```\n\n---\n\n## array.shift()\n\nThe function removes an array's first element and returns its value.\n\n### Returns\nThe value of the removed element.",
    "keywords": [
      "array.pop",
      "array.new_float",
      "array.size",
      "array.push",
      "array.get",
      "array.range",
      "array.remove",
      "array.reverse",
      "array.set",
      "array.sum",
      "array.shift",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-104",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"array.shift example\")\na = array.new_float(5,high)\nremovedEl = array.shift(a)\nplot(array.size(a))\nplot(removedEl)\n```\n\n---\n\n## array.size()\n\nThe function returns the number of elements in an array.\n\n### Returns\nThe number of elements in the array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.size example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\n// note that changes in slice also modify original array\nslice = array.slice(a, 0, 5)\narray.push(slice, open)\n// size was changed in slice and in original array\nplot(array.size(a))\nplot(array.size(slice))\n```\n\n---\n\n## array.slice()\n\nThe function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays.\n\n### Returns\nA shallow copy of an array's slice.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.slice example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\n// take elements from 0 to 4\n// *note that changes in slice also modify original array \nslice = array.slice(a, 0, 5)\nplot(array.sum(a) / 10)\nplot(array.sum(slice) / 5)\n```\n\n---\n\n## array.some()\n\nReturns true if at least one element of the id array is true, false otherwise.\n\n### Remarks\nThis function also works with arrays of int and float types, in which case zero values are considered false, and all others true.\n\n---\n\n## array.sort()\n\nThe function sorts the elements of an array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.sort example\")\na = array.new_float(0,0)\nfor i = 0 to 5\n    array.push(a, high[i])\narray.sort(a, order.descending)\nif barstate.islast\n    label.new(bar_index, close, str.tostring(a))\n```\n\n---\n\n## array.sort_indices()\n\nReturns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.sort_indices\")\na = array.from(5, -2, 0, 9, 1)\nsortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]\nindexOfSmallestValue = array.get(sortedIndices, 0) // 1\nsmallestValue = array.get(a, indexOfSmallestValue) // -2\nplot(smallestValue)\n```\n\n---\n\n## array.standardize()\n\nThe function returns the array of standardized elements.\n\n### Returns\nThe array of standardized elements.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.standardize example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nb = array.standardize(a)\nplot(array.min(b))\nplot(array.max(b))\n```\n\n---\n\n## array.stdev()\n\nThe function returns the standard deviation of an array's elements.\n\n### Returns\nThe standard deviation of the array's elements.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.stdev example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.stdev(a))\n```\n\n---\n\n## array.sum()\n\nThe function returns the sum of an array's elements.\n\n### Returns\nThe sum of the array's elements.",
    "keywords": [
      "array.shift",
      "array.new_float",
      "array.size",
      "array.push",
      "array.slice",
      "array.sum",
      "array.some",
      "array.sort",
      "order.descending",
      "barstate.islast",
      "label.new",
      "str.tostring",
      "array.sort_indices",
      "array.from",
      "array.get",
      "array.standardize",
      "array.min",
      "array.max",
      "array.stdev",
      "indicator",
      "plot",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-105",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"array.sum example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.sum(a))\n```\n\n---\n\n## array.unshift()\n\nThe function inserts the value at the beginning of the array.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.unshift example\")\na = array.new_float(5, 0)\narray.unshift(a, open)\nplot(array.get(a, 0))\n```\n\n---\n\n## array.variance()\n\nThe function returns the variance of an array's elements.\n\n### Returns\nThe variance of the array's elements.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array.variance example\")\na = array.new_float(0)\nfor i = 0 to 9\n    array.push(a, close[i])\nplot(array.variance(a))\n```\n\n---\n\n## barcolor()\n\nSet color of bars.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"barcolor example\", overlay=true)\nbarcolor(close < open ? color.black : color.white)\n```\n\n---\n\n## bgcolor()\n\nFill background of bars with specified color.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"bgcolor example\", overlay=true)\nbgcolor(close < open ? color.new(color.red,70) : color.new(color.green, 70))\n```\n\n---\n\n## bool()\n\nConverts the x value to a bool value. Returns false if x is na, false, or an int/float value equal to 0. Returns true for all other possible values.\n\n### Returns\nThe value of the argument after casting to bool.\n\n---\n\n## box()\n\nCasts na to box.\n\n### Returns\nThe value of the argument after casting to box.\n\n---\n\n## box.copy()\n\nClones the box object.\n\n### Code Example\n```pine\n//@version=6\nindicator('Last 50 bars price ranges', overlay = true)\nLOOKBACK = 50\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n    var BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))\n    var BoxPrev = box.copy(BoxLast)\n    box.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])\n    box.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])\n    box.set_bgcolor(BoxPrev, color.new(color.red, 80))\n```\n\n---\n\n## box.delete()\n\nDeletes the specified box object. If it has already been deleted, does nothing.\n\n---\n\n## box.get_bottom()\n\nReturns the price value of the bottom border of the box.\n\n### Returns\nThe price value.\n\n---\n\n## box.get_left()\n\nReturns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box.\n\n### Returns\nA bar index or a UNIX timestamp (in milliseconds).\n\n---\n\n## box.get_right()\n\nReturns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box.\n\n### Returns\nA bar index or a UNIX timestamp (in milliseconds).\n\n---\n\n## box.get_top()\n\nReturns the price value of the top border of the box.\n\n### Returns\nThe price value.\n\n---\n\n## box.new()\n\nCreates a new box object.\n\n### Returns\nThe ID of a box object which may be used in box.set_*() and box.get_*() functions.",
    "keywords": [
      "array.sum",
      "array.new_float",
      "array.push",
      "array.unshift",
      "array.get",
      "array.variance",
      "color.black",
      "color.white",
      "color.new",
      "color.red",
      "color.green",
      "box.copy",
      "ta.highest",
      "ta.lowest",
      "barstate.islastconfirmedhistory",
      "box.new",
      "box.set_lefttop",
      "box.set_rightbottom",
      "box.set_bgcolor",
      "box.delete",
      "box.get_bottom",
      "box.get_left",
      "box.get_right",
      "box.get_top",
      "box.set_",
      "box.get_",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "barcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-106",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"box.new\")\nvar b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\nbox.set_lefttop(b, time, 100)\nbox.set_rightbottom(b, time + 60 * 60 * 24, 500)\nbox.set_bgcolor(b, color.green)\n```\n\n---\n\n## box.set_bgcolor()\n\nSets the background color of the box.\n\n---\n\n## box.set_border_color()\n\nSets the border color of the box.\n\n---\n\n## box.set_border_style()\n\nSets the border style of the box.\n\n---\n\n## box.set_border_width()\n\nSets the border width of the box.\n\n---\n\n## box.set_bottom()\n\nSets the bottom coordinate of the box.\n\n---\n\n## box.set_bottom_right_point()\n\nSets the bottom-right corner location of the id box to point.\n\n---\n\n## box.set_extend()\n\nSets extending type of the border of this box object. When extend.none is used, the horizontal borders start at the left border and end at the right border. With extend.left or extend.right, the horizontal borders are extended indefinitely to the left or right of the box, respectively. With extend.both, the horizontal borders are extended on both sides.\n\n---\n\n## box.set_left()\n\nSets the left coordinate of the box.\n\n---\n\n## box.set_lefttop()\n\nSets the left and top coordinates of the box.\n\n---\n\n## box.set_right()\n\nSets the right coordinate of the box.\n\n---\n\n## box.set_rightbottom()\n\nSets the right and bottom coordinates of the box.\n\n---\n\n## box.set_text()\n\nThe function sets the text in the box.\n\n---\n\n## box.set_text_color()\n\nThe function sets the color of the text inside the box.\n\n---\n\n## box.set_text_font_family()\n\nThe function sets the font family of the text inside the box.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Example of setting the box font\")\nif barstate.islastconfirmedhistory\n    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")\n    box.set_text_font_family(b, font.family_monospace)\n```\n\n---\n\n## box.set_text_formatting()\n\nSets the formatting attributes the drawing applies to displayed text.\n\n---\n\n## box.set_text_halign()\n\nThe function sets the horizontal alignment of the box's text.\n\n---\n\n## box.set_text_size()\n\nThe function sets the size of the box's text.\n\n---\n\n## box.set_text_valign()\n\nThe function sets the vertical alignment of a box's text.\n\n---\n\n## box.set_text_wrap()\n\nThe function sets the mode of wrapping of the text inside the box.\n\n---\n\n## box.set_top()\n\nSets the top coordinate of the box.\n\n---\n\n## box.set_top_left_point()\n\nSets the top-left corner location of the id box to point.\n\n---\n\n## box.set_xloc()\n\nSets the left and right borders of a box and updates its xloc property.\n\n---\n\n## chart.point.copy()\n\nCreates a copy of a chart.point object with the specified id.\n\n---\n\n## chart.point.from_index()\n\nReturns a chart.point object with index as its x-coordinate and price as its y-coordinate.\n\n### Remarks\nThe time field values of chart.point instances returned from this function will be na, meaning drawing objects with xloc values set to xloc.bar_time will not work with them.\n\n---\n\n## chart.point.from_time()\n\nReturns a chart.point object with time as its x-coordinate and price as its y-coordinate.",
    "keywords": [
      "box.new",
      "xloc.bar_time",
      "line.style_dashed",
      "box.set_lefttop",
      "box.set_rightbottom",
      "box.set_bgcolor",
      "color.green",
      "box.set_border_color",
      "box.set_border_style",
      "box.set_border_width",
      "box.set_bottom",
      "box.set_bottom_right_point",
      "box.set_extend",
      "extend.none",
      "extend.left",
      "extend.right",
      "extend.both",
      "box.set_left",
      "box.set_right",
      "box.set_text",
      "box.set_text_color",
      "box.set_text_font_family",
      "barstate.islastconfirmedhistory",
      "ta.tr",
      "font.family_monospace",
      "box.set_text_formatting",
      "box.set_text_halign",
      "box.set_text_size",
      "box.set_text_valign",
      "box.set_text_wrap",
      "box.set_top",
      "box.set_top_left_point",
      "box.set_xloc",
      "chart.point",
      "indicator",
      "bgcolor",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-107",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Remarks\nThe index field values of chart.point instances returned from this function will be na, meaning drawing objects with xloc values set to xloc.bar_index will not work with them.\n\n---\n\n## chart.point.new()\n\nCreates a new chart.point object with the specified time, index, and price.\n\n### Remarks\nWhether a drawing object uses a point's time or index field as an x-coordinate depends on the xloc type used in the function call that returned the drawing. It's important to note that this function does not verify that the time and index values refer to the same bar.\n\n---\n\n## chart.point.now()\n\nReturns a chart.point object with price as the y-coordinate\n\n### Remarks\nThe chart.point instance returned from this function records values for its index and time fields on the bar it executed on, making it suitable for use with drawing objects of any xloc type.\n\n---\n\n## color()\n\nCasts na to color\n\n### Returns\nThe value of the argument after casting to color.\n\n---\n\n## color.b()\n\nRetrieves the value of the color's blue component.\n\n### Returns\nThe value (0 to 255) of the color's blue component.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.b\", overlay=true)\nplot(color.b(color.blue))\n```\n\n---\n\n## color.from_gradient()\n\nBased on the relative position of value in the bottom_value to top_value range, the function returns a color from the gradient defined by bottom_color to top_color.\n\n### Returns\nA color calculated from the linear gradient between bottom_color to top_color.\n\n### Remarks\nUsing this function will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the User Manual for more information.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.from_gradient\", overlay=true)\ncolor1 = color.from_gradient(close, low, high, color.yellow, color.lime)\ncolor2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))\nplot(close, color=color1)\nplot(ta.rsi(close,7), color=color2)\n```\n\n---\n\n## color.g()\n\nRetrieves the value of the color's green component.\n\n### Returns\nThe value (0 to 255) of the color's green component.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.g\", overlay=true)\nplot(color.g(color.green))\n```\n\n---\n\n## color.new()\n\nFunction color applies the specified transparency to the given color.\n\n### Returns\nColor with specified transparency.\n\n### Remarks\nUsing arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the User Manual for more information.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.new\", overlay=true)\nplot(close, color=color.new(color.red, 50))\n```\n\n---\n\n## color.r()\n\nRetrieves the value of the color's red component.\n\n### Returns\nThe value (0 to 255) of the color's red component.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.r\", overlay=true)\nplot(color.r(color.red))\n```\n\n---\n\n## color.rgb()\n\nCreates a new color with transparency using the RGB color model.\n\n### Returns\nColor with specified transparency.",
    "keywords": [
      "chart.point",
      "xloc.bar_index",
      "color.b",
      "color.blue",
      "color.from_gradient",
      "color.yellow",
      "color.lime",
      "ta.rsi",
      "color.rgb",
      "color.g",
      "color.green",
      "color.new",
      "e.g",
      "color.red",
      "color.r",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "const",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-108",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "indicator()",
    "content": "### Remarks\nUsing arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the User Manual for more information.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.rgb\", overlay=true)\nplot(close, color=color.rgb(255, 0, 0, 50))\n```\n\n---\n\n## color.t()\n\nRetrieves the color's transparency.\n\n### Returns\nThe value (0-100) of the color's transparency.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color.t\", overlay=true)\nplot(color.t(color.new(color.red, 50)))\n```\n\n---\n\n## dayofmonth()\n\n### Returns\nDay of month (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day.\n\n---\n\n## dayofweek()\n\n### Returns\nDay of week (in exchange timezone) for provided UNIX time.\n\n### Remarks\nNote that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day. UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n---\n\n## fill()\n\nFills background between two plots or hlines with a given color.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Fill between hlines\", overlay = false)\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color = color.new(color.blue, 90))\n\n//@version=6\nindicator(\"Fill between plots\", overlay = true)\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color = color.new(color.green, 90))\n\n//@version=6\nindicator(\"Gradient Fill between hlines\", overlay = false)\ntopVal = input.int(100)\nbotVal = input.int(0)\ntopCol = input.color(color.red)\nbotCol = input.color(color.blue)\ntopLine = hline(100, color = topCol, linestyle = hline.style_solid)\nbotLine = hline(0,   color = botCol, linestyle = hline.style_solid)\nfill(topLine, botLine, topVal, botVal, topCol, botCol)\n```\n\n---\n\n## fixnan()\n\nFor a given series replaces NaN values with previous nearest non-NaN value.\n\n### Returns\nSeries without na gaps.\n\n---\n\n## float()\n\nCasts na to float\n\n### Returns\nThe value of the argument after casting to float.\n\n---\n\n## hline()\n\nRenders a horizontal line at a given fixed price level.\n\n### Returns\nAn hline object, that can be used in fill\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.hline\", overlay=true)\nhline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)\n\n// You may fill the background between any two hlines with a fill() function:\nh1 = hline(20)\nh2 = hline(10)\nfill(h1, h2, color=color.new(color.green, 90))\n```\n\n---\n\n## hour()\n\n### Returns\nHour (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n---",
    "keywords": [
      "e.g",
      "color.rgb",
      "color.t",
      "color.new",
      "color.red",
      "color.blue",
      "color.green",
      "input.int",
      "input.color",
      "hline.style_solid",
      "input.hline",
      "hline.style_dotted",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "fill",
      "series",
      "simple",
      "const",
      "for"
    ]
  },
  {
    "id": "doc-109",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## indicator()\n\nThis declaration statement designates the script as an indicator and sets a number of indicator-related properties.\n\n### Remarks\nEvery indicator script must have one indicator call.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"My script\", shorttitle=\"Script\")\nplot(close)\n```\n\n---\n\n## input()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input\", overlay=true)\ni_switch = input(true, \"On/Off\")\nplot(i_switch ? open : na)\n\ni_len = input(7, \"Length\")\ni_src = input(close, \"Source\")\nplot(ta.sma(i_src, i_len))\n\ni_border = input(142.50, \"Price Border\")\nhline(i_border)\nbgcolor(close > i_border ? color.green : color.red)\n\ni_col = input(color.red, \"Plot Color\")\nplot(close, color=i_col)\n\ni_text = input(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, text=i_text)\nlabel.delete(l[1])\n```\n\n---\n\n## input.bool()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a checkmark to the script's inputs.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.bool function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.bool\", overlay=true)\ni_switch = input.bool(true, \"On/Off\")\nplot(i_switch ? open : na)\n```\n\n---\n\n## input.color()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a color picker that allows the user to select a color and transparency, either from a palette or a hex value.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.color function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.color\", overlay=true)\ni_col = input.color(color.red, \"Plot Color\")\nplot(close, color=i_col)\n```\n\n---\n\n## input.enum()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown with options based on the enum fields passed to its defval and options parameters.\n\n### Returns\nValue of input variable.\n\n### Remarks\nAll fields included in the defval and options arguments must belong to the same enum.",
    "keywords": [
      "ta.sma",
      "color.green",
      "color.red",
      "label.new",
      "label.delete",
      "input.bool",
      "input.color",
      "input.enum",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "bgcolor",
      "var",
      "type",
      "switch",
      "for"
    ]
  },
  {
    "id": "doc-110",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "input.session()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum        Contains fields with popular timezones as titles.\n//@field exch  Has an empty string as the title to represent the chart timezone.\nenum tz\n    utc  = \"UTC\"\n    exch = \"\"\n    ny   = \"America/New_York\"\n    chi  = \"America/Chicago\"\n    lon  = \"Europe/London\"\n    tok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n    inSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")\n```\n\n---\n\n## input.float()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a float input to the script's inputs.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.float function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.float\", overlay=true)\ni_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)\nplot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)\n\ni_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])\nplot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)\n```\n\n---\n\n## input.int()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for an integer input to the script's inputs.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.int function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.int\", overlay=true)\ni_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)\nplot(ta.sma(close, i_len1))\n\ni_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])\nplot(ta.sma(close, i_len2))\n```\n\n---\n\n## input.price()\n\nAdds a price input to the script's \"Settings/Inputs\" tab. Using confirm = true activates the interactive input mode where a price is selected by clicking on the chart.\n\n### Returns\nValue of input variable.\n\n### Remarks\nWhen using interactive mode, a time input can be combined with a price input if both function calls use the same argument for their inline parameter.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.price\", overlay=true)\nprice1 = input.price(title=\"Date\", defval=42)\nplot(price1)\n\nprice2 = input.price(54, title=\"Date\")\nplot(price2)\n```\n\n---",
    "keywords": [
      "input.session",
      "input.enum",
      "tz.utc",
      "str.tostring",
      "color.new",
      "color.green",
      "input.float",
      "math.sin",
      "math.cos",
      "color.red",
      "input.int",
      "ta.sma",
      "input.price",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-111",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "input.time()",
    "content": "## input.session()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds two dropdowns that allow the user to specify the beginning and the end of a session using the session selector and returns the result as a string.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.session function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.session\", overlay=true)\ni_sess = input.session(\"1300-1700\", \"Session\", options=[\"0930-1600\", \"1300-1700\", \"1700-2100\"])\nt = time(timeframe.period, i_sess)\nbgcolor(time == t ? color.green : na)\n```\n\n---\n\n## input.source()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a source for the calculation, e.g. close, hl2, etc. The user can also select an output from another indicator on their chart as the source.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.source function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.source\", overlay=true)\ni_src = input.source(close, \"Source\")\nplot(i_src)\n```\n\n---\n\n## input.string()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a string input to the script's inputs.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.string function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.string\", overlay=true)\ni_text = input.string(\"Hello!\", \"Message\")\nl = label.new(bar_index, high, i_text)\nlabel.delete(l[1])\n```\n\n---\n\n## input.symbol()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field that allows the user to select a specific symbol using the symbol search and returns that symbol, paired with its exchange prefix, as a string.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.symbol function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.symbol\", overlay=true)\ni_sym = input.symbol(\"DELL\", \"Symbol\")\ns = request.security(i_sym, 'D', close)\nplot(s)\n```\n\n---\n\n## input.text_area()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a multiline text input.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.text_area function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.text_area\")\ni_text = input.text_area(defval = \"Hello \\nWorld!\", title = \"Message\")\nplot(close)\n```\n\n---",
    "keywords": [
      "input.session",
      "timeframe.period",
      "color.green",
      "input.source",
      "e.g",
      "input.string",
      "label.new",
      "label.delete",
      "input.symbol",
      "request.security",
      "input.text_area",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-112",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## input.time()\n\nAdds a time input to the script's \"Settings/Inputs\" tab. This function adds two input widgets on the same line: one for the date and one for the time. The function returns a date/time value in UNIX format. Using confirm = true activates the interactive input mode where a point in time is selected by clicking on the chart.\n\n### Returns\nValue of input variable.\n\n### Remarks\nWhen using interactive mode, a price input can be combined with a time input if both function calls use the same argument for their inline parameter.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.time\", overlay=true)\ni_date = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"Date\")\nl = label.new(i_date, high, \"Date\", xloc=xloc.bar_time)\nlabel.delete(l[1])\n```\n\n---\n\n## input.timeframe()\n\nAdds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a specific timeframe via the timeframe selector and returns it as a string. The selector includes the custom timeframes a user may have added using the chart's Timeframe dropdown.\n\n### Returns\nValue of input variable.\n\n### Remarks\nResult of input.timeframe function always should be assigned to a variable, see examples above.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"input.timeframe\", overlay=true)\ni_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])\ns = request.security(\"AAPL\", i_res, close)\nplot(s)\n```\n\n---\n\n## int()\n\nCasts na or truncates float value to int\n\n### Returns\nThe value of the argument after casting to int.\n\n---\n\n## label()\n\nCasts na to label\n\n### Returns\nThe value of the argument after casting to label.\n\n---\n\n## label.copy()\n\nClones the label object.\n\n### Returns\nNew label ID object which may be passed to label.setXXX and label.getXXX functions.\n\n### Code Example\n```pine\n//@version=6\nindicator('Last 100 bars highest/lowest', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nhighestBars = ta.highestbars(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nlowestBars = ta.lowestbars(LOOKBACK)\nif barstate.islastconfirmedhistory\n    var labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)\n    var labelLow = label.copy(labelHigh)\n    label.set_xy(labelLow, bar_index + lowestBars, lowest)\n    label.set_text(labelLow, str.tostring(lowest))\n    label.set_color(labelLow, color.red)\n    label.set_style(labelLow, label.style_label_up)\n```\n\n---\n\n## label.delete()\n\nDeletes the specified label object. If it has already been deleted, does nothing.\n\n---\n\n## label.get_text()\n\nReturns the text of this label object.\n\n### Returns\nString object containing the text of this label.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"label.get_text\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_text(my_label)\nlabel.new(time, close, text = a + \" new\", xloc=xloc.bar_time)\n```\n\n---\n\n## label.get_x()\n\nReturns UNIX time or bar index (depending on the last xloc value set) of this label's position.\n\n### Returns\nUNIX timestamp (in milliseconds) or bar index.",
    "keywords": [
      "input.time",
      "label.new",
      "xloc.bar_time",
      "label.delete",
      "input.timeframe",
      "request.security",
      "label.copy",
      "label.set",
      "label.get",
      "ta.highest",
      "ta.highestbars",
      "ta.lowest",
      "ta.lowestbars",
      "barstate.islastconfirmedhistory",
      "str.tostring",
      "color.green",
      "label.set_xy",
      "label.set_text",
      "label.set_color",
      "color.red",
      "label.set_style",
      "label.style_label_up",
      "label.get_text",
      "label.get_x",
      "label.setXXX",
      "label.getXXX",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-113",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "line.delete()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"label.get_x\")\nmy_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)\na = label.get_x(my_label)\nplot(time - label.get_x(my_label)) //draws zero plot\n```\n\n---\n\n## label.get_y()\n\nReturns price of this label's position.\n\n### Returns\nFloating point value representing price.\n\n---\n\n## label.new()\n\nCreates new label object.\n\n### Returns\nLabel ID object which may be passed to label.setXXX and label.getXXX functions.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"label.new\")\nvar label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)\nlabel.set_x(label1, 0)\nlabel.set_xloc(label1, time, xloc.bar_time)\nlabel.set_color(label1, color.red)\nlabel.set_size(label1, size.large)\n```\n\n---\n\n## label.set_color()\n\nSets label border and arrow color.\n\n---\n\n## label.set_point()\n\nSets the location of the id label to point.\n\n---\n\n## label.set_size()\n\nSets arrow and text size of the specified label object.\n\n---\n\n## label.set_style()\n\nSets label style.\n\n---\n\n## label.set_text()\n\nSets label text\n\n---\n\n## label.set_text_font_family()\n\nThe function sets the font family of the text inside the label.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Example of setting the label font\")\nif barstate.islastconfirmedhistory\n    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)\n    label.set_text_font_family(l, font.family_monospace)\n```\n\n---\n\n## label.set_text_formatting()\n\nSets the formatting attributes the drawing applies to displayed text.\n\n---\n\n## label.set_textalign()\n\nSets the alignment for the label text.\n\n---\n\n## label.set_textcolor()\n\nSets color of the label text.\n\n---\n\n## label.set_tooltip()\n\nSets the tooltip text.\n\n---\n\n## label.set_x()\n\nSets bar index or bar time (depending on the xloc) of the label position.\n\n---\n\n## label.set_xloc()\n\nSets x-location and new bar index/time value.\n\n---\n\n## label.set_xy()\n\nSets bar index/time and price of the label position.\n\n---\n\n## label.set_y()\n\nSets price of the label position\n\n---\n\n## label.set_yloc()\n\nSets new y-location calculation algorithm.\n\n---\n\n## library()\n\nDeclaration statement identifying a script as a library.\n\n### Code Example\n```pine\n//@version=6\n// @description Math library\nlibrary(\"num_methods\", overlay = true)\n// Calculate \"sinh()\" from the float parameter `x`\nexport sinh(float x) =>\n    (math.exp(x) - math.exp(-x)) / 2.0\nplot(sinh(0))\n```\n\n---\n\n## line()\n\nCasts na to line\n\n### Returns\nThe value of the argument after casting to line.\n\n---\n\n## line.copy()\n\nClones the line object.\n\n### Returns\nNew line ID object which may be passed to line.setXXX and line.getXXX functions.\n\n### Code Example\n```pine\n//@version=6\nindicator('Last 100 bars price range', overlay = true)\nLOOKBACK = 100\nhighest = ta.highest(LOOKBACK)\nlowest = ta.lowest(LOOKBACK)\nif barstate.islastconfirmedhistory\n    var lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)\n    var lineBottom = line.copy(lineTop)\n    line.set_y1(lineBottom, lowest)\n    line.set_y2(lineBottom, lowest)\n    line.set_color(lineBottom, color.red)\n```\n\n---",
    "keywords": [
      "label.get_x",
      "label.new",
      "xloc.bar_time",
      "label.get_y",
      "label.set",
      "label.get",
      "label.style_circle",
      "label.set_x",
      "label.set_xloc",
      "label.set_color",
      "color.red",
      "label.set_size",
      "size.large",
      "label.set_point",
      "label.set_style",
      "label.set_text",
      "label.set_text_font_family",
      "barstate.islastconfirmedhistory",
      "yloc.abovebar",
      "font.family_monospace",
      "label.set_text_formatting",
      "label.set_textalign",
      "label.set_textcolor",
      "label.set_tooltip",
      "label.set_xy",
      "label.set_y",
      "label.set_yloc",
      "math.exp",
      "line.copy",
      "line.set",
      "line.get",
      "ta.highest",
      "ta.lowest",
      "line.new",
      "color.green",
      "line.set_y",
      "line.set_color",
      "label.setXXX",
      "label.getXXX",
      "line.setXXX",
      "line.getXXX",
      "line.set_y1",
      "line.set_y2",
      "indicator",
      "overlay",
      "plot",
      "var",
      "export",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-114",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "line.set_y2()",
    "content": "## line.delete()\n\nDeletes the specified line object. If it has already been deleted, does nothing.\n\n---\n\n## line.get_price()\n\nReturns the price level of a line at a given bar index.\n\n### Returns\nPrice value of line 'id' at bar index 'x'.\n\n### Remarks\nThe line is considered to have been created using 'extend=extend.both'. This function can only be called for lines created using 'xloc.bar_index'. If you try to call it for a line created with 'xloc.bar_time', it will generate an error.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"GetPrice\", overlay=true)\nvar line l = na\nif bar_index == 10\n    l := line.new(0, high[5], bar_index, high)\nplot(line.get_price(l, bar_index), color=color.green)\n```\n\n---\n\n## line.get_x1()\n\nReturns UNIX time or bar index (depending on the last xloc value set) of the first point of the line.\n\n### Returns\nUNIX timestamp (in milliseconds) or bar index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line.get_x1\")\nmy_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\na = line.get_x1(my_line)\nplot(time - line.get_x1(my_line)) //draws zero plot\n```\n\n---\n\n## line.get_x2()\n\nReturns UNIX time or bar index (depending on the last xloc value set) of the second point of the line.\n\n### Returns\nUNIX timestamp (in milliseconds) or bar index.\n\n---\n\n## line.get_y1()\n\nReturns price of the first point of the line.\n\n### Returns\nPrice value.\n\n---\n\n## line.get_y2()\n\nReturns price of the second point of the line.\n\n### Returns\nPrice value.\n\n---\n\n## line.new()\n\nCreates new line object.\n\n### Returns\nLine ID object which may be passed to line.setXXX and line.getXXX functions.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line.new\")\nvar line1 = line.new(0, low, bar_index, high, extend=extend.right)\nvar line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)\nline.set_x2(line1, 0)\nline.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)\nline.set_color(line2, color.green)\nline.set_width(line2, 5)\n```\n\n---\n\n## line.set_color()\n\nSets the line color\n\n---\n\n## line.set_extend()\n\nSets extending type of this line object. If extend=extend.none, draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to extend.right or extend.left, draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend=extend.both, draws a straight line that goes through these points.\n\n---\n\n## line.set_first_point()\n\nSets the first point of the id line to point.\n\n---\n\n## line.set_second_point()\n\nSets the second point of the id line to point.\n\n---\n\n## line.set_style()\n\nSets the line style\n\n---\n\n## line.set_width()\n\nSets the line width.\n\n---\n\n## line.set_x1()\n\nSets bar index or bar time (depending on the xloc) of the first point.\n\n---\n\n## line.set_x2()\n\nSets bar index or bar time (depending on the xloc) of the second point.\n\n---\n\n## line.set_xloc()\n\nSets x-location and new bar index/time values.\n\n---\n\n## line.set_xy1()\n\nSets bar index/time and price of the first point.\n\n---\n\n## line.set_xy2()\n\nSets bar index/time and price of the second point\n\n---\n\n## line.set_y1()\n\nSets price of the first point\n\n---",
    "keywords": [
      "line.delete",
      "line.get_price",
      "extend.both",
      "xloc.bar_index",
      "xloc.bar_time",
      "line.new",
      "color.green",
      "line.get_x",
      "line.get_y",
      "line.set",
      "line.get",
      "extend.right",
      "line.style_dashed",
      "line.set_x",
      "line.set_xloc",
      "line.set_color",
      "line.set_width",
      "line.set_extend",
      "extend.none",
      "extend.left",
      "line.set_first_point",
      "line.set_second_point",
      "line.set_style",
      "line.set_xy",
      "line.set_y",
      "line.get_x1",
      "line.get_x2",
      "line.get_y1",
      "line.get_y2",
      "line.setXXX",
      "line.getXXX",
      "line.set_x2",
      "line.set_x1",
      "line.set_xy1",
      "line.set_xy2",
      "line.set_y1",
      "indicator",
      "overlay",
      "plot",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-115",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "log.info()",
    "content": "## line.set_y2()\n\nSets price of the second point.\n\n---\n\n## linefill()\n\nCasts na to linefill.\n\n### Returns\nThe value of the argument after casting to linefill.\n\n---\n\n## linefill.delete()\n\nDeletes the specified linefill object. If it has already been deleted, does nothing.\n\n---\n\n## linefill.get_line1()\n\nReturns the ID of the first line used in the id linefill.\n\n---\n\n## linefill.get_line2()\n\nReturns the ID of the second line used in the id linefill.\n\n---\n\n## linefill.new()\n\nCreates a new linefill object and displays it on the chart, filling the space between line1 and line2 with the color specified in color.\n\n### Returns\nThe ID of a linefill object that can be passed to other linefill.*() functions.\n\n### Remarks\nIf any line of the two is deleted, the linefill object is also deleted. If the lines are moved (e.g. via line.set_xy functions), the linefill object is also moved. If both lines are extended in the same direction relative to the lines themselves (e.g. both have extend.right as the value of their extend= parameter), the space between line extensions will also be filled.\n\n---\n\n## linefill.set_color()\n\nThe function sets the color of the linefill object passed to it.\n\n---\n\n## log.error()\n\nConverts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"error\" debug level.\n\n### Returns\nThe formatted string.\n\n### Remarks\nAny curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.  The function can apply additional formatting to some values inside of the {}. The list of additional formatting options can be found in the EXAMPLE section of the str.format article.  The string used as the formatString argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.  The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses log.*() functions.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    limitLevel = close * 1.01\n    log.info(\"Long limit order has been placed at {0}\", limitLevel)\n    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n    log.error(\"The strategy has lost 90% of the initial capital!\")\n```\n\n---",
    "keywords": [
      "line.set_y",
      "linefill.delete",
      "linefill.get_line",
      "linefill.new",
      "e.g",
      "line.set_xy",
      "extend.right",
      "linefill.set_color",
      "log.error",
      "str.format",
      "input.int",
      "ta.crossover",
      "ta.sma",
      "log.info",
      "strategy.order",
      "strategy.long",
      "strategy.exit",
      "strategy.opentrades",
      "log.warning",
      "strategy.initial_capital",
      "strategy.equity",
      "line.set_y2",
      "strategy",
      "overlay",
      "input",
      "fill",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-116",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## log.info()\n\nConverts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"info\" debug level.\n\n### Returns\nThe formatted string.\n\n### Remarks\nAny curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.  The function can apply additional formatting to some values inside of the {}. The list of additional formatting options can be found in the EXAMPLE section of the str.format article.  The string used as the formatString argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.  The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses log.*() functions.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    limitLevel = close * 1.01\n    log.info(\"Long limit order has been placed at {0}\", limitLevel)\n    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n    log.error(\"The strategy has lost 90% of the initial capital!\")\n```\n\n---\n\n## log.warning()\n\nConverts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"warning\" debug level.\n\n### Returns\nThe formatted string.\n\n### Remarks\nAny curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.  The function can apply additional formatting to some values inside of the {}. The list of additional formatting options can be found in the EXAMPLE section of the str.format article.  The string used as the formatString argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.  The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses log.*() functions.",
    "keywords": [
      "log.info",
      "str.format",
      "input.int",
      "ta.crossover",
      "ta.sma",
      "strategy.order",
      "strategy.long",
      "strategy.exit",
      "strategy.opentrades",
      "log.warning",
      "strategy.initial_capital",
      "strategy.equity",
      "log.error",
      "strategy",
      "overlay",
      "input",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-117",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"My strategy\", overlay = true, process_orders_on_close = true)\nbracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    limitLevel = close * 1.01\n    log.info(\"Long limit order has been placed at {0}\", limitLevel)\n    strategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)\n\n    log.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)\n    strategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)\n\nif strategy.opentrades > 10\n    log.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)\n\nlast10Perc = strategy.initial_capital / 10 > strategy.equity\nif (last10Perc and not last10Perc[1])\n    log.error(\"The strategy has lost 90% of the initial capital!\")\n```\n\n---\n\n## map.clear()\n\nClears the map, removing all key-value pairs from it.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.clear example\")\noddMap = map.new<int, bool>()\noddMap.put(1, true)\noddMap.put(2, false)\noddMap.put(3, true)\nmap.clear(oddMap)\nplot(oddMap.size())\n```\n\n---\n\n## map.contains()\n\nReturns true if the key was found in the id map, false otherwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.includes example\")\na = map.new<string, float>()\na.put(\"open\", open)\np = close\nif map.contains(a, \"open\")\n    p := a.get(\"open\")\nplot(p)\n```\n\n---\n\n## map.copy()\n\nCreates a copy of an existing map.\n\n### Returns\nA copy of the id map.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.copy example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nb = map.copy(a)\na := map.new<string, int>()\na.put(\"example\", 2)\nplot(a.get(\"example\"))\nplot(b.get(\"example\"))\n```\n\n---\n\n## map.get()\n\nReturns the value associated with the specified key in the id map.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.get example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n    a.put(i, size-i)\nplot(map.get(a, 1))\n```\n\n---\n\n## map.keys()\n\nReturns an array of all the keys in the id map. The resulting array is a copy and any changes to it are not reflected in the original map.\n\n### Remarks\nMaps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.keys example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nkeys = map.keys(a)\nohlc = 0.0\nfor key in keys\n    ohlc += a.get(key)\nplot(ohlc/4)\n```\n\n---\n\n## map.new<type,type>()\n\nCreates a new map object: a collection that consists of key-value pairs, where all keys are of the keyType, and all values are of the valueType.\n\n### Returns\nThe ID of a map object which may be used in other map.*() functions.",
    "keywords": [
      "input.int",
      "ta.crossover",
      "ta.sma",
      "log.info",
      "strategy.order",
      "strategy.long",
      "strategy.exit",
      "strategy.opentrades",
      "log.warning",
      "strategy.initial_capital",
      "strategy.equity",
      "log.error",
      "map.clear",
      "map.new",
      "map.contains",
      "map.includes",
      "a.put",
      "a.get",
      "map.copy",
      "b.get",
      "map.get",
      "map.keys",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-118",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "math.asin()",
    "content": "### Remarks\nEach key is unique and can only appear once. When adding a new value with a key that the map already contains, that value replaces the old value associated with the key. Maps maintain insertion order. Note that the order does not change when inserting a pair with a key that's already in the map. The new pair replaces the existing pair with the key in such cases.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.new<string, int> example\")\na = map.new<string, int>()\na.put(\"example\", 1)\nlabel.new(bar_index, close, str.tostring(a.get(\"example\")))\n```\n\n---\n\n## map.put()\n\nPuts a new key-value pair into the id map.\n\n### Returns\nThe previous value associated with key if the key was already present in the map, or na if the key is new.\n\n### Remarks\nMaps maintain insertion order. Note that the order does not change when inserting a pair with a key that's already in the map. The new pair replaces the existing pair with the key in such cases.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.put example\")\na = map.new<string, float>()\nmap.put(a, \"first\", 10)\nmap.put(a, \"second\", 15)\nprevFirst = map.put(a, \"first\", 20)\ncurrFirst = a.get(\"first\")\nplot(prevFirst)\nplot(currFirst)\n```\n\n---\n\n## map.put_all()\n\nPuts all key-value pairs from the id2 map into the id map.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.put_all example\")\na = map.new<string, float>()\nb = map.new<string, float>()\na.put(\"first\", 10)\na.put(\"second\", 15)\nb.put(\"third\", 20)\nmap.put_all(a, b)\nplot(a.get(\"third\"))\n```\n\n---\n\n## map.remove()\n\nRemoves a key-value pair from the id map.\n\n### Returns\nThe previous value associated with key if the key was present in the map, or na if there was no such key.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.remove example\")\na = map.new<string, color>()\na.put(\"firstColor\", color.green)\noldColorValue = map.remove(a, \"firstColor\")\nplot(close, color = oldColorValue)\n```\n\n---\n\n## map.size()\n\nReturns the number of key-value pairs in the id map.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.size example\")\na = map.new<int, int>()\nsize = 10\nfor i = 0 to size\n    a.put(i, size-i)\nplot(map.size(a))\n```\n\n---\n\n## map.values()\n\nReturns an array of all the values in the id map. The resulting array is a copy and any changes to it are not reflected in the original map.\n\n### Remarks\nMaps maintain insertion order. The elements within the array returned by this function will also be in the insertion order.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map.values example\")\na = map.new<string, float>()\na.put(\"open\", open)\na.put(\"high\", high)\na.put(\"low\", low)\na.put(\"close\", close)\nvalues = map.values(a)\nohlc = 0.0\nfor value in values\n    ohlc += value\nplot(ohlc/4)\n```\n\n---\n\n## math.abs()\n\nAbsolute value of number is number if number >= 0, or -number otherwise.\n\n### Returns\nThe absolute value of number.\n\n---\n\n## math.acos()\n\nThe acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1].\n\n### Returns\nThe arc cosine of a value; the returned angle is in the range [0, Pi], or na if y is outside of range [-1, 1].\n\n---",
    "keywords": [
      "map.new",
      "a.put",
      "label.new",
      "str.tostring",
      "a.get",
      "map.put",
      "map.put_all",
      "b.put",
      "map.remove",
      "color.green",
      "map.size",
      "map.values",
      "math.abs",
      "math.acos",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-119",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "math.round_to_mintick()",
    "content": "## math.asin()\n\nThe asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1].\n\n### Returns\nThe arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or na if y is outside of range [-1, 1].\n\n---\n\n## math.atan()\n\nThe atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y.\n\n### Returns\nThe arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2].\n\n---\n\n## math.avg()\n\nCalculates average of all given series (elementwise).\n\n### Returns\nAverage.\n\n---\n\n## math.ceil()\n\nRounds the specified number up to the smallest whole number (\"int\" value) that is greater than or equal to it.\n\n### Returns\nThe smallest \"int\" value that is greater than or equal to the number.\n\n---\n\n## math.cos()\n\nThe cos function returns the trigonometric cosine of an angle.\n\n### Returns\nThe trigonometric cosine of an angle.\n\n---\n\n## math.exp()\n\nThe exp function of number is e raised to the power of number, where e is Euler's number.\n\n### Returns\nA value representing e raised to the power of number.\n\n---\n\n## math.floor()\n\nRounds the specified number down to the largest whole number (\"int\" value) that is less than or equal to it.\n\n### Returns\nThe largest \"int\" value that is less than or equal to the number.\n\n---\n\n## math.log()\n\nNatural logarithm of any number > 0 is the unique y such that e^y = number.\n\n### Returns\nThe natural logarithm of number.\n\n---\n\n## math.log10()\n\nThe common (or base 10) logarithm of number is the power to which 10 must be raised to obtain the number. 10^y = number.\n\n### Returns\nThe base 10 logarithm of number.\n\n---\n\n## math.max()\n\nReturns the greatest of multiple values.\n\n### Returns\nThe greatest of multiple given values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"math.max\", overlay=true)\nplot(math.max(close, open))\nplot(math.max(close, math.max(open, 42)))\n```\n\n---\n\n## math.min()\n\nReturns the smallest of multiple values.\n\n### Returns\nThe smallest of multiple given values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"math.min\", overlay=true)\nplot(math.min(close, open))\nplot(math.min(close, math.min(open, 42)))\n```\n\n---\n\n## math.pow()\n\nMathematical power function.\n\n### Returns\nbase raised to the power of exponent. If base is a series, it is calculated elementwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"math.pow\", overlay=true)\nplot(math.pow(close, 2))\n```\n\n---\n\n## math.random()\n\nReturns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence.\n\n### Returns\nA random value.\n\n---\n\n## math.round()\n\nReturns the value of number rounded to the nearest integer, with ties rounding up. If the precision parameter is used, returns a float value rounded to that amount of decimal places.\n\n### Returns\nThe value of number rounded to the nearest integer, or according to precision.\n\n### Remarks\nNote that for 'na' values function returns 'na'.\n\n---",
    "keywords": [
      "math.asin",
      "math.atan",
      "math.avg",
      "math.ceil",
      "math.cos",
      "math.exp",
      "math.floor",
      "math.log",
      "math.max",
      "math.min",
      "math.pow",
      "math.random",
      "math.round",
      "math.log10",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-120",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## math.round_to_mintick()\n\nReturns the value rounded to the symbol's mintick, i.e. the nearest value that can be divided by syminfo.mintick, without the remainder, with ties rounding up.\n\n### Returns\nThe number rounded to tick precision.\n\n### Remarks\nNote that for 'na' values function returns 'na'.\n\n---\n\n## math.sign()\n\nSign (signum) of number is zero if number is zero, 1.0 if number is greater than zero, -1.0 if number is less than zero.\n\n### Returns\nThe sign of the argument.\n\n---\n\n## math.sin()\n\nThe sin function returns the trigonometric sine of an angle.\n\n### Returns\nThe trigonometric sine of an angle.\n\n---\n\n## math.sqrt()\n\nSquare root of any number >= 0 is the unique y >= 0 such that y^2 = number.\n\n### Returns\nThe square root of number.\n\n---\n\n## math.sum()\n\nThe sum function returns the sliding sum of last y values of x.\n\n### Returns\nSum of source for length bars back.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## math.tan()\n\nThe tan function returns the trigonometric tangent of an angle.\n\n### Returns\nThe trigonometric tangent of an angle.\n\n---\n\n## math.todegrees()\n\nReturns an approximately equivalent angle in degrees from an angle measured in radians.\n\n### Returns\nThe angle value in degrees.\n\n---\n\n## math.toradians()\n\nReturns an approximately equivalent angle in radians from an angle measured in degrees.\n\n### Returns\nThe angle value in radians.\n\n---\n\n## matrix.add_col()\n\nThe function adds a column at the column index of the id matrix. The column can consist of na values, or an array can be used to provide values.\n\n### Remarks\nRather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the matrix.add_row function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.add_col()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a column with `na` values to the matrix.\nmatrix.add_col(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m))\n\n//@version=6\nindicator(\"`matrix.add_col()` Example 2\")\n\nif barstate.islastconfirmedhistory\n    // Create an empty matrix object. \n    var m = matrix.new<int>()\n    \n    // Create an array with values `1` and `3`.\n    var a = array.from(1, 3)\n    \n    // Add the `a` array as the first column of the empty matrix.\n    matrix.add_col(m, 0, a)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m))\n```\n\n---\n\n## matrix.add_row()\n\nThe function adds a row at the row index of the id matrix. The row can consist of na values, or an array can be used to provide values.\n\n### Remarks\nIndexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values.",
    "keywords": [
      "math.round_to_mintick",
      "i.e",
      "syminfo.mintick",
      "math.sign",
      "math.sin",
      "math.sqrt",
      "math.sum",
      "math.tan",
      "math.todegrees",
      "math.toradians",
      "matrix.add_col",
      "matrix.add_row",
      "matrix.new",
      "barstate.islastconfirmedhistory",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "array.from",
      "indicator",
      "fill",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-121",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.add_row()` Example 1\")\n\n// Create a 2x3 \"int\" matrix containing values `0`.\nm = matrix.new<int>(2, 3, 0)\n\n// Add a row with `na` values to the matrix.\nmatrix.add_row(m)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m))\n\n//@version=6\nindicator(\"`matrix.add_row()` Example 2\")\n\nif barstate.islastconfirmedhistory\n    // Create an empty matrix object. \n    var m = matrix.new<int>()\n    \n    // Create an array with values `1` and `2`.\n    var a = array.from(1, 2)\n    \n    // Add the `a` array as the first row of the empty matrix.\n    matrix.add_row(m, 0, a)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m))\n```\n\n---\n\n## matrix.avg()\n\nThe function calculates the average of all elements in the matrix.\n\n### Returns\nThe average value from the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.avg()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the average value of the matrix.\nvar x = matrix.avg(m)\n\nplot(x, 'Matrix average value')\n```\n\n---\n\n## matrix.col()\n\nThe function creates a one-dimensional array from the elements of a matrix column.\n\n### Returns\nAn array ID containing the column values of the id matrix.\n\n### Remarks\nIndexing of rows starts at 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.col()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first column of matrix `m`.\na = matrix.col(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))\n```\n\n---\n\n## matrix.columns()\n\nThe function returns the number of columns in the matrix.\n\n### Returns\nThe number of columns in the matrix id.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.columns()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of columns in matrix `m`.\nvar x = matrix.columns(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))\n```\n\n---\n\n## matrix.concat()\n\nThe function appends the m2 matrix to the m1 matrix.\n\n### Returns\nReturns the id1 matrix concatenated with the id2 matrix.\n\n### Remarks\nThe number of columns in both matrices must be identical.",
    "keywords": [
      "matrix.add_row",
      "matrix.new",
      "barstate.islastconfirmedhistory",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "array.from",
      "matrix.avg",
      "matrix.set",
      "matrix.col",
      "array.get",
      "matrix.columns",
      "label.new",
      "matrix.concat",
      "indicator",
      "plot",
      "fill",
      "var",
      "if"
    ]
  },
  {
    "id": "doc-122",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.concat()` Example\")\n\n// Create a 2x4 \"int\" matrix containing values `0`.\nm1 = matrix.new<int>(2, 4, 0)\n// Create a 2x4 \"int\" matrix containing values `1`.\nm2 = matrix.new<int>(2, 4, 1)\n\n// Append matrix `m2` to `m1`.\nmatrix.concat(m1, m2)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix Elements:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n```\n\n---\n\n## matrix.copy()\n\nThe function creates a new matrix which is a copy of the original.\n\n### Returns\nA new matrix object of the copied id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.copy()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 \"float\" matrix with `1` values.\n    var m1 = matrix.new<float>(2, 3, 1)\n    \n    // Copy the matrix to a new one.\n    // Note that unlike what `matrix.copy()` does, \n    // the simple assignment operation `m2 = m1`\n    // would NOT create a new copy of the `m1` matrix.\n    // It would merely create a copy of its ID referencing the same matrix.\n    var m2 = matrix.copy(m1)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 5, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Matrix Copy:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.det()\n\nThe function returns the determinant of a square matrix.\n\n### Returns\nThe determinant value of the id matrix.\n\n### Remarks\nFunction calculation based on the LU decomposition algorithm.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.det` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<float>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0,  3)\nmatrix.set(m, 0, 1,  7)\nmatrix.set(m, 1, 0,  1)\nmatrix.set(m, 1, 1, -4)\n\n// Get the determinant of the matrix. \nvar x = matrix.det(m)\n\nplot(x, 'Matrix determinant')\n```\n\n---\n\n## matrix.diff()\n\nThe function returns a new matrix resulting from the subtraction between matrices id1 and id2, or of matrix id1 and an id2 scalar (a numerical value).\n\n### Returns\nA new matrix object containing the difference between id2 and id1.",
    "keywords": [
      "matrix.concat",
      "matrix.new",
      "barstate.islastconfirmedhistory",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.copy",
      "matrix.det",
      "matrix.set",
      "matrix.diff",
      "indicator",
      "plot",
      "fill",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-123",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.diff()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix containing values `5`.\n    var m1 = matrix.new<float>(2, 3, 5) \n    // Create a 2x3 matrix containing values `4`.\n    var m2 = matrix.new<float>(2, 3, 4) \n    // Create a new matrix containing the difference between matrices `m1` and `m2`.\n    var m3 = matrix.diff(m1, m2) \n    \n    // Display using a table.\n    var t = table.new(position.top_right, 1, 2, color.green)\n    table.cell(t, 0, 0, \"Difference between two matrices:\")\n    table.cell(t, 0, 1, str.tostring(m3))\n\n//@version=6\nindicator(\"`matrix.diff()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix with values `4`.\n    var m1 = matrix.new<float>(2, 3, 4)\n    \n    // Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.\n    var m2 = matrix.diff(m1, 1)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 1, 2, color.green)\n    table.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")\n    table.cell(t, 0, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.eigenvalues()\n\nThe function returns an array containing the eigenvalues of a square matrix.\n\n### Returns\nAn array containing the eigenvalues of the id matrix.\n\n### Remarks\nThe function is calculated using \"The Implicit QL Algorithm\".\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.eigenvalues()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 2)\n    matrix.set(m1, 0, 1, 4)\n    matrix.set(m1, 1, 0, 6)\n    matrix.set(m1, 1, 1, 8)\n    \n    // Get the eigenvalues of the matrix.\n    tr = matrix.eigenvalues(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Array of Eigenvalues:\")\n    table.cell(t, 1, 1, str.tostring(tr))\n```\n\n---\n\n## matrix.eigenvectors()\n\nReturns a matrix of eigenvectors, in which each column is an eigenvector of the id matrix.\n\n### Returns\nA new matrix containing the eigenvectors of the id matrix.\n\n### Remarks\nThe function is calculated using \"The Implicit QL Algorithm\".",
    "keywords": [
      "matrix.diff",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.eigenvalues",
      "matrix.set",
      "matrix.eigenvectors",
      "indicator",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-124",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "matrix.is_antisymmetric()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.eigenvectors()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix \n    var m1 = matrix.new<int>(2, 2, 1)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 2)\n    matrix.set(m1, 0, 1, 4)\n    matrix.set(m1, 1, 0, 6)\n    matrix.set(m1, 1, 1, 8)\n    \n    // Get the eigenvectors of the matrix.\n    m2 = matrix.eigenvectors(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix Elements:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Matrix Eigenvectors:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.elements_count()\n\nThe function returns the total number of all matrix elements.\n\n---\n\n## matrix.fill()\n\nThe function fills a rectangular area of the id matrix defined by the indices from_column to to_column (not including it) and from_row to to_row(not including it) with the value.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.fill()` Example\")\n\n// Create a 4x5 \"int\" matrix containing values `0`.\nm = matrix.new<float>(4, 5, 0)\n\n// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.\nmatrix.fill(m, hl2, 0, 2, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))\n```\n\n---\n\n## matrix.get()\n\nThe function returns the element with the specified index of the matrix.\n\n### Returns\nThe value of the element at the row and column index of the id matrix.\n\n### Remarks\nIndexing of the rows and columns starts at zero.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.get()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from the `hl2` values.\nm = matrix.new<float>(2, 3, hl2)\n\n// Return the value of the element at index [0, 0] of matrix `m`.\nx = matrix.get(m, 0, 0)\n\nplot(x)\n```\n\n---\n\n## matrix.inv()\n\nThe function returns the inverse of a square matrix.\n\n### Returns\nA new matrix, which is the inverse of the id matrix.\n\n### Remarks\nThe function is calculated using the LU decomposition algorithm.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.inv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Inverse of the matrix.\n    var m2 = matrix.inv(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Inverse matrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.is_antidiagonal()\n\nThe function determines if the matrix is anti-diagonal (all elements outside the secondary diagonal are zero).\n\n### Returns\nReturns true if the id matrix is ‚Äã‚Äãanti-diagonal, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---",
    "keywords": [
      "matrix.eigenvectors",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "matrix.set",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.elements_count",
      "matrix.fill",
      "label.new",
      "matrix.get",
      "matrix.inv",
      "matrix.is_antidiagonal",
      "indicator",
      "plot",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-125",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## matrix.is_antisymmetric()\n\nThe function determines if a matrix is antisymmetric (its transpose equals its negative).\n\n### Returns\nReturns true, if the id matrix is antisymmetric, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---\n\n## matrix.is_binary()\n\nThe function determines if the matrix is binary (when all elements of the matrix are 0 or 1).\n\n### Returns\nReturns true if the id matrix is binary, false otherwise.\n\n---\n\n## matrix.is_diagonal()\n\nThe function determines if the matrix is diagonal (all elements outside the main diagonal are zero).\n\n### Returns\nReturns true if the id matrix is diagonal, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---\n\n## matrix.is_identity()\n\nThe function determines if a matrix is an identity matrix (elements with ones on the main diagonal and zeros elsewhere).\n\n### Returns\nReturns true if id is an identity matrix, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---\n\n## matrix.is_square()\n\nThe function determines if the matrix is square (it has the same number of rows and columns).\n\n### Returns\nReturns true if the id matrix is square, false otherwise.\n\n---\n\n## matrix.is_stochastic()\n\nThe function determines if the matrix is stochastic.\n\n### Returns\nReturns true if the id matrix is stochastic, false otherwise.\n\n---\n\n## matrix.is_symmetric()\n\nThe function determines if a square matrix is symmetric (elements are symmetric with respect to the main diagonal).\n\n### Returns\nReturns true if the id matrix is symmetric, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---\n\n## matrix.is_triangular()\n\nThe function determines if the matrix is triangular (if all elements above or below the main diagonal are zero).\n\n### Returns\nReturns true if the id matrix is triangular, false otherwise.\n\n### Remarks\nReturns false with non-square matrices.\n\n---\n\n## matrix.is_zero()\n\nThe function determines if all elements of the matrix are zero.\n\n### Returns\nReturns true if all elements of the id matrix are zero, false otherwise.\n\n---\n\n## matrix.kron()\n\nThe function returns the Kronecker product for the id1 and id2 matrices.\n\n### Returns\nA new matrix containing the Kronecker product of id1 and id2.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.kron()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n    // Create two matrices with default values `1` and `2`. \n    var m1 = matrix.new<float>(2, 2, 1) \n    var m2 = matrix.new<float>(2, 2, 2) \n    \n    // Calculate the Kronecker product of the matrices.\n    var m3 = matrix.kron(m1, m2) \n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 5, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix 1:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 1, \"‚äó\")\n    table.cell(t, 2, 0, \"Matrix 2:\")\n    table.cell(t, 2, 1, str.tostring(m2))\n    table.cell(t, 3, 1, \"=\")\n    table.cell(t, 4, 0, \"Kronecker product:\")\n    table.cell(t, 4, 1, str.tostring(m3))\n```\n\n---\n\n## matrix.max()\n\nThe function returns the largest value from the matrix elements.\n\n### Returns\nThe maximum value from the id matrix.",
    "keywords": [
      "matrix.is_antisymmetric",
      "matrix.is_binary",
      "matrix.is_diagonal",
      "matrix.is_identity",
      "matrix.is_square",
      "matrix.is_stochastic",
      "matrix.is_symmetric",
      "matrix.is_triangular",
      "matrix.is_zero",
      "matrix.kron",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.max",
      "indicator",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-126",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.max()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the maximum value in the matrix.\nvar x = matrix.max(m)\n\nplot(x, 'Matrix maximum value')\n```\n\n---\n\n## matrix.median()\n\nThe function calculates the median (\"the middle\" value) of matrix elements.\n\n### Remarks\nNote that na elements of the matrix are not considered when calculating the median.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.median()` Example\")\n\n// Create a 2x2 matrix.\nm = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the median of the matrix.\nx = matrix.median(m)\n\nplot(x, 'Median of the matrix')\n```\n\n---\n\n## matrix.min()\n\nThe function returns the smallest value from the matrix elements.\n\n### Returns\nThe smallest value from the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.min()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 1)\nmatrix.set(m, 0, 1, 2)\nmatrix.set(m, 1, 0, 3)\nmatrix.set(m, 1, 1, 4)\n\n// Get the minimum value from the matrix.\nvar x = matrix.min(m)\n\nplot(x, 'Matrix minimum value')\n```\n\n---\n\n## matrix.mode()\n\nThe function calculates the mode of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values.\n\n### Returns\nThe most frequently occurring value from the id matrix. If none exists, returns the smallest value instead.\n\n### Remarks\nNote that na elements of the matrix are not considered when calculating the mode.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.mode()` Example\")\n\n// Create a 2x2 matrix.\nvar m = matrix.new<int>(2, 2, na)\n// Fill the matrix with values.\nmatrix.set(m, 0, 0, 0)\nmatrix.set(m, 0, 1, 0)\nmatrix.set(m, 1, 0, 1)\nmatrix.set(m, 1, 1, 1)\n\n// Get the mode of the matrix.\nvar x = matrix.mode(m)\n\nplot(x, 'Mode of the matrix')\n```\n\n---\n\n## matrix.mult()\n\nThe function returns a new matrix resulting from the product between the matrices id1 and id2, or between an id1 matrix and an id2 scalar (a numerical value), or between an id1 matrix and an id2 vector (an array of values).\n\n### Returns\nA new matrix object containing the product of id2 and id1.",
    "keywords": [
      "matrix.max",
      "matrix.new",
      "matrix.set",
      "matrix.median",
      "matrix.min",
      "matrix.mode",
      "matrix.mult",
      "indicator",
      "plot",
      "fill",
      "var",
      "if"
    ]
  },
  {
    "id": "doc-127",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.mult()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 6x2 matrix containing values `5`.\n    var m1 = matrix.new<float>(6, 2, 5) \n    // Create a 2x3 matrix containing values `4`.\n    // Note that it must have the same quantity of rows as there are columns in the first matrix.\n    var m2 = matrix.new<float>(2, 3, 4) \n    // Create a new matrix from the multiplication of the two matrices.\n    var m3 = matrix.mult(m1, m2) \n    \n    // Display using a table.\n    var t = table.new(position.top_right, 1, 2, color.green)\n    table.cell(t, 0, 0, \"Product of two matrices:\")\n    table.cell(t, 0, 1, str.tostring(m3))\n\n//@version=6\nindicator(\"`matrix.mult()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix containing values `4`.\n    var m1 = matrix.new<float>(2, 3, 4) \n    \n    // Create a new matrix from the product of the two matrices.\n    scalar = 5\n    var m2 = matrix.mult(m1, scalar) \n    \n    // Display using a table.\n    var t = table.new(position.top_right, 5, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix 1:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 1, \"x\")\n    table.cell(t, 2, 0, \"Scalar:\")\n    table.cell(t, 2, 1, str.tostring(scalar))\n    table.cell(t, 3, 1, \"=\")\n    table.cell(t, 4, 0, \"Matrix 2:\")\n    table.cell(t, 4, 1, str.tostring(m2))\n\n//@version=6\nindicator(\"`matrix.mult()` Example 3\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix containing values `4`.\n    var m1 = matrix.new<int>(2, 3, 4)\n    \n    // Create an array of three elements.\n    var int[] a = array.from(1, 1, 1)\n    \n    // Create a new matrix containing the product of the `m1` matrix and the `a` array.\n    var m3 = matrix.mult(m1, a) \n    \n    // Display using a table.\n    var t = table.new(position.top_right, 5, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix 1:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 1, \"x\")\n    table.cell(t, 2, 0, \"Value:\")\n    table.cell(t, 2, 1, str.tostring(a, \" \"))\n    table.cell(t, 3, 1, \"=\")\n    table.cell(t, 4, 0, \"Matrix 3:\")\n    table.cell(t, 4, 1, str.tostring(m3))\n```\n\n---\n\n## matrix.new<type>()\n\nThe function creates a new matrix object. A matrix is a two-dimensional data structure containing rows and columns. All elements in the matrix must be of the type specified in the type template (\"<type>\").\n\n### Returns\nThe ID of the new matrix object.",
    "keywords": [
      "matrix.mult",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "array.from",
      "indicator",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-128",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.new<type>()` Example 1\")\n\n// Create a 2x3 (2 rows x 3 columns) \"int\" matrix with values zero.\nvar m = matrix.new<int>(2, 3, 0)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))\n\n//@version=6\nindicator(\"`matrix.new<type>()` Example 2\")\n\n// Function to create a matrix whose rows are filled with array values.\nmatrixFromArray(int rows, int columns, array<float> data) =>\n    m = matrix.new<float>(rows, columns)\n    for i = 0 to rows <= 0 ? na : rows - 1\n        for j = 0 to columns <= 0 ? na : columns - 1\n            matrix.set(m, i, j, array.get(data, i * columns + j))\n    m\n    \n// Create a 3x3 matrix from an array of values.\nvar m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m1))\n\n//@version=6\nindicator(\"`matrix.new<type>()` Example 3\")\n\n// Function to create a matrix from a text string.\n// Values in a row must be separated by a space. Each line is one row.\nmatrixFromInputArea(stringOfValues) =>\n    var rowsArray = str.split(stringOfValues, \"\\n\")\n    var rows = array.size(rowsArray)\n    var cols = array.size(str.split(array.get(rowsArray, 0), \" \"))\n    var matrix = matrix.new<float>(rows, cols, na) \n    row = 0\n    for rowString in rowsArray\n        col = 0\n        values = str.split(rowString, \" \")\n        for val in values\n            matrix.set(matrix, row, col, str.tonumber(val))\n            col += 1\n        row += 1\n    matrix\n\n\nstringInput = input.text_area(\"1 2 3\\n4 5 6\\n7 8 9\")\nvar m = matrixFromInputArea(stringInput)    \n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))\n\n//@version=6\nindicator(\"`matrix.new<type>()` Example 4\")\n\n// Function to create a matrix with random values (0.0 to 1.0).\nmatrixRandom(int rows, int columns)=>\n    result = matrix.new<float>(rows, columns)\n    for i = 0 to rows - 1\n        for j = 0 to columns - 1\n            matrix.set(result, i, j, math.random())\n    result\n\n// Create a 2x3 matrix with random values.\nvar m = matrixRandom(2, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))\n```\n\n---\n\n## matrix.pinv()\n\nThe function returns the pseudoinverse of a matrix.\n\n### Returns\nA new matrix containing the pseudoinverse of the id matrix.\n\n### Remarks\nThe function is calculated using a Moore‚ÄìPenrose inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of matrix.inv.",
    "keywords": [
      "matrix.new",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "matrix.set",
      "array.get",
      "array.from",
      "str.split",
      "array.size",
      "str.tonumber",
      "input.text_area",
      "math.random",
      "matrix.pinv",
      "matrix.inv",
      "indicator",
      "input",
      "fill",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-129",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.pinv()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Pseudoinverse of the matrix.\n    var m2 = matrix.pinv(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Pseudoinverse matrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.pow()\n\nThe function calculates the product of the matrix by itself power times.\n\n### Returns\nThe product of the id matrix by itself power times.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.pow()` Example\")\n\n// Display using a table.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, 2)\n    // Calculate the power of three of the matrix.\n    var m2 = matrix.pow(m1, 3)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Matrix¬≥:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.rank()\n\nThe function calculates the rank of the matrix.\n\n### Returns\nThe rank of the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.rank()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Get the rank of the matrix. \n    r = matrix.rank(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Rank of the matrix:\")\n    table.cell(t, 1, 1, str.tostring(r))\n```\n\n---\n\n## matrix.remove_col()\n\nThe function removes the column at column index of the id matrix and returns an array containing the removed column's values.\n\n### Returns\nAn array containing the elements of the column removed from the id matrix.\n\n### Remarks\nIndexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns. Deleting a column is also much slower than deleting a row with the matrix.remove_row function.",
    "keywords": [
      "matrix.pinv",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "matrix.set",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.pow",
      "matrix.rank",
      "matrix.remove_col",
      "matrix.remove_row",
      "indicator",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-130",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "matrix.reverse()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"matrix_remove_col\", overlay = true)\n\n// Create a 2x2 matrix with ones.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first column from the `matrixCopy` matrix.\narr = matrix.remove_col(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n    var t = table.new(position.top_right, 3, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(matrixOrig))\n    table.cell(t, 1, 0, \"Removed Elements:\")\n    table.cell(t, 1, 1, str.tostring(arr))\n    table.cell(t, 2, 0, \"Result Matrix:\")\n    table.cell(t, 2, 1, str.tostring(matrixCopy))\n```\n\n---\n\n## matrix.remove_row()\n\nThe function removes the row at row index of the id matrix and returns an array containing the removed row's values.\n\n### Returns\nAn array containing the elements of the row removed from the id matrix.\n\n### Remarks\nIndexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"matrix_remove_row\", overlay = true)\n\n// Create a 2x2 \"int\" matrix containing values `1`.\nvar matrixOrig = matrix.new<int>(2, 2, 1)\n\n// Set values to the 'matrixOrig' matrix.\nmatrix.set(matrixOrig, 0, 1, 2)\nmatrix.set(matrixOrig, 1, 0, 3)\nmatrix.set(matrixOrig, 1, 1, 4)\n\n// Create a copy of the 'matrixOrig' matrix.\nmatrixCopy = matrix.copy(matrixOrig)\n\n// Remove the first row from the matrix `matrixCopy`.\narr = matrix.remove_row(matrixCopy, 0)\n\n// Display matrix elements.\nif barstate.islastconfirmedhistory\n    var t = table.new(position.top_right, 3, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(matrixOrig))\n    table.cell(t, 1, 0, \"Removed Elements:\")\n    table.cell(t, 1, 1, str.tostring(arr))\n    table.cell(t, 2, 0, \"Result Matrix:\")\n    table.cell(t, 2, 1, str.tostring(matrixCopy))\n```\n\n---\n\n## matrix.reshape()\n\nThe function rebuilds the id matrix to rows x cols dimensions.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.reshape()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix.\n    var m1 = matrix.new<float>(2, 3)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 0, 2, 3)\n    matrix.set(m1, 1, 0, 4)\n    matrix.set(m1, 1, 1, 5)\n    matrix.set(m1, 1, 2, 6)\n    \n    // Copy the matrix to a new one.\n    var m2 = matrix.copy(m1)\n    \n    // Reshape the copy to a 3x2.\n    matrix.reshape(m2, 3, 2)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Reshaped matrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---",
    "keywords": [
      "matrix.new",
      "matrix.set",
      "matrix.copy",
      "matrix.remove_col",
      "barstate.islastconfirmedhistory",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.remove_row",
      "matrix.reshape",
      "indicator",
      "overlay",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-131",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## matrix.reverse()\n\nThe function reverses the order of rows and columns in the matrix id. The first row and first column become the last, and the last become the first.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.reverse()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Copy the matrix to a new one.\n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Copy matrix elements to a new matrix.\n    var m2 = matrix.copy(m1)\n    \n    // Reverse the `m2` copy of the original matrix. \n    matrix.reverse(m2)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Reversed matrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.row()\n\nThe function creates a one-dimensional array from the elements of a matrix row.\n\n### Returns\nAn array ID containing the row values of the id matrix.\n\n### Remarks\nIndexing of rows starts at 0.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.row()` Example\", \"\", true)\n\n// Create a 2x3 \"float\" matrix from `hlc3` values.\nm = matrix.new<float>(2, 3, hlc3)\n\n// Return an array with the values of the first row of the matrix.\na = matrix.row(m, 0)\n\n// Plot the first value from the array `a`.\nplot(array.get(a, 0))\n```\n\n---\n\n## matrix.rows()\n\nThe function returns the number of rows in the matrix.\n\n### Returns\nThe number of rows in the matrix id.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.rows()` Example\")\n\n// Create a 2x6 matrix with values `0`.\nvar m = matrix.new<int>(2, 6, 0)\n\n// Get the quantity of rows in the matrix.\nvar x = matrix.rows(m)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))\n```\n\n---\n\n## matrix.set()\n\nThe function assigns value to the element at the row and column of the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.set()` Example\")\n\n// Create a 2x3 \"int\" matrix containing values `4`.\nm = matrix.new<int>(2, 3, 4)\n\n// Replace the value of element at row 1 and column 2 with value `3`.\nmatrix.set(m, 0, 1, 3)\n\n// Display using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m))\n```\n\n---\n\n## matrix.sort()\n\nThe function rearranges the rows in the id matrix following the sorted order of the values in the column.",
    "keywords": [
      "matrix.reverse",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "matrix.set",
      "matrix.copy",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.row",
      "array.get",
      "matrix.rows",
      "label.new",
      "matrix.sort",
      "indicator",
      "plot",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-132",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.sort()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<float>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 3)\n    matrix.set(m1, 0, 1, 4)\n    matrix.set(m1, 1, 0, 1)\n    matrix.set(m1, 1, 1, 2)\n    \n    // Copy the matrix to a new one.\n    var m2 = matrix.copy(m1)\n    // Sort the rows of `m2` using the default arguments (first column and ascending order).\n    matrix.sort(m2)\n    \n    // Display using a table.\n    if barstate.islastconfirmedhistory\n        var t = table.new(position.top_right, 2, 2, color.green)\n        table.cell(t, 0, 0, \"Original matrix:\")\n        table.cell(t, 0, 1, str.tostring(m1))\n        table.cell(t, 1, 0, \"Sorted matrix:\")\n        table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.submatrix()\n\nThe function extracts a submatrix of the id matrix within the specified indices.\n\n### Returns\nA new matrix object containing the submatrix of the id matrix defined by the from_row, to_row, from_column and to_column indices.\n\n### Remarks\nIndexing of the rows and columns starts at zero.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.submatrix()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix matrix with values `0`.\n    var m1 = matrix.new<int>(2, 3, 0)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 0, 2, 3)\n    matrix.set(m1, 1, 0, 4)\n    matrix.set(m1, 1, 1, 5)\n    matrix.set(m1, 1, 2, 6)\n    \n    // Create a 2x2 submatrix of the `m1` matrix.\n    var m2 = matrix.submatrix(m1, 0, 2, 1, 3)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original Matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Submatrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.sum()\n\nThe function returns a new matrix resulting from the sum of two matrices id1 and id2, or of an id1 matrix and an id2 scalar (a numerical value).\n\n### Returns\nA new matrix object containing the sum of id2 and id1.",
    "keywords": [
      "matrix.sort",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "matrix.set",
      "matrix.copy",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.submatrix",
      "matrix.sum",
      "indicator",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-133",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.sum()` Example 1\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix containing values `5`.\n    var m1 = matrix.new<float>(2, 3, 5) \n    // Create a 2x3 matrix containing values `4`.\n    var m2 = matrix.new<float>(2, 3, 4) \n    // Create a new matrix that sums matrices `m1` and `m2`.\n    var m3 = matrix.sum(m1, m2) \n    \n    // Display using a table.\n    var t = table.new(position.top_right, 1, 2, color.green)\n    table.cell(t, 0, 0, \"Sum of two matrices:\")\n    table.cell(t, 0, 1, str.tostring(m3))\n\n//@version=6\nindicator(\"`matrix.sum()` Example 2\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x3 matrix with values `4`.\n    var m1 = matrix.new<float>(2, 3, 4)\n    \n    // Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.\n    var m2 = matrix.sum(m1, 1)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 1, 2, color.green)\n    table.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")\n    table.cell(t, 0, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.swap_columns()\n\nThe function swaps the columns at the index column1 and column2 in the id matrix.\n\n### Remarks\nIndexing of the rows and columns starts at zero.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.swap_columns()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix with ‚Äòna‚Äô values.\n    var m1 = matrix.new<int>(2, 2, na)    \n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Copy the matrix to a new one.\n    var m2 = matrix.copy(m1)\n    \n    // Swap the first and second columns of the matrix copy.\n    matrix.swap_columns(m2, 0, 1)\n\n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Swapped columns in copy:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.swap_rows()\n\nThe function swaps the rows at the index row1 and row2 in the id matrix.\n\n### Remarks\nIndexing of the rows and columns starts at zero.",
    "keywords": [
      "matrix.sum",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.swap_columns",
      "matrix.set",
      "matrix.copy",
      "matrix.swap_rows",
      "indicator",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-134",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.swap_rows()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 3x2 matrix with ‚Äòna‚Äô values.\n    var m1 = matrix.new<int>(3, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    matrix.set(m1, 2, 0, 5)\n    matrix.set(m1, 2, 1, 6)\n    \n    // Copy the matrix to a new one.\n    var m2 = matrix.copy(m1)\n    \n    // Swap the first and second rows of the matrix copy.\n    matrix.swap_rows(m2, 0, 1)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Swapped rows in copy:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## matrix.trace()\n\nThe function calculates the trace of a matrix (the sum of the main diagonal's elements).\n\n### Returns\nThe trace of the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.trace()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<int>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Get the trace of the matrix.\n    tr = matrix.trace(m1)\n    \n    // Display matrix elements.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Matrix elements:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Trace of the matrix:\")\n    table.cell(t, 1, 1, str.tostring(tr))\n```\n\n---\n\n## matrix.transpose()\n\nThe function creates a new, transposed version of the id. This interchanges the row and column index of each element.\n\n### Returns\nA new matrix containing the transposed version of the id matrix.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`matrix.transpose()` Example\")\n\n// For efficiency, execute this code only once.\nif barstate.islastconfirmedhistory\n    // Create a 2x2 matrix. \n    var m1 = matrix.new<float>(2, 2, na)\n    // Fill the matrix with values.\n    matrix.set(m1, 0, 0, 1)\n    matrix.set(m1, 0, 1, 2)\n    matrix.set(m1, 1, 0, 3)\n    matrix.set(m1, 1, 1, 4)\n    \n    // Create a transpose of the matrix.\n    var m2 = matrix.transpose(m1)\n    \n    // Display using a table.\n    var t = table.new(position.top_right, 2, 2, color.green)\n    table.cell(t, 0, 0, \"Original matrix:\")\n    table.cell(t, 0, 1, str.tostring(m1))\n    table.cell(t, 1, 0, \"Transposed matrix:\")\n    table.cell(t, 1, 1, str.tostring(m2))\n```\n\n---\n\n## max_bars_back()\n\nFunction sets the maximum number of bars that is available for historical reference of a given built-in or user variable. When operator '[]' is applied to a variable - it is a reference to a historical value of that variable.\n\n### Returns\nvoid",
    "keywords": [
      "matrix.swap_rows",
      "barstate.islastconfirmedhistory",
      "matrix.new",
      "matrix.set",
      "matrix.copy",
      "table.new",
      "position.top_right",
      "color.green",
      "table.cell",
      "str.tostring",
      "matrix.trace",
      "matrix.transpose",
      "indicator",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-135",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "plotbar()",
    "content": "### Remarks\nAt the moment 'max_bars_back' cannot be applied to built-ins like 'hl2', 'hlc3', 'ohlc4'. Please use multiple 'max_bars_back' calls as workaround here (e.g. instead of a single ‚Äòmax_bars_back(hl2, 100)‚Äô call you should call the function twice: ‚Äòmax_bars_back(high, 100), max_bars_back(low, 100)‚Äô).  If the indicator or strategy 'max_bars_back' parameter is used, all variables in the indicator are affected. This may result in excessive memory usage and cause runtime problems. When possible (i.e. when the cause is a variable rather than a function), please use the max_bars_back function instead.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"max_bars_back\")\nclose_() => close\ndepth() => 400\nd = depth()\nv = close_()\nmax_bars_back(v, 500)\nout = if bar_index > 0\n    v[d]\nelse\n    v\nplot(out)\n```\n\n---\n\n## minute()\n\n### Returns\nMinute (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n---\n\n## month()\n\n### Returns\nMonth (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. Note that this function returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day.\n\n---\n\n## na()\n\nTests if x is na.\n\n### Returns\nReturns true if x is na, false otherwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"na\")\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// ALTERNATIVE\n// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))\n```\n\n---\n\n## nz()\n\nReplaces NaN values with zeros (or given value) in a series.\n\n### Returns\nThe value of source if it is not na. If the value of source is na, returns zero, or the replacement argument when one is used.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"nz\", overlay=true)\nplot(nz(ta.sma(close, 100)))\n```\n\n---\n\n## plot()\n\nPlots a series of data on the chart.\n\n### Returns\nA plot object, that can be used in fill\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plot\")\nplot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)\n\n// You may fill the background between any two plots with a fill() function:\np1 = plot(open)\np2 = plot(close)\nfill(p1, p2, color=color.new(color.green, 90))\n```\n\n---\n\n## plotarrow()\n\nPlots up and down arrows on the chart. Up arrow is drawn at every indicator positive value, down arrow is drawn at every negative value. If indicator returns na then no arrow is drawn. Arrows has different height, the more absolute indicator value the longer arrow is drawn.\n\n### Remarks\nUse plotarrow function in conjunction with 'overlay=true' indicator parameter!\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plotarrow example\", overlay=true)\ncodiff = close - open\nplotarrow(codiff, colorup=color.new(color.teal,40), colordown=color.new(color.orange, 40))\n```\n\n---",
    "keywords": [
      "e.g",
      "i.e",
      "ta.sma",
      "color.new",
      "plot.style_area",
      "color.green",
      "color.teal",
      "color.orange",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-136",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## plotbar()\n\nPlots ohlc bars on the chart.\n\n### Remarks\nEven if one value of open, high, low or close equal NaN then bar no draw. The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plotbar example\", overlay=true)\nplotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)\n```\n\n---\n\n## plotcandle()\n\nPlots candles on the chart.\n\n### Remarks\nEven if one value of open, high, low or close equal NaN then bar no draw. The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plotcandle example\", overlay=true)\nplotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)\n```\n\n---\n\n## plotchar()\n\nPlots visual shapes using any given one Unicode character on the chart.\n\n### Remarks\nUse plotchar function in conjunction with 'overlay=true' indicator parameter!\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plotchar example\", overlay=true)\ndata = close >= open\nplotchar(data, char='‚ùÑ')\n```\n\n---\n\n## plotshape()\n\nPlots visual shapes on the chart.\n\n### Remarks\nUse plotshape function in conjunction with 'overlay=true' indicator parameter!\n\n### Code Example\n```pine\n//@version=6\nindicator(\"plotshape example 1\", overlay=true)\ndata = close >= open\nplotshape(data, style=shape.xcross)\n```\n\n---\n\n## polyline.delete()\n\nDeletes the specified polyline object. It has no effect if the id doesn't exist.\n\n---\n\n## polyline.new()\n\nCreates a new polyline instance and displays it on the chart, sequentially connecting all of the points in the points array with line segments. The segments in the drawing can be straight or curved depending on the curved parameter.\n\n### Returns\nThe ID of a new polyline object that a script can use in other polyline.*() functions.",
    "keywords": [
      "color.green",
      "color.red",
      "color.black",
      "shape.xcross",
      "polyline.delete",
      "polyline.new",
      "indicator",
      "overlay",
      "plot",
      "if"
    ]
  },
  {
    "id": "doc-137",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Returns",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Polylines example\", overlay = true)\n\n//@variable If `true`, connects all points in the polyline with curved line segments. \nbool curvedInput = input.bool(false, \"Curve Polyline\")\n//@variable If `true`, connects the first point in the polyline to the last point.\nbool closedInput = input.bool(true, \"Close Polyline\")\n//@variable The color of the space filled by the polyline.\ncolor fillcolor = input.color(color.new(color.blue, 90), \"Fill Color\")\n\n// Time and price inputs for the polyline's points. \np1x = input.time(0,  \"p1\", confirm = true, inline = \"p1\")\np1y = input.price(0, \"  \", confirm = true, inline = \"p1\")\np2x = input.time(0,  \"p2\", confirm = true, inline = \"p2\")\np2y = input.price(0, \"  \", confirm = true, inline = \"p2\")\np3x = input.time(0,  \"p3\", confirm = true, inline = \"p3\")\np3y = input.price(0, \"  \", confirm = true, inline = \"p3\")\np4x = input.time(0,  \"p4\", confirm = true, inline = \"p4\")\np4y = input.price(0, \"  \", confirm = true, inline = \"p4\")\np5x = input.time(0,  \"p5\", confirm = true, inline = \"p5\")\np5y = input.price(0, \"  \", confirm = true, inline = \"p5\")\n\nif barstate.islastconfirmedhistory\n    //@variable An array of `chart.point` objects for the new polyline.\n    var points = array.new<chart.point>()\n    // Push new `chart.point` instances into the `points` array.\n    points.push(chart.point.from_time(p1x, p1y))\n    points.push(chart.point.from_time(p2x, p2y))\n    points.push(chart.point.from_time(p3x, p3y))\n    points.push(chart.point.from_time(p4x, p4y))\n    points.push(chart.point.from_time(p5x, p5y))\n    // Add labels for each `chart.point` in `points`.\n    l1p1 = label.new(points.get(0), text = \"p1\", xloc = xloc.bar_time, color = na)\n    l1p2 = label.new(points.get(1), text = \"p2\", xloc = xloc.bar_time, color = na)\n    l2p1 = label.new(points.get(2), text = \"p3\", xloc = xloc.bar_time, color = na)\n    l2p2 = label.new(points.get(3), text = \"p4\", xloc = xloc.bar_time, color = na)\n    // Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.\n    polyline.new(points, curved = curvedInput, closed = closedInput, fill_color = fillcolor, xloc = xloc.bar_time)\n```\n\n---\n\n## request.currency_rate()\n\nProvides a daily rate that can be used to convert a value expressed in the from currency to another in the to currency.\n\n### Remarks\nIf from and to arguments are equal, function returns 1. Please note that using this variable/function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Close in British Pounds\")\nrate = request.currency_rate(syminfo.currency, \"GBP\")\nplot(close * rate)\n```\n\n---\n\n## request.dividends()\n\nRequests dividends data for the specified symbol.\n\n### Returns\nRequested series, or n/a if there is no dividends data for the specified symbol.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"request.dividends\")\ns1 = request.dividends(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.dividends(\"NASDAQ:BELFA\", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)\n```\n\n---\n\n## request.earnings()\n\nRequests earnings data for the specified symbol.",
    "keywords": [
      "input.bool",
      "input.color",
      "color.new",
      "color.blue",
      "input.time",
      "input.price",
      "barstate.islastconfirmedhistory",
      "chart.point",
      "array.new",
      "points.push",
      "label.new",
      "points.get",
      "xloc.bar_time",
      "polyline.new",
      "request.currency_rate",
      "syminfo.currency",
      "request.dividends",
      "dividends.net",
      "barmerge.gaps_on",
      "barmerge.lookahead_on",
      "request.earnings",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-138",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Returns\nRequested series, or n/a if there is no earnings data for the specified symbol.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"request.earnings\")\ns1 = request.earnings(\"NASDAQ:BELFA\")\nplot(s1)\ns2 = request.earnings(\"NASDAQ:BELFA\", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)\n```\n\n---\n\n## request.economic()\n\nRequests economic data for a symbol. Economic data includes information such as the state of a country's economy (GDP, inflation rate, etc.) or of a particular industry (steel production, ICU beds, etc.).\n\n### Returns\nRequested series.\n\n### Remarks\nEconomic data can also be accessed from charts, just like a regular symbol. Use \"ECONOMIC\" as the exchange name and {country_code}{field} as the ticker. The name of US GDP data is thus \"ECONOMIC:USGDP\".\n\n### Code Example\n```pine\n//@version=6\nindicator(\"US GDP\")\ne = request.economic(\"US\", \"GDP\")\nplot(e)\n```\n\n---\n\n## request.financial()\n\nRequests financial series for symbol.\n\n### Returns\nRequested series.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"request.financial\")\nf = request.financial(\"NASDAQ:MSFT\", \"ACCOUNTS_PAYABLE\", \"FY\")\nplot(f)\n```\n\n---\n\n## request.quandl()\n\nNote: This function has been deprecated due to the API change from NASDAQ Data Link. Requests for \"QUANDL\" symbols are no longer valid and requests for them return a runtime error.\n\n### Returns\nRequested series.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"request.quandl\")\nf = request.quandl(\"CFTC/SB_FO_ALL\", barmerge.gaps_off, 0)\nplot(f)\n```\n\n---\n\n## request.security()\n\nRequests the result of an expression from a specified context (symbol and timeframe).\n\n### Returns\nA result determined by expression.\n\n### Remarks\nScripts using this function might calculate differently on historical and realtime bars, leading to repainting. A single script can contain no more than 40 unique request.*() function calls. A call is unique only if it does not call the same function with the same arguments. When using two calls to a request.*() function to evaluate the same expression from the same context with different calc_bars_count values, the second call requests the same number of historical bars as the first. For example, if a script calls request.security(\"AAPL\", \"\", close, calc_bars_count = 3) after it calls request.security(\"AAPL\", \"\", close, calc_bars_count = 5), the second call also uses five bars of historical data, not three. The symbol of a request.() call can be inherited if it is not specified precisely, i.e., if the symbol argument is an empty string or syminfo.tickerid. Similarly, the timeframe of a request.() call can be inherited if the timeframe argument is an empty string or timeframe.period. These values are normally taken from the chart on which the script is running. However, if request.*() function A is called from within the expression of request.*() function B, then function A can inherit the values from function B. See here for more information.",
    "keywords": [
      "request.earnings",
      "earnings.actual",
      "barmerge.gaps_on",
      "barmerge.lookahead_on",
      "request.economic",
      "request.financial",
      "request.quandl",
      "barmerge.gaps_off",
      "request.security",
      "i.e",
      "syminfo.tickerid",
      "timeframe.period",
      "indicator",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-139",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Simple `request.security()` calls\")\n// Returns 1D close of the current symbol.\ndailyClose = request.security(syminfo.tickerid, \"1D\", close)\nplot(dailyClose)\n\n// Returns the close of \"AAPL\" from the same timeframe as currently open on the chart.\naaplClose = request.security(\"AAPL\", timeframe.period, close)\nplot(aaplClose)\n\n//@version=6\nindicator(\"Advanced `request.security()` calls\")\n// This calculates a 10-period moving average on the active chart.\nsma = ta.sma(close, 10)\n// This sends the `sma` calculation for execution in the context of the \"AAPL\" symbol at a \"240\" (4 hours) timeframe.\naaplSma = request.security(\"AAPL\", \"240\", sma)\nplot(aaplSma)\n\n// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:\nindexHighTF = barstate.isrealtime ? 1 : 0\nindexCurrTF = barstate.isrealtime ? 0 : 1\nnonRepaintingClose = request.security(syminfo.tickerid, \"1D\", close[indexHighTF])[indexCurrTF]\nplot(nonRepaintingClose, \"Non-repainting close\")\n\n// Returns the 1H close of \"AAPL\", extended session included. The value is dividend-adjusted.\nextendedTicker = ticker.modify(\"NASDAQ:AAPL\", session = session.extended, adjustment = adjustment.dividends)\naaplExtAdj = request.security(extendedTicker, \"60\", close)\nplot(aaplExtAdj)\n\n// Returns the result of a user-defined function.\n// The `max` variable is mutable, but we can pass it to `request.security()` because it is wrapped in a function.\nallTimeHigh(source) =>\n    var max = source\n    max := math.max(max, source)\nallTimeHigh1D = request.security(syminfo.tickerid, \"1D\", allTimeHigh(high))\n\n// By using a tuple `expression`, we obtain several values with only one `request.security()` call.\n[open1D, high1D, low1D, close1D, ema1D] = request.security(syminfo.tickerid, \"1D\", [open, high, low, close, ta.ema(close, 10)])\nplotcandle(open1D, high1D, low1D, close1D)\nplot(ema1D)\n\n// Returns an array containing the OHLC values of the chart's symbol from the 1D timeframe.\nohlcArray = request.security(syminfo.tickerid, \"1D\", array.from(open, high, low, close))\nplotcandle(array.get(ohlcArray, 0), array.get(ohlcArray, 1), array.get(ohlcArray, 2), array.get(ohlcArray, 3))\n```\n\n---\n\n## request.security_lower_tf()\n\nRequests the results of an expression from a specified symbol on a timeframe lower than or equal to the chart's timeframe. It returns an array containing one element for each lower-timeframe bar within the chart bar. On a 5-minute chart, requesting data using a timeframe argument of \"1\" typically returns an array with five elements representing the value of the expression on each 1-minute bar, ordered by time with the earliest value first.\n\n### Returns\nAn array of a type determined by expression, or a tuple of these.",
    "keywords": [
      "request.security",
      "syminfo.tickerid",
      "timeframe.period",
      "ta.sma",
      "barstate.isrealtime",
      "ticker.modify",
      "session.extended",
      "adjustment.dividends",
      "math.max",
      "ta.ema",
      "array.from",
      "array.get",
      "request.security_lower_tf",
      "indicator",
      "plot",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-140",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "str.contains()",
    "content": "### Remarks\nScripts using this function might calculate differently on historical and realtime bars, leading to repainting. Please note that spreads (e.g., \"AAPL+MSFT*TSLA\") do not always return reliable data with this function. A single script can contain no more than 40 unique request.*() function calls. A call is unique only if it does not call the same function with the same arguments. When using two calls to a request.*() function to evaluate the same expression from the same context with different calc_bars_count values, the second call requests the same number of historical bars as the first. For example, if a script calls request.security(\"AAPL\", \"\", close, calc_bars_count = 3) after it calls request.security(\"AAPL\", \"\", close, calc_bars_count = 5), the second call also uses five bars of historical data, not three. The symbol of a request.() call can be inherited if it is not specified precisely, i.e., if the symbol argument is an empty string or syminfo.tickerid. Similarly, the timeframe of a request.() call can be inherited if the timeframe argument is an empty string or timeframe.period. These values are normally taken from the chart that the script is running on. However, if request.*() function A is called from within the expression of request.*() function B, then function A can inherit the values from function B. See here for more information.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`request.security_lower_tf()` Example\", overlay = true)\n\n// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.\narrClose = request.security_lower_tf(syminfo.tickerid, \"60\", close)\n\nif bar_index == last_bar_index - 1\n    label.new(bar_index, high, str.tostring(arrClose))\n```\n\n---\n\n## request.seed()\n\nRequests data from a user-maintained GitHub repository and returns it as a series. An in-depth tutorial on how to add new data can be found here.\n\n### Returns\nRequested series or tuple of series, which may include array/matrix IDs.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"BTC Development Activity\")\n\n[devAct, devActSMA] = request.seed(\"seed_crypto_santiment\", \"BTC_DEV_ACTIVITY\", [close, ta.sma(close, 10)])\n\nplot(devAct, \"BTC Development Activity\")\nplot(devActSMA, \"BTC Development Activity SMA10\", color = color.yellow)\n```\n\n---\n\n## request.splits()\n\nRequests splits data for the specified symbol.\n\n### Returns\nRequested series, or n/a if there is no splits data for the specified symbol.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"request.splits\")\ns1 = request.splits(\"NASDAQ:BELFA\", splits.denominator)\nplot(s1)\ns2 = request.splits(\"NASDAQ:BELFA\", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)\nplot(s2)\n```\n\n---\n\n## runtime.error()\n\nWhen called, causes a runtime error with the error message specified in the message argument.\n\n---\n\n## second()\n\n### Returns\nSecond (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n---",
    "keywords": [
      "e.g",
      "request.security",
      "i.e",
      "syminfo.tickerid",
      "timeframe.period",
      "request.security_lower_tf",
      "label.new",
      "str.tostring",
      "request.seed",
      "ta.sma",
      "color.yellow",
      "request.splits",
      "splits.denominator",
      "barmerge.gaps_on",
      "barmerge.lookahead_on",
      "runtime.error",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-141",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "str.format_time()",
    "content": "## str.contains()\n\nReturns true if the source string contains the str substring, false otherwise.\n\n### Returns\nTrue if the str was found in the source string, false otherwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.contains\")\n// If the current chart is a continuous futures chart, e.g ‚ÄúBTC1!‚Äù, then the function will return true, false otherwise.\nvar isFutures = str.contains(syminfo.tickerid, \"!\")\nplot(isFutures ? 1 : 0)\n```\n\n---\n\n## str.endswith()\n\nReturns true if the source string ends with the substring specified in str, false otherwise.\n\n### Returns\nTrue if the source string ends with the substring specified in str, false otherwise.\n\n---\n\n## str.format()\n\nConverts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list.\n\n### Returns\nThe formatted string.\n\n### Remarks\nBy default, formatted numbers will display up to three decimals with no trailing zeros. The string used as the formatString argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results. Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.format\", overlay=true)\n// The format specifier inside the curly braces accepts certain modifiers:\n// - Specify the number of decimals to display:\ns1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3\nlabel.new(bar_index, close, text=s1)\n// - Round a float value to an integer:\ns2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1\nlabel.new(bar_index - 1, close, text=s2)\n// - Display a number in currency:\ns3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34\nlabel.new(bar_index - 2, close, text=s3)\n// - Display a number as a percentage:\ns4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%\nlabel.new(bar_index - 3, close, text=s4)\n// EXAMPLES WITH SEVERAL ARGUMENTS\n// returns: Number 1 is not equal to 4\ns5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)\nlabel.new(bar_index - 4, close, text=s5)\n// returns: 1.34 != 1.3\ns6 = str.format(\"{0} != {0, number, #.#}\", 1.34)\nlabel.new(bar_index - 5, close, text=s6)\n// returns: 1 is equal to 1, but 2 is equal to 2\ns7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)\nlabel.new(bar_index - 6, close, text=s7)\n// returns: The cash turnover amounted to $1,340,000.00\ns8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)\nlabel.new(bar_index - 7, close, text=s8)\n// returns: Expected return is 10% - 20%\ns9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)\nlabel.new(bar_index - 8, close, text=s9)\n```\n\n---",
    "keywords": [
      "str.contains",
      "e.g",
      "syminfo.tickerid",
      "str.endswith",
      "str.format",
      "label.new",
      "indicator",
      "overlay",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-142",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## str.format_time()\n\nConverts the time timestamp into a string formatted according to format and timezone.\n\n### Returns\nThe formatted string.\n\n### Remarks\nThe M, d, h, H, m and s tokens can all be doubled to generate leading zeros. For example, the month of January will display as 1 with M, or 01 with MM.  The most frequently used formatting tokens are:  y - Year. Use yy to output the last two digits of the year or yyyy to output all four. Year 2000 will be 00 with yy or 2000 with yyyy. M - Month. Not to be confused with lowercase m, which stands for minute. d - Day of the month. a - AM/PM postfix. h - Hour in the 12-hour format. The last hour of the day will be 11 in this format. H - Hour in the 24-hour format. The last hour of the day will be 23 in this format. m - Minute. s - Second. S - Fractions of a second. Z - Timezone, the HHmm offset from UTC, preceded by either + or -.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.format_time\")\nif timeframe.change(\"1D\")\n    formattedTime = str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone)\n    label.new(bar_index, high, formattedTime)\n```\n\n---\n\n## str.length()\n\nReturns an integer corresponding to the amount of chars in that string.\n\n### Returns\nThe number of chars in source string.\n\n---\n\n## str.lower()\n\nReturns a new string with all letters converted to lowercase.\n\n### Returns\nA new string with all letters converted to lowercase.\n\n---\n\n## str.match()\n\nReturns the new substring of the source string if it matches a regex regular expression, an empty string otherwise.\n\n### Returns\nThe new substring of the source string if it matches a regex regular expression, an empty string otherwise.\n\n### Remarks\nFunction returns first occurrence of the regular expression in the source string. The backslash \"\\\" symbol in theregex string needs to be escaped with additional backslash, e.g. \"\\\\d\" stands for regular expression \"\\d\".\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.match\")\n\ns = input.string(\"It's time to sell some NASDAQ:AAPL!\")\n\n// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"\nvar string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")\n\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\"\n```\n\n---\n\n## str.pos()\n\nReturns the position of the first occurrence of the str string in the source string, 'na' otherwise.\n\n### Returns\nPosition of the str string in the source string.\n\n### Remarks\nStrings indexing starts at 0.\n\n---\n\n## str.repeat()\n\nConstructs a new string containing the source string repeated repeat times with the separator injected between each repeated instance.\n\n### Remarks\nReturns na if the source is na.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.repeat\")\nrepeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"\nlabel.new(bar_index,close,repeat)\n```\n\n---\n\n## str.replace()\n\nReturns a new string with the Nth occurrence of the target string replaced by the replacement string, where N is specified in occurrence.\n\n### Returns\nProcessed string.",
    "keywords": [
      "str.format_time",
      "timeframe.change",
      "syminfo.timezone",
      "label.new",
      "str.length",
      "str.lower",
      "str.match",
      "e.g",
      "input.string",
      "barstate.islastconfirmedhistory",
      "str.pos",
      "str.repeat",
      "str.replace",
      "indicator",
      "input",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-143",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"str.replace\")\nvar source = \"FTX:BTCUSD / FTX:BTCEUR\"\n\n// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string\nvar newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)\n\nif barstate.islastconfirmedhistory\n    // Display \"BINANCE:BTCUSD / FTX:BTCEUR\"\n    label.new(bar_index, high, text = newSource)\n```\n\n---\n\n## str.replace_all()\n\nReplaces each occurrence of the target string in the source string with the replacement string.\n\n### Returns\nProcessed string.\n\n---\n\n## str.split()\n\nDivides a string into an array of substrings and returns its array id.\n\n### Returns\nThe id of an array of strings.\n\n---\n\n## str.startswith()\n\nReturns true if the source string starts with the substring specified in str, false otherwise.\n\n### Returns\nTrue if the source string starts with the substring specified in str, false otherwise.\n\n---\n\n## str.substring()\n\nReturns a new string that is a substring of the source string. The substring begins with the character at the index specified by begin_pos and extends to 'end_pos - 1' of the source string.\n\n### Returns\nThe substring extracted from the source string.\n\n### Remarks\nStrings indexing starts from 0. If begin_pos is equal to end_pos, the function returns an empty string.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.substring\", overlay = true)\nsym= input.symbol(\"NASDAQ:AAPL\")\npos = str.pos(sym, \":\") // Get position of \":\" character\ntkr= str.substring(sym, pos+1) // \"AAPL\"\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text = tkr)\n```\n\n---\n\n## str.tonumber()\n\nConverts a value represented in string to its \"float\" equivalent.\n\n### Returns\nA \"float\" equivalent of the value in string. If the value is not a properly formed integer or floating point value, the function returns na.\n\n---\n\n## str.tostring()\n\n### Returns\nThe string representation of the value argument.\n\n### Remarks\nThe formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\". To display trailing zeros, use '0' instead of '#'. For example, '#.000'. When using format.mintick, the value will be rounded to the nearest number that can be divided by syminfo.mintick without the remainder. The string is returned with trailing zeros. If the x argument is a string, the same string value will be returned. Bool type arguments return \"true\" or \"false\". When x is na, the function returns \"NaN\".\n\n---\n\n## str.trim()\n\nConstructs a new string with all consecutive whitespaces and other control characters (e.g., ‚Äú\\n‚Äù, ‚Äú\\t‚Äù, etc.) removed from the left and right of the source.\n\n### Remarks\nReturns an empty string (\"\") if the result is empty after the trim or if the source is na.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"str.trim\")\ntrim = str.trim(\"    abc    \") // Returns \"abc\"\nlabel.new(bar_index,close,trim)\n```\n\n---\n\n## str.upper()\n\nReturns a new string with all letters converted to uppercase.\n\n### Returns\nA new string with all letters converted to uppercase.\n\n---\n\n## strategy()\n\nThis declaration statement designates the script as a strategy and sets a number of strategy-related properties.",
    "keywords": [
      "str.replace",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.replace_all",
      "str.split",
      "str.startswith",
      "str.substring",
      "input.symbol",
      "str.pos",
      "str.tonumber",
      "str.tostring",
      "e.g",
      "format.mintick",
      "syminfo.mintick",
      "str.trim",
      "str.upper",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-144",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Remarks\nYou can learn more about strategies in our User Manual. Every strategy script must have one strategy call. Strategies using calc_on_every_tick = true parameter may calculate differently on historical and realtime bars, which causes repainting. Strategies always use the chart's prices to enter and exit positions. Using them on non-standard chart types (Heikin Ashi, Renko, etc.) will produce misleading results, as their prices are synthetic. Backtesting on non-standard charts is thus not recommended. The maximum number of orders a strategy can open, unless it uses Deep Backtesting mode, is 9000. If the strategy exceeds this limit, it removes the oldest order's information when a new entry appears in the \"List of Trades\" tab. The strategy.closedtrades.*() functions return na for trades opened or closed by removed orders. To retrieve the index of the oldest available closed trade, use the strategy.closedtrades.first_index variable.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"My strategy\", overlay = true)\n\n// Enter long by market if current open is greater than previous high.\nif open > high[1]\n    strategy.entry(\"Long\", strategy.long, 1)\n// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named \"Long\".\nstrategy.exit(\"Exit\", \"Long\", profit = 10, loss = 5)\n```\n\n---\n\n## strategy.cancel()\n\nCancels a pending or unfilled order with a specific identifier. If multiple unfilled orders share the same ID, calling this command with that ID as the id argument cancels all of them. If a script calls this command with an id representing the ID of a filled order, it has no effect.\n\n### Code Example\n```pine\n//@version=6\nstrategy(title = \"Order cancellation demo\")\n\nconditionForBuy = open > high[1]\nif conditionForBuy\n    strategy.entry(\"Long\", strategy.long, 1, limit = low) // Enter long using limit order at low price of current bar if `conditionForBuy` is `true`.\nif not conditionForBuy\n    strategy.cancel(\"Long\") // Cancel the entry order with name \"Long\" if `conditionForBuy` is `false`.\n```\n\n---\n\n## strategy.cancel_all()\n\nCancels all pending or unfilled orders, regardless of their identifiers.\n\n### Code Example\n```pine\n//@version=6\nstrategy(title = \"Cancel all orders demo\")\nconditionForBuy1 = open > high[1]\nif conditionForBuy1\n    strategy.entry(\"Long entry 1\", strategy.long, 1, limit = low) // Enter long using a limit order if `conditionForBuy1` is `true`.\nconditionForBuy2 = conditionForBuy1 and open[1] > high[2]\nfloat lowest2 = ta.lowest(low, 2)\nif conditionForBuy2\n    strategy.entry(\"Long entry 2\", strategy.long, 1, limit = lowest2) // Enter long using a limit order if `conditionForBuy2` is `true`.\nconditionForStopTrading = open < lowest2\nif conditionForStopTrading\n    strategy.cancel_all() // Cancel both limit orders if `conditionForStopTrading` is `true`.\n```\n\n---\n\n## strategy.close()\n\nCreates an order to exit from the part of a position opened by entry orders with a specific identifier. If multiple entries in the position share the same ID, the orders from this command apply to all those entries, starting from the first open trade, when its calls use that ID as the id argument.",
    "keywords": [
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.long",
      "strategy.exit",
      "strategy.cancel",
      "strategy.cancel_all",
      "ta.lowest",
      "strategy.close",
      "strategy",
      "overlay",
      "fill",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-145",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Remarks\nWhen a position consists of several open trades and the close_entries_rule in the strategy declaration statement is \"FIFO\" (default), a strategy.close call exits from the position starting with the first open trade. This behavior applies even if the id value is the entry ID of different open trades. However, in that case, the maximum exit order size still depends on the trades opened by orders with the id identifier. For more information, see this section of our User Manual.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"Partial close strategy\")\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to close the long trade when `sma14` crosses under `sma28`. \nif ta.crossunder(sma14, sma28)\n    strategy.close(\"My Long Entry ID\", \"50% market close\", qty_percent = 50)\n\n// Plot the position size.\nplot(strategy.position_size)\n```\n\n---\n\n## strategy.close_all()\n\nCreates an order to close an open position completely, regardless of the identifiers of the entry orders that opened or added to it.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"Multi-entry close strategy\")\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long trade every time `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.order(\"My Long Entry ID \" + str.tostring(strategy.opentrades), strategy.long)\n\n// Place a market order to close the entire position every 500 bars. \nif bar_index % 500 == 0\n    strategy.close_all()\n\n// Plot the position size.\nplot(strategy.position_size)\n```\n\n---\n\n## strategy.closedtrades.commission()\n\nReturns the sum of entry and exit fees paid in the closed trade, expressed in strategy.account_currency.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot total fees for the latest closed trade.\nplot(strategy.closedtrades.commission(strategy.closedtrades - 1))\n```\n\n---\n\n## strategy.closedtrades.entry_bar_index()\n\nReturns the bar_index of the closed trade's entry.",
    "keywords": [
      "strategy.close",
      "ta.sma",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "ta.crossunder",
      "strategy.position_size",
      "strategy.close_all",
      "strategy.order",
      "str.tostring",
      "strategy.opentrades",
      "strategy.closedtrades",
      "strategy.account_currency",
      "strategy.commission",
      "strategy",
      "plot",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-146",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.entry_bar_index Example\")\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n// Function that calculates the average amount of bars in a trade.\navgBarsPerTrade() =>\n    sumBarsPerTrade = 0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        // Loop through all closed trades, starting with the oldest.\n        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n    result = nz(sumBarsPerTrade / strategy.closedtrades)\nplot(avgBarsPerTrade())\n```\n\n---\n\n## strategy.closedtrades.entry_comment()\n\nReturns the comment message of the closed trade's entry, or na\nif there is no entry with this trade_num.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n    strategy.exit(\"EXIT\", trail_points = 1000, trail_offset = 0)\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last closed trade:')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.closedtrades.entry_comment(strategy.closedtrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.closedtrades.entry_price(strategy.closedtrades - 1)))\n```\n\n---\n\n## strategy.closedtrades.entry_id()\n\nReturns the id of the closed trade's entry.\n\n### Returns\nReturns the id of the closed trade's entry.\n\n### Remarks\nThe function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.entry_id Example\", overlay = true)\n\n// Enter a short position and close at the previous to last bar.\nif bar_index == 1\n    strategy.entry(\"Short at bar #\" + str.tostring(bar_index), strategy.short)\nif bar_index == last_bar_index - 2\n    strategy.close_all()\n    \n// Display ID of the last entry position.\nif barstate.islastconfirmedhistory\n    label.new(last_bar_index, high, \"Last Entry ID is: \" + strategy.closedtrades.entry_id(strategy.closedtrades - 1))\n```\n\n---\n\n## strategy.closedtrades.entry_price()\n\nReturns the price of the closed trade's entry.",
    "keywords": [
      "strategy.closedtrades",
      "ta.rising",
      "strategy.entry",
      "strategy.long",
      "ta.falling",
      "strategy.close",
      "ta.crossover",
      "ta.sma",
      "str.tostring",
      "strategy.exit",
      "table.new",
      "position.top_right",
      "color.orange",
      "barstate.islastconfirmedhistory",
      "barstate.isrealtime",
      "table.cell",
      "strategy.short",
      "strategy.close_all",
      "label.new",
      "strategy",
      "overlay",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-147",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.entry_price Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Return the entry price for the latest entry.\nentryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\n\nplot(entryPrice, \"Long entry price\")\n\n// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"strategy.closedtrades.entry_price Example 2\")\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)\n```\n\n---\n\n## strategy.closedtrades.entry_time()\n\nReturns the UNIX time of the closed trade's entry, expressed in milliseconds..\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.entry_time Example\", overlay = true)\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration \navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")\n```\n\n---\n\n## strategy.closedtrades.exit_bar_index()\n\nReturns the bar_index of the closed trade's exit.",
    "keywords": [
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.short",
      "ta.rising",
      "ta.falling",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "strategy",
      "overlay",
      "plot",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-148",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.exit_bar_index Example 1\")\n\n// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.\nif bar_index == 0\n    strategy.entry(\"Short\", strategy.short)\nif bar_index == last_bar_index - 10\n    strategy.close(\"Short\")\n\n// Calculate the amount of bars since the last closed trade.\nbarsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : na\n\nplot(barsSinceClosed, \"Bars since last closed trade\")\n\n// Calculates the average amount of bars per trade.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_bar_index Example 2\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Function that calculates the average amount of bars per trade.\navgBarsPerTrade() =>\n    sumBarsPerTrade = 0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        // Loop through all closed trades, starting with the oldest.\n        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1\n    result = nz(sumBarsPerTrade / strategy.closedtrades)\n\nplot(avgBarsPerTrade())\n```\n\n---\n\n## strategy.closedtrades.exit_comment()\n\nReturns the comment message of the closed trade's exit, or\nna if there is no entry with this trade_num.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.exit_comment()` Example\", overlay = true)\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Exit\", stop = open * 0.95, limit = close * 1.05, trail_points = 100, trail_offset = 0, comment_profit = \"TP\", comment_loss = \"SL\", comment_trailing = \"TRAIL\")\n\nexitStats() =>\n    int slCount = 0\n    int tpCount = 0\n    int trailCount = 0\n    \n    if strategy.closedtrades > 0\n        for i = 0 to strategy.closedtrades - 1\n            switch strategy.closedtrades.exit_comment(i)\n                \"TP\"    => tpCount    += 1\n                \"SL\"    => slCount    += 1\n                \"TRAIL\" => trailCount += 1\n    [slCount, tpCount, trailCount]\n\nvar testTable = table.new(position.top_right, 1, 4, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory\n    [slCount, tpCount, trailCount] = exitStats()\n    table.cell(testTable, 0, 0, \"Closed trades (\" + str.tostring(strategy.closedtrades) +\") stats:\")\n    table.cell(testTable, 0, 1, \"Stop Loss: \" + str.tostring(slCount))\n    table.cell(testTable, 0, 2, \"Take Profit: \" + str.tostring(tpCount))\n    table.cell(testTable, 0, 3, \"Trailing Stop: \" + str.tostring(trailCount))\n```\n\n---\n\n## strategy.closedtrades.exit_id()\n\nReturns the id of the closed trade's exit.\n\n### Returns\nReturns the id of the closed trade's exit.\n\n### Remarks\nThe function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1.",
    "keywords": [
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.short",
      "strategy.close",
      "ta.rising",
      "strategy.long",
      "ta.falling",
      "ta.crossover",
      "ta.sma",
      "strategy.exit",
      "table.new",
      "position.top_right",
      "color.orange",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "strategy",
      "overlay",
      "plot",
      "var",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-149",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.exit_id Example\", overlay = true)\n\n// Strategy calls to create single short and long trades\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.entry(\"Short Entry\", strategy.short)\n    \n// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id\n// We detect the correct entry id by determining if a position is long or short based on the position quantity\nif ta.change(strategy.opentrades) != 0\n    posSign = strategy.opentrades.size(strategy.opentrades - 1)\n    strategy.exit(posSign > 0 ? \"SL Long Exit\" : \"SL Short Exit\", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)\n\n// When a new closed trade is detected then we place a label above the bar with the exit info\nif ta.change(strategy.closedtrades) != 0\n    msg = \"Trade closed by: \" + strategy.closedtrades.exit_id(strategy.closedtrades - 1)\n    label.new(bar_index, high + (3 * ta.tr), msg)\n```\n\n---\n\n## strategy.closedtrades.exit_price()\n\nReturns the price of the closed trade's exit.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.exit_price Example 1\")\n\n// We are creating a long trade every 5 bars\nif bar_index % 5 == 0\n    strategy.entry(\"Long\", strategy.long)\nstrategy.close(\"Long\")\n\n// Return the exit price from the latest closed trade.\nexitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\n\nplot(exitPrice, \"Long exit price\")\n\n// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_price Example 2\")\n\n// Strategy calls to create single short and long trades.\nif bar_index == last_bar_index - 15\n    strategy.entry(\"Long Entry\", strategy.long)\nelse if bar_index == last_bar_index - 10\n    strategy.close(\"Long Entry\")\n    strategy.entry(\"Short\", strategy.short)\nelse if bar_index == last_bar_index - 5\n    strategy.close(\"Short\")\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)\n```\n\n---\n\n## strategy.closedtrades.exit_time()\n\nReturns the UNIX time of the closed trade's exit, expressed in milliseconds.",
    "keywords": [
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.long",
      "strategy.short",
      "ta.change",
      "strategy.opentrades",
      "strategy.exit",
      "ta.tr",
      "label.new",
      "strategy.close",
      "strategy",
      "overlay",
      "plot",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-150",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.closedtrades.exit_time Example 1\")\n\n// Enter long trades on three rising bars; exit on two falling bars.\nif ta.rising(close, 3)\n    strategy.entry(\"Long\", strategy.long)\nif ta.falling(close, 2)\n    strategy.close(\"Long\")\n\n// Calculate the average trade duration. \navgTradeDuration() =>\n    sumTradeDuration = 0\n    for i = 0 to strategy.closedtrades - 1\n        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)\n    result = nz(sumTradeDuration / strategy.closedtrades)\n\n// Display average duration converted to seconds and formatted using 2 decimal points.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")\n\n// Reopens a closed trade after X seconds.\n//@version=6\nstrategy(\"strategy.closedtrades.exit_time Example 2\")\n\n// Strategy calls to emulate a single long trade at the first bar.\nif bar_index == 0\n    strategy.entry(\"Long\", strategy.long)\n\nreopenPositionAfter(timeSec) =>\n    if strategy.closedtrades > 0\n        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000\n            strategy.entry(\"Long\", strategy.long)\n\n// Reopen last closed position after 120 sec.                \nreopenPositionAfter(120)\n\nif ta.change(strategy.opentrades) != 0\n    strategy.exit(\"Long\", stop = low * 0.9, profit = high * 2.5)\n```\n\n---\n\n## strategy.closedtrades.max_drawdown()\n\nReturns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed in strategy.account_currency.\n\n### Remarks\nThe function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.max_drawdown` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the closed trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")\n```\n\n---\n\n## strategy.closedtrades.max_drawdown_percent()\n\nReturns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.closedtrades.max_runup()\n\nReturns the maximum run up of the closed trade, i.e., the maximum possible profit during the trade, expressed in strategy.account_currency.",
    "keywords": [
      "strategy.closedtrades",
      "ta.rising",
      "strategy.entry",
      "strategy.long",
      "ta.falling",
      "strategy.close",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "ta.change",
      "strategy.opentrades",
      "strategy.exit",
      "i.e",
      "strategy.account_currency",
      "math.max",
      "strategy",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-151",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.max_runup` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade runup value from all of the closed trades.\nmaxTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxTradeRunUp(), \"Max trade runup\")\n```\n\n---\n\n## strategy.closedtrades.max_runup_percent()\n\nReturns the maximum run-up of the closed trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: Highest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.closedtrades.profit()\n\nReturns the profit/loss of the closed trade, expressed in strategy.account_currency. Losses are expressed as negative values.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.profit` Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate average gross profit by adding the difference between gross profit and commission.\navgGrossProfit() =>\n    sumGrossProfit = 0.0\n    for tradeNo = 0 to strategy.closedtrades - 1\n        sumGrossProfit += strategy.closedtrades.profit(tradeNo) - strategy.closedtrades.commission(tradeNo)\n    result = nz(sumGrossProfit / strategy.closedtrades)\n    \nplot(avgGrossProfit(), \"Average gross profit\")\n```\n\n---\n\n## strategy.closedtrades.profit_percent()\n\nReturns the profit/loss value of the closed trade, expressed as a percentage. Losses are expressed as negative values.\n\n---\n\n## strategy.closedtrades.size()\n\nReturns the direction and the number of contracts traded in the closed trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.",
    "keywords": [
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "math.max",
      "i.e",
      "strategy.account_currency",
      "strategy",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-152",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.default_entry_qty()",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.closedtrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts traded in the last closed trade.     \nplot(strategy.closedtrades.size(strategy.closedtrades - 1), \"Number of contracts traded\")\n\n// Calculates the average profit percentage for all closed trades.\n//@version=6\nstrategy(\"`strategy.closedtrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n\n// Calculate profit for both closed trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.closedtrades - 1\n    entryP = strategy.closedtrades.entry_price(tradeNo)\n    exitP = strategy.closedtrades.exit_price(tradeNo)\n    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for both closed trades.\navgProfitPct = nz(profitPct / strategy.closedtrades)\n\nplot(avgProfitPct)\n```\n\n---\n\n## strategy.convert_to_account()\n\nConverts the value from the currency that the symbol on the chart is traded in (syminfo.currency) to the currency used by the strategy (strategy.account_currency).\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.convert_to_account` Example 1\", currency = currency.EUR)\n\nplot(close, \"Close price using default currency\")\nplot(strategy.convert_to_account(close), \"Close price converted to strategy currency\")\n\n// Calculates the \"Buy and hold return\" using your account's currency.\n//@version=6\nstrategy(\"`strategy.convert_to_account` Example 2\", currency = currency.EUR)\n\ndateInput = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"From Date\", confirm = true)\n\nbuyAndHoldReturnPct(fromDate) =>\n    if time >= fromDate\n        money = close * syminfo.pointvalue\n        var initialBal = strategy.convert_to_account(money)\n        (strategy.convert_to_account(money) - initialBal) / initialBal * 100\n        \nplot(buyAndHoldReturnPct(dateInput))\n```\n\n---\n\n## strategy.convert_to_symbol()\n\nConverts the value from the currency used by the strategy (strategy.account_currency) to the currency that the symbol on the chart is traded in (syminfo.currency).\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.convert_to_symbol` Example\", currency = currency.EUR)\n\n// Calculate the max qty we can buy using current chart's currency.\ncalcContracts(accountMoney) =>\n    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)\n\n// Return max qty we can buy using 300 euros\nqt = calcContracts(300)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = qt)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n```\n\n---",
    "keywords": [
      "strategy.closedtrades",
      "math.floor",
      "strategy.equity",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.convert_to_account",
      "syminfo.currency",
      "strategy.account_currency",
      "input.time",
      "syminfo.pointvalue",
      "strategy.convert_to_symbol",
      "strategy",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-153",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.default_entry_qty()\n\nCalculates the default quantity, in units, of an entry order from strategy.entry or strategy.order if it were to fill at the specified fill_price value. The calculation depends on several strategy properties, including default_qty_type, default_qty_value, currency, and other parameters in the strategy function and their representation in the \"Properties\" tab of the strategy's settings.\n\n### Remarks\nThis function does not consider open positions simulated by a strategy. For example, if a strategy script has an open position from a long order with a qty of 10 units, using the strategy.entry function to simulate a short order with a qty of 5 will prompt the script to sell 15 units to reverse the position. This function will still return 5 in such a case since it doesn't consider an open trade. This value represents the default calculated quantity of an order. Order placement commands can override the default value by explicitly passing a new qty value in the function call.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"Supertrend Strategy\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 15)\n\n//@variable The length of the ATR calculation.\natrPeriod = input(10, \"ATR Length\")\n//@variable The ATR multiplier.\nfactor = input.float(3.0, \"Factor\", step = 0.01)\n//@variable The tick offset of the stop order.\nstopOffsetInput = input.int(100, \"Tick offset for entry stop\")\n\n// Get the direction of the SuperTrend.\n[_, direction] = ta.supertrend(factor, atrPeriod)\n\nif ta.change(direction) < 0\n    //@variable The stop price of the entry order.\n    stopPrice = close + syminfo.mintick * stopOffsetInput\n    //@variable The expected default fill quantity at the `stopPrice`. This value may not reflect actual qty of the filled order, because fill price may be different.\n    calculatedQty = strategy.default_entry_qty(stopPrice)\n    strategy.entry(\"My Long Entry Id\", strategy.long, stop = stopPrice)\n    label.new(bar_index, stopPrice, str.format(\"Stop set at {0}\\nExpected qty at {0}: {1}\", math.round_to_mintick(stopPrice), calculatedQty))\n\nif ta.change(direction) > 0\n    strategy.close_all()\n```\n\n---\n\n## strategy.entry()\n\nCreates a new order to open or add to a position. If an unfilled order with the same id exists, a call to this command modifies that order.",
    "keywords": [
      "strategy.default_entry_qty",
      "strategy.entry",
      "strategy.order",
      "strategy.percent_of_equity",
      "input.float",
      "input.int",
      "ta.supertrend",
      "ta.change",
      "syminfo.mintick",
      "strategy.long",
      "label.new",
      "str.format",
      "math.round_to_mintick",
      "strategy.close_all",
      "strategy",
      "overlay",
      "input",
      "fill",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-154",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.exit()",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"Market order strategy\", overlay = true)\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to close the short trade and enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28)\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to close the long trade and enter a short position when `sma14` crosses under `sma28`.\nif ta.crossunder(sma14, sma28)\n    strategy.entry(\"My Short Entry ID\", strategy.short)\n\n//@version=6\nstrategy(\"Limit order strategy\", overlay=true, margin_long=100, margin_short=100)\n\n//@variable The distance from the `close` price for each limit order.\nfloat limitOffsetInput = input.int(100, \"Limit offset, in ticks\", 1) * syminfo.mintick\n\n//@function Draws a label and line at the specified `price` to visualize a limit order's level. \ndrawLimit(float price, bool isLong) =>\n    color col = isLong ? color.blue : color.red\n    label.new(\n         bar_index, price, (isLong ? \"Long\" : \"Short\") + \" limit order created\", \n         style = label.style_label_right, color = col, textcolor = color.white\n     )\n    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// Initialize two `line` variables to reference limit line IDs.\nvar line longLimit  = na\nvar line shortLimit = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28)\n    // Cancel any unfilled sell orders with the specified ID.\n    strategy.cancel(\"My Short Entry ID\")\n    //@variable The limit price level. Its value is `limitOffsetInput` ticks below the current `close`.\n    float limitLevel = close - limitOffsetInput\n    // Place a long limit order to close the short trade and enter a long position at the `limitLevel`.\n    strategy.entry(\"My Long Entry ID\", strategy.long, limit = limitLevel)\n    // Make new drawings for the long limit and stop extending the `shortLimit` line.\n    longLimit := drawLimit(limitLevel, isLong = true)\n    shortLimit.stopExtend()\n    \nif ta.crossunder(sma14, sma28)\n    // Cancel any unfilled buy orders with the specified ID.\n    strategy.cancel(\"My Long Entry ID\")\n    //@variable The limit price level. Its value is `limitOffsetInput` ticks above the current `close`.\n    float limitLevel = close + limitOffsetInput\n    // Place a short limit order to close the long trade and enter a short position at the `limitLevel`.\n    strategy.entry(\"My Short Entry ID\", strategy.short, limit = limitLevel)\n    // Make new drawings for the short limit and stop extending the `shortLimit` line.\n    shortLimit := drawLimit(limitLevel, isLong = false)\n    longLimit.stopExtend()\n```\n\n---",
    "keywords": [
      "ta.sma",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "ta.crossunder",
      "strategy.short",
      "input.int",
      "syminfo.mintick",
      "color.blue",
      "color.red",
      "label.new",
      "label.style_label_right",
      "color.white",
      "line.new",
      "extend.right",
      "line.style_dashed",
      "l.set_x",
      "l.set_extend",
      "extend.none",
      "strategy.cancel",
      "strategy",
      "overlay",
      "input",
      "fill",
      "var",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-155",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.exit()\n\nCreates price-based orders to exit from an open position. If unfilled exit orders with the same id exist, calls to this command modify those orders. This command can generate more than one type of exit order, depending on the specified parameters. However, it does not create market orders. To exit from a position with a market order, use strategy.close or strategy.close_all.\n\n### Remarks\nA single call to the strategy.exit command can generate exit orders for several entries in an open position, depending on the call's from_entry value. If the call does not include a from_entry argument, it creates exit orders for all open trades, even the ones opened after the call, until the position closes. See this section of our User Manual to learn more. When a position consists of several open trades, and the close_entries_rule in the strategy declaration statement is \"FIFO\" (default), the orders from a strategy.exit call exit from the position starting with the first open trade. This behavior applies even if the from_entry value is the entry ID of different open trades. However, in that case, the maximum size of the exit orders still depends on the trades opened by orders with the from_entry ID. For more information, see this section of our User Manual. If a strategy.exit call includes arguments for creating stop-loss and trailing stop orders, the command places only the order that is supposed to fill first, because both orders are of the \"stop\" type.",
    "keywords": [
      "strategy.exit",
      "strategy.close",
      "strategy.close_all",
      "strategy",
      "fill",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-156",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.opentrades.commission()",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"Exit bracket strategy\", overlay = true)\n\n// Inputs that define the profit and loss amount of each trade as a tick distance from the entry price.\nint profitDistanceInput = input.int(100, \"Profit distance, in ticks\", 1)\nint lossDistanceInput   = input.int(100, \"Loss distance, in ticks\", 1)\n\n// Variables to track the take-profit and stop-loss price. \nvar float takeProfit = na\nvar float stopLoss   = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28) and strategy.opentrades == 0\n    // Place a market order to enter a long position.\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n    // Place a take-profit and stop-loss order when the entry order fills. \n    strategy.exit(\"My Long Exit ID\", \"My Long Entry ID\", profit = profitDistanceInput, loss = lossDistanceInput)\n\nif ta.change(strategy.opentrades) == 1\n    //@variable The long entry price.\n    float entryPrice = strategy.opentrades.entry_price(0)\n    // Update the `takeProfit` and `stopLoss` values.\n    takeProfit := entryPrice + profitDistanceInput * syminfo.mintick\n    stopLoss   := entryPrice - lossDistanceInput * syminfo.mintick\n\nif ta.change(strategy.closedtrades) == 1\n    // Reset the `takeProfit` and `stopLoss`.\n    takeProfit := na\n    stopLoss   := na\n\n// Plot the `takeProfit` and `stopLoss`.\nplot(takeProfit, \"Take-profit level\", color.green, 2, plot.style_linebr)\nplot(stopLoss, \"Stop-loss level\", color.red, 2, plot.style_linebr)\n\n//@version=6\nstrategy(\"Trailing stop strategy\", overlay = true)\n\n//@variable The distance required to activate the trailing stop.\nfloat activationDistanceInput = input.int(100, \"Trail activation distance, in ticks\") * syminfo.mintick \n//@variable The number of ticks the trailing stop follows behind the price as it reaches new peaks. \nint trailDistanceInput = input.int(100, \"Trail distance, in ticks\")\n\n//@function Draws a label and line at the specified `price` to visualize a trailing stop order's activation level. \ndrawActivation(float price) =>\n    label.new(\n         bar_index, price, \"Activation level\", style = label.style_label_right, \n         color = color.gray, textcolor = color.white\n     )\n    line.new(\n         bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = color.gray\n     )\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// The activation line, active trailing stop price, and active trailing stop flag. \nvar line activationLine     = na\nvar float trailingStopPrice = na\nvar bool isActive           = false\n\nif bar_index % 100 == 0 and strategy.opentrades == 0\n    trailingStopPrice := na\n    isActive          := false\n    // Place a market order to enter a long position.\n    strategy.entry(\"My Long Entry ID\", strategy.long)\n    //@variable The activation level's price. \n    float activationPrice = close + activationDistanceInput\n    // Create a trailing stop order that activates the defined number of ticks above the entry price.\n    strategy.exit(\n         \"My Long Exit ID\", \"My Long Entry ID\", trail_price = activationPrice, trail_offset = trailDistanceInput,\n         oca_name = \"Exit\"\n     )\n    // Create new drawings at the `activationPrice`.\n    activationLine := drawActivation(activationPrice)\n\n// Logic for trailing stop visualization. \nif strategy.opentrades == 1\n    // Stop extending the `activationLine` when the stop activates.\n    if not isActive and high > activationLine.get_price(bar_index)\n        isActive := true\n        activationLine.stopExtend()\n    // Update the `trailingStopPrice` while the trailing stop is active. \n    if isActive\n        float offsetPrice = high - trailDistanceInput * syminfo.mintick\n        trailingStopPrice := math.max(nz(trailingStopPrice, offsetPrice), offsetPrice)\n\n// Close the trade with a market order if the trailing stop does not activate before the next 300th bar. \nif not isActive and bar_index % 300 == 0\n    strategy.close_all(\"Market close\")\n\n// Reset the `trailingStopPrice` and `isActive` flags when the trade closes, and stop extending the `activationLine`.\nif ta.change(strategy.closedtrades) > 0\n    if not isActive\n        activationLine.stopExtend()\n    trailingStopPrice := na\n    isActive          := false\n\n// Plot the `trailingStopPrice`.\nplot(trailingStopPrice, \"Trailing stop\", color.red, 3, plot.style_linebr)\n```\n\n---",
    "keywords": [
      "input.int",
      "ta.sma",
      "ta.crossover",
      "strategy.opentrades",
      "strategy.entry",
      "strategy.long",
      "strategy.exit",
      "ta.change",
      "syminfo.mintick",
      "strategy.closedtrades",
      "color.green",
      "plot.style_linebr",
      "color.red",
      "label.new",
      "label.style_label_right",
      "color.gray",
      "color.white",
      "line.new",
      "extend.right",
      "line.style_dashed",
      "l.set_x",
      "l.set_extend",
      "extend.none",
      "math.max",
      "strategy.close_all",
      "strategy",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "method",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-157",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.opentrades.commission()\n\nReturns the sum of entry and exit fees paid in the open trade, expressed in strategy.account_currency.\n\n### Code Example\n```pine\n// Calculates the gross profit or loss for the current open position.\n//@version=6\nstrategy(\"`strategy.opentrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate gross profit or loss for open positions only.\ntradeOpenGrossPL() =>\n    sumOpenGrossPL = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)\n    result = sumOpenGrossPL\n    \nplot(tradeOpenGrossPL())\n```\n\n---\n\n## strategy.opentrades.entry_bar_index()\n\nReturns the bar_index of the open trade's entry.\n\n### Code Example\n```pine\n// Wait 10 bars and then close the position.\n//@version=6\nstrategy(\"`strategy.opentrades.entry_bar_index` Example\")\n\nbarsSinceLastEntry() =>\n    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na\n\n// Enter a long position if there are no open positions.\nif strategy.opentrades == 0\n    strategy.entry(\"Long\", strategy.long)\n\n// Close the long position after 10 bars. \nif barsSinceLastEntry() >= 10\n    strategy.close(\"Long\")\n```\n\n---\n\n## strategy.opentrades.entry_comment()\n\nReturns the comment message of the open trade's entry, or\nna if there is no entry with this trade_num.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.opentrades.entry_comment()` Example\", overlay = true)\n\nstopPrice = open * 1.01\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))\n\nvar testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)\n\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    table.cell(testTable, 0, 0, 'Last entry stats')\n    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.opentrades.entry_comment(strategy.opentrades - 1))\n    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.opentrades.entry_price(strategy.opentrades - 1)))\n```\n\n---\n\n## strategy.opentrades.entry_id()\n\nReturns the id of the open trade's entry.\n\n### Returns\nReturns the id of the open trade's entry.\n\n### Remarks\nThe function returns na if trade_num is not in the range: 0 to strategy.opentrades-1.",
    "keywords": [
      "strategy.opentrades",
      "strategy.account_currency",
      "strategy.commission",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "ta.crossover",
      "ta.sma",
      "str.tostring",
      "table.new",
      "position.top_right",
      "color.orange",
      "barstate.islastconfirmedhistory",
      "barstate.isrealtime",
      "table.cell",
      "strategy",
      "overlay",
      "plot",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-158",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.opentrades.max_drawdown()",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.opentrades.entry_id` Example\", overlay = true)\n\n// We enter a long position when 14 period sma crosses over 28 period sma.\n// We enter a short position when 14 period sma crosses under 28 period sma.\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\n// Strategy calls to enter a long or short position when the corresponding condition is met.\nif longCondition\n    strategy.entry(\"Long entry at bar #\" + str.tostring(bar_index), strategy.long)\nif shortCondition\n    strategy.entry(\"Short entry at bar #\" + str.tostring(bar_index), strategy.short)\n\n// Display ID of the latest open position.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high + (2 * ta.tr), \"Last opened position is \\n \" + strategy.opentrades.entry_id(strategy.opentrades - 1))\n```\n\n---\n\n## strategy.opentrades.entry_price()\n\nReturns the price of the open trade's entry.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.opentrades.entry_price Example 1\", overlay = true)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif ta.crossover(close, ta.sma(close, 14))\n    strategy.entry(\"Long\", strategy.long)\n\n// Return the entry price for the latest closed trade.\ncurrEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)\ncurrExitPrice = currEntryPrice * 1.05\n\nif high >= currExitPrice\n    strategy.close(\"Long\")\n\nplot(currEntryPrice, \"Long entry price\", style = plot.style_linebr)\nplot(currExitPrice, \"Long exit price\", color.green, style = plot.style_linebr)\n\n// Calculates the average price for the open position.\n//@version=6\nstrategy(\"strategy.opentrades.entry_price Example 2\", pyramiding = 2)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates the average price for the open position.\navgOpenPositionPrice() =>\n    sumOpenPositionPrice = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size\n    result = nz(sumOpenPositionPrice / strategy.opentrades)\n\nplot(avgOpenPositionPrice())\n```\n\n---\n\n## strategy.opentrades.entry_time()\n\nReturns the UNIX time of the open trade's entry, expressed in milliseconds.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.opentrades.entry_time Example\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculates duration in milliseconds since the last position was opened.\ntimeSinceLastEntry()=>\n    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : na\n\nplot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, \"Days since last entry\")\n```\n\n---",
    "keywords": [
      "strategy.opentrades",
      "ta.crossover",
      "ta.sma",
      "ta.crossunder",
      "strategy.entry",
      "str.tostring",
      "strategy.long",
      "strategy.short",
      "barstate.islastconfirmedhistory",
      "label.new",
      "ta.tr",
      "strategy.close",
      "plot.style_linebr",
      "color.green",
      "strategy.position_size",
      "strategy",
      "overlay",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-159",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.opentrades.profit()",
    "content": "## strategy.opentrades.max_drawdown()\n\nReturns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed in strategy.account_currency.\n\n### Remarks\nThe function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.opentrades.max_drawdown Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max drawdown of the latest open trade.\nplot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), \"Max drawdown of the latest open trade\")\n\n// Calculates the max trade drawdown value for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.max_drawdown` Example 2\", pyramiding = 100)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Get the biggest max trade drawdown value from all of the open trades.\nmaxTradeDrawDown() =>\n    maxDrawdown = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))\n    result = maxDrawdown\n\nplot(maxTradeDrawDown(), \"Biggest max drawdown\")\n```\n\n---\n\n## strategy.opentrades.max_drawdown_percent()\n\nReturns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.opentrades.max_runup()\n\nReturns the maximum run up of the open trade, i.e., the maximum possible profit during the trade, expressed in strategy.account_currency.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.opentrades.max_runup Example 1\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the max runup of the latest open trade.\nplot(strategy.opentrades.max_runup(strategy.opentrades - 1), \"Max runup of the latest open trade\")\n\n// Calculates the max trade runup value for all open trades.\n//@version=6\nstrategy(\"strategy.opentrades.max_runup Example 2\", pyramiding = 100)\n\n// Enter a long position every 30 bars.\nif bar_index % 30 == 0\n    strategy.entry(\"Long\", strategy.long)\n\n// Calculate biggest max trade runup value from all of the open trades.\nmaxOpenTradeRunUp() =>\n    maxRunup = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))\n    result = maxRunup\n\nplot(maxOpenTradeRunUp(), \"Biggest max runup of all open trades\")\n```\n\n---\n\n## strategy.opentrades.max_runup_percent()\n\nReturns the maximum run-up of the open trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: Highest Value During Trade / (Entry Price x Quantity) * 100.\n\n---",
    "keywords": [
      "strategy.opentrades",
      "i.e",
      "strategy.account_currency",
      "strategy.closedtrades",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "math.max",
      "strategy",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-160",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.opentrades.profit()\n\nReturns the profit/loss of the open trade, expressed in strategy.account_currency. Losses are expressed as negative values.\n\n### Code Example\n```pine\n// Returns the profit of the last open trade.\n//@version=6\nstrategy(\"`strategy.opentrades.profit` Example 1\", commission_type = strategy.commission.percent, commission_value = 0.1)\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\nplot(strategy.opentrades.profit(strategy.opentrades - 1), \"Profit of the latest open trade\")\n\n// Calculates the profit for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.profit` Example 2\", pyramiding = 5)\n\n// Strategy calls to enter 5 long positions every 2 bars.\nif bar_index % 2 == 0\n    strategy.entry(\"Long\", strategy.long, qty = 5)\n\n// Calculate open profit or loss for the open positions.\ntradeOpenPL() =>\n    sumProfit = 0.0\n    for tradeNo = 0 to strategy.opentrades - 1\n        sumProfit += strategy.opentrades.profit(tradeNo)\n    result = sumProfit\n    \nplot(tradeOpenPL(), \"Profit of all open trades\")\n```\n\n---\n\n## strategy.opentrades.profit_percent()\n\nReturns the profit/loss of the open trade, expressed as a percentage. Losses are expressed as negative values.\n\n---\n\n## strategy.opentrades.size()\n\nReturns the direction and the number of contracts traded in the open trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`strategy.opentrades.size` Example 1\")\n\n// We calculate the max amt of shares we can buy.\namtShares = math.floor(strategy.equity / close)\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long, qty = amtShares)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Plot the number of contracts in the latest open trade.\nplot(strategy.opentrades.size(strategy.opentrades - 1), \"Amount of contracts in latest open trade\")\n\n// Calculates the average profit percentage for all open trades.\n//@version=6\nstrategy(\"`strategy.opentrades.size` Example 2\")\n\n// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.\nif bar_index % 15 == 0\n    strategy.entry(\"Long\", strategy.long)\nif bar_index % 20 == 0\n    strategy.close(\"Long\")\n\n// Calculate profit for all open trades.\nprofitPct = 0.0\nfor tradeNo = 0 to strategy.opentrades - 1\n    entryP = strategy.opentrades.entry_price(tradeNo)\n    exitP = close\n    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100\n    \n// Calculate average profit percent for all open trades.\navgProfitPct = nz(profitPct / strategy.opentrades)\nplot(avgProfitPct)\n```\n\n---\n\n## strategy.order()\n\nCreates a new order to open, add to, or exit from a position. If an unfilled order with the same id exists, a call to this command modifies that order.",
    "keywords": [
      "strategy.opentrades",
      "strategy.account_currency",
      "strategy.commission",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "math.floor",
      "strategy.equity",
      "strategy.order",
      "strategy",
      "plot",
      "fill",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-161",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "strategy.risk.allow_entry_in()",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"Market order strategy\", overlay = true)\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\n// Place a market order to enter a long position when `sma14` crosses over `sma28`.\nif ta.crossover(sma14, sma28) and strategy.position_size == 0\n    strategy.order(\"My Long Entry ID\", strategy.long)\n\n// Place a market order to sell the same quantity as the long trade when `sma14` crosses under `sma28`, \n// effectively closing the long position.\nif ta.crossunder(sma14, sma28) and strategy.position_size > 0\n    strategy.order(\"My Long Exit ID\", strategy.short)\n\n//@version=6\nstrategy(\"Limit and stop exit strategy\", overlay = true)\n\n//@variable The distance from the long entry price for each short limit order.\nfloat shortOffsetInput = input.int(200, \"Sell limit/stop offset, in ticks\", 1) * syminfo.mintick\n\n//@function Draws a label and line at the specified `price` to visualize a limit order's level. \ndrawLimit(float price, bool isLong, bool isStop = false) =>\n    color col = isLong ? color.blue : color.red\n    label.new(\n         bar_index, price, (isLong ? \"Long \" : \"Short \") + (isStop ? \"stop\" : \"limit\") + \" order created\", \n         style = label.style_label_right, color = col, textcolor = color.white\n     )\n    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)\n\n//@function Stops the `l` line from extending further.\nmethod stopExtend(line l) =>\n    l.set_x2(bar_index)\n    l.set_extend(extend.none)\n\n// Initialize two `line` variables to reference limit and stop line IDs.\nvar line profitLimit = na\nvar line lossStop    = na\n\n// Calculate a 14-bar and 28-bar moving average of `close` prices.\nfloat sma14 = ta.sma(close, 14)\nfloat sma28 = ta.sma(close, 28)\n\nif ta.crossover(sma14, sma28) and strategy.position_size == 0\n    // Place a market order to enter a long position.\n    strategy.order(\"My Long Entry ID\", strategy.long)\n    \nif strategy.position_size > 0 and strategy.position_size[1] == 0\n    //@variable The entry price of the long trade. \n    float entryPrice = strategy.opentrades.entry_price(0)\n    // Calculate short limit and stop levels above and below the `entryPrice`.\n    float profitLevel = entryPrice + shortOffsetInput\n    float lossLevel   = entryPrice - shortOffsetInput\n    // Place short limit and stop orders at the `profitLevel` and `lossLevel`. \n    strategy.order(\"Profit\", strategy.short, limit = profitLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)\n    strategy.order(\"Loss\", strategy.short, stop = lossLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)\n    // Make new drawings for the `profitLimit` and `lossStop` lines.\n    profitLimit := drawLimit(profitLevel, isLong = false)\n    lossStop    := drawLimit(lossLevel, isLong = false, isStop = true)\n\nif ta.change(strategy.closedtrades) > 0\n    // Stop extending the `profitLimit` and `lossStop` lines.\n    profitLimit.stopExtend()\n    lossStop.stopExtend()\n```\n\n---",
    "keywords": [
      "ta.sma",
      "ta.crossover",
      "strategy.position_size",
      "strategy.order",
      "strategy.long",
      "ta.crossunder",
      "strategy.short",
      "input.int",
      "syminfo.mintick",
      "color.blue",
      "color.red",
      "label.new",
      "label.style_label_right",
      "color.white",
      "line.new",
      "extend.right",
      "line.style_dashed",
      "l.set_x",
      "l.set_extend",
      "extend.none",
      "strategy.opentrades",
      "strategy.oca",
      "ta.change",
      "strategy.closedtrades",
      "strategy",
      "overlay",
      "input",
      "var",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-162",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## strategy.risk.allow_entry_in()\n\nThis function can be used to specify in which market direction the strategy.entry function is allowed to open positions.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.risk.allow_entry_in\")\n\nstrategy.risk.allow_entry_in(strategy.direction.long)\nif open > close\n    strategy.entry(\"Long\", strategy.long)\n// Instead of opening a short position with 10 contracts, this command will close long entries.\nif open < close\n    strategy.entry(\"Short\", strategy.short, qty = 10)\n```\n\n---\n\n## strategy.risk.max_cons_loss_days()\n\nThe purpose of this rule is to cancel all pending orders, close all open positions and stop placing orders after a specified number of consecutive days with losses. The rule affects the whole strategy.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"risk.max_cons_loss_days Demo 1\")\nstrategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.\nplot(strategy.position_size)\n```\n\n---\n\n## strategy.risk.max_drawdown()\n\nThe purpose of this rule is to determine maximum drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"risk.max_drawdown Demo 1\")\nstrategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity\nplot(strategy.position_size)\n\n//@version=6\nstrategy(\"risk.max_drawdown Demo 2\", currency = \"EUR\")\nstrategy.risk.max_drawdown(2000, strategy.cash) // set maximum drawdown to 2000 EUR from maximum equity\nplot(strategy.position_size)\n```\n\n---\n\n## strategy.risk.max_intraday_filled_orders()\n\nThe purpose of this rule is to determine maximum number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum number of filled orders is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"risk.max_intraday_filled_orders Demo\")\nstrategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).\nif open > close\n    strategy.entry(\"buy\", strategy.long)\nif open < close\n    strategy.entry(\"sell\", strategy.short)\n```\n\n---\n\n## strategy.risk.max_intraday_loss()\n\nThe maximum loss value allowed during a day. It is specified either in money (base currency), or in percentage of maximum intraday equity (0 -100).",
    "keywords": [
      "strategy.risk",
      "strategy.entry",
      "strategy.direction",
      "strategy.long",
      "strategy.short",
      "risk.max_cons_loss_days",
      "strategy.position_size",
      "risk.max_drawdown",
      "strategy.percent_of_equity",
      "strategy.cash",
      "risk.max_intraday_filled_orders",
      "strategy",
      "plot",
      "fill",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-163",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n// Sets the maximum intraday loss using the strategy's equity value.\n//@version=6\nstrategy(\"strategy.risk.max_intraday_loss Example 1\", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)\n\n// Input for maximum intraday loss %. \nlossPct = input.float(10)\n\n// Set maximum intraday loss to our lossPct input\nstrategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n    strategy.entry(\"Short\", strategy.short)\n\n// Store equity value from the beginning of the day\neqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)\n\n// Calculate change of the current equity from the beginning of the current day.\neqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)\n\n// Plot it\nplot(eqChgPct) \nhline(-lossPct)\n\n// Sets the maximum intraday loss using the strategy's cash value.\n//@version=6\nstrategy(\"strategy.risk.max_intraday_loss Example 2\", overlay = false)\n\n// Input for maximum intraday loss in absolute cash value of the symbol. \nabsCashLoss = input.float(5)\n\n// Set maximum intraday loss to `absCashLoss` in account currency.\nstrategy.risk.max_intraday_loss(absCashLoss, strategy.cash)\n\n// Enter Short at bar_index zero.\nif bar_index == 0\n    strategy.entry(\"Short\", strategy.short)\n\n// Store the open price value from the beginning of the day.\nbeginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)\n\n// Calculate the absolute price change for the current period.\npriceChg = (close - beginPrice)\n\nhline(absCashLoss)\nplot(priceChg)\n```\n\n---\n\n## strategy.risk.max_position_size()\n\nThe purpose of this rule is to determine maximum size of a market position. The rule affects the following function: strategy.entry. The 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units, so the total position size doesn't exceed the value specified in 'strategy.risk.max_position_size'. If minimum possible quantity still violates the rule, the order will not be placed.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"risk.max_position_size Demo\", default_qty_value = 100)\nstrategy.risk.max_position_size(10)\nif open > close\n    strategy.entry(\"buy\", strategy.long)\nplot(strategy.position_size) // max plot value will be 10\n```\n\n---\n\n## string()\n\nCasts na to string\n\n### Returns\nThe value of the argument after casting to string.\n\n---\n\n## syminfo.prefix()\n\nReturns exchange prefix of the symbol, e.g. \"NASDAQ\".\n\n### Returns\nReturns exchange prefix of the symbol, e.g. \"NASDAQ\".\n\n### Remarks\nThe result of the function is used in the ticker.new/ticker.modify and request.security.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.prefix fun\", overlay=true)\ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)\n```\n\n---\n\n## syminfo.ticker()\n\nReturns symbol name without exchange prefix, e.g. \"AAPL\".\n\n### Returns\nReturns symbol name without exchange prefix, e.g. \"AAPL\".\n\n### Remarks\nThe result of the function is used in the ticker.new/ticker.modify and request.security.",
    "keywords": [
      "strategy.risk",
      "strategy.percent_of_equity",
      "input.float",
      "strategy.entry",
      "strategy.short",
      "ta.valuewhen",
      "ta.change",
      "strategy.equity",
      "strategy.cash",
      "risk.max_position_size",
      "strategy.long",
      "strategy.position_size",
      "syminfo.prefix",
      "e.g",
      "ticker.new",
      "ticker.modify",
      "request.security",
      "input.symbol",
      "syminfo.ticker",
      "session.extended",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "hline",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-164",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.ticker fun\", overlay=true) \ni_sym = input.symbol(\"NASDAQ:AAPL\")\npref = syminfo.prefix(i_sym)\ntick = syminfo.ticker(i_sym)\nt = ticker.new(pref, tick, session.extended)\ns = request.security(t, \"1D\", close)\nplot(s)\n```\n\n---\n\n## ta.alma()\n\nArnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average.\n\n### Returns\nArnaud Legoux Moving Average.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.alma\", overlay=true) \nplot(ta.alma(close, 9, 0.85, 6))\n\n// same on pine, but much less efficient\npine_alma(series, windowsize, offset, sigma) =>\n    m = offset * (windowsize - 1)\n    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true\n    s = windowsize / sigma\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to windowsize - 1\n        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))\n        norm := norm + weight\n        sum := sum + series[windowsize - i - 1] * weight\n    sum / norm\nplot(pine_alma(close, 9, 0.85, 6))\n```\n\n---\n\n## ta.atr()\n\nFunction atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1])).\n\n### Returns\nAverage true range.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.atr\")\nplot(ta.atr(14))\n\n//the same on pine\npine_atr(length) =>\n    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))\n    //true range can be also calculated with ta.tr(true)\n    ta.rma(trueRange, length)\n\nplot(pine_atr(14))\n```\n\n---\n\n## ta.barssince()\n\nCounts the number of bars since the last time the condition was true.\n\n### Returns\nNumber of bars since condition was true.\n\n### Remarks\nIf the condition has never been met prior to the current bar, the function returns na. Please note that using this variable/function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.barssince\")\n// get number of bars since last color.green bar\nplot(ta.barssince(close >= open))\n```\n\n---\n\n## ta.bb()\n\nBollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences.\n\n### Returns\nBollinger Bands.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "syminfo.ticker",
      "input.symbol",
      "syminfo.prefix",
      "ticker.new",
      "session.extended",
      "request.security",
      "ta.alma",
      "math.floor",
      "math.exp",
      "math.pow",
      "ta.atr",
      "math.max",
      "math.abs",
      "ta.tr",
      "ta.rma",
      "ta.barssince",
      "color.green",
      "ta.bb",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-165",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.bb\")\n\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n// the same on pine\nf_bb(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    [basis, basis + dev, basis - dev]\n\n[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)\n```\n\n---\n\n## ta.bbw()\n\nBollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band.\n\n### Returns\nBollinger Bands Width.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.bbw\")\n\nplot(ta.bbw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_bbw(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    (((basis + dev) - (basis - dev)) / basis) * 100\n\nplot(f_bbw(close, 5, 4))\n```\n\n---\n\n## ta.cci()\n\nThe CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers.\n\n### Returns\nCommodity channel index of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.change()\n\nCompares the current source value to its value length bars ago and returns the difference.\n\n### Returns\nThe difference between the values when they are numerical. When a 'bool' source is used, returns true when the current source is different from the previous source.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime) != 0\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')\n```\n\n---\n\n## ta.cmo()\n\nChande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period.\n\n### Returns\nChande Momentum Oscillator.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.cmo\")\nplot(ta.cmo(close, 5), color=color.yellow)\n\n// the same on pine\nf_cmo(src, length) =>\n    float mom = ta.change(src)\n    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)\n    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)\n    100 * (sm1 - sm2) / (sm1 + sm2)\n\nplot(f_cmo(close, 5))\n```\n\n---\n\n## ta.cog()\n\nThe cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio.\n\n### Returns\nCenter of Gravity.\n\n### Remarks\nna values in the source series are ignored.",
    "keywords": [
      "ta.bb",
      "color.yellow",
      "ta.sma",
      "ta.stdev",
      "ta.bbw",
      "ta.cci",
      "ta.change",
      "color.new",
      "color.green",
      "ta.cmo",
      "math.sum",
      "ta.cog",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-166",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.cog\", overlay=true) \nplot(ta.cog(close, 10))\n\n// the same on pine\npine_cog(source, length) =>\n    sum = math.sum(source, length)\n    num = 0.0\n    for i = 0 to length - 1\n        price = source[i]\n        num := num + price * (i + 1)\n    -num / sum\n\nplot(pine_cog(close, 10))\n```\n\n---\n\n## ta.correlation()\n\nCorrelation coefficient. Describes the degree to which two series tend to deviate from their ta.sma values.\n\n### Returns\nCorrelation coefficient.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.cross()\n\n### Returns\ntrue if two series have crossed each other, otherwise false.\n\n---\n\n## ta.crossover()\n\nThe source1-series is defined as having crossed over source2-series if, on the current bar, the value of source1 is greater than the value of source2, and on the previous bar, the value of source1 was less than or equal to the value of source2.\n\n### Returns\ntrue if source1 crossed over source2 otherwise false.\n\n---\n\n## ta.crossunder()\n\nThe source1-series is defined as having crossed under source2-series if, on the current bar, the value of source1 is less than the value of source2, and on the previous bar, the value of source1 was greater than or equal to the value of source2.\n\n### Returns\ntrue if source1 crossed under source2 otherwise false.\n\n---\n\n## ta.cum()\n\nCumulative (total) sum of source. In other words it's a sum of all elements of source.\n\n### Returns\nTotal sum series.\n\n---\n\n## ta.dev()\n\nMeasure of difference between the series and it's ta.sma\n\n### Returns\nDeviation of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.dev\")\nplot(ta.dev(close, 10))\n\n// the same on pine\npine_dev(source, length) =>\n    mean = ta.sma(source, length)\n    sum = 0.0\n    for i = 0 to length - 1\n        val = source[i]\n        sum := sum + math.abs(val - mean)\n    dev = sum/length\nplot(pine_dev(close, 10))\n```\n\n---\n\n## ta.dmi()\n\nThe dmi function returns the directional movement index.\n\n### Returns\nTuple of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX).\n\n### Code Example\n```pine\n//@version=6\nindicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)\nlen = input.int(17, minval=1, title=\"DI Length\")\nlensig = input.int(14, title=\"ADX Smoothing\", minval=1)\n[diplus, diminus, adx] = ta.dmi(len, lensig)\nplot(adx, color=color.red, title=\"ADX\")\nplot(diplus, color=color.blue, title=\"+DI\")\nplot(diminus, color=color.orange, title=\"-DI\")\n```\n\n---\n\n## ta.ema()\n\nThe ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: EMA = alpha * source + (1 - alpha) * EMA[1], where alpha = 2 / (length + 1).\n\n### Returns\nExponential moving average of source with alpha = 2 / (length + 1).",
    "keywords": [
      "ta.cog",
      "math.sum",
      "ta.correlation",
      "ta.sma",
      "ta.cross",
      "ta.crossover",
      "ta.crossunder",
      "ta.cum",
      "ta.dev",
      "math.abs",
      "ta.dmi",
      "format.price",
      "input.int",
      "color.red",
      "color.blue",
      "color.orange",
      "ta.ema",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-167",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Remarks\nPlease note that using this variable/function can cause indicator repainting. na values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.ema\")\nplot(ta.ema(close, 15))\n\n//the same on pine\npine_ema(src, length) =>\n    alpha = 2 / (length + 1)\n    sum = 0.0\n    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_ema(close,15))\n```\n\n---\n\n## ta.falling()\n\nTest if the source series is now falling for length bars long.\n\n### Returns\ntrue if current source value is less than any previous source value for length bars back, false otherwise.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.highest()\n\nHighest value for a given number of bars back.\n\n### Returns\nHighest value in the series.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses high as a source series. na values in the source series are ignored.\n\n---\n\n## ta.highestbars()\n\nHighest value offset for a given number of bars back.\n\n### Returns\nOffset to the highest bar.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses high as a source series. na values in the source series are ignored.\n\n---\n\n## ta.hma()\n\nThe hma function returns the Hull Moving Average.\n\n### Returns\nHull moving average of 'source' for 'length' bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Hull Moving Average\")\nsrc = input(defval=close, title=\"Source\")\nlength = input(defval=9, title=\"Length\")\nhmaBuildIn = ta.hma(src, length)\nplot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)\n```\n\n---\n\n## ta.kc()\n\nKeltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below.\n\n### Returns\nKeltner Channels.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.kc\")\n\n[middle, upper, lower] = ta.kc(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n\n// the same on pine\nf_kc(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    [basis, basis + rangeEma * mult, basis - rangeEma * mult]\n    \n[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)\n```\n\n---\n\n## ta.kcw()\n\nKeltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel.\n\n### Returns\nKeltner Channels Width.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "ta.ema",
      "ta.falling",
      "ta.highest",
      "ta.highestbars",
      "ta.hma",
      "ta.kc",
      "color.yellow",
      "ta.tr",
      "ta.kcw",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-168",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.kcw\")\n\nplot(ta.kcw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_kcw(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    \n    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis\n\nplot(f_kcw(close, 5, 4, true))\n```\n\n---\n\n## ta.linreg()\n\nLinear regression curve. A line that best fits the prices specified over a user-defined time period. It is calculated using the least squares method. The result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where intercept and slope are the values calculated with the least squares method on source series.\n\n### Returns\nLinear regression curve.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.lowest()\n\nLowest value for a given number of bars back.\n\n### Returns\nLowest value in the series.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses low as a source series. na values in the source series are ignored.\n\n---\n\n## ta.lowestbars()\n\nLowest value offset for a given number of bars back.\n\n### Returns\nOffset to the lowest bar.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses low as a source series. na values in the source series are ignored.\n\n---\n\n## ta.macd()\n\nMACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock's price.\n\n### Returns\nTuple of three MACD series: MACD line, signal line and histogram line.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"MACD\")\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplot(macdLine, color=color.blue)\nplot(signalLine, color=color.orange)\nplot(histLine, color=color.red, style=plot.style_histogram)\n\n//@version=6\nindicator(\"MACD\")\n[_, signalLine, _] = ta.macd(close, 12, 26, 9)\nplot(signalLine, color=color.orange)\n```\n\n---\n\n## ta.max()\n\nReturns the all-time high value of source from the beginning of the chart up to the current bar.\n\n### Remarks\nna occurrences of source are ignored.\n\n---\n\n## ta.median()\n\nReturns the median of the series.\n\n### Returns\nThe median of the series.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.mfi()\n\nMoney Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset.\n\n### Returns\nMoney Flow Index.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "ta.kcw",
      "color.yellow",
      "ta.ema",
      "ta.tr",
      "ta.linreg",
      "ta.lowest",
      "ta.lowestbars",
      "ta.macd",
      "color.blue",
      "color.orange",
      "color.red",
      "plot.style_histogram",
      "ta.max",
      "ta.median",
      "ta.mfi",
      "indicator",
      "plot",
      "series",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-169",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Money Flow Index\")\n\nplot(ta.mfi(hlc3, 14), color=color.yellow)\n\n// the same on pine\npine_mfi(src, length) =>\n    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)\n    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)\n    mfi = 100.0 - (100.0 / (1.0 + upper / lower))\n    mfi\n\nplot(pine_mfi(hlc3, 14))\n```\n\n---\n\n## ta.min()\n\nReturns the all-time low value of source from the beginning of the chart up to the current bar.\n\n### Remarks\nna occurrences of source are ignored.\n\n---\n\n## ta.mode()\n\nReturns the mode of the series. If there are several values with the same frequency, it returns the smallest value.\n\n### Returns\nThe most frequently occurring value from the source. If none exists, returns the smallest value instead.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.mom()\n\nMomentum of source price and source price length bars ago. This is simply a difference: source - source[length].\n\n### Returns\nMomentum of source price and source price length bars ago.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.percentile_linear_interpolation()\n\nCalculates percentile using method of linear interpolation between the two nearest ranks.\n\n### Returns\nP-th percentile of source series for length bars back.\n\n### Remarks\nNote that a percentile calculated using this method will NOT always be a member of the input data set. na values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.percentile_nearest_rank()\n\nCalculates percentile using method of Nearest Rank.\n\n### Returns\nP-th percentile of source series for length bars back.\n\n### Remarks\nUsing the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile. A percentile calculated using the Nearest Rank method will always be a member of the input data set. The 100th percentile is defined to be the largest value in the input data set. na values in the source series are ignored.\n\n---\n\n## ta.percentrank()\n\nPercent rank is the percents of how many previous values was less than or equal to the current value of given series.\n\n### Returns\nPercent rank of source for length bars back.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.pivot_point_levels()\n\nCalculates the pivot point levels using the specified type and anchor.\n\n### Returns\nAn array<float> with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified type return na values (e.g., \"DM\" only calculates P, R1, and S1).\n\n### Remarks\nThe developing parameter cannot be true when type is set to \"Woodie\", because the Woodie calculation for a period depends on that period's open, which means that the pivot value is either available or unavailable, but never developing. If used together, the indicator will return a runtime error.",
    "keywords": [
      "ta.mfi",
      "color.yellow",
      "math.sum",
      "ta.change",
      "ta.min",
      "ta.mode",
      "ta.mom",
      "ta.percentile_linear_interpolation",
      "ta.percentile_nearest_rank",
      "ta.percentrank",
      "ta.pivot_point_levels",
      "e.g",
      "indicator",
      "input",
      "plot",
      "series",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-170",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)\ntimeframe = \"1W\"\ntypeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])\nweekChange = timeframe.change(timeframe)\npivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)\nif weekChange\n    for pivotLevel in pivotPointsArray\n        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)\n```\n\n---\n\n## ta.pivothigh()\n\nThis function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point.\n\n### Returns\nPrice of the point or 'NaN'.\n\n### Remarks\nIf parameters 'leftbars' or 'rightbars' are series you should use max_bars_back function for the 'source' variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"PivotHigh\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\nph = ta.pivothigh(leftBars, rightBars)\nplot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)\n```\n\n---\n\n## ta.pivotlow()\n\nThis function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point.\n\n### Returns\nPrice of the point or 'NaN'.\n\n### Remarks\nIf parameters 'leftbars' or 'rightbars' are series you should use max_bars_back function for the 'source' variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"PivotLow\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\npl = ta.pivotlow(close, leftBars, rightBars)\nplot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)\n```\n\n---\n\n## ta.range()\n\nReturns the difference between the min and max values in a series.\n\n### Returns\nThe difference between the min and max values in the series.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.rci()\n\nCalculates the Rank Correlation Index (RCI), which measures the directional consistency of price movements. It evaluates the monotonic relationship between a source series and the bar index over length bars using Spearman's rank correlation coefficient. The resulting value is scaled to a range of -100 to 100, where 100 indicates the source consistently increased over the period, and -100 indicates it consistently decreased. Values between -100 and 100 reflect varying degrees of upward or downward consistency.\n\n### Returns\nThe Rank Correlation Index, a value between -100 to 100.\n\n---\n\n## ta.rising()\n\nTest if the source series is now rising for length bars long.\n\n### Returns\ntrue if current source is greater than any previous source for length bars back, false otherwise.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.rma()\n\nMoving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length.\n\n### Returns\nExponential moving average of source with alpha = 1 / length.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "input.string",
      "timeframe.change",
      "ta.pivot_point_levels",
      "line.new",
      "timeframe.in_seconds",
      "xloc.bar_time",
      "ta.pivothigh",
      "plot.style_cross",
      "color.red",
      "ta.pivotlow",
      "color.blue",
      "ta.range",
      "ta.rci",
      "ta.rising",
      "ta.rma",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-171",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.rma\")\nplot(ta.rma(close, 15))\n\n//the same on pine\npine_rma(src, length) =>\n    alpha = 1/length\n    sum = 0.0\n    sum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_rma(close, 15))\n```\n\n---\n\n## ta.roc()\n\nCalculates the percentage of change (rate of change) between the current value of source and its value length bars ago.\n\n### Returns\nThe rate of change of source for length bars back.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.rsi()\n\nRelative strength index. It is calculated using the ta.rma() of upward and downward changes of source over the last length bars.\n\n### Returns\nRelative strength index.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.rsi\")\nplot(ta.rsi(close, 7))\n\n// same on pine, but less efficient\npine_rsi(x, y) => \n    u = math.max(x - x[1], 0) // upward ta.change\n    d = math.max(x[1] - x, 0) // downward ta.change\n    rs = ta.rma(u, y) / ta.rma(d, y)\n    res = 100 - 100 / (1 + rs)\n    res\n\nplot(pine_rsi(close, 7))\n```\n\n---\n\n## ta.sar()\n\nParabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods.\n\n### Returns\nParabolic SAR.",
    "keywords": [
      "ta.rma",
      "ta.sma",
      "ta.roc",
      "ta.rsi",
      "math.max",
      "ta.change",
      "ta.sar",
      "indicator",
      "plot",
      "series",
      "method",
      "for"
    ]
  },
  {
    "id": "doc-172",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.sar\")\nplot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n\n// The same on Pine Script¬Æ\npine_sar(start, inc, max) =>\n    var float result = na\n    var float maxMin = na\n    var float acceleration = na\n    var bool isBelow = false\n    bool isFirstTrendBar = false\n    \n    if bar_index == 1\n        if close > close[1]\n            isBelow := true\n            maxMin := high\n            result := low[1]\n        else\n            isBelow := false\n            maxMin := low\n            result := high[1]\n        isFirstTrendBar := true\n        acceleration := start\n    \n    result := result + acceleration * (maxMin - result)\n    \n    if isBelow\n        if result > low\n            isFirstTrendBar := true\n            isBelow := false\n            result := math.max(high, maxMin)\n            maxMin := low\n            acceleration := start\n    else\n        if result < high\n            isFirstTrendBar := true\n            isBelow := true\n            result := math.min(low, maxMin)\n            maxMin := high\n            acceleration := start\n            \n    if not isFirstTrendBar\n        if isBelow\n            if high > maxMin\n                maxMin := high\n                acceleration := math.min(acceleration + inc, max)\n        else\n            if low < maxMin\n                maxMin := low\n                acceleration := math.min(acceleration + inc, max)\n    \n    if isBelow\n        result := math.min(result, low[1])\n        if bar_index > 1\n            result := math.min(result, low[2])\n        \n    else\n        result := math.max(result, high[1])\n        if bar_index > 1\n            result := math.max(result, high[2])\n    \n    result\n    \nplot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n```\n\n---\n\n## ta.sma()\n\nThe sma function returns the moving average, that is the sum of last y values of x, divided by y.\n\n### Returns\nSimple moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.sma\")\nplot(ta.sma(close, 15))\n\n// same on pine, but much less efficient\npine_sma(x, y) =>\n    sum = 0.0\n    for i = 0 to y - 1\n        sum := sum + x[i] / y\n    sum\nplot(pine_sma(close, 15))\n```\n\n---\n\n## ta.stdev()\n\n### Returns\nStandard deviation.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample. na values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "ta.sar",
      "plot.style_cross",
      "math.max",
      "math.min",
      "ta.sma",
      "ta.stdev",
      "indicator",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-173",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "ta.tr()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.stdev\")\nplot(ta.stdev(close, 5))\n\n//the same on pine\nisZero(val, eps) => math.abs(val) <= eps\n\nSUM(fst, snd) =>\n    EPS = 1e-10\n    res = fst + snd\n    if isZero(res, EPS)\n        res := 0\n    else\n        if not isZero(res, 1e-4)\n            res := res\n        else\n            15\n\npine_stdev(src, length) =>\n    avg = ta.sma(src, length)\n    sumOfSquareDeviations = 0.0\n    for i = 0 to length - 1\n        sum = SUM(src[i], -avg)\n        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum\n\n    stdev = math.sqrt(sumOfSquareDeviations / length)\nplot(pine_stdev(close, 5))\n```\n\n---\n\n## ta.stoch()\n\nStochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length)).\n\n### Returns\nStochastic.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.supertrend()\n\nThe Supertrend Indicator. The Supertrend is a trend following indicator.\n\n### Returns\nTuple of two supertrend series: supertrend line and direction of trend. Possible values are 1 (down direction) and -1 (up direction).\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Pine Script¬Æ Supertrend\")\n\n[supertrend, direction] = ta.supertrend(3, 10)\nplot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n\n// The same on Pine Script¬Æ\npine_supertrend(factor, atrPeriod) =>\n    src = hl2\n    atr = ta.atr(atrPeriod)\n    upperBand = src + factor * atr\n    lowerBand = src - factor * atr\n    prevLowerBand = nz(lowerBand[1])\n    prevUpperBand = nz(upperBand[1])\n\n    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand\n    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand\n    int _direction = na\n    float superTrend = na\n    prevSuperTrend = superTrend[1]\n    if na(atr[1])\n        _direction := 1\n    else if prevSuperTrend == prevUpperBand\n        _direction := close > upperBand ? -1 : 1\n    else\n        _direction := close < lowerBand ? 1 : -1\n    superTrend := _direction == -1 ? lowerBand : upperBand\n    [superTrend, _direction]\n\n[Pine_Supertrend, pineDirection] = pine_supertrend(3, 10)\nplot(pineDirection < 0 ? Pine_Supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(pineDirection > 0 ? Pine_Supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n```\n\n---\n\n## ta.swma()\n\nSymmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6].\n\n### Returns\nSymmetrically weighted moving average.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.swma\")\nplot(ta.swma(close))\n\n// same on pine, but less efficient\npine_swma(x) =>\n    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6\nplot(pine_swma(close))\n```\n\n---",
    "keywords": [
      "ta.stdev",
      "math.abs",
      "ta.sma",
      "math.sqrt",
      "ta.stoch",
      "ta.supertrend",
      "color.green",
      "plot.style_linebr",
      "color.red",
      "ta.atr",
      "ta.swma",
      "indicator",
      "plot",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-174",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## ta.tr()\n\nCalculates the current bar's true range. Unlike a bar's actual range (high - low), true range accounts for potential gaps by taking the maximum of the current bar's actual range and the absolute distances from the previous bar's close to the current bar's high and low. The formula is: math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1]))\n\n### Returns\nTrue range. It is math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).\n\n### Remarks\nta.tr(false) is exactly the same as ta.tr.\n\n---\n\n## ta.tsi()\n\nTrue strength index. It uses moving averages of the underlying momentum of a financial instrument.\n\n### Returns\nTrue strength index. A value in range [-1, 1].\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.valuewhen()\n\nReturns the value of the source series on the bar where the condition was true on the nth most recent occurrence.\n\n### Remarks\nThis function requires execution on every bar. It is not recommended to use it inside a for or while loop structure, where its behavior can be unexpected. Please note that using this function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))\n```\n\n---\n\n## ta.variance()\n\nVariance is the expectation of the squared deviation of a series from its mean (ta.sma), and it informally measures how far a set of numbers are spread out from their mean.\n\n### Returns\nVariance of source for length bars back.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample. na values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.vwap()\n\nVolume weighted average price.\n\n### Returns\nA VWAP series, or a tuple [vwap, upper_band, lower_band] if stdev_mult is specified.\n\n### Remarks\nCalculations only begin the first time the anchor condition becomes true. Until then, the function returns na.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Simple VWAP\")\nvwap = ta.vwap(open)\nplot(vwap)\n\n//@version=6\nindicator(\"Advanced VWAP\")\nvwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])\nstdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")\nanchorTimeframe = switch vwapAnchorInput\n    \"Daily\"   => \"1D\"\n    \"Weekly\"  => \"1W\"\n    \"Monthly\" => \"1M\"\nanchor = timeframe.change(anchorTimeframe)\n[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)\nplot(vwap)\nplot(upper, color = color.green)\nplot(lower, color = color.green)\n```\n\n---\n\n## ta.vwma()\n\nThe vwma function returns volume-weighted moving average of source for length bars back. It is the same as: sma(source * volume, length) / sma(volume, length).\n\n### Returns\nVolume-weighted moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.",
    "keywords": [
      "ta.tr",
      "math.max",
      "math.abs",
      "ta.tsi",
      "ta.valuewhen",
      "ta.sma",
      "ta.cross",
      "ta.variance",
      "ta.vwap",
      "input.string",
      "input.float",
      "timeframe.change",
      "color.green",
      "ta.vwma",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "switch",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-175",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "table.cell_set_text_color()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.vwma\")\nplot(ta.vwma(close, 15))\n\n// same on pine, but less efficient\npine_vwma(x, y) =>\n    ta.sma(x * volume, y) / ta.sma(volume, y)\nplot(pine_vwma(close, 15))\n```\n\n---\n\n## ta.wma()\n\nThe wma function returns weighted moving average of source for length bars back. In wma weighting factors decrease in arithmetical progression.\n\n### Returns\nWeighted moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.wma\")\nplot(ta.wma(close, 15))\n\n// same on pine, but much less efficient\npine_wma(x, y) =>\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to y - 1\n        weight = (y - i) * y\n        norm := norm + weight\n        sum := sum + x[i] * weight\n    sum / norm\nplot(pine_wma(close, 15))\n```\n\n---\n\n## ta.wpr()\n\nWilliams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars.\n\n### Returns\nWilliams %R.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)\nplot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))\n```\n\n---\n\n## table()\n\nCasts na to table\n\n### Returns\nThe value of the argument after casting to table.\n\n---\n\n## table.cell()\n\nThe function defines a cell in the table and sets its attributes.\n\n### Remarks\nThis function does not create the table itself, but defines the table‚Äôs cells. To use it, you first need to create a table object with table.new. Each table.cell call overwrites all previously defined properties of a cell. If you call table.cell twice in a row, e.g., the first time with text='Test Text', and the second time with text_color=color.red but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string. If you want, instead, to modify any of the cell's properties, use the table.cell_set_*() functions. A single script can only display one table in each of the possible locations. If table.cell is used on several bars to change the same attribute of a cell (e.g. change the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell‚Äôs background will be yellow. Avoid unnecessary setting of cell properties by enclosing function calls in an if barstate.islast block whenever possible, to restrict their execution to the last bar of the series.\n\n---\n\n## table.cell_set_bgcolor()\n\nThe function sets the background color of the cell.\n\n---\n\n## table.cell_set_height()\n\nThe function sets the height of cell.\n\n---\n\n## table.cell_set_text()\n\nThe function sets the text in the specified cell.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")\n```\n\n---",
    "keywords": [
      "ta.vwma",
      "ta.sma",
      "ta.wma",
      "ta.wpr",
      "format.price",
      "color.new",
      "table.cell",
      "table.new",
      "e.g",
      "color.red",
      "table.cell_set_",
      "i.e",
      "barstate.islast",
      "table.cell_set_bgcolor",
      "table.cell_set_height",
      "table.cell_set_text",
      "position.top_left",
      "color.yellow",
      "color.blue",
      "indicator",
      "plot",
      "bgcolor",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-176",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "## table.cell_set_text_color()\n\nThe function sets the color of the text inside the cell.\n\n---\n\n## table.cell_set_text_font_family()\n\nThe function sets the font family of the text inside the cell.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Example of setting the table cell font\")\nvar t = table.new(position.top_left, rows = 1, columns = 1)\ntable.cell(t, 0, 0, \"monospace\", text_color = color.blue)\ntable.cell_set_text_font_family(t, 0, 0, font.family_monospace)\n```\n\n---\n\n## table.cell_set_text_formatting()\n\nSets the formatting attributes the drawing applies to displayed text.\n\n---\n\n## table.cell_set_text_halign()\n\nThe function sets the horizontal alignment of the cell's text.\n\n---\n\n## table.cell_set_text_size()\n\nThe function sets the size of the cell's text.\n\n---\n\n## table.cell_set_text_valign()\n\nThe function sets the vertical alignment of a cell's text.\n\n---\n\n## table.cell_set_tooltip()\n\nThe function sets the tooltip in the specified cell.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"TABLE example\")\nvar tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)\ntable.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)\ntable.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")\n```\n\n---\n\n## table.cell_set_width()\n\nThe function sets the width of the cell.\n\n---\n\n## table.clear()\n\nThe function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"A donut\", overlay=true)\nif barstate.islast\n    colNum = 8, rowNum = 8\n    padding = \"‚óØ\"\n    donutTable = table.new(position.middle_right, colNum, rowNum)\n    for c = 0 to colNum - 1\n        for r = 0 to rowNum - 1\n            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))\n    table.clear(donutTable, 2, 2, 5, 5)\n```\n\n---\n\n## table.delete()\n\nThe function deletes a table.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table.delete example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\nif barstate.isrealtime\n    table.delete(testTable)\n```\n\n---\n\n## table.merge_cells()\n\nThe function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",
    "keywords": [
      "table.cell_set_text_color",
      "table.cell_set_text_font_family",
      "table.new",
      "position.top_left",
      "table.cell",
      "color.blue",
      "font.family_monospace",
      "table.cell_set_text_formatting",
      "table.cell_set_text_halign",
      "table.cell_set_text_size",
      "table.cell_set_text_valign",
      "table.cell_set_tooltip",
      "color.yellow",
      "table.cell_set_width",
      "table.clear",
      "barstate.islast",
      "position.middle_right",
      "color.new",
      "color.black",
      "table.delete",
      "position.top_right",
      "str.tostring",
      "color.teal",
      "barstate.isrealtime",
      "table.merge_cells",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-177",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "table.set_position()",
    "content": "### Remarks\nThis function will merge cells, even if their properties are not yet defined with table.cell. The resulting merged cell inherits all of its values from the cell located at start_column:start_row, except width and height. The width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually. To modify the merged cell with any of the table.cell_set_* functions, target the cell at the start_column:start_row coordinates. An attempt to merge a cell that has already been merged will result in an error.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table.merge_cells example\")\nSMA50  = ta.sma(close, 50)\nSMA100 = ta.sma(close, 100)\nSMA200 = ta.sma(close, 200)\nif barstate.islast\n    maTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)\n    // Header\n    table.cell(maTable, 0, 0, text = \"SMA Table\")\n    table.merge_cells(maTable, 0, 0, 2, 0)\n    // Cell Titles\n    table.cell(maTable, 0, 1, text = \"SMA 50\")\n    table.cell(maTable, 1, 1, text = \"SMA 100\")\n    table.cell(maTable, 2, 1, text = \"SMA 200\")\n    // Values\n    table.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))\n    table.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))\n    table.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))\n```\n\n---\n\n## table.new()\n\nThe function creates a new table.\n\n### Returns\nThe ID of a table object that can be passed to other table.*() functions.\n\n### Remarks\nThis function creates the table object itself, but the table will not be displayed until its cells are populated. To define a cell and change its contents or attributes, use table.cell and other table.cell_*() functions. One table.new call can only display one table (the last one drawn), but the function itself will be recalculated on each bar it is used on. For performance reasons, it is wise to use table.new in conjunction with either the var keyword (so the table object is only created on the first bar) or in an if barstate.islast block (so the table object is only created on the last bar).\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table.new example\")\nvar testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\nif barstate.islast\n    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))\n    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)\n```\n\n---\n\n## table.set_bgcolor()\n\nThe function sets the background color of a table.\n\n---\n\n## table.set_border_color()\n\nThe function sets the color of the borders (excluding the outer frame) of the table's cells.\n\n---\n\n## table.set_border_width()\n\nThe function sets the width of the borders (excluding the outer frame) of the table's cells.\n\n---\n\n## table.set_frame_color()\n\nThe function sets the color of the outer frame of a table.\n\n---\n\n## table.set_frame_width()\n\nThe function set the width of the outer frame of a table.\n\n---",
    "keywords": [
      "table.cell",
      "table.cell_set_",
      "table.merge_cells",
      "ta.sma",
      "barstate.islast",
      "table.new",
      "position.bottom_right",
      "color.gray",
      "color.black",
      "color.white",
      "str.tostring",
      "table.cell_",
      "position.top_right",
      "color.yellow",
      "color.teal",
      "table.set_bgcolor",
      "table.set_border_color",
      "table.set_border_width",
      "table.set_frame_color",
      "table.set_frame_width",
      "indicator",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-178",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Returns",
    "content": "## table.set_position()\n\nThe function sets the position of a table.\n\n---\n\n## ticker.heikinashi()\n\nCreates a ticker identifier for requesting Heikin Ashi bar values.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.heikinashi\", overlay=true) \nheikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\n\nheikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)\nplot(heikinashi_close)\nplot(heikinashi_aapl_60_close)\n```\n\n---\n\n## ticker.inherit()\n\nConstructs a ticker ID for the specified symbol with additional parameters inherited from the ticker ID passed into the function call, allowing the script to request a symbol's data using the same modifiers that the from_tickerid has, including extended session, dividend adjustment, currency conversion, non-standard chart types, back-adjustment, settlement-as-close, etc.\n\n### Remarks\nIf the constructed ticker ID inherits a modifier that doesn't apply to the symbol (e.g., if the from_tickerid has Extended Hours enabled, but no such option is available for the symbol), the script will ignore the modifier when requesting data using the ID.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.inherit\")\n\n//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.\ntickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)\n//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.\nHAtickerExtHours = ticker.heikinashi(tickerExtHours)\n//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.\ntestSymbol = \"NASDAQ:MSFT\"\n//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.\ntestSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)\n\n//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers. \nsecData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)\n//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers. \ncompareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)\n\nplot(secData, color = color.green)\nplot(compareData)\n```\n\n---\n\n## ticker.kagi()\n\nCreates a ticker identifier for requesting Kagi values.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.kagi\", overlay=true) \nkagi_tickerid = ticker.kagi(syminfo.tickerid, 3)\nkagi_close = request.security(kagi_tickerid, timeframe.period, close)\nplot(kagi_close)\n```\n\n---\n\n## ticker.linebreak()\n\nCreates a ticker identifier for requesting Line Break values.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.linebreak\", overlay=true) \nlinebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)\nlinebreak_close = request.security(linebreak_tickerid, timeframe.period, close)\nplot(linebreak_close)\n```\n\n---\n\n## ticker.modify()\n\nCreates a ticker identifier for requesting additional data for the script.",
    "keywords": [
      "table.set_position",
      "ticker.heikinashi",
      "request.security",
      "syminfo.tickerid",
      "timeframe.period",
      "ticker.inherit",
      "e.g",
      "ticker.new",
      "session.extended",
      "color.green",
      "ticker.kagi",
      "ticker.linebreak",
      "ticker.modify",
      "indicator",
      "overlay",
      "plot",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-179",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker_modify\", overlay=true)\nt1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nc1 = request.security(t1, \"D\", close)\nt2 = ticker.modify(t1, session.extended)\nc2 = request.security(t2, \"2D\", close)\nplot(c1)\nplot(c2)\n```\n\n---\n\n## ticker.new()\n\nCreates a ticker identifier for requesting additional data for the script.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Remarks\nYou may use return value of ticker.new function as input argument for ticker.heikinashi, ticker.renko, ticker.linebreak, ticker.kagi, ticker.pointfigure functions.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.new\", overlay=true) \nt = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)\nt2 = ticker.heikinashi(t)\nc = request.security(t2, timeframe.period, low, barmerge.gaps_on)\nplot(c, style=plot.style_linebr)\n```\n\n---\n\n## ticker.pointfigure()\n\nCreates a ticker identifier for requesting Point & Figure values.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.pointfigure\", overlay=true) \npnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)\npnf_close = request.security(pnf_tickerid, timeframe.period, close)\nplot(pnf_close)\n```\n\n---\n\n## ticker.renko()\n\nCreates a ticker identifier for requesting Renko values.\n\n### Returns\nString value of ticker id, that can be supplied to request.security function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ticker.renko\", overlay=true) \nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\nrenko_close = request.security(renko_tickerid, timeframe.period, close)\nplot(renko_close)\n\n//@version=6\nindicator(\"Renko candles\", overlay=false)\nrenko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)\n[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])\nplotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)\n```\n\n---\n\n## ticker.standard()\n\nCreates a ticker to request data from a standard chart that is unaffected by modifiers like extended session, dividend adjustment, currency conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc. Among other things, this makes it possible to retrieve standard chart values when the script is running on a non-standard chart.\n\n### Returns\nA string representing the ticker of a standard chart in the \"prefix:ticker\" format. If the symbol argument does not contain the prefix and ticker information, the function returns the supplied argument as is.",
    "keywords": [
      "request.security",
      "ticker.new",
      "syminfo.prefix",
      "syminfo.ticker",
      "session.regular",
      "adjustment.splits",
      "ticker.modify",
      "session.extended",
      "ticker.heikinashi",
      "ticker.renko",
      "ticker.linebreak",
      "ticker.kagi",
      "ticker.pointfigure",
      "timeframe.period",
      "barmerge.gaps_on",
      "plot.style_linebr",
      "syminfo.tickerid",
      "color.green",
      "color.red",
      "ticker.standard",
      "indicator",
      "overlay",
      "input",
      "plot",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-180",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ticker.standard\", overlay = true)\n// This script should be run on a non-standard chart such as HA, Renko...\n\n// Requests data from the chart type the script is running on.\nchartTypeValue = request.security(syminfo.tickerid, \"1D\", close)\n\n// Request data from the standard chart type, regardless of the chart type the script is running on.\nstandardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)\n\n// This will not use a standard ticker ID because the `symbol` argument contains only the ticker ‚Äî not the prefix (exchange).\nstandardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)\n\nplot(chartTypeValue)\nplot(standardChartValue, color = color.green)\n```\n\n---\n\n## time()\n\nThe time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session.\n\n### Returns\nUNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Time\", overlay=true)\n// Try this on chart AAPL,1\ntimeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0\nplot(timeinrange(\"1\", \"1300-1400\"), color=color.red)\n\n// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:\nnewbar(res) => ta.change(time(res)) == 0 ? 0 : 1\nplot(newbar(\"10\"))\n\n//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"0000-0000:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)\n\n//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)\n```\n\n---\n\n## time_close()\n\nReturns the UNIX time of the current bar's close for the specified timeframe and session, or na if the time point is outside the session. On tick charts and price-based charts such as Renko, line break, Kagi, point & figure, and range, this function returns an na timestamp for the latest realtime bar (because the future closing time is unpredictable), but a valid timestamp for any previous bar.\n\n### Returns\nUNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Time\", overlay=true)\nt1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")\nbgcolor(not na(t1) ? color.new(color.blue, 90) : na)\n```\n\n---\n\n## timeframe.change()\n\nDetects changes in the specified timeframe.\n\n### Returns\nReturns true on the first bar of a new timeframe, false otherwise.\n\n### Code Example\n```pine\n//@version=6\n// Run this script on an intraday chart.\nindicator(\"New day started\", overlay = true)\n// Highlights the first bar of the new day.\nisNewDay = timeframe.change(\"1D\")\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n```\n\n---\n\n## timeframe.from_seconds()\n\nConverts a number of seconds into a valid timeframe string.\n\n### Returns\nA timeframe string compliant with timeframe string specifications.",
    "keywords": [
      "ticker.standard",
      "request.security",
      "syminfo.tickerid",
      "syminfo.ticker",
      "color.green",
      "color.red",
      "ta.change",
      "timeframe.period",
      "color.new",
      "color.blue",
      "timeframe.change",
      "timeframe.from_seconds",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-181",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "enum",
    "content": "### Remarks\nIf no valid timeframe exists for the quantity of seconds supplied, the next higher valid timeframe will be returned. Accordingly, one second or less will return \"1S\", 2-5 seconds will return \"5S\", and 604,799 seconds (one second less than 7 days) will return \"7D\". If the seconds exactly represent two or more valid timeframes, the one with the larger base unit will be used. Thus 604,800 seconds (7 days) returns \"1W\", not \"7D\". All values above 31,622,400 (366 days) return \"12M\".\n\n### Code Example\n```pine\n//@version=6\nindicator(\"HTF Close\", \"\", true)\nint chartTf = timeframe.in_seconds()\nstring tfTimes5 = timeframe.from_seconds(chartTf * 5)\nfloat htfClose = request.security(syminfo.tickerid, tfTimes5, close)\nplot(htfClose)\n```\n\n---\n\n## timeframe.in_seconds()\n\nConverts a timeframe string into seconds.\n\n### Returns\nThe \"int\" representation of the number of seconds in the timeframe string.\n\n### Remarks\nWhen the timeframe is \"1M\" or more, calculations use 2628003 as the number of seconds in one month, which represents 30.4167 (365/12) days.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`timeframe_in_seconds()`\")\n\n// Get a user-selected timeframe.\ntfInput = input.timeframe(\"1D\")\n\n// Convert it into an \"int\" number of seconds.\nsecondsInTf = timeframe.in_seconds(tfInput)\n\nplot(secondsInTf)\n```\n\n---\n\n## timestamp()\n\nFunction timestamp returns UNIX time of specified date and time.\n\n### Returns\nUNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"timestamp\")\nplot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)\nplot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)\nplot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)\nplot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))\nplot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)\nplot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)\nplot(timestamp(\"Feb 01 2020 22:10:05\"))\nplot(timestamp(\"2011-10-10T14:48:00\"))\nplot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))\n```\n\n---\n\n## weekofyear()\n\n### Returns\nWeek of year (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. Note that this function returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.\n\n---\n\n## year()\n\n### Returns\nYear (in exchange timezone) for provided UNIX time.\n\n### Remarks\nUNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. Note that this function returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day.\n\n---\n\n# Keywords\n\n## and\n\nLogical AND. Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n### Remarks\nIf expr1 evaluates to false, the and operator returns false without evaluating expr2.\n\n---",
    "keywords": [
      "timeframe.in_seconds",
      "timeframe.from_seconds",
      "request.security",
      "syminfo.tickerid",
      "input.timeframe",
      "color.green",
      "syminfo.timezone",
      "color.blue",
      "color.yellow",
      "color.lime",
      "color.fuchsia",
      "e.g",
      "indicator",
      "input",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-182",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## enum\n\nThis keyword allows the creation of an enumeration, enum for short. Enums are unique constructs that hold groups of predefined constants.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum       Contains fields with popular timezones as titles.\n//@field exch Has an empty string as the title to represent the chart timezone.\nenum tz\n    utc  = \"UTC\"\n    exch = \"\"\n    ny   = \"America/New_York\"\n    chi  = \"America/Chicago\"\n    lon  = \"Europe/London\"\n    tok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n    inSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")\n\n//@version=6\nindicator(\"Map with enum keys\")\n\n//@enum        Contains fields with titles representing ticker IDs.\n//@field aapl  Has an Apple ticker ID as its title.\n//@field tsla  Has a Tesla ticker ID as its title.\n//@field amzn  Has an Amazon ticker ID as its title.\nenum symbols\n    aapl = \"NASDAQ:AAPL\"\n    tsla = \"NASDAQ:TSLA\"\n    amzn = \"NASDAQ:AMZN\"\n\n//@variable A map that accepts fields from the `symbols` enum as keys and \"float\" values.\nmap<symbols, float> data = map.new<symbols, float>()\n// Put key-value pairs into the `data` map.\ndata.put(symbols.aapl, request.security(str.tostring(symbols.aapl), timeframe.period, close))\ndata.put(symbols.tsla, request.security(str.tostring(symbols.tsla), timeframe.period, close))\ndata.put(symbols.amzn, request.security(str.tostring(symbols.amzn), timeframe.period, close))\n// Plot the value from the `data` map accessed by the `symbols.aapl` key.\nplot(data.get(symbols.aapl))\n```\n\n---\n\n## export\n\nUsed in libraries to prefix the declaration of functions or user-defined type definitions that will be available from other scripts importing the library.\n\n### Remarks\nEach library must have at least one exported function or user-defined type (UDT). Exported functions cannot use variables from the global scope if they are arrays, mutable variables (reassigned with :=), or variables of 'input' form. Exported functions cannot use request.*() functions. Exported functions must explicitly declare each parameter's type and all parameters must be used in the function's body. By default, all arguments passed to exported functions are of the series form, unless they are explicitly specified as simple in the function's signature. The @description, @function, @param, @type, @field, and @returns compiler annotations are used to automatically generate the library's description and release notes, and in the Pine Script¬Æ Editor's tooltips.",
    "keywords": [
      "input.session",
      "input.enum",
      "tz.utc",
      "str.tostring",
      "color.new",
      "color.green",
      "map.new",
      "data.put",
      "symbols.aapl",
      "request.security",
      "timeframe.period",
      "symbols.tsla",
      "symbols.amzn",
      "data.get",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "const",
      "export",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-183",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\n//@function Displays a string as a table cell for debugging purposes.\n//@param txt String to display.\n//@returns Void.\nexport print(string txt) => \n    var table t = table.new(position.middle_right, 1, 1)\n    table.cell(t, 0, 0, txt, bgcolor = color.yellow)\n// Using the function from inside the library to show an example on the published chart.\n// This has no impact on scripts using the library.\nprint(\"Library Test\")\n```\n\n---\n\n## for\n\nCreates a count-controlled loop, which uses a counter variable to manage the iterative executions of its local code block. The loop continues new iterations until the counter reaches a specified final value.\n\n### Remarks\nModifying a loop's to_num value during an iteration does not change the direction of the loop's counter. For a loop that counts upward, setting the to_num to a value less than the from_num value on an iteration stops the loop immediately after that iteration ends. Likewise, a loop that counts downward stops after an iteration where the to_num value becomes greater than the from_num value.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Basic `for` loop\")\n\n//@function Calculates the number of bars in the last `length` bars that have their `close` above the current `close`.\n//@param length The number of bars used in the calculation.\ngreaterCloseCount(length) =>\n    int result = 0\n    for i = 1 to length\n        if close[i] > close\n            result += 1\n    result\n\nplot(greaterCloseCount(14))\n\n//@version=6\nindicator(\"`for` loop with a step\")\n\na = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nsum = 0.0\n\nfor i = 0 to 9 by 5\n    // Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.\n    sum += array.get(a, i)\n\nplot(sum)\n```\n\n---\n\n## for...in\n\nThe for...in structure allows the repeated execution of a number of statements for each element in an array. It can be used with either one argument: array_element, or with two: [index, array_element]. The second form doesn't affect the functionality of the loop. It tracks the current iteration's index in the tuple's first variable.",
    "keywords": [
      "table.new",
      "position.middle_right",
      "table.cell",
      "color.yellow",
      "array.from",
      "array.get",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "export",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-184",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "method",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"for...in\")\n// Here we determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values\nfloat[] ohlcValues = array.from(open, high, low, close)\nqtyGreaterThan(value, array) =>\n    int result = 0\n    for currentElement in array\n        if currentElement > value\n            result += 1\n        result\nplot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))\n\n//@version=6\nindicator(\"for...in\")\nvar valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)\nvar isPos = array.new_bool(10, false)\n\nfor [index, value] in valuesArray\n    if value > 0\n        array.set(isPos, index, true)\n\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(isPos))\n\n//@version=6\nindicator(\"`for ... in` matrix Example\")\n\n// Create a 2x3 matrix with values `4`.\nmatrix1 = matrix.new<int>(2, 3, 4)\n\nsum = 0.0\n// Loop through every row of the matrix.\nfor rowArray in matrix1\n    // Sum values of the every row \n    sum += array.sum(rowArray)\n\nplot(sum)\n```\n\n---\n\n## if\n\nIf statement defines what block of statements must be executed when conditions of the expression are satisfied.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"if\")\n// This code compiles\nx = if close > open\n    close\nelse\n    open\n\n// This code doesn‚Äôt compile\n// y = if close > open\n//     close\n// else\n//     \"open\"\nplot(x)\n\n//@version=6\nindicator(\"if\")\nx = if close > open\n    close\n// If current close > current open, then x = close.\n// Otherwise the x = na.\nplot(x)\n\n//@version=6\nindicator(\"if\")\nx = if open > close\n    5\nelse if high > low\n    close\nelse\n    open\nplot(x)\n\n//@version=6\nstrategy(\"if\")\nif (ta.crossover(high, low))\n    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\n    strategy.cancel(id=\"BBandLE\")\n\n//@version=6\nindicator(\"if\")\nfloat x = na\nif close > open\n    if close > close[1]\n        x := close\n    else\n        x := close[1]\nelse\n    x := open\nplot(x)\n```\n\n---\n\n## import\n\nUsed to load an external library into a script and bind its functions to a namespace. The importing script can be an indicator, a strategy, or another library. A library must be published (privately or publicly) before it can be imported.\n\n### Remarks\nUsing an alias that replaces a built-in namespace such as math.* or strategy.* is allowed, but if the library contains function names that shadow Pine Script¬Æ's built-in functions, the built-ins will become unavailable. The same version of a library can only be imported once. Aliases must be distinct for each imported library. When calling library functions, casting their arguments to types other than their declared type is not allowed. An import statement cannot use 'as' or 'import' as username, libraryName, or alias identifiers.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"num_methods import\")\n// Import the first version of the username‚Äôs \"num_methods\" library and assign it to the \"m\" namespace\",\nimport username/num_methods/1 as m\n// Call the ‚Äúsinh()‚Äù function from the imported library\ny = m.sinh(3.14)\n// Plot value returned by the \"sinh()\" function\",\nplot(y)\n```\n\n---",
    "keywords": [
      "array.from",
      "ta.sma",
      "array.new_bool",
      "array.set",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "matrix.new",
      "array.sum",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "strategy.oca",
      "strategy.cancel",
      "m.sinh",
      "indicator",
      "strategy",
      "plot",
      "var",
      "import",
      "method",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-185",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## method\n\nThis keyword is used to prefix a function declaration, indicating it can then be invoked using dot notation by appending its name to a variable of the type of its first parameter and omitting that first parameter. Alternatively, functions declared as methods can also be invoked like normal user-defined functions. In that case, an argument must be supplied for its first parameter.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"\")\n\nvar prices = array.new<float>()\n\n//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.\nmethod maintainArray(array<float> id, maxSize, value) =>\n    id.push(value)\n    if id.size() > maxSize\n        id.shift()\n\nprices.maintainArray(50, close)\n// The method can also be called like a function, without using dot notation.\n// In this case an argument must be supplied for its first parameter.\n// maintainArray(prices, 50, close)\n\n// This calls the `array.avg()` built-in using dot notation with the `prices` array.\n// It is possible because built-in functions belonging to some namespaces that are a special Pine type\n// can be invoked with method notation when the function's first parameter is an ID of that type.\n// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.\nplot(prices.avg())\n```\n\n---\n\n## not\n\nLogical negation (NOT). Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## or\n\nLogical OR. Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n### Remarks\nIf expr1 evaluates to true, the or operator returns true without evaluating expr2.\n\n---\n\n## switch\n\nThe switch operator transfers control to one of the several statements, depending on the values of a condition and expressions.\n\n### Returns\nThe value of the last expression in the local block of statements that is executed.\n\n### Remarks\nOnly one of the local_block instances or the default_local_block can be executed. The default_local_block is introduced with the => token alone and is only executed when none of the preceding blocks are executed. If the result of the switch statement is assigned to a variable and a default_local_block is not specified, the statement returns na if no local_block is executed. When assigning the result of the switch statement to a variable, all local_block instances must return the same type of value.",
    "keywords": [
      "array.new",
      "id.push",
      "id.size",
      "id.shift",
      "prices.maintain",
      "array.avg",
      "prices.avg",
      "indicator",
      "plot",
      "fill",
      "var",
      "series",
      "method",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-186",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "varip",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Switch using an expression\")\n\nstring i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\n\nfloat ma = switch i_maType\n    \"EMA\" => ta.ema(close, 10)\n    \"SMA\" => ta.sma(close, 10)\n    \"RMA\" => ta.rma(close, 10)\n    // Default used when the three first cases do not match.\n    => ta.wma(close, 10)\n\nplot(ma)\n\n//@version=6\nstrategy(\"Switch without an expression\", overlay = true)\n\nbool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\n    longCondition  => strategy.entry(\"Long ID\", strategy.long)\n    shortCondition => strategy.entry(\"Short ID\", strategy.short)\n```\n\n---\n\n## type\n\nThis keyword allows the declaration of user-defined types (UDT) from which scripts can instantiate objects. UDTs are composite types that contain an arbitrary number of fields of any built-in or user-defined type, including the defined UDT itself. The syntax to define a UDT is:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Multi Time Period Chart\", overlay = true)\n\ntimeframeInput = input.timeframe(\"1D\")\n\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    int   t = time\n\ndrawBox(bar b, right) =>\n    bar s = bar.new()\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))\n\nupdateBox(box boxId, bar b) =>\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.set_border_color(boxId, boxColor)\n    box.set_bgcolor(boxId, color.new(boxColor, 90))\n    box.set_top(boxId, b.h)\n    box.set_bottom(boxId, b.l)\n    box.set_right(boxId, time)\n\nsecBar = request.security(syminfo.tickerid, timeframeInput, bar.new())\n\nif not na(secBar)\n    // To avoid a runtime error, only process data when an object exists.\n    if not barstate.islast\n        if timeframe.change(timeframeInput)\n            // On historical bars, draw a new box in the past when the HTF closes.\n            drawBox(secBar, time[1])\n    else\n        var box lastBox = na\n        if na(lastBox) or timeframe.change(timeframeInput)\n            // On the last bar, only draw a new current box the first time we get there or when HTF changes.\n            lastBox := drawBox(secBar, time)\n        else\n            // On other chart updates, use setters to modify the current box.\n            updateBox(lastBox, secBar)\n```\n\n---\n\n## var\n\nvar is the keyword used for assigning and one-time initializing of the variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Var keyword example\")\nvar a = close\nvar b = 0.0\nvar c = 0.0\nvar green_bars_count = 0\nif close > open\n    var x = close\n    b := x\n    green_bars_count := green_bars_count + 1\n    if green_bars_count >= 10\n        var y = close\n        c := y\nplot(a)\nplot(b)\nplot(c)\n```\n\n---",
    "keywords": [
      "input.string",
      "ta.ema",
      "ta.sma",
      "ta.rma",
      "ta.wma",
      "ta.crossover",
      "ta.crossunder",
      "strategy.entry",
      "strategy.long",
      "strategy.short",
      "input.timeframe",
      "bar.new",
      "b.c",
      "b.o",
      "color.green",
      "color.red",
      "box.new",
      "b.t",
      "b.h",
      "b.l",
      "xloc.bar_time",
      "color.new",
      "box.set_border_color",
      "box.set_bgcolor",
      "box.set_top",
      "box.set_bottom",
      "box.set_right",
      "request.security",
      "syminfo.tickerid",
      "barstate.islast",
      "timeframe.change",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-187",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "chart.point",
    "content": "## varip\n\nvarip (var intrabar persist) is the keyword used for the assignment and one-time initialization of a variable or a field of a user-defined type. It‚Äôs similar to the var keyword, but variables and fields declared with varip retain their values between executions of the script on the same bar.\n\n### Remarks\nWhen using varip to declare variables in strategies that may execute more than once per historical chart bar, the values of such variables are preserved across successive iterations of the script on the same bar. The effect of varip eliminates the rollback of variables before each successive execution of a script on the same bar.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"varip\")\nvarip int v = -1\nv := v + 1\nplot(v)\n\n//@version=6\nindicator(\"varip with types\")\ntype barData\n    int index = -1\n    varip int ticks = -1\n\nvar currBar = barData.new()\ncurrBar.index += 1\ncurrBar.ticks += 1\n\n// Will be equal to bar_index on all bars\nplot(currBar.index)\n// In real time, will increment per every tick on the chart\nplot(currBar.ticks)\n```\n\n---\n\n## while\n\nThe while statement allows the conditional iteration of a local code block.\n\n### Remarks\nThe local code block after the initial while line must be indented with four spaces or a tab. For the while loop to terminate, the boolean expression following while must eventually become false, or a break must be executed.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"while\")\n// This is a simple example of calculating a factorial using a while loop.\nint i_n = input.int(10, \"Factorial Size\", minval=0)\nint counter   = i_n\nint factorial = 1\nwhile counter > 0\n    factorial := factorial * counter\n    counter   := counter - 1\n\nplot(factorial)\n```\n\n---\n\n# Types\n\n## array\n\nKeyword used to explicitly declare the \"array\" type of a variable or a parameter. Array objects (or IDs) can be created with the array.new<type>, array.from function.\n\n### Remarks\nArray objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array\", overlay=true)\narray<float> a = na\na := array.new<float>(1, close)\nplot(array.get(a, 0))\n```\n\n---\n\n## bool\n\nKeyword used to explicitly declare the \"bool\" (boolean) type of a variable or a parameter. \"Bool\" variables can have values true or false.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"bool\")\nbool b = true    // Same as `b = true`\nplot(b ? open : close)\n```\n\n---\n\n## box\n\nKeyword used to explicitly declare the \"box\" type of a variable or a parameter. Box objects (or IDs) can be created with the box.new function.\n\n### Remarks\nBox objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"box\")\n// Empty `box1` box ID.\nvar box box1 = na\n// `box` type is unnecessary because `box.new()` returns a \"box\" type.\nvar box2 = box.new(na, na, na, na)\nbox3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\n```\n\n---",
    "keywords": [
      "input.int",
      "array.new",
      "array.from",
      "array.get",
      "box.new",
      "xloc.bar_time",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "varip",
      "series",
      "simple",
      "type",
      "for",
      "while"
    ]
  },
  {
    "id": "doc-188",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "## chart.point\n\nKeyword to explicitly declare the type of a variable or parameter as chart.point. Scripts can produce chart.point instances using the chart.point.from_time, chart.point.from_index, chart.point.now, and chart.point.new functions.\n\n---\n\n## color\n\nKeyword used to explicitly declare the \"color\" type of a variable or a parameter.\n\n### Remarks\nColor literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent 00 to FF hexadecimal values (0 to 255 in decimal) where RR, GG and BB pairs are the values for the color's red, green and blue components. AA is an optional value for the color's transparency (or alpha component) where 00 is invisible and FF opaque. When no AA pair is supplied, FF is used. The hexadecimal letters can be upper or lower case. Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color\", overlay = true)\n\ncolor textColor = color.green\ncolor labelColor = #FF000080 // Red color (FF0000) with 50% transparency (80 which is half of FF).\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)\n\n// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.\nc = color.rgb(0,255,0,0)\nplot(close, color = c)\n```\n\n---\n\n## const\n\nThe const keyword explicitly assigns the \"const\" type qualifier to variables and the parameters of non-exported functions. Variables and parameters with the \"const\" qualifier reference values established at compile time that never change in the script's execution.\n\n### Remarks\nTo learn more, see our User Manual's section on type qualifiers.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"custom plot title\")\n\n//@function Concatenates two \"const string\" values.\nconcatStrings(const string x, const string y) =>\n    const string result = x + y\n\n//@variable The title of the plot.\nconst string myTitle = concatStrings(\"My \", \"Plot\")\n\nplot(close, myTitle)\n\n//@version=6\nindicator(\"can't assign input to const\")\n\n//@variable A variable declared as \"const float\" that attempts to assign the result of `input.float()` as its value.\n//          This declaration causes an error. The \"input float\" qualified type is stronger than \"const float\".\nconst float myVar = input.float(2.0)\n\nplot(myVar)\n```\n\n---\n\n## float\n\nKeyword used to explicitly declare the \"float\" (floating point) type of a variable or a parameter.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"float\")\nfloat f = 3.14    // Same as `f = 3.14`\nf := na\nplot(f)\n```\n\n---\n\n## int\n\nKeyword used to explicitly declare the \"int\" (integer) type of a variable or a parameter.",
    "keywords": [
      "chart.point",
      "color.green",
      "barstate.islastconfirmedhistory",
      "label.new",
      "color.new",
      "color.rgb",
      "input.float",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-189",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"int\")\nint i = 14    // Same as `i = 14`\ni := na\nplot(i)\n```\n\n---\n\n## label\n\nKeyword used to explicitly declare the \"label\" type of a variable or a parameter. Label objects (or IDs) can be created with the label.new function.\n\n### Remarks\nLabel objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"label\")\n// Empty `label1` label ID.\nvar label label1 = na\n// `label` type is unnecessary because `label.new()` returns \"label\" type.\nvar label2 = label.new(na, na, na)\nif barstate.islastconfirmedhistory\n    label3 = label.new(bar_index, high, text = \"label3 text\")\n```\n\n---\n\n## line\n\nKeyword used to explicitly declare the \"line\" type of a variable or a parameter. Line objects (or IDs) can be created with the line.new function.\n\n### Remarks\nLine objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line\")\n// Empty `line1` line ID.\nvar line line1 = na\n// `line` type is unnecessary because `line.new()` returns \"line\" type.\nvar line2 = line.new(na, na, na, na)\nline3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)\n```\n\n---\n\n## linefill\n\nKeyword used to explicitly declare the \"linefill\" type of a variable or a parameter. Linefill objects (or IDs) can be created with the linefill.new function.\n\n### Remarks\nLinefill objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"linefill\", overlay=true)\n// Empty `linefill1` line ID.\nvar linefill linefill1 = na\n// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.\nvar linefill2 = linefill.new(na, na, na)\n\nif barstate.islastconfirmedhistory\n    line1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)\n    line2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)\n    linefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))\n```\n\n---\n\n## map\n\nKeyword used to explicitly declare the \"map\" type of a variable or a parameter. Map objects (or IDs) can be created with the map.new<type,type> function.\n\n### Remarks\nMap objects are always of series form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map\", overlay=true)\nmap<int, float> a = na\na := map.new<int, float>()\na.put(bar_index, close)\nlabel.new(bar_index, a.get(bar_index), \"Current close\")\n```\n\n---\n\n## matrix\n\nKeyword used to explicitly declare the \"matrix\" type of a variable or a parameter. Matrix objects (or IDs) can be created with the matrix.new<type> function.\n\n### Remarks\nMatrix objects are always of \"series\" form.",
    "keywords": [
      "label.new",
      "barstate.islastconfirmedhistory",
      "line.new",
      "extend.right",
      "linefill.new",
      "color.new",
      "color.green",
      "map.new",
      "a.put",
      "a.get",
      "matrix.new",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-190",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"matrix example\")\n\n// Create `m1` matrix of `int` type.\nmatrix<int> m1 = matrix.new<int>(2, 3, 0)\n\n// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.\nm2 = matrix.new<int>(2, 3, 0)\n\n// Display matrix using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m2))\n```\n\n---\n\n## polyline\n\nKeyword to explicitly declare the type of a variable or parameter as polyline. Scripts can produce polyline instances using the polyline.new function.\n\n---\n\n## series\n\nThe series keyword explicitly assigns the \"series\" type qualifier to variables and function parameters. Variables and parameters that use the \"series\" qualifier can reference values that change throughout a script's execution.\n\n### Remarks\nTo learn more, see our User Manual's section on type qualifiers.\n\n### Code Example\n```pine\n//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function Finds the highest `source` value over `length` bars, filtered by the `cond` condition.\nexport conditionalHighest(series float source, series bool cond, series int length) =>\n    //@variable The highest `source` value from when the `cond` was `true` over `length` bars.\n    series float result = na\n    // Loop to find the highest value.\n    for i = 0 to length - 1\n        if cond[i]\n            value   = source[i]\n            result := math.max(nz(result, value), value)\n    // Return the `result`.\n    result\n\n//@variable Is `true` once every five bars.\nseries bool condition = bar_index % 5 == 0\n\n//@variable The highest `close` value from every fifth bar over the last 100 bars.\nseries float hiValue = conditionalHighest(close, condition, 100)\n\nplot(hiValue)\nbgcolor(condition ? color.new(color.teal, 80) : na)\n\n//@version=6\nindicator(\"series variable not allowed\")\n\n//@variable A variable declared as \"series int\" with a value of 5.\nseries int myVar = 5\n\n// This call causes an error.\n// The `histbase` accepts \"input int/float\". It can't accept the stronger \"series int\" qualified type.\nplot(close, style = plot.style_histogram, histbase = myVar)\n```\n\n---\n\n## simple\n\nThe simple keyword explicitly assigns the \"simple\" type qualifier to variables and function parameters. Variables and parameters that use the \"simple\" qualifier can reference values established at the beginning of a script's execution that do not change later.\n\n### Remarks\nTo learn more, see our User Manual's section on type qualifiers.",
    "keywords": [
      "matrix.new",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "polyline.new",
      "math.max",
      "color.new",
      "color.teal",
      "plot.style_histogram",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-191",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": ":=",
    "content": "### Code Example\n```pine\n//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function         Calculates the length values for a ribbon of four EMAs by multiplying the `baseLength`.\n//@param baseLength The initial EMA length. Requires \"simple int\" because you can't use \"series int\" in `ta.ema()`.\n//@returns          A tuple of length values.\nexport ribbonLengths(simple int baseLength) =>\n    simple int length1 = baseLength\n    simple int length2 = baseLength * 2\n    simple int length3 = baseLength * 3\n    simple int length4 = baseLength * 4\n    [length1, length2, length3, length4]\n\n// Get a tuple of \"simple int\" length values.\n[len1, len2, len3, len4] = ribbonLengths(14)\n\n// Plot four EMAs using the values from the tuple.\nplot(ta.ema(close, len1), \"EMA 1\", color = color.red)\nplot(ta.ema(close, len2), \"EMA 1\", color = color.orange)\nplot(ta.ema(close, len3), \"EMA 1\", color = color.green)\nplot(ta.ema(close, len4), \"EMA 1\", color = color.blue)\n\n//@version=6\nindicator(\"can't change simple to series\")\n\n//@variable A variable declared as \"simple float\" with a value of 5.0.\nsimple float myVar = 5.0\n\n// This reassignment causes an error.\n// The `close` variable returns a \"series float\" value. Since `myVar` is restricted to \"simple\" values, it cannot\n// change its qualifier to \"series\".\nmyVar := close\n\nplot(myVar)\n```\n\n---\n\n## string\n\nKeyword used to explicitly declare the \"string\" type of a variable or a parameter.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"string\")\nstring s = \"Hello World!\"    // Same as `s = \"Hello world!\"`\n// string s = na // same as \"\" \nplot(na, title=s)\n```\n\n---\n\n## table\n\nKeyword used to explicitly declare the \"table\" type of a variable or a parameter. Table objects (or IDs) can be created with the table.new function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table\")\n// Empty `table1` table ID.\nvar table table1 = na\n// `table` type is unnecessary because `table.new()` returns \"table\" type.\nvar table2 = table.new(position.top_left, na, na)\n\nif barstate.islastconfirmedhistory\n    var table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)\n    table.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")\n```\n\n### Remarks\nTable objects are always of \"series\" form.\n\n# Operators\n\n---\n\n## -\n\nSubtraction or unary minus. Applicable to numerical expressions.\n\n### Returns\nReturns integer or float value, or series of values:\n\n### Remarks\nYou may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.\n\n---\n\n## -=\n\nSubtraction assignment. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"-=\")\n// Equals to expr1 = expr1 - expr2.\na = 2\nb = 3\na -= b\n// Result: a = -1.\nplot(a)\n```\n\n---",
    "keywords": [
      "ta.ema",
      "color.red",
      "color.orange",
      "color.green",
      "color.blue",
      "table.new",
      "position.top_left",
      "barstate.islastconfirmedhistory",
      "position.top_right",
      "color.yellow",
      "table.cell",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-192",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "## :=\n\nReassignment operator. It is used to assign a new value to a previously declared variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"My script\")\n\nmyVar = 10\n\nif close > open\n    // Modifies the existing global scope `myVar` variable by changing its value from 10 to 20.\n    myVar := 20\n    // Creates a new `myVar` variable local to the `if` condition and unreachable from the global scope.\n    // Does not affect the `myVar` declared in global scope.\n    myVar = 30\n\nplot(myVar)\n```\n\n---\n\n## !=\n\nNot equal to. Applicable to expressions of any type.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## ?:\n\nTernary conditional operator.\n\n### Returns\nexpr2 if expr1 is evaluated to true, expr3 otherwise. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true.\n\n### Remarks\nUse na for 'else' branch if you do not need it. You can combine two or more ?: operators to achieve the equivalent of a 'switch'-like statement (see examples above). You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"?:\")\n// Draw circles at the bars where open crosses close\ns2 = ta.cross(open, close) ? math.avg(open,close) : na\nplot(s2, style=plot.style_circles, linewidth=2, color=color.red)\n\n// Combination of ?: operators for 'switch'-like logic\nc = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray\nplot(hl2, color=c)\n```\n\n---\n\n## []\n\nSeries subscript. Provides access to previous values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be rounded down.\n\n### Returns\nA series of values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"[]\")\n// [] can be used to \"save\" variable value between bars\na = 0.0 // declare `a`\na := a[1] // immediately set current value to the same as previous. `na` in the beginning of history\nif high == low // if some condition - change `a` value to another\n    a := low\nplot(a)\n```\n\n---\n\n## *\n\nMultiplication. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n---\n\n## *=\n\nMultiplication assignment. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"*=\")\n// Equals to expr1 = expr1 * expr2.\na = 2\nb = 3\na *= b\n// Result: a = 6.\nplot(a)\n```\n\n---\n\n## /\n\nDivision. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n---\n\n## /=\n\nDivision assignment. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"/=\")\n// Equals to expr1 = expr1 / expr2.\nfloat a = 3.0\nb = 3\na /= b\n// Result: a = 1.\nplot(a)\n```\n\n---\n\n## %\n\nModulo (integer remainder). Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.",
    "keywords": [
      "ta.cross",
      "math.avg",
      "plot.style_circles",
      "color.red",
      "timeframe.isintraday",
      "timeframe.isdaily",
      "color.green",
      "timeframe.isweekly",
      "color.blue",
      "color.gray",
      "indicator",
      "plot",
      "var",
      "series",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-193",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "@enum",
    "content": "### Remarks\nIn Pine Script¬Æ, when the integer remainder is calculated, the quotient is truncated, i.e. rounded towards the lowest absolute value. The resulting value will have the same sign as the dividend. Example: -1 % 9 = -1 - 9 * int(-1/9) = -1 - 9 * int(-0.111) = -1 - 9 * 0 = -1.\n\n---\n\n## %=\n\nModulo assignment. Applicable to numerical expressions.\n\n### Returns\nInteger or float value, or series of values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"%=\")\n// Equals to expr1 = expr1 % expr2.\na = 3\nb = 3\na %= b\n// Result: a = 0.\nplot(a)\n```\n\n---\n\n## +\n\nAddition or unary plus. Applicable to numerical expressions or strings.\n\n### Returns\nBinary + for strings returns concatenation of expr1 and expr2\n\n### Remarks\nYou may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.\n\n---\n\n## +=\n\nAddition assignment. Applicable to numerical expressions or strings.\n\n### Returns\nFor strings returns concatenation of expr1 and expr2. For numbers returns integer or float value, or series of values.\n\n### Remarks\nYou may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"+=\")\n// Equals to expr1 = expr1 + expr2.\na = 2\nb = 3\na += b\n// Result: a = 5.\nplot(a)\n```\n\n---\n\n## <\n\nLess than. Applicable to numerical expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## <=\n\nLess than or equal to. Applicable to numerical expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## ==\n\nEqual to. Applicable to expressions of any type.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## =>\n\nThe '=>' operator is used in user-defined function declarations and in switch statements.\n\n### Remarks\nYou can learn more about user-defined functions in the User Manual's pages on Declaring functions and Libraries.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"=>\")\n// single-line function\nf1(x, y) => x + y\n// multi-line function\nf2(x, y) => \n    sum = x + y\n    sumChange = ta.change(sum, 10)\n    // Function automatically returns the last expression used in it\nplot(f1(30, 8) + f2(1, 3))\n```\n\n---\n\n## >\n\nGreater than. Applicable to numerical expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## >=\n\nGreater than or equal to. Applicable to numerical expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n# Annotations\n\n## @description\n\nSets a custom description for scripts that use the library declaration statement. The text provided with this annotation will be used to pre-fill the \"Description\" field in the publication dialogue.\n\n### Code Example\n```pine\n//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n    label.new(bar_index, high, text = labelText)\n```\n\n---",
    "keywords": [
      "i.e",
      "ta.change",
      "label.new",
      "indicator",
      "plot",
      "fill",
      "var",
      "series",
      "export",
      "type",
      "switch",
      "for"
    ]
  },
  {
    "id": "doc-194",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "## @enum\n\nIf placed above an enum declaration, it adds a custom description for the enum. The Pine Editor's autosuggest uses this description and displays it when a user hovers over the enum name. When used in library scripts, the descriptions of all enums using the export keyword will pre-fill the \"Description\" field in the publication dialogue.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum       Contains fields with popular timezones as titles.\n//@field exch Has an empty string as the title to represent the chart timezone.\nenum tz\n    utc  = \"UTC\"\n    exch = \"\"\n    ny   = \"America/New_York\"\n    chi  = \"America/Chicago\"\n    lon  = \"Europe/London\"\n    tok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n    inSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")\n```\n\n---\n\n## @field\n\nIf placed above a type or enum declaration, it adds a custom description for a field of the type/enum. After the annotation, users should specify the field name, followed by its description.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))\n```\n\n---\n\n## @function\n\nIf placed above a function declaration, it adds a custom description for the function.\n\n### Code Example\n```pine\n//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n    label.new(bar_index, high, text = labelText)\n```\n\n---\n\n## @param\n\nIf placed above a function declaration, it adds a custom description for a function parameter. After the annotation, users should specify the parameter name, then its description.",
    "keywords": [
      "input.session",
      "input.enum",
      "tz.utc",
      "str.tostring",
      "color.new",
      "color.green",
      "i.e",
      "ta.highestbars",
      "label.new",
      "highest.index",
      "highest.price",
      "indicator",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "series",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-195",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n    label.new(bar_index, high, text = labelText)\n```\n\n---\n\n## @returns\n\nIf placed above a function declaration, it adds a custom description for what that function returns.\n\n### Code Example\n```pine\n//@version=6\n// @description Provides a tool to quickly output a label on the chart.\nlibrary(\"MyLibrary\")\n\n// @function Outputs a label with `labelText` on the bar's high.\n// @param labelText (series string) The text to display on the label.\n// @returns Drawn label.\nexport drawLabel(string labelText) =>\n    label.new(bar_index, high, text = labelText)\n```\n\n---\n\n## @strategy_alert_message\n\nIf used within a strategy script, it provides a default message to pre-fill the \"Message\" field in the alert creation dialogue.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"My strategy\", overlay=true, margin_long=100, margin_short=100)\n//@strategy_alert_message Strategy alert on symbol {{ticker}}\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\nstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = 10 / syminfo.mintick, loss = 10 / syminfo.mintick)\n```\n\n---\n\n## @type\n\nIf placed above a type declaration, it adds a custom description for the type.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))\n```\n\n---\n\n## @variable\n\nIf placed above a variable declaration, it adds a custom description for the variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"New high over the last 20 bars\", overlay = true)\n\n//@type A point on a chart.\n//@field index The index of the bar where the point is located, i.e., its `x` coordinate.\n//@field price The price where the point is located, i.e., its `y` coordinate.\ntype Point\n    int index\n    float price\n\n//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.\nPoint highest = na\n\nif ta.highestbars(high, 20) == 0\n    highest := Point.new(bar_index, high)\n    label.new(highest.index, highest.price, str.tostring(highest.price))\n```\n\n---\n\n## @version=\n\nSpecifies the Pine Script¬Æ version that the script will use. The number in this annotation should not be confused with the script's version number, which updates on every saved change to the code.",
    "keywords": [
      "label.new",
      "ta.crossover",
      "ta.sma",
      "strategy.entry",
      "strategy.long",
      "strategy.exit",
      "syminfo.mintick",
      "i.e",
      "ta.highestbars",
      "highest.index",
      "highest.price",
      "str.tostring",
      "indicator",
      "strategy",
      "overlay",
      "fill",
      "alert",
      "var",
      "series",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-196",
    "type": "documentation",
    "source": "pinescriptv6_complete_reference.md",
    "section": "root",
    "title": "Code Example",
    "content": "### Remarks\nThe version should always be specified. Otherwise, for compatibility reasons, the script will be compiled using Pine Script¬Æ v1, which lacks most of the newer features and is bound to confuse. This annotation can be anywhere within a script, but we recommend placing it at the top of the code for readability.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Pine v6 Indicator\")\nplot(close)\n\n//This indicator has no version annotation, so it will try to use v1.\n//Pine Script¬Æ v1 has no function named `indicator()`, so the script will not compile.\nindicator(\"Pine v1 Indicator\")\nplot(close)\n```\n\n---",
    "keywords": [
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-197",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "color.orange",
    "content": "# Constants\n\n## adjustment.dividends\n\n**Type:** const string\n\nConstant for dividends adjustment type (dividends adjustment is applied).\n\n---\n\n## adjustment.none\n\n**Type:** const string\n\nConstant for none adjustment type (no adjustment is applied).\n\n---\n\n## adjustment.splits\n\n**Type:** const string\n\nConstant for splits adjustment type (splits adjustment is applied).\n\n---\n\n## alert.freq_all\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## alert.freq_once_per_bar\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## alert.freq_once_per_bar_close\n\n**Type:** const string\n\nA named constant for use with the freq parameter of the alert() function.\n\n---\n\n## backadjustment.inherit\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## backadjustment.off\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## backadjustment.on\n\n**Type:** const backadjustment\n\nA constant to specify the value of the backadjustment parameter in ticker.new and ticker.modify functions.\n\n---\n\n## barmerge.gaps_off\n\n**Type:** const barmerge_gaps\n\nMerge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value.\n\n---\n\n## barmerge.gaps_on\n\n**Type:** const barmerge_gaps\n\nMerge strategy for requested data. Data is merged with possible gaps (na values).\n\n---\n\n## barmerge.lookahead_off\n\n**Type:** const barmerge_lookahead\n\nMerge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from \"future\" on calculation on history.\n\n---\n\n## barmerge.lookahead_on\n\n**Type:** const barmerge_lookahead\n\nMerge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from \"future\" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators.\n\n---\n\n## color.aqua\n\n**Type:** const color\n\nIs a named constant for #00BCD4 color.\n\n---\n\n## color.black\n\n**Type:** const color\n\nIs a named constant for #363A45 color.\n\n---\n\n## color.blue\n\n**Type:** const color\n\nIs a named constant for #2962ff color.\n\n---\n\n## color.fuchsia\n\n**Type:** const color\n\nIs a named constant for #E040FB color.\n\n---\n\n## color.gray\n\n**Type:** const color\n\nIs a named constant for #787B86 color.\n\n---\n\n## color.green\n\n**Type:** const color\n\nIs a named constant for #4CAF50 color.\n\n---\n\n## color.lime\n\n**Type:** const color\n\nIs a named constant for #00E676 color.\n\n---\n\n## color.maroon\n\n**Type:** const color\n\nIs a named constant for #880E4F color.\n\n---\n\n## color.navy\n\n**Type:** const color\n\nIs a named constant for #311B92 color.\n\n---\n\n## color.olive\n\n**Type:** const color\n\nIs a named constant for #808000 color.\n\n---",
    "keywords": [
      "adjustment.dividends",
      "adjustment.none",
      "adjustment.splits",
      "alert.freq_all",
      "alert.freq_once_per_bar",
      "alert.freq_once_per_bar_close",
      "backadjustment.inherit",
      "ticker.new",
      "ticker.modify",
      "backadjustment.off",
      "backadjustment.on",
      "barmerge.gaps_off",
      "barmerge.gaps_on",
      "barmerge.lookahead_off",
      "barmerge.lookahead_on",
      "color.aqua",
      "color.black",
      "color.blue",
      "color.fuchsia",
      "color.gray",
      "color.green",
      "color.lime",
      "color.maroon",
      "color.navy",
      "color.olive",
      "indicator",
      "strategy",
      "fill",
      "alert",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-198",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "display.all",
    "content": "## color.orange\n\n**Type:** const color\n\nIs a named constant for #FF9800 color.\n\n---\n\n## color.purple\n\n**Type:** const color\n\nIs a named constant for #9C27B0 color.\n\n---\n\n## color.red\n\n**Type:** const color\n\nIs a named constant for #F23645 color.\n\n---\n\n## color.silver\n\n**Type:** const color\n\nIs a named constant for #B2B5BE color.\n\n---\n\n## color.teal\n\n**Type:** const color\n\nIs a named constant for #089981 color.\n\n---\n\n## color.white\n\n**Type:** const color\n\nIs a named constant for #FFFFFF color.\n\n---\n\n## color.yellow\n\n**Type:** const color\n\nIs a named constant for #FDD835 color.\n\n---\n\n## currency.AUD\n\n**Type:** const string\n\nAustralian dollar.\n\n---\n\n## currency.BTC\n\n**Type:** const string\n\nBitcoin.\n\n---\n\n## currency.CAD\n\n**Type:** const string\n\nCanadian dollar.\n\n---\n\n## currency.CHF\n\n**Type:** const string\n\nSwiss franc.\n\n---\n\n## currency.EGP\n\n**Type:** const string\n\nEgyptian pound.\n\n---\n\n## currency.ETH\n\n**Type:** const string\n\nEthereum.\n\n---\n\n## currency.EUR\n\n**Type:** const string\n\nEuro.\n\n---\n\n## currency.GBP\n\n**Type:** const string\n\nPound sterling.\n\n---\n\n## currency.HKD\n\n**Type:** const string\n\nHong Kong dollar.\n\n---\n\n## currency.INR\n\n**Type:** const string\n\nIndian rupee.\n\n---\n\n## currency.JPY\n\n**Type:** const string\n\nJapanese yen.\n\n---\n\n## currency.KRW\n\n**Type:** const string\n\nSouth Korean won.\n\n---\n\n## currency.MYR\n\n**Type:** const string\n\nMalaysian ringgit.\n\n---\n\n## currency.NOK\n\n**Type:** const string\n\nNorwegian krone.\n\n---\n\n## currency.NONE\n\n**Type:** const string\n\nUnspecified currency.\n\n---\n\n## currency.NZD\n\n**Type:** const string\n\nNew Zealand dollar.\n\n---\n\n## currency.PKR\n\n**Type:** const string\n\nPakistani rupee.\n\n---\n\n## currency.PLN\n\n**Type:** const string\n\nPolish zloty.\n\n---\n\n## currency.RUB\n\n**Type:** const string\n\nRussian ruble.\n\n---\n\n## currency.SEK\n\n**Type:** const string\n\nSwedish krona.\n\n---\n\n## currency.SGD\n\n**Type:** const string\n\nSingapore dollar.\n\n---\n\n## currency.TRY\n\n**Type:** const string\n\nTurkish lira.\n\n---\n\n## currency.USD\n\n**Type:** const string\n\nUnited States dollar.\n\n---\n\n## currency.USDT\n\n**Type:** const string\n\nTether.\n\n---\n\n## currency.ZAR\n\n**Type:** const string\n\nSouth African rand.\n\n---\n\n## dayofweek.friday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.monday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.saturday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.sunday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.thursday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.tuesday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---\n\n## dayofweek.wednesday\n\n**Type:** const int\n\nIs a named constant for return value of dayofweek function and value of dayofweek variable.\n\n---",
    "keywords": [
      "color.orange",
      "color.purple",
      "color.red",
      "color.silver",
      "color.teal",
      "color.white",
      "color.yellow",
      "dayofweek.friday",
      "dayofweek.monday",
      "dayofweek.saturday",
      "dayofweek.sunday",
      "dayofweek.thursday",
      "dayofweek.tuesday",
      "dayofweek.wednesday",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-199",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "font.family_default",
    "content": "## display.all\n\n**Type:** const plot_simple_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in all possible locations.\n\n---\n\n## display.data_window\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in the Data Window, a menu accessible from the chart's right sidebar.\n\n---\n\n## display.none\n\n**Type:** const plot_simple_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. plot*() functions using this will not display their plotted values anywhere. However, alert template messages and fill functions can still use the values, and they will appear in exported chart data. input*() functions using this constant will only display their values within the script's settings.\n\n---\n\n## display.pane\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() functions. Displays plotted values in the chart pane used by the script.\n\n---\n\n## display.price_scale\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() functions. Displays the plot‚Äôs label and value on the price scale if the chart's settings allow it.\n\n---\n\n## display.status_line\n\n**Type:** const plot_display\n\nA named constant for use with the display parameter of plot*() and input*() functions. Displays plotted or input values in the status line next to the script's name on the chart if the chart's settings allow it.\n\n---\n\n## dividends.gross\n\n**Type:** const string\n\nA named constant for the request.dividends function. Is used to request the dividends return on a stock before deductions.\n\n---\n\n## dividends.net\n\n**Type:** const string\n\nA named constant for the request.dividends function. Is used to request the dividends return on a stock after deductions.\n\n---\n\n## earnings.actual\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the earnings value as it was reported.\n\n---\n\n## earnings.estimate\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the estimated earnings value.\n\n---\n\n## earnings.standardized\n\n**Type:** const string\n\nA named constant for the request.earnings function. Is used to request the standardized earnings value.\n\n---\n\n## extend.both\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.left\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.none\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## extend.right\n\n**Type:** const string\n\nA named constant for line.new and line.set_extend functions.\n\n---\n\n## false\n\nLiteral representing a bool value, and result of a comparison operation.\n\n### Remarks\nSee the User Manual for comparison operators and logical operators.\n\n---",
    "keywords": [
      "display.all",
      "display.data_window",
      "display.none",
      "display.pane",
      "display.price_scale",
      "display.status_line",
      "dividends.gross",
      "request.dividends",
      "dividends.net",
      "earnings.actual",
      "request.earnings",
      "earnings.estimate",
      "earnings.standardized",
      "extend.both",
      "line.new",
      "line.set_extend",
      "extend.left",
      "extend.none",
      "extend.right",
      "input",
      "plot",
      "fill",
      "alert",
      "simple",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-200",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "label.style_label_left",
    "content": "## font.family_default\n\n**Type:** const string\n\nDefault text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions.\n\n---\n\n## font.family_monospace\n\n**Type:** const string\n\nMonospace text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions.\n\n---\n\n## format.inherit\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values from the parent series in the indicator function.\n\n---\n\n## format.mintick\n\n**Type:** const string\n\nIs a named constant to use with the str.tostring function. Passing a number to str.tostring with this argument rounds the number to the nearest value that can be divided by syminfo.mintick, without the remainder, with ties rounding up, and returns the string version of said value with trailing zeros.\n\n---\n\n## format.percent\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values.\n\n### Remarks\nThe default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the indicator function.\n\n---\n\n## format.price\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as prices in the indicator function.\n\n### Remarks\nIf format is format.price, default precision value is set. You can use the precision argument of indicator function to change the precision value.\n\n---\n\n## format.volume\n\n**Type:** const string\n\nIs a named constant for selecting the formatting of the script output values as volume in the indicator function, e.g. '5183' will be formatted as '5.183K'.\n\n---\n\n## hline.style_dashed\n\n**Type:** const hline_style\n\nIs a named constant for dashed linestyle of hline function.\n\n---\n\n## hline.style_dotted\n\n**Type:** const hline_style\n\nIs a named constant for dotted linestyle of hline function.\n\n---\n\n## hline.style_solid\n\n**Type:** const hline_style\n\nIs a named constant for solid linestyle of hline function.\n\n---\n\n## label.style_arrowdown\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_arrowup\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_circle\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_cross\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_diamond\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_flag\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_center\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_down\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---",
    "keywords": [
      "font.family_default",
      "box.new",
      "box.set_text_font_family",
      "label.new",
      "label.set_text_font_family",
      "table.cell",
      "table.cell_set_text_font_family",
      "font.family_monospace",
      "format.inherit",
      "format.mintick",
      "str.tostring",
      "syminfo.mintick",
      "format.percent",
      "format.price",
      "format.volume",
      "e.g",
      "hline.style_dashed",
      "hline.style_dotted",
      "hline.style_solid",
      "label.style_arrowdown",
      "label.set_style",
      "label.style_arrowup",
      "label.style_circle",
      "label.style_cross",
      "label.style_diamond",
      "label.style_flag",
      "label.style_label_center",
      "label.style_label_down",
      "indicator",
      "hline",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-201",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "math.phi",
    "content": "## label.style_label_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_lower_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_lower_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_up\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_upper_left\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_label_upper_right\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_none\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_square\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_text_outline\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_triangledown\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_triangleup\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## label.style_xcross\n\n**Type:** const string\n\nLabel style for label.new and label.set_style functions.\n\n---\n\n## line.style_arrow_both\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrows on both points.\n\n---\n\n## line.style_arrow_left\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrow on the first point.\n\n---\n\n## line.style_arrow_right\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions. Solid line with arrow on the second point.\n\n---\n\n## line.style_dashed\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## line.style_dotted\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## line.style_solid\n\n**Type:** const string\n\nLine style for line.new and line.set_style functions.\n\n---\n\n## location.abovebar\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted above main series bars.\n\n---\n\n## location.absolute\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted on chart using indicator value as a price coordinate.\n\n---\n\n## location.belowbar\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted below main series bars.\n\n---\n\n## location.bottom\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted near the bottom chart border.\n\n---\n\n## location.top\n\n**Type:** const string\n\nLocation value for plotshape, plotchar functions. Shape is plotted near the top chart border.\n\n---\n\n## math.e\n\n**Type:** const float\n\nIs a named constant for Euler's number. It is equal to 2.7182818284590452.\n\n---",
    "keywords": [
      "label.style_label_left",
      "label.new",
      "label.set_style",
      "label.style_label_lower_left",
      "label.style_label_lower_right",
      "label.style_label_right",
      "label.style_label_up",
      "label.style_label_upper_left",
      "label.style_label_upper_right",
      "label.style_none",
      "label.style_square",
      "label.style_text_outline",
      "label.style_triangledown",
      "label.style_triangleup",
      "label.style_xcross",
      "line.style_arrow_both",
      "line.new",
      "line.set_style",
      "line.style_arrow_left",
      "line.style_arrow_right",
      "line.style_dashed",
      "line.style_dotted",
      "line.style_solid",
      "location.abovebar",
      "location.absolute",
      "location.belowbar",
      "location.bottom",
      "location.top",
      "math.e",
      "indicator",
      "plot",
      "series",
      "const",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-202",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "position.middle_center",
    "content": "## math.phi\n\n**Type:** const float\n\nIs a named constant for the golden ratio. It is equal to 1.6180339887498948.\n\n---\n\n## math.pi\n\n**Type:** const float\n\nIs a named constant for Archimedes' constant. It is equal to 3.1415926535897932.\n\n---\n\n## math.rphi\n\n**Type:** const float\n\nIs a named constant for the golden ratio conjugate. It is equal to 0.6180339887498948.\n\n---\n\n## order.ascending\n\n**Type:** const sort_order\n\nDetermines the sort order of the array from the smallest to the largest value.\n\n---\n\n## order.descending\n\n**Type:** const sort_order\n\nDetermines the sort order of the array from the largest to the smallest value.\n\n---\n\n## plot.style_area\n\n**Type:** const plot_style\n\nA named constant for the 'Area' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_areabr\n\n**Type:** const plot_style\n\nA named constant for the 'Area With Breaks' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_area, except the gaps in the data are not filled.\n\n---\n\n## plot.style_circles\n\n**Type:** const plot_style\n\nA named constant for the 'Circles' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_columns\n\n**Type:** const plot_style\n\nA named constant for the 'Columns' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_cross\n\n**Type:** const plot_style\n\nA named constant for the 'Cross' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_histogram\n\n**Type:** const plot_style\n\nA named constant for the 'Histogram' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_line\n\n**Type:** const plot_style\n\nA named constant for the 'Line' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_linebr\n\n**Type:** const plot_style\n\nA named constant for the 'Line With Breaks' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_line, except the gaps in the data are not filled.\n\n---\n\n## plot.style_stepline\n\n**Type:** const plot_style\n\nA named constant for the 'Step Line' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## plot.style_stepline_diamond\n\n**Type:** const plot_style\n\nA named constant for the 'Step Line With Diamonds' style, to be used as an argument for the style parameter in the plot function. Similar to plot.style_stepline, except the data changes are also marked with the Diamond shapes.\n\n---\n\n## plot.style_steplinebr\n\n**Type:** const plot_style\n\nA named constant for the 'Step line with Breaks' style, to be used as an argument for the style parameter in the plot function.\n\n---\n\n## position.bottom_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.bottom_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.bottom_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---",
    "keywords": [
      "math.phi",
      "math.pi",
      "math.rphi",
      "order.ascending",
      "order.descending",
      "plot.style_area",
      "plot.style_areabr",
      "plot.style_circles",
      "plot.style_columns",
      "plot.style_cross",
      "plot.style_histogram",
      "plot.style_line",
      "plot.style_linebr",
      "plot.style_stepline",
      "plot.style_stepline_diamond",
      "plot.style_steplinebr",
      "position.bottom_center",
      "table.new",
      "table.cell",
      "position.bottom_left",
      "position.bottom_right",
      "plot",
      "fill",
      "const",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-203",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "size.large",
    "content": "## position.middle_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.middle_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.middle_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_center\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_left\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## position.top_right\n\n**Type:** const string\n\nTable position is used in table.new, table.cell functions.\n\n---\n\n## scale.left\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added to the left price scale.\n\n---\n\n## scale.none\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'.\n\n---\n\n## scale.right\n\n**Type:** const scale_type\n\nScale value for indicator function. Indicator is added to the right price scale.\n\n---\n\n## session.extended\n\n**Type:** const string\n\nConstant for extended session type (with extended hours data).\n\n---\n\n## session.regular\n\n**Type:** const string\n\nConstant for regular session type (no extended hours data).\n\n---\n\n## settlement_as_close.inherit\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## settlement_as_close.off\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## settlement_as_close.on\n\n**Type:** const settlement\n\nA constant to specify the value of the settlement_as_close parameter in ticker.new and ticker.modify functions.\n\n---\n\n## shape.arrowdown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.arrowup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.circle\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.cross\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.diamond\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.flag\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.labeldown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.labelup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.square\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.triangledown\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.triangleup\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## shape.xcross\n\n**Type:** const string\n\nShape style for plotshape function.\n\n---\n\n## size.auto\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape automatically adapts to the size of the bars.\n\n---\n\n## size.huge\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly huge.\n\n---",
    "keywords": [
      "position.middle_center",
      "table.new",
      "table.cell",
      "position.middle_left",
      "position.middle_right",
      "position.top_center",
      "position.top_left",
      "position.top_right",
      "scale.left",
      "scale.none",
      "scale.right",
      "session.extended",
      "session.regular",
      "settlement_as_close.inherit",
      "ticker.new",
      "ticker.modify",
      "settlement_as_close.off",
      "settlement_as_close.on",
      "shape.arrowdown",
      "shape.arrowup",
      "shape.circle",
      "shape.cross",
      "shape.diamond",
      "shape.flag",
      "shape.labeldown",
      "shape.labelup",
      "shape.square",
      "shape.triangledown",
      "shape.triangleup",
      "shape.xcross",
      "size.auto",
      "size.huge",
      "indicator",
      "overlay",
      "plot",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-204",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## size.large\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly large.\n\n---\n\n## size.normal\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly normal.\n\n---\n\n## size.small\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly small.\n\n---\n\n## size.tiny\n\n**Type:** const string\n\nSize value for plotshape, plotchar functions. The size of the shape constantly tiny.\n\n---\n\n## splits.denominator\n\n**Type:** const string\n\nA named constant for the request.splits function. Is used to request the denominator (the number below the line in a fraction) of a splits.\n\n---\n\n## splits.numerator\n\n**Type:** const string\n\nA named constant for the request.splits function. Is used to request the numerator (the number above the line in a fraction) of a splits.\n\n---\n\n## strategy.cash\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that an amount of cash in the strategy.account_currency will be used to enter trades.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.\n    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.commission.cash_per_contract\n\n**Type:** const string\n\nCommission type for an order. Money displayed in the account currency per contract.\n\n---\n\n## strategy.commission.cash_per_order\n\n**Type:** const string\n\nCommission type for an order. Money displayed in the account currency per order.\n\n---\n\n## strategy.commission.percent\n\n**Type:** const string\n\nCommission type for an order. A percentage of the cash volume of order.\n\n---\n\n## strategy.direction.all\n\n**Type:** const string\n\nIt allows strategy to open both long and short positions.\n\n---\n\n## strategy.direction.long\n\n**Type:** const string\n\nIt allows strategy to open only long positions.\n\n---\n\n## strategy.direction.short\n\n**Type:** const string\n\nIt allows strategy to open only short positions.\n\n---\n\n## strategy.fixed\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that a number of contracts/shares/lots will be used to enter trades.",
    "keywords": [
      "size.large",
      "size.normal",
      "size.small",
      "size.tiny",
      "splits.denominator",
      "request.splits",
      "splits.numerator",
      "strategy.cash",
      "strategy.entry",
      "strategy.order",
      "strategy.account_currency",
      "strategy.long",
      "strategy.close",
      "strategy.commission",
      "strategy.direction",
      "strategy.fixed",
      "strategy",
      "overlay",
      "plot",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-205",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)\n\nif bar_index == 0\n    // As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.\n    // qty = 50\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.long\n\n**Type:** const strategy_direction\n\nA named constant for use with the direction parameter of the strategy.entry and strategy.order commands. It specifies that the command creates a buy order.\n\n---\n\n## strategy.oca.cancel\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that the strategy cancels the unfilled order when another order with the same oca_name and oca_type executes.\n\n### Remarks\nStrategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from strategy.order calls with the same oca_* arguments, the strategy cannot fully or partially cancel either one.\n\n---\n\n## strategy.oca.none\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that the order executes independently of all other orders, including those with the same oca_name.\n\n---\n\n## strategy.oca.reduce\n\n**Type:** const string\n\nA named constant for use with the oca_type parameter of the strategy.entry and strategy.order commands. It specifies that when another order with the same oca_name and oca_type executes, the strategy reduces the unfilled order by that order's size. If the unfilled order's size reaches 0 after reduction, it is the same as canceling the order entirely.\n\n### Remarks\nStrategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from strategy.order calls with the same oca_* arguments, the strategy cannot fully or partially cancel either one. Orders from strategy.exit automatically use this OCA type, and they belong to the same OCA group by default.\n\n---\n\n## strategy.percent_of_equity\n\n**Type:** const string\n\nThis is one of the arguments that can be supplied to the default_qty_type parameter in the strategy declaration statement. It is only relevant when no value is used for the ‚Äòqty‚Äô parameter in strategy.entry or strategy.order function calls. It specifies that a percentage (0-100) of equity will be used to enter trades.",
    "keywords": [
      "strategy.fixed",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.order",
      "strategy.oca",
      "strategy.exit",
      "strategy.percent_of_equity",
      "strategy",
      "overlay",
      "fill",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-206",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "xloc.bar_time",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)\n\n// As ‚Äòqty‚Äô is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.\nif bar_index == 0\n    strategy.entry(\"EN\", strategy.long)\nif bar_index == 2\n    strategy.close(\"EN\")\nplot(strategy.equity)\n\n // The ‚Äòqty‚Äô parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).\nif bar_index == 4\n    strategy.entry(\"EN\", strategy.long, qty = 10)\nif bar_index == 6\n    strategy.close(\"EN\")\n```\n\n---\n\n## strategy.short\n\n**Type:** const strategy_direction\n\nA named constant for use with the direction parameter of the strategy.entry and strategy.order commands. It specifies that the command creates a sell order.\n\n---\n\n## text.align_bottom\n\n**Type:** const string\n\nVertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions.\n\n---\n\n## text.align_center\n\n**Type:** const string\n\nText alignment for box.new, box.set_text_halign, box.set_text_valign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_left\n\n**Type:** const string\n\nHorizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_right\n\n**Type:** const string\n\nHorizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions.\n\n---\n\n## text.align_top\n\n**Type:** const string\n\nVertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions.\n\n---\n\n## text.format_bold\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Makes the text bold.\n\n---\n\n## text.format_italic\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Italicizes the text.\n\n---\n\n## text.format_none\n\n**Type:** const text_format\n\nA named constant for use with the text_formatting parameter of the label.new(), box.new(), table.cell(), and *set_text_formatting() functions. Signifies no special text formatting.\n\n---\n\n## text.wrap_auto\n\n**Type:** const string\n\nAutomatic wrapping mode for box.new and box.set_text_wrap functions.\n\n---\n\n## text.wrap_none\n\n**Type:** const string\n\nDisabled wrapping mode for box.new and box.set_text_wrap functions.\n\n---\n\n## true\n\nLiteral representing one of the values a bool variable can hold, or an expression can evaluate to when it uses comparison or logical operators.\n\n### Remarks\nSee the User Manual for comparison operators and logical operators.\n\n---\n\n## xloc.bar_index\n\n**Type:** const string\n\nA constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_index, the drawing object treats each x-coordinate as a bar_index value.\n\n---",
    "keywords": [
      "strategy.percent_of_equity",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "strategy.equity",
      "strategy.short",
      "strategy.order",
      "text.align_bottom",
      "box.new",
      "box.set_text_valign",
      "table.cell",
      "table.cell_set_text_valign",
      "text.align_center",
      "box.set_text_halign",
      "label.new",
      "label.set_textalign",
      "text.align_left",
      "text.align_right",
      "text.align_top",
      "text.format_bold",
      "text.format_italic",
      "text.format_none",
      "text.wrap_auto",
      "box.set_text_wrap",
      "text.wrap_none",
      "xloc.bar_index",
      "strategy",
      "overlay",
      "plot",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-207",
    "type": "documentation",
    "source": "reference/constants.md",
    "section": "reference",
    "title": "yloc.price",
    "content": "## xloc.bar_time\n\n**Type:** const string\n\nA constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If xloc = xloc.bar_time, the drawing object treats each x-coordinate as a UNIX timestamp, expressed in milliseconds.\n\n---\n\n## yloc.abovebar\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---\n\n## yloc.belowbar\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---\n\n## yloc.price\n\n**Type:** const string\n\nA named constant that specifies the algorithm of interpretation of y-value in function label.new.\n\n---",
    "keywords": [
      "xloc.bar_time",
      "yloc.abovebar",
      "label.new",
      "yloc.belowbar",
      "yloc.price",
      "const",
      "type",
      "if"
    ]
  },
  {
    "id": "doc-208",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Remarks",
    "content": "# Functions - Technical Analysis All ta.* functions (RSI, SMA, etc.)\n\n## ta.alma()\n\nArnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average.\n\n### Returns\nArnaud Legoux Moving Average.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.alma\", overlay=true) \nplot(ta.alma(close, 9, 0.85, 6))\n\n// same on pine, but much less efficient\npine_alma(series, windowsize, offset, sigma) =>\n    m = offset * (windowsize - 1)\n    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true\n    s = windowsize / sigma\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to windowsize - 1\n        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))\n        norm := norm + weight\n        sum := sum + series[windowsize - i - 1] * weight\n    sum / norm\nplot(pine_alma(close, 9, 0.85, 6))\n```\n\n---\n\n## ta.atr()\n\nFunction atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1])).\n\n### Returns\nAverage true range.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.atr\")\nplot(ta.atr(14))\n\n//the same on pine\npine_atr(length) =>\n    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))\n    //true range can be also calculated with ta.tr(true)\n    ta.rma(trueRange, length)\n\nplot(pine_atr(14))\n```\n\n---\n\n## ta.barssince()\n\nCounts the number of bars since the last time the condition was true.\n\n### Returns\nNumber of bars since condition was true.\n\n### Remarks\nIf the condition has never been met prior to the current bar, the function returns na. Please note that using this variable/function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.barssince\")\n// get number of bars since last color.green bar\nplot(ta.barssince(close >= open))\n```\n\n---\n\n## ta.bb()\n\nBollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences.\n\n### Returns\nBollinger Bands.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.bb\")\n\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n// the same on pine\nf_bb(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    [basis, basis + dev, basis - dev]\n\n[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)\n```\n\n---\n\n## ta.bbw()\n\nBollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band.\n\n### Returns\nBollinger Bands Width.",
    "keywords": [
      "ta.alma",
      "math.floor",
      "math.exp",
      "math.pow",
      "ta.atr",
      "math.max",
      "math.abs",
      "ta.tr",
      "ta.rma",
      "ta.barssince",
      "color.green",
      "ta.bb",
      "color.yellow",
      "ta.sma",
      "ta.stdev",
      "ta.bbw",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-209",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "ta.crossover()",
    "content": "### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.bbw\")\n\nplot(ta.bbw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_bbw(src, length, mult) =>\n    float basis = ta.sma(src, length)\n    float dev = mult * ta.stdev(src, length)\n    (((basis + dev) - (basis - dev)) / basis) * 100\n\nplot(f_bbw(close, 5, 4))\n```\n\n---\n\n## ta.cci()\n\nThe CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers.\n\n### Returns\nCommodity channel index of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.change()\n\nCompares the current source value to its value length bars ago and returns the difference.\n\n### Returns\nThe difference between the values when they are numerical. When a 'bool' source is used, returns true when the current source is different from the previous source.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator('Day and Direction Change', overlay = true)\ndailyBarTime = time('1D')\nisNewDay = ta.change(dailyBarTime) != 0\nbgcolor(isNewDay ? color.new(color.green, 80) : na)\n\nisGreenBar = close >= open\ncolorChange = ta.change(isGreenBar)\nplotshape(colorChange, 'Direction Change')\n```\n\n---\n\n## ta.cmo()\n\nChande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period.\n\n### Returns\nChande Momentum Oscillator.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.cmo\")\nplot(ta.cmo(close, 5), color=color.yellow)\n\n// the same on pine\nf_cmo(src, length) =>\n    float mom = ta.change(src)\n    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)\n    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)\n    100 * (sm1 - sm2) / (sm1 + sm2)\n\nplot(f_cmo(close, 5))\n```\n\n---\n\n## ta.cog()\n\nThe cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio.\n\n### Returns\nCenter of Gravity.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.cog\", overlay=true) \nplot(ta.cog(close, 10))\n\n// the same on pine\npine_cog(source, length) =>\n    sum = math.sum(source, length)\n    num = 0.0\n    for i = 0 to length - 1\n        price = source[i]\n        num := num + price * (i + 1)\n    -num / sum\n\nplot(pine_cog(close, 10))\n```\n\n---\n\n## ta.correlation()\n\nCorrelation coefficient. Describes the degree to which two series tend to deviate from their ta.sma values.\n\n### Returns\nCorrelation coefficient.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.cross()\n\n### Returns\ntrue if two series have crossed each other, otherwise false.\n\n---",
    "keywords": [
      "ta.bbw",
      "color.yellow",
      "ta.sma",
      "ta.stdev",
      "ta.cci",
      "ta.change",
      "color.new",
      "color.green",
      "ta.cmo",
      "math.sum",
      "ta.cog",
      "ta.correlation",
      "ta.cross",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-210",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Returns",
    "content": "## ta.crossover()\n\nThe source1-series is defined as having crossed over source2-series if, on the current bar, the value of source1 is greater than the value of source2, and on the previous bar, the value of source1 was less than or equal to the value of source2.\n\n### Returns\ntrue if source1 crossed over source2 otherwise false.\n\n---\n\n## ta.crossunder()\n\nThe source1-series is defined as having crossed under source2-series if, on the current bar, the value of source1 is less than the value of source2, and on the previous bar, the value of source1 was greater than or equal to the value of source2.\n\n### Returns\ntrue if source1 crossed under source2 otherwise false.\n\n---\n\n## ta.cum()\n\nCumulative (total) sum of source. In other words it's a sum of all elements of source.\n\n### Returns\nTotal sum series.\n\n---\n\n## ta.dev()\n\nMeasure of difference between the series and it's ta.sma\n\n### Returns\nDeviation of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.dev\")\nplot(ta.dev(close, 10))\n\n// the same on pine\npine_dev(source, length) =>\n    mean = ta.sma(source, length)\n    sum = 0.0\n    for i = 0 to length - 1\n        val = source[i]\n        sum := sum + math.abs(val - mean)\n    dev = sum/length\nplot(pine_dev(close, 10))\n```\n\n---\n\n## ta.dmi()\n\nThe dmi function returns the directional movement index.\n\n### Returns\nTuple of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX).\n\n### Code Example\n```pine\n//@version=6\nindicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)\nlen = input.int(17, minval=1, title=\"DI Length\")\nlensig = input.int(14, title=\"ADX Smoothing\", minval=1)\n[diplus, diminus, adx] = ta.dmi(len, lensig)\nplot(adx, color=color.red, title=\"ADX\")\nplot(diplus, color=color.blue, title=\"+DI\")\nplot(diminus, color=color.orange, title=\"-DI\")\n```\n\n---\n\n## ta.ema()\n\nThe ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: EMA = alpha * source + (1 - alpha) * EMA[1], where alpha = 2 / (length + 1).\n\n### Returns\nExponential moving average of source with alpha = 2 / (length + 1).\n\n### Remarks\nPlease note that using this variable/function can cause indicator repainting. na values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.ema\")\nplot(ta.ema(close, 15))\n\n//the same on pine\npine_ema(src, length) =>\n    alpha = 2 / (length + 1)\n    sum = 0.0\n    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_ema(close,15))\n```\n\n---\n\n## ta.falling()\n\nTest if the source series is now falling for length bars long.\n\n### Returns\ntrue if current source value is less than any previous source value for length bars back, false otherwise.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.highest()\n\nHighest value for a given number of bars back.",
    "keywords": [
      "ta.crossover",
      "ta.crossunder",
      "ta.cum",
      "ta.dev",
      "ta.sma",
      "math.abs",
      "ta.dmi",
      "format.price",
      "input.int",
      "color.red",
      "color.blue",
      "color.orange",
      "ta.ema",
      "ta.falling",
      "ta.highest",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-211",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Remarks",
    "content": "### Returns\nHighest value in the series.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses high as a source series. na values in the source series are ignored.\n\n---\n\n## ta.highestbars()\n\nHighest value offset for a given number of bars back.\n\n### Returns\nOffset to the highest bar.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses high as a source series. na values in the source series are ignored.\n\n---\n\n## ta.hma()\n\nThe hma function returns the Hull Moving Average.\n\n### Returns\nHull moving average of 'source' for 'length' bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Hull Moving Average\")\nsrc = input(defval=close, title=\"Source\")\nlength = input(defval=9, title=\"Length\")\nhmaBuildIn = ta.hma(src, length)\nplot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)\n```\n\n---\n\n## ta.kc()\n\nKeltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below.\n\n### Returns\nKeltner Channels.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.kc\")\n\n[middle, upper, lower] = ta.kc(close, 5, 4)\nplot(middle, color=color.yellow)\nplot(upper, color=color.yellow)\nplot(lower, color=color.yellow)\n\n\n// the same on pine\nf_kc(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    [basis, basis + rangeEma * mult, basis - rangeEma * mult]\n    \n[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)\n\nplot(pineMiddle)\nplot(pineUpper)\nplot(pineLower)\n```\n\n---\n\n## ta.kcw()\n\nKeltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel.\n\n### Returns\nKeltner Channels Width.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.kcw\")\n\nplot(ta.kcw(close, 5, 4), color=color.yellow)\n\n// the same on pine\nf_kcw(src, length, mult, useTrueRange) =>\n    float basis = ta.ema(src, length)\n    float span = (useTrueRange) ? ta.tr : (high - low)\n    float rangeEma = ta.ema(span, length)\n    \n    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis\n\nplot(f_kcw(close, 5, 4, true))\n```\n\n---\n\n## ta.linreg()\n\nLinear regression curve. A line that best fits the prices specified over a user-defined time period. It is calculated using the least squares method. The result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where intercept and slope are the values calculated with the least squares method on source series.\n\n### Returns\nLinear regression curve.",
    "keywords": [
      "ta.highestbars",
      "ta.hma",
      "ta.kc",
      "color.yellow",
      "ta.ema",
      "ta.tr",
      "ta.kcw",
      "ta.linreg",
      "indicator",
      "input",
      "plot",
      "series",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-212",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Remarks",
    "content": "### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.lowest()\n\nLowest value for a given number of bars back.\n\n### Returns\nLowest value in the series.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses low as a source series. na values in the source series are ignored.\n\n---\n\n## ta.lowestbars()\n\nLowest value offset for a given number of bars back.\n\n### Returns\nOffset to the lowest bar.\n\n### Remarks\nTwo args version: source is a series and length is the number of bars back. One arg version: length is the number of bars back. Algorithm uses low as a source series. na values in the source series are ignored.\n\n---\n\n## ta.macd()\n\nMACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock's price.\n\n### Returns\nTuple of three MACD series: MACD line, signal line and histogram line.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"MACD\")\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplot(macdLine, color=color.blue)\nplot(signalLine, color=color.orange)\nplot(histLine, color=color.red, style=plot.style_histogram)\n\n//@version=6\nindicator(\"MACD\")\n[_, signalLine, _] = ta.macd(close, 12, 26, 9)\nplot(signalLine, color=color.orange)\n```\n\n---\n\n## ta.max()\n\nReturns the all-time high value of source from the beginning of the chart up to the current bar.\n\n### Remarks\nna occurrences of source are ignored.\n\n---\n\n## ta.median()\n\nReturns the median of the series.\n\n### Returns\nThe median of the series.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.mfi()\n\nMoney Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset.\n\n### Returns\nMoney Flow Index.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Money Flow Index\")\n\nplot(ta.mfi(hlc3, 14), color=color.yellow)\n\n// the same on pine\npine_mfi(src, length) =>\n    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)\n    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)\n    mfi = 100.0 - (100.0 / (1.0 + upper / lower))\n    mfi\n\nplot(pine_mfi(hlc3, 14))\n```\n\n---\n\n## ta.min()\n\nReturns the all-time low value of source from the beginning of the chart up to the current bar.\n\n### Remarks\nna occurrences of source are ignored.\n\n---\n\n## ta.mode()\n\nReturns the mode of the series. If there are several values with the same frequency, it returns the smallest value.\n\n### Returns\nThe most frequently occurring value from the source. If none exists, returns the smallest value instead.",
    "keywords": [
      "ta.lowest",
      "ta.lowestbars",
      "ta.macd",
      "color.blue",
      "color.orange",
      "color.red",
      "plot.style_histogram",
      "ta.max",
      "ta.median",
      "ta.mfi",
      "color.yellow",
      "math.sum",
      "ta.change",
      "ta.min",
      "ta.mode",
      "indicator",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-213",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Code Example",
    "content": "### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.mom()\n\nMomentum of source price and source price length bars ago. This is simply a difference: source - source[length].\n\n### Returns\nMomentum of source price and source price length bars ago.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.percentile_linear_interpolation()\n\nCalculates percentile using method of linear interpolation between the two nearest ranks.\n\n### Returns\nP-th percentile of source series for length bars back.\n\n### Remarks\nNote that a percentile calculated using this method will NOT always be a member of the input data set. na values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.percentile_nearest_rank()\n\nCalculates percentile using method of Nearest Rank.\n\n### Returns\nP-th percentile of source series for length bars back.\n\n### Remarks\nUsing the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile. A percentile calculated using the Nearest Rank method will always be a member of the input data set. The 100th percentile is defined to be the largest value in the input data set. na values in the source series are ignored.\n\n---\n\n## ta.percentrank()\n\nPercent rank is the percents of how many previous values was less than or equal to the current value of given series.\n\n### Returns\nPercent rank of source for length bars back.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.pivot_point_levels()\n\nCalculates the pivot point levels using the specified type and anchor.\n\n### Returns\nAn array<float> with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified type return na values (e.g., \"DM\" only calculates P, R1, and S1).\n\n### Remarks\nThe developing parameter cannot be true when type is set to \"Woodie\", because the Woodie calculation for a period depends on that period's open, which means that the pivot value is either available or unavailable, but never developing. If used together, the indicator will return a runtime error.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)\ntimeframe = \"1W\"\ntypeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])\nweekChange = timeframe.change(timeframe)\npivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)\nif weekChange\n    for pivotLevel in pivotPointsArray\n        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)\n```\n\n---\n\n## ta.pivothigh()\n\nThis function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point.\n\n### Returns\nPrice of the point or 'NaN'.\n\n### Remarks\nIf parameters 'leftbars' or 'rightbars' are series you should use max_bars_back function for the 'source' variable.",
    "keywords": [
      "ta.mom",
      "ta.percentile_linear_interpolation",
      "ta.percentile_nearest_rank",
      "ta.percentrank",
      "ta.pivot_point_levels",
      "e.g",
      "input.string",
      "timeframe.change",
      "line.new",
      "timeframe.in_seconds",
      "xloc.bar_time",
      "ta.pivothigh",
      "indicator",
      "overlay",
      "input",
      "var",
      "series",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-214",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"PivotHigh\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\nph = ta.pivothigh(leftBars, rightBars)\nplot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)\n```\n\n---\n\n## ta.pivotlow()\n\nThis function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point.\n\n### Returns\nPrice of the point or 'NaN'.\n\n### Remarks\nIf parameters 'leftbars' or 'rightbars' are series you should use max_bars_back function for the 'source' variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"PivotLow\", overlay=true)\nleftBars = input(2)\nrightBars=input(2)\npl = ta.pivotlow(close, leftBars, rightBars)\nplot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)\n```\n\n---\n\n## ta.range()\n\nReturns the difference between the min and max values in a series.\n\n### Returns\nThe difference between the min and max values in the series.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.rci()\n\nCalculates the Rank Correlation Index (RCI), which measures the directional consistency of price movements. It evaluates the monotonic relationship between a source series and the bar index over length bars using Spearman's rank correlation coefficient. The resulting value is scaled to a range of -100 to 100, where 100 indicates the source consistently increased over the period, and -100 indicates it consistently decreased. Values between -100 and 100 reflect varying degrees of upward or downward consistency.\n\n### Returns\nThe Rank Correlation Index, a value between -100 to 100.\n\n---\n\n## ta.rising()\n\nTest if the source series is now rising for length bars long.\n\n### Returns\ntrue if current source is greater than any previous source for length bars back, false otherwise.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.rma()\n\nMoving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length.\n\n### Returns\nExponential moving average of source with alpha = 1 / length.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.rma\")\nplot(ta.rma(close, 15))\n\n//the same on pine\npine_rma(src, length) =>\n    alpha = 1/length\n    sum = 0.0\n    sum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])\nplot(pine_rma(close, 15))\n```\n\n---\n\n## ta.roc()\n\nCalculates the percentage of change (rate of change) between the current value of source and its value length bars ago.\n\n### Returns\nThe rate of change of source for length bars back.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n---\n\n## ta.rsi()\n\nRelative strength index. It is calculated using the ta.rma() of upward and downward changes of source over the last length bars.\n\n### Returns\nRelative strength index.\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "ta.pivothigh",
      "plot.style_cross",
      "color.red",
      "ta.pivotlow",
      "color.blue",
      "ta.range",
      "ta.rci",
      "ta.rising",
      "ta.rma",
      "ta.sma",
      "ta.roc",
      "ta.rsi",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-215",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.rsi\")\nplot(ta.rsi(close, 7))\n\n// same on pine, but less efficient\npine_rsi(x, y) => \n    u = math.max(x - x[1], 0) // upward ta.change\n    d = math.max(x[1] - x, 0) // downward ta.change\n    rs = ta.rma(u, y) / ta.rma(d, y)\n    res = 100 - 100 / (1 + rs)\n    res\n\nplot(pine_rsi(close, 7))\n```\n\n---\n\n## ta.sar()\n\nParabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods.\n\n### Returns\nParabolic SAR.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.sar\")\nplot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n\n// The same on Pine Script¬Æ\npine_sar(start, inc, max) =>\n    var float result = na\n    var float maxMin = na\n    var float acceleration = na\n    var bool isBelow = false\n    bool isFirstTrendBar = false\n    \n    if bar_index == 1\n        if close > close[1]\n            isBelow := true\n            maxMin := high\n            result := low[1]\n        else\n            isBelow := false\n            maxMin := low\n            result := high[1]\n        isFirstTrendBar := true\n        acceleration := start\n    \n    result := result + acceleration * (maxMin - result)\n    \n    if isBelow\n        if result > low\n            isFirstTrendBar := true\n            isBelow := false\n            result := math.max(high, maxMin)\n            maxMin := low\n            acceleration := start\n    else\n        if result < high\n            isFirstTrendBar := true\n            isBelow := true\n            result := math.min(low, maxMin)\n            maxMin := high\n            acceleration := start\n            \n    if not isFirstTrendBar\n        if isBelow\n            if high > maxMin\n                maxMin := high\n                acceleration := math.min(acceleration + inc, max)\n        else\n            if low < maxMin\n                maxMin := low\n                acceleration := math.min(acceleration + inc, max)\n    \n    if isBelow\n        result := math.min(result, low[1])\n        if bar_index > 1\n            result := math.min(result, low[2])\n        \n    else\n        result := math.max(result, high[1])\n        if bar_index > 1\n            result := math.max(result, high[2])\n    \n    result\n    \nplot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)\n```\n\n---\n\n## ta.sma()\n\nThe sma function returns the moving average, that is the sum of last y values of x, divided by y.\n\n### Returns\nSimple moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.sma\")\nplot(ta.sma(close, 15))\n\n// same on pine, but much less efficient\npine_sma(x, y) =>\n    sum = 0.0\n    for i = 0 to y - 1\n        sum := sum + x[i] / y\n    sum\nplot(pine_sma(close, 15))\n```\n\n---\n\n## ta.stdev()\n\n### Returns\nStandard deviation.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample. na values in the source series are ignored; the function calculates on the length quantity of non-na values.",
    "keywords": [
      "ta.rsi",
      "math.max",
      "ta.change",
      "ta.rma",
      "ta.sar",
      "plot.style_cross",
      "math.min",
      "ta.sma",
      "ta.stdev",
      "indicator",
      "plot",
      "var",
      "series",
      "simple",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-216",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "ta.tr()",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.stdev\")\nplot(ta.stdev(close, 5))\n\n//the same on pine\nisZero(val, eps) => math.abs(val) <= eps\n\nSUM(fst, snd) =>\n    EPS = 1e-10\n    res = fst + snd\n    if isZero(res, EPS)\n        res := 0\n    else\n        if not isZero(res, 1e-4)\n            res := res\n        else\n            15\n\npine_stdev(src, length) =>\n    avg = ta.sma(src, length)\n    sumOfSquareDeviations = 0.0\n    for i = 0 to length - 1\n        sum = SUM(src[i], -avg)\n        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum\n\n    stdev = math.sqrt(sumOfSquareDeviations / length)\nplot(pine_stdev(close, 5))\n```\n\n---\n\n## ta.stoch()\n\nStochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length)).\n\n### Returns\nStochastic.\n\n### Remarks\nna values in the source series are ignored.\n\n---\n\n## ta.supertrend()\n\nThe Supertrend Indicator. The Supertrend is a trend following indicator.\n\n### Returns\nTuple of two supertrend series: supertrend line and direction of trend. Possible values are 1 (down direction) and -1 (up direction).\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Pine Script¬Æ Supertrend\")\n\n[supertrend, direction] = ta.supertrend(3, 10)\nplot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n\n// The same on Pine Script¬Æ\npine_supertrend(factor, atrPeriod) =>\n    src = hl2\n    atr = ta.atr(atrPeriod)\n    upperBand = src + factor * atr\n    lowerBand = src - factor * atr\n    prevLowerBand = nz(lowerBand[1])\n    prevUpperBand = nz(upperBand[1])\n\n    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand\n    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand\n    int _direction = na\n    float superTrend = na\n    prevSuperTrend = superTrend[1]\n    if na(atr[1])\n        _direction := 1\n    else if prevSuperTrend == prevUpperBand\n        _direction := close > upperBand ? -1 : 1\n    else\n        _direction := close < lowerBand ? 1 : -1\n    superTrend := _direction == -1 ? lowerBand : upperBand\n    [superTrend, _direction]\n\n[Pine_Supertrend, pineDirection] = pine_supertrend(3, 10)\nplot(pineDirection < 0 ? Pine_Supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)\nplot(pineDirection > 0 ? Pine_Supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)\n```\n\n---\n\n## ta.swma()\n\nSymmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6].\n\n### Returns\nSymmetrically weighted moving average.\n\n### Remarks\nna values in the source series are included in calculations and will produce an na result.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.swma\")\nplot(ta.swma(close))\n\n// same on pine, but less efficient\npine_swma(x) =>\n    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6\nplot(pine_swma(close))\n```\n\n---",
    "keywords": [
      "ta.stdev",
      "math.abs",
      "ta.sma",
      "math.sqrt",
      "ta.stoch",
      "ta.supertrend",
      "color.green",
      "plot.style_linebr",
      "color.red",
      "ta.atr",
      "ta.swma",
      "indicator",
      "plot",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-217",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Code Example",
    "content": "## ta.tr()\n\nCalculates the current bar's true range. Unlike a bar's actual range (high - low), true range accounts for potential gaps by taking the maximum of the current bar's actual range and the absolute distances from the previous bar's close to the current bar's high and low. The formula is: math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1]))\n\n### Returns\nTrue range. It is math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).\n\n### Remarks\nta.tr(false) is exactly the same as ta.tr.\n\n---\n\n## ta.tsi()\n\nTrue strength index. It uses moving averages of the underlying momentum of a financial instrument.\n\n### Returns\nTrue strength index. A value in range [-1, 1].\n\n### Remarks\nna values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.valuewhen()\n\nReturns the value of the source series on the bar where the condition was true on the nth most recent occurrence.\n\n### Remarks\nThis function requires execution on every bar. It is not recommended to use it inside a for or while loop structure, where its behavior can be unexpected. Please note that using this function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.valuewhen\")\nslow = ta.sma(close, 7)\nfast = ta.sma(close, 14)\n// Get value of `close` on second most recent cross\nplot(ta.valuewhen(ta.cross(slow, fast), close, 1))\n```\n\n---\n\n## ta.variance()\n\nVariance is the expectation of the squared deviation of a series from its mean (ta.sma), and it informally measures how far a set of numbers are spread out from their mean.\n\n### Returns\nVariance of source for length bars back.\n\n### Remarks\nIf biased is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample. na values in the source series are ignored; the function calculates on the length quantity of non-na values.\n\n---\n\n## ta.vwap()\n\nVolume weighted average price.\n\n### Returns\nA VWAP series, or a tuple [vwap, upper_band, lower_band] if stdev_mult is specified.\n\n### Remarks\nCalculations only begin the first time the anchor condition becomes true. Until then, the function returns na.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Simple VWAP\")\nvwap = ta.vwap(open)\nplot(vwap)\n\n//@version=6\nindicator(\"Advanced VWAP\")\nvwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])\nstdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")\nanchorTimeframe = switch vwapAnchorInput\n    \"Daily\"   => \"1D\"\n    \"Weekly\"  => \"1W\"\n    \"Monthly\" => \"1M\"\nanchor = timeframe.change(anchorTimeframe)\n[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)\nplot(vwap)\nplot(upper, color = color.green)\nplot(lower, color = color.green)\n```\n\n---\n\n## ta.vwma()\n\nThe vwma function returns volume-weighted moving average of source for length bars back. It is the same as: sma(source * volume, length) / sma(volume, length).\n\n### Returns\nVolume-weighted moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.",
    "keywords": [
      "ta.tr",
      "math.max",
      "math.abs",
      "ta.tsi",
      "ta.valuewhen",
      "ta.sma",
      "ta.cross",
      "ta.variance",
      "ta.vwap",
      "input.string",
      "input.float",
      "timeframe.change",
      "color.green",
      "ta.vwma",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "switch",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-218",
    "type": "documentation",
    "source": "reference/functions/ta.md",
    "section": "reference/functions",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"ta.vwma\")\nplot(ta.vwma(close, 15))\n\n// same on pine, but less efficient\npine_vwma(x, y) =>\n    ta.sma(x * volume, y) / ta.sma(volume, y)\nplot(pine_vwma(close, 15))\n```\n\n---\n\n## ta.wma()\n\nThe wma function returns weighted moving average of source for length bars back. In wma weighting factors decrease in arithmetical progression.\n\n### Returns\nWeighted moving average of source for length bars back.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ta.wma\")\nplot(ta.wma(close, 15))\n\n// same on pine, but much less efficient\npine_wma(x, y) =>\n    norm = 0.0\n    sum = 0.0\n    for i = 0 to y - 1\n        weight = (y - i) * y\n        norm := norm + weight\n        sum := sum + x[i] * weight\n    sum / norm\nplot(pine_wma(close, 15))\n```\n\n---\n\n## ta.wpr()\n\nWilliams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars.\n\n### Returns\nWilliams %R.\n\n### Remarks\nna values in the source series are ignored.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)\nplot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))\n```",
    "keywords": [
      "ta.vwma",
      "ta.sma",
      "ta.wma",
      "ta.wpr",
      "format.price",
      "color.new",
      "indicator",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "doc-219",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "Remarks",
    "content": "# Keywords\n\n## and\n\nLogical AND. Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n### Remarks\nIf expr1 evaluates to false, the and operator returns false without evaluating expr2.\n\n---\n\n## enum\n\nThis keyword allows the creation of an enumeration, enum for short. Enums are unique constructs that hold groups of predefined constants.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Session highlight\", overlay = true)\n\n//@enum       Contains fields with popular timezones as titles.\n//@field exch Has an empty string as the title to represent the chart timezone.\nenum tz\n    utc  = \"UTC\"\n    exch = \"\"\n    ny   = \"America/New_York\"\n    chi  = \"America/Chicago\"\n    lon  = \"Europe/London\"\n    tok  = \"Asia/Tokyo\"\n\n//@variable The session string.\nselectedSession = input.session(\"1200-1500\", \"Session\")\n//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.\nselectedTimezone = input.enum(tz.utc, \"Session Timezone\")\n\n//@variable Is `true` if the current bar's time is in the specified session.\nbool inSession = false\nif not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))\n    inSession := true\n\n// Highlight the background when `inSession` is `true`.\nbgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")\n\n//@version=6\nindicator(\"Map with enum keys\")\n\n//@enum        Contains fields with titles representing ticker IDs.\n//@field aapl  Has an Apple ticker ID as its title.\n//@field tsla  Has a Tesla ticker ID as its title.\n//@field amzn  Has an Amazon ticker ID as its title.\nenum symbols\n    aapl = \"NASDAQ:AAPL\"\n    tsla = \"NASDAQ:TSLA\"\n    amzn = \"NASDAQ:AMZN\"\n\n//@variable A map that accepts fields from the `symbols` enum as keys and \"float\" values.\nmap<symbols, float> data = map.new<symbols, float>()\n// Put key-value pairs into the `data` map.\ndata.put(symbols.aapl, request.security(str.tostring(symbols.aapl), timeframe.period, close))\ndata.put(symbols.tsla, request.security(str.tostring(symbols.tsla), timeframe.period, close))\ndata.put(symbols.amzn, request.security(str.tostring(symbols.amzn), timeframe.period, close))\n// Plot the value from the `data` map accessed by the `symbols.aapl` key.\nplot(data.get(symbols.aapl))\n```\n\n---\n\n## export\n\nUsed in libraries to prefix the declaration of functions or user-defined type definitions that will be available from other scripts importing the library.",
    "keywords": [
      "input.session",
      "input.enum",
      "tz.utc",
      "str.tostring",
      "color.new",
      "color.green",
      "map.new",
      "data.put",
      "symbols.aapl",
      "request.security",
      "timeframe.period",
      "symbols.tsla",
      "symbols.amzn",
      "data.get",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "const",
      "export",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-220",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Remarks\nEach library must have at least one exported function or user-defined type (UDT). Exported functions cannot use variables from the global scope if they are arrays, mutable variables (reassigned with :=), or variables of 'input' form. Exported functions cannot use request.*() functions. Exported functions must explicitly declare each parameter's type and all parameters must be used in the function's body. By default, all arguments passed to exported functions are of the series form, unless they are explicitly specified as simple in the function's signature. The @description, @function, @param, @type, @field, and @returns compiler annotations are used to automatically generate the library's description and release notes, and in the Pine Script¬Æ Editor's tooltips.\n\n### Code Example\n```pine\n//@version=6\n//@description Library of debugging functions.\nlibrary(\"Debugging_library\", overlay = true)\n//@function Displays a string as a table cell for debugging purposes.\n//@param txt String to display.\n//@returns Void.\nexport print(string txt) => \n    var table t = table.new(position.middle_right, 1, 1)\n    table.cell(t, 0, 0, txt, bgcolor = color.yellow)\n// Using the function from inside the library to show an example on the published chart.\n// This has no impact on scripts using the library.\nprint(\"Library Test\")\n```\n\n---\n\n## for\n\nCreates a count-controlled loop, which uses a counter variable to manage the iterative executions of its local code block. The loop continues new iterations until the counter reaches a specified final value.\n\n### Remarks\nModifying a loop's to_num value during an iteration does not change the direction of the loop's counter. For a loop that counts upward, setting the to_num to a value less than the from_num value on an iteration stops the loop immediately after that iteration ends. Likewise, a loop that counts downward stops after an iteration where the to_num value becomes greater than the from_num value.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Basic `for` loop\")\n\n//@function Calculates the number of bars in the last `length` bars that have their `close` above the current `close`.\n//@param length The number of bars used in the calculation.\ngreaterCloseCount(length) =>\n    int result = 0\n    for i = 1 to length\n        if close[i] > close\n            result += 1\n    result\n\nplot(greaterCloseCount(14))\n\n//@version=6\nindicator(\"`for` loop with a step\")\n\na = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nsum = 0.0\n\nfor i = 0 to 9 by 5\n    // Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.\n    sum += array.get(a, i)\n\nplot(sum)\n```\n\n---\n\n## for...in\n\nThe for...in structure allows the repeated execution of a number of statements for each element in an array. It can be used with either one argument: array_element, or with two: [index, array_element]. The second form doesn't affect the functionality of the loop. It tracks the current iteration's index in the tuple's first variable.",
    "keywords": [
      "table.new",
      "position.middle_right",
      "table.cell",
      "color.yellow",
      "array.from",
      "array.get",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-221",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "method",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"for...in\")\n// Here we determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values\nfloat[] ohlcValues = array.from(open, high, low, close)\nqtyGreaterThan(value, array) =>\n    int result = 0\n    for currentElement in array\n        if currentElement > value\n            result += 1\n        result\nplot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))\n\n//@version=6\nindicator(\"for...in\")\nvar valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)\nvar isPos = array.new_bool(10, false)\n\nfor [index, value] in valuesArray\n    if value > 0\n        array.set(isPos, index, true)\n\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(isPos))\n\n//@version=6\nindicator(\"`for ... in` matrix Example\")\n\n// Create a 2x3 matrix with values `4`.\nmatrix1 = matrix.new<int>(2, 3, 4)\n\nsum = 0.0\n// Loop through every row of the matrix.\nfor rowArray in matrix1\n    // Sum values of the every row \n    sum += array.sum(rowArray)\n\nplot(sum)\n```\n\n---\n\n## if\n\nIf statement defines what block of statements must be executed when conditions of the expression are satisfied.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"if\")\n// This code compiles\nx = if close > open\n    close\nelse\n    open\n\n// This code doesn‚Äôt compile\n// y = if close > open\n//     close\n// else\n//     \"open\"\nplot(x)\n\n//@version=6\nindicator(\"if\")\nx = if close > open\n    close\n// If current close > current open, then x = close.\n// Otherwise the x = na.\nplot(x)\n\n//@version=6\nindicator(\"if\")\nx = if open > close\n    5\nelse if high > low\n    close\nelse\n    open\nplot(x)\n\n//@version=6\nstrategy(\"if\")\nif (ta.crossover(high, low))\n    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")\nelse\n    strategy.cancel(id=\"BBandLE\")\n\n//@version=6\nindicator(\"if\")\nfloat x = na\nif close > open\n    if close > close[1]\n        x := close\n    else\n        x := close[1]\nelse\n    x := open\nplot(x)\n```\n\n---\n\n## import\n\nUsed to load an external library into a script and bind its functions to a namespace. The importing script can be an indicator, a strategy, or another library. A library must be published (privately or publicly) before it can be imported.\n\n### Remarks\nUsing an alias that replaces a built-in namespace such as math.* or strategy.* is allowed, but if the library contains function names that shadow Pine Script¬Æ's built-in functions, the built-ins will become unavailable. The same version of a library can only be imported once. Aliases must be distinct for each imported library. When calling library functions, casting their arguments to types other than their declared type is not allowed. An import statement cannot use 'as' or 'import' as username, libraryName, or alias identifiers.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"num_methods import\")\n// Import the first version of the username‚Äôs \"num_methods\" library and assign it to the \"m\" namespace\",\nimport username/num_methods/1 as m\n// Call the ‚Äúsinh()‚Äù function from the imported library\ny = m.sinh(3.14)\n// Plot value returned by the \"sinh()\" function\",\nplot(y)\n```\n\n---",
    "keywords": [
      "array.from",
      "ta.sma",
      "array.new_bool",
      "array.set",
      "barstate.islastconfirmedhistory",
      "label.new",
      "str.tostring",
      "matrix.new",
      "array.sum",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "strategy.oca",
      "strategy.cancel",
      "m.sinh",
      "indicator",
      "strategy",
      "plot",
      "var",
      "import",
      "method",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-222",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## method\n\nThis keyword is used to prefix a function declaration, indicating it can then be invoked using dot notation by appending its name to a variable of the type of its first parameter and omitting that first parameter. Alternatively, functions declared as methods can also be invoked like normal user-defined functions. In that case, an argument must be supplied for its first parameter.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"\")\n\nvar prices = array.new<float>()\n\n//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.\nmethod maintainArray(array<float> id, maxSize, value) =>\n    id.push(value)\n    if id.size() > maxSize\n        id.shift()\n\nprices.maintainArray(50, close)\n// The method can also be called like a function, without using dot notation.\n// In this case an argument must be supplied for its first parameter.\n// maintainArray(prices, 50, close)\n\n// This calls the `array.avg()` built-in using dot notation with the `prices` array.\n// It is possible because built-in functions belonging to some namespaces that are a special Pine type\n// can be invoked with method notation when the function's first parameter is an ID of that type.\n// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.\nplot(prices.avg())\n```\n\n---\n\n## not\n\nLogical negation (NOT). Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n---\n\n## or\n\nLogical OR. Applicable to boolean expressions.\n\n### Returns\nBoolean value, or series of boolean values.\n\n### Remarks\nIf expr1 evaluates to true, the or operator returns true without evaluating expr2.\n\n---\n\n## switch\n\nThe switch operator transfers control to one of the several statements, depending on the values of a condition and expressions.\n\n### Returns\nThe value of the last expression in the local block of statements that is executed.\n\n### Remarks\nOnly one of the local_block instances or the default_local_block can be executed. The default_local_block is introduced with the => token alone and is only executed when none of the preceding blocks are executed. If the result of the switch statement is assigned to a variable and a default_local_block is not specified, the statement returns na if no local_block is executed. When assigning the result of the switch statement to a variable, all local_block instances must return the same type of value.",
    "keywords": [
      "array.new",
      "id.push",
      "id.size",
      "id.shift",
      "prices.maintain",
      "array.avg",
      "prices.avg",
      "indicator",
      "plot",
      "fill",
      "var",
      "series",
      "method",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-223",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "varip",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"Switch using an expression\")\n\nstring i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\n\nfloat ma = switch i_maType\n    \"EMA\" => ta.ema(close, 10)\n    \"SMA\" => ta.sma(close, 10)\n    \"RMA\" => ta.rma(close, 10)\n    // Default used when the three first cases do not match.\n    => ta.wma(close, 10)\n\nplot(ma)\n\n//@version=6\nstrategy(\"Switch without an expression\", overlay = true)\n\nbool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\n\nswitch\n    longCondition  => strategy.entry(\"Long ID\", strategy.long)\n    shortCondition => strategy.entry(\"Short ID\", strategy.short)\n```\n\n---\n\n## type\n\nThis keyword allows the declaration of user-defined types (UDT) from which scripts can instantiate objects. UDTs are composite types that contain an arbitrary number of fields of any built-in or user-defined type, including the defined UDT itself. The syntax to define a UDT is:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Multi Time Period Chart\", overlay = true)\n\ntimeframeInput = input.timeframe(\"1D\")\n\ntype bar\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    int   t = time\n\ndrawBox(bar b, right) =>\n    bar s = bar.new()\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))\n\nupdateBox(box boxId, bar b) =>\n    color boxColor = b.c >= b.o ? color.green : color.red\n    box.set_border_color(boxId, boxColor)\n    box.set_bgcolor(boxId, color.new(boxColor, 90))\n    box.set_top(boxId, b.h)\n    box.set_bottom(boxId, b.l)\n    box.set_right(boxId, time)\n\nsecBar = request.security(syminfo.tickerid, timeframeInput, bar.new())\n\nif not na(secBar)\n    // To avoid a runtime error, only process data when an object exists.\n    if not barstate.islast\n        if timeframe.change(timeframeInput)\n            // On historical bars, draw a new box in the past when the HTF closes.\n            drawBox(secBar, time[1])\n    else\n        var box lastBox = na\n        if na(lastBox) or timeframe.change(timeframeInput)\n            // On the last bar, only draw a new current box the first time we get there or when HTF changes.\n            lastBox := drawBox(secBar, time)\n        else\n            // On other chart updates, use setters to modify the current box.\n            updateBox(lastBox, secBar)\n```\n\n---\n\n## var\n\nvar is the keyword used for assigning and one-time initializing of the variable.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Var keyword example\")\nvar a = close\nvar b = 0.0\nvar c = 0.0\nvar green_bars_count = 0\nif close > open\n    var x = close\n    b := x\n    green_bars_count := green_bars_count + 1\n    if green_bars_count >= 10\n        var y = close\n        c := y\nplot(a)\nplot(b)\nplot(c)\n```\n\n---",
    "keywords": [
      "input.string",
      "ta.ema",
      "ta.sma",
      "ta.rma",
      "ta.wma",
      "ta.crossover",
      "ta.crossunder",
      "strategy.entry",
      "strategy.long",
      "strategy.short",
      "input.timeframe",
      "bar.new",
      "b.c",
      "b.o",
      "color.green",
      "color.red",
      "box.new",
      "b.t",
      "b.h",
      "b.l",
      "xloc.bar_time",
      "color.new",
      "box.set_border_color",
      "box.set_bgcolor",
      "box.set_top",
      "box.set_bottom",
      "box.set_right",
      "request.security",
      "syminfo.tickerid",
      "barstate.islast",
      "timeframe.change",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-224",
    "type": "documentation",
    "source": "reference/keywords.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## varip\n\nvarip (var intrabar persist) is the keyword used for the assignment and one-time initialization of a variable or a field of a user-defined type. It‚Äôs similar to the var keyword, but variables and fields declared with varip retain their values between executions of the script on the same bar.\n\n### Remarks\nWhen using varip to declare variables in strategies that may execute more than once per historical chart bar, the values of such variables are preserved across successive iterations of the script on the same bar. The effect of varip eliminates the rollback of variables before each successive execution of a script on the same bar.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"varip\")\nvarip int v = -1\nv := v + 1\nplot(v)\n\n//@version=6\nindicator(\"varip with types\")\ntype barData\n    int index = -1\n    varip int ticks = -1\n\nvar currBar = barData.new()\ncurrBar.index += 1\ncurrBar.ticks += 1\n\n// Will be equal to bar_index on all bars\nplot(currBar.index)\n// In real time, will increment per every tick on the chart\nplot(currBar.ticks)\n```\n\n---\n\n## while\n\nThe while statement allows the conditional iteration of a local code block.\n\n### Remarks\nThe local code block after the initial while line must be indented with four spaces or a tab. For the while loop to terminate, the boolean expression following while must eventually become false, or a break must be executed.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"while\")\n// This is a simple example of calculating a factorial using a while loop.\nint i_n = input.int(10, \"Factorial Size\", minval=0)\nint counter   = i_n\nint factorial = 1\nwhile counter > 0\n    factorial := factorial * counter\n    counter   := counter - 1\n\nplot(factorial)\n```\n\n---",
    "keywords": [
      "input.int",
      "indicator",
      "input",
      "plot",
      "var",
      "varip",
      "simple",
      "type",
      "for",
      "while"
    ]
  },
  {
    "id": "doc-225",
    "type": "documentation",
    "source": "reference/types.md",
    "section": "reference",
    "title": "Remarks",
    "content": "# Types\n\n## array\n\nKeyword used to explicitly declare the \"array\" type of a variable or a parameter. Array objects (or IDs) can be created with the array.new<type>, array.from function.\n\n### Remarks\nArray objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"array\", overlay=true)\narray<float> a = na\na := array.new<float>(1, close)\nplot(array.get(a, 0))\n```\n\n---\n\n## bool\n\nKeyword used to explicitly declare the \"bool\" (boolean) type of a variable or a parameter. \"Bool\" variables can have values true or false.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"bool\")\nbool b = true    // Same as `b = true`\nplot(b ? open : close)\n```\n\n---\n\n## box\n\nKeyword used to explicitly declare the \"box\" type of a variable or a parameter. Box objects (or IDs) can be created with the box.new function.\n\n### Remarks\nBox objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"box\")\n// Empty `box1` box ID.\nvar box box1 = na\n// `box` type is unnecessary because `box.new()` returns a \"box\" type.\nvar box2 = box.new(na, na, na, na)\nbox3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)\n```\n\n---\n\n## chart.point\n\nKeyword to explicitly declare the type of a variable or parameter as chart.point. Scripts can produce chart.point instances using the chart.point.from_time, chart.point.from_index, chart.point.now, and chart.point.new functions.\n\n---\n\n## color\n\nKeyword used to explicitly declare the \"color\" type of a variable or a parameter.\n\n### Remarks\nColor literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent 00 to FF hexadecimal values (0 to 255 in decimal) where RR, GG and BB pairs are the values for the color's red, green and blue components. AA is an optional value for the color's transparency (or alpha component) where 00 is invisible and FF opaque. When no AA pair is supplied, FF is used. The hexadecimal letters can be upper or lower case. Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"color\", overlay = true)\n\ncolor textColor = color.green\ncolor labelColor = #FF000080 // Red color (FF0000) with 50% transparency (80 which is half of FF).\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)\n\n// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.\nc = color.rgb(0,255,0,0)\nplot(close, color = c)\n```\n\n---\n\n## const\n\nThe const keyword explicitly assigns the \"const\" type qualifier to variables and the parameters of non-exported functions. Variables and parameters with the \"const\" qualifier reference values established at compile time that never change in the script's execution.",
    "keywords": [
      "array.new",
      "array.from",
      "array.get",
      "box.new",
      "xloc.bar_time",
      "chart.point",
      "color.green",
      "barstate.islastconfirmedhistory",
      "label.new",
      "color.new",
      "color.rgb",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-226",
    "type": "documentation",
    "source": "reference/types.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Remarks\nTo learn more, see our User Manual's section on type qualifiers.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"custom plot title\")\n\n//@function Concatenates two \"const string\" values.\nconcatStrings(const string x, const string y) =>\n    const string result = x + y\n\n//@variable The title of the plot.\nconst string myTitle = concatStrings(\"My \", \"Plot\")\n\nplot(close, myTitle)\n\n//@version=6\nindicator(\"can't assign input to const\")\n\n//@variable A variable declared as \"const float\" that attempts to assign the result of `input.float()` as its value.\n//          This declaration causes an error. The \"input float\" qualified type is stronger than \"const float\".\nconst float myVar = input.float(2.0)\n\nplot(myVar)\n```\n\n---\n\n## float\n\nKeyword used to explicitly declare the \"float\" (floating point) type of a variable or a parameter.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"float\")\nfloat f = 3.14    // Same as `f = 3.14`\nf := na\nplot(f)\n```\n\n---\n\n## int\n\nKeyword used to explicitly declare the \"int\" (integer) type of a variable or a parameter.\n\n### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"int\")\nint i = 14    // Same as `i = 14`\ni := na\nplot(i)\n```\n\n---\n\n## label\n\nKeyword used to explicitly declare the \"label\" type of a variable or a parameter. Label objects (or IDs) can be created with the label.new function.\n\n### Remarks\nLabel objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"label\")\n// Empty `label1` label ID.\nvar label label1 = na\n// `label` type is unnecessary because `label.new()` returns \"label\" type.\nvar label2 = label.new(na, na, na)\nif barstate.islastconfirmedhistory\n    label3 = label.new(bar_index, high, text = \"label3 text\")\n```\n\n---\n\n## line\n\nKeyword used to explicitly declare the \"line\" type of a variable or a parameter. Line objects (or IDs) can be created with the line.new function.\n\n### Remarks\nLine objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line\")\n// Empty `line1` line ID.\nvar line line1 = na\n// `line` type is unnecessary because `line.new()` returns \"line\" type.\nvar line2 = line.new(na, na, na, na)\nline3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)\n```\n\n---\n\n## linefill\n\nKeyword used to explicitly declare the \"linefill\" type of a variable or a parameter. Linefill objects (or IDs) can be created with the linefill.new function.\n\n### Remarks\nLinefill objects are always of \"series\" form.",
    "keywords": [
      "input.float",
      "label.new",
      "barstate.islastconfirmedhistory",
      "line.new",
      "extend.right",
      "linefill.new",
      "indicator",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-227",
    "type": "documentation",
    "source": "reference/types.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"linefill\", overlay=true)\n// Empty `linefill1` line ID.\nvar linefill linefill1 = na\n// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.\nvar linefill2 = linefill.new(na, na, na)\n\nif barstate.islastconfirmedhistory\n    line1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)\n    line2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)\n    linefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))\n```\n\n---\n\n## map\n\nKeyword used to explicitly declare the \"map\" type of a variable or a parameter. Map objects (or IDs) can be created with the map.new<type,type> function.\n\n### Remarks\nMap objects are always of series form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"map\", overlay=true)\nmap<int, float> a = na\na := map.new<int, float>()\na.put(bar_index, close)\nlabel.new(bar_index, a.get(bar_index), \"Current close\")\n```\n\n---\n\n## matrix\n\nKeyword used to explicitly declare the \"matrix\" type of a variable or a parameter. Matrix objects (or IDs) can be created with the matrix.new<type> function.\n\n### Remarks\nMatrix objects are always of \"series\" form.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"matrix example\")\n\n// Create `m1` matrix of `int` type.\nmatrix<int> m1 = matrix.new<int>(2, 3, 0)\n\n// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.\nm2 = matrix.new<int>(2, 3, 0)\n\n// Display matrix using a label.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, str.tostring(m2))\n```\n\n---\n\n## polyline\n\nKeyword to explicitly declare the type of a variable or parameter as polyline. Scripts can produce polyline instances using the polyline.new function.\n\n---\n\n## series\n\nThe series keyword explicitly assigns the \"series\" type qualifier to variables and function parameters. Variables and parameters that use the \"series\" qualifier can reference values that change throughout a script's execution.\n\n### Remarks\nTo learn more, see our User Manual's section on type qualifiers.",
    "keywords": [
      "linefill.new",
      "barstate.islastconfirmedhistory",
      "line.new",
      "extend.right",
      "color.new",
      "color.green",
      "map.new",
      "a.put",
      "label.new",
      "a.get",
      "matrix.new",
      "str.tostring",
      "polyline.new",
      "indicator",
      "overlay",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-228",
    "type": "documentation",
    "source": "reference/types.md",
    "section": "reference",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function Finds the highest `source` value over `length` bars, filtered by the `cond` condition.\nexport conditionalHighest(series float source, series bool cond, series int length) =>\n    //@variable The highest `source` value from when the `cond` was `true` over `length` bars.\n    series float result = na\n    // Loop to find the highest value.\n    for i = 0 to length - 1\n        if cond[i]\n            value   = source[i]\n            result := math.max(nz(result, value), value)\n    // Return the `result`.\n    result\n\n//@variable Is `true` once every five bars.\nseries bool condition = bar_index % 5 == 0\n\n//@variable The highest `close` value from every fifth bar over the last 100 bars.\nseries float hiValue = conditionalHighest(close, condition, 100)\n\nplot(hiValue)\nbgcolor(condition ? color.new(color.teal, 80) : na)\n\n//@version=6\nindicator(\"series variable not allowed\")\n\n//@variable A variable declared as \"series int\" with a value of 5.\nseries int myVar = 5\n\n// This call causes an error.\n// The `histbase` accepts \"input int/float\". It can't accept the stronger \"series int\" qualified type.\nplot(close, style = plot.style_histogram, histbase = myVar)\n```\n\n---\n\n## simple\n\nThe simple keyword explicitly assigns the \"simple\" type qualifier to variables and function parameters. Variables and parameters that use the \"simple\" qualifier can reference values established at the beginning of a script's execution that do not change later.\n\n### Remarks\nTo learn more, see our User Manual's section on type qualifiers.\n\n### Code Example\n```pine\n//@version=6\n//@description A library with custom functions.\nlibrary(\"CustomFunctions\", overlay = true)\n\n//@function         Calculates the length values for a ribbon of four EMAs by multiplying the `baseLength`.\n//@param baseLength The initial EMA length. Requires \"simple int\" because you can't use \"series int\" in `ta.ema()`.\n//@returns          A tuple of length values.\nexport ribbonLengths(simple int baseLength) =>\n    simple int length1 = baseLength\n    simple int length2 = baseLength * 2\n    simple int length3 = baseLength * 3\n    simple int length4 = baseLength * 4\n    [length1, length2, length3, length4]\n\n// Get a tuple of \"simple int\" length values.\n[len1, len2, len3, len4] = ribbonLengths(14)\n\n// Plot four EMAs using the values from the tuple.\nplot(ta.ema(close, len1), \"EMA 1\", color = color.red)\nplot(ta.ema(close, len2), \"EMA 1\", color = color.orange)\nplot(ta.ema(close, len3), \"EMA 1\", color = color.green)\nplot(ta.ema(close, len4), \"EMA 1\", color = color.blue)\n\n//@version=6\nindicator(\"can't change simple to series\")\n\n//@variable A variable declared as \"simple float\" with a value of 5.0.\nsimple float myVar = 5.0\n\n// This reassignment causes an error.\n// The `close` variable returns a \"series float\" value. Since `myVar` is restricted to \"simple\" values, it cannot\n// change its qualifier to \"series\".\nmyVar := close\n\nplot(myVar)\n```\n\n---\n\n## string\n\nKeyword used to explicitly declare the \"string\" type of a variable or a parameter.",
    "keywords": [
      "math.max",
      "color.new",
      "color.teal",
      "plot.style_histogram",
      "ta.ema",
      "color.red",
      "color.orange",
      "color.green",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-229",
    "type": "documentation",
    "source": "reference/types.md",
    "section": "reference",
    "title": "Remarks",
    "content": "### Remarks\nExplicitly mentioning the type in a variable declaration is optional, except when it is initialized with na. Learn more about Pine Script¬Æ types in the User Manual page on the Type System.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"string\")\nstring s = \"Hello World!\"    // Same as `s = \"Hello world!\"`\n// string s = na // same as \"\" \nplot(na, title=s)\n```\n\n---\n\n## table\n\nKeyword used to explicitly declare the \"table\" type of a variable or a parameter. Table objects (or IDs) can be created with the table.new function.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table\")\n// Empty `table1` table ID.\nvar table table1 = na\n// `table` type is unnecessary because `table.new()` returns \"table\" type.\nvar table2 = table.new(position.top_left, na, na)\n\nif barstate.islastconfirmedhistory\n    var table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)\n    table.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")\n```\n\n### Remarks\nTable objects are always of \"series\" form.",
    "keywords": [
      "table.new",
      "position.top_left",
      "barstate.islastconfirmedhistory",
      "position.top_right",
      "color.yellow",
      "table.cell",
      "indicator",
      "plot",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-230",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Remarks",
    "content": "# Variables \n\n---\n\n## ask\n\nThe ask price at the time of the current tick, which represents the lowest price an active seller will accept for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is na.\n\n**Type:** series float\n\n\n### Remarks\nIf the bid/ask values change since the last tick but no new trades are made, these changes will not be reflected in the value of this variable. It is only updated on new ticks.\n\n---\n\n## bar_index\n\n**Type:** series int\n\nCurrent bar index. Numbering is zero-based, index of the first bar is 0.\n\n### Remarks\nNote that bar_index has replaced n variable in version 4. Note that bar indexing starts from 0 on the first historical bar. Please note that using this variable/function can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"bar_index\")\nplot(bar_index)\nplot(bar_index > 5000 ? close : 0)\n```\n\n---\n\n## barstate.isconfirmed\n\n**Type:** series bool\n\nReturns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. It is NOT recommended to use barstate.isconfirmed in request.security expression. Its value requested from request.security is unpredictable. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.isfirst\n\n**Type:** series bool\n\nReturns true if current bar is first bar in barset, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.ishistory\n\n**Type:** series bool\n\nReturns true if current bar is a historical bar, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.islast\n\n**Type:** series bool\n\nReturns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.islastconfirmedhistory\n\n**Type:** series bool\n\nReturns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.isnew\n\n**Type:** series bool\n\nReturns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar.",
    "keywords": [
      "barstate.isconfirmed",
      "request.security",
      "barstate.isfirst",
      "barstate.ishistory",
      "barstate.islast",
      "barstate.islastconfirmedhistory",
      "barstate.isnew",
      "indicator",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-231",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Remarks",
    "content": "### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## barstate.isrealtime\n\n**Type:** series bool\n\nReturns true if current bar is a real-time bar, false otherwise.\n\n### Remarks\nPine Script¬Æ code that uses this variable could calculate differently on history and real-time data. Please note that using this variable/function can cause indicator repainting.\n\n---\n\n## bid\n\n**Type:** series float\n\nThe bid price at the time of the current tick, which represents the highest price an active buyer is willing to pay for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is na.\n\n### Remarks\nIf the bid/ask values change since the last tick but no new trades are made, these changes will not be reflected in the value of this variable. It is only updated on new ticks.\n\n---\n\n## box.all\n\n**Type:** array<box>\n\nReturns an array filled with all the current boxes drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"box.all\")\n//delete all boxes\nbox.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)\na_allBoxes = box.all\nif array.size(a_allBoxes) > 0\n    for i = 0 to array.size(a_allBoxes) - 1\n        box.delete(array.get(a_allBoxes, i))\n```\n\n---\n\n## chart.bg_color\n\n**Type:** input color\n\nReturns the color of the chart's background from the \"Chart settings/Appearance/Background\" field. When a gradient is selected, the middle point of the gradient is returned.\n\n---\n\n## chart.fg_color\n\n**Type:** input color\n\nReturns a color providing optimal contrast with chart.bg_color.\n\n---\n\n## chart.is_heikinashi\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Heikin Ashi, false otherwise.\n\n---\n\n## chart.is_kagi\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Kagi, false otherwise.\n\n---\n\n## chart.is_linebreak\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Line break, false otherwise.\n\n---\n\n## chart.is_pnf\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Point & figure, false otherwise.\n\n---\n\n## chart.is_range\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Range, false otherwise.\n\n---\n\n## chart.is_renko\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is Renko, false otherwise.\n\n---\n\n## chart.is_standard\n\n**Type:** simple bool\n\n### Returns\nReturns true if the chart type is not one of the following: Renko, Kagi, Line break, Point & figure, Range, Heikin Ashi; false otherwise.\n\n---\n\n## chart.left_visible_bar_time\n\n**Type:** input int\n\nThe time of the leftmost bar currently visible on the chart.",
    "keywords": [
      "barstate.isrealtime",
      "box.all",
      "box.new",
      "xloc.bar_time",
      "line.style_dashed",
      "array.size",
      "box.delete",
      "array.get",
      "chart.bg_color",
      "chart.fg_color",
      "chart.is_heikinashi",
      "chart.is_kagi",
      "chart.is_linebreak",
      "chart.is_pnf",
      "chart.is_range",
      "chart.is_renko",
      "chart.is_standard",
      "chart.left_visible_bar_time",
      "indicator",
      "input",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-232",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "dividends.future_pay_date",
    "content": "### Remarks\nScripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars. Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting.\n\n---\n\n## chart.right_visible_bar_time\n\n**Type:** input int\n\nThe time of the rightmost bar currently visible on the chart.\n\n### Remarks\nScripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars. Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting.\n\n---\n\n## close\n\n**Type:** series float\n\nClose price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. close[1], close[2].\n\n---\n\n## dayofmonth\n\n**Type:** series int\n\nDate of current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.\n\n---\n\n## dayofweek\n\n**Type:** series int\n\nDay of week for current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day. You can use dayofweek.sunday, dayofweek.monday, dayofweek.tuesday, dayofweek.wednesday, dayofweek.thursday, dayofweek.friday and dayofweek.saturday variables for comparisons.\n\n---\n\n## dividends.future_amount\n\n**Type:** series float\n\nReturns the payment amount of the upcoming dividend in the currency of the current instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---\n\n## dividends.future_ex_date\n\n**Type:** series int\n\nReturns the Ex-dividend date (Ex-date) of the current instrument's next dividend payment, or na if this data isn't available. Ex-dividend date signifies when investors are no longer entitled to a payout from the most recent dividend. Only those who purchased shares before this day are entitled to the dividend payment.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---",
    "keywords": [
      "chart.right_visible_bar_time",
      "e.g",
      "dayofweek.sunday",
      "dayofweek.monday",
      "dayofweek.tuesday",
      "dayofweek.wednesday",
      "dayofweek.thursday",
      "dayofweek.friday",
      "dayofweek.saturday",
      "dividends.future_amount",
      "dividends.future_ex_date",
      "input",
      "alert",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-233",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## dividends.future_pay_date\n\n**Type:** series int\n\nReturns the Payment date (Pay date) of the current instrument's next dividend payment, or na if this data isn't available. Payment date signifies the day when eligible investors will receive the dividend payment.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend.\n\n---\n\n## earnings.future_eps\n\n**Type:** series float\n\nReturns the estimated Earnings per Share of the next earnings report in the currency of the instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_period_end_time\n\n**Type:** series int\n\nChecks the data for the next earnings report and returns the UNIX timestamp of the day when the financial period covered by those earnings ends, or na if this data isn't available.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_revenue\n\n**Type:** series float\n\nReturns the estimated Revenue of the next earnings report in the currency of the instrument, or na if this data isn't available.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## earnings.future_time\n\n**Type:** series int\n\nReturns a UNIX timestamp indicating the expected time of the next earnings report, or na if this data isn't available.\n\n### Returns\nUNIX time, expressed in milliseconds.\n\n### Remarks\nThis value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report.\n\n---\n\n## high\n\n**Type:** series float\n\nCurrent high price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. high[1], high[2].\n\n---\n\n## hl2\n\n**Type:** series float\n\nIs a shortcut for (high + low)/2\n\n---\n\n## hlc3\n\n**Type:** series float\n\nIs a shortcut for (high + low + close)/3\n\n---\n\n## hlcc4\n\n**Type:** series float\n\nIs a shortcut for (high + low + close + close)/4\n\n---\n\n## hour\n\n**Type:** series int\n\nCurrent bar hour in exchange timezone.\n\n---\n\n## label.all\n\n**Type:** array<label>\n\nReturns an array filled with all the current labels drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.",
    "keywords": [
      "dividends.future_pay_date",
      "earnings.future_eps",
      "earnings.future_period_end_time",
      "earnings.future_revenue",
      "earnings.future_time",
      "e.g",
      "label.all",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-234",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Remarks",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"label.all\")\n//delete all labels\nlabel.new(bar_index, close)\na_allLabels = label.all\nif array.size(a_allLabels) > 0\n    for i = 0 to array.size(a_allLabels) - 1\n        label.delete(array.get(a_allLabels, i))\n```\n\n---\n\n## last_bar_index\n\n**Type:** series int\n\nBar index of the last chart bar. Bar indices begin at zero on the first bar.\n\n### Returns\nLast historical bar index for closed markets, or the real-time bar index for open markets.\n\n### Remarks\nPlease note that using this variable can cause indicator repainting.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)\nlastBarsFilterInput = input.int(100, \"Bars Count:\")\n// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.\n// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.\nvar lastbar = last_bar_index\n// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.\nallowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime\nbgcolor(allowedToTrade ? color.new(color.green, 80) : na)\n```\n\n---\n\n## last_bar_time\n\n**Type:** series int\n\nTime in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nPlease note that using this variable/function can cause indicator repainting. Note that this variable returns the timestamp based on the time of the bar's open.\n\n---\n\n## line.all\n\n**Type:** array<line>\n\nReturns an array filled with all the current lines drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"line.all\")\n//delete all lines\nline.new(bar_index - 10, close, bar_index, close)\na_allLines = line.all\nif array.size(a_allLines) > 0\n    for i = 0 to array.size(a_allLines) - 1\n        line.delete(array.get(a_allLines, i))\n```\n\n---\n\n## linefill.all\n\n**Type:** array<linefill>\n\nReturns an array filled with all the current linefill objects drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n---\n\n## low\n\n**Type:** series float\n\nCurrent low price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. low[1], low[2].\n\n---\n\n## minute\n\n**Type:** series int\n\nCurrent bar minute in exchange timezone.\n\n---\n\n## month\n\n**Type:** series int\n\nCurrent bar month in exchange timezone.\n\n### Remarks\nNote that this variable returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day.\n\n---\n\n## na\n\n**Type:** simple na\n\nA keyword signifying \"not available\", indicating that a variable has no assigned value.",
    "keywords": [
      "label.all",
      "label.new",
      "array.size",
      "label.delete",
      "array.get",
      "input.int",
      "barstate.isrealtime",
      "color.new",
      "color.green",
      "line.all",
      "line.new",
      "line.delete",
      "linefill.all",
      "e.g",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-235",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "session.islastbar",
    "content": "### Remarks\nDo not use this variable with comparison operators to test values for na, as it might lead to unexpected behavior. Instead, use the na function. Note that na can be used to initialize variables when the initialization statement also specifies the variable's type.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"na\")\n// CORRECT\n// Plot no value when on bars zero to nine. Plot `close` on other bars.\nplot(bar_index < 10 ? na : close)\n// CORRECT ALTERNATIVE\n// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.\nfloat a = na\nif bar_index >= 10\n    a := close\nplot(a)\n\n// INCORRECT\n// Trying to test the preceding bar's `close` for `na`.\n// The next line, if uncommented, will cause a compilation error, because direct comparison with `na` is not allowed.\n// plot(close[1] == na ? close : close[1])\n// CORRECT\n// Use the `na()` function to test for `na`.\nplot(na(close[1]) ? close : close[1])\n// CORRECT ALTERNATIVE\n// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.\nplot(nz(close[1], close))\n```\n\n---\n\n## ohlc4\n\n**Type:** series float\n\nIs a shortcut for (open + high + low + close)/4\n\n---\n\n## open\n\n**Type:** series float\n\nCurrent open price.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. open[1], open[2].\n\n---\n\n## polyline.all\n\n**Type:** array<polyline>\n\nReturns an array containing all current polyline instances drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array references the ID of the oldest polyline object on the chart.\n\n---\n\n## second\n\n**Type:** series int\n\nCurrent bar second in exchange timezone.\n\n---\n\n## session.isfirstbar\n\n**Type:** series bool\n\nReturns true if the current bar is the first bar of the day's session, false otherwise. If extended session information is used, only returns true on the first bar of the pre-market bars.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.isfirstbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition \n    strategy.entry(\"Long\", strategy.long)\n\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.isfirstbar_regular\n\n**Type:** series bool\n\nReturns true on the first regular session bar of the day, false otherwise. The result is the same whether extended session information is used or not.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.isfirstbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---",
    "keywords": [
      "e.g",
      "polyline.all",
      "session.isfirstbar",
      "strategy.entry",
      "strategy.long",
      "session.islastbar",
      "barstate.isconfirmed",
      "strategy.close",
      "session.isfirstbar_regular",
      "session.islastbar_regular",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-236",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "strategy.avg_trade",
    "content": "## session.islastbar\n\n**Type:** series bool\n\nReturns true if the current bar is the last bar of the day's session, false otherwise. If extended session information is used, only returns true on the last bar of the post-market bars.\n\n### Remarks\nThis variable is not guaranteed to return true once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar. This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.islastbar` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's last bar.\n// The position will enter on the `open` of next session's first bar.\nif session.islastbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n // Close 'Long' position at the close of the last bar of the trading session\nif session.islastbar and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.islastbar_regular\n\n**Type:** series bool\n\nReturns true on the last regular session bar of the day, false otherwise. The result is the same whether extended session information is used or not.\n\n### Remarks\nThis variable is not guaranteed to return true once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar. This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko.\n\n### Code Example\n```pine\n//@version=6\nstrategy(\"`session.islastbar_regular` Example\", overlay = true)\nlongCondition = year >= 2022\n// Place a long order at the `close` of the trading session's first bar.\nif session.isfirstbar and longCondition\n    strategy.entry(\"Long\", strategy.long)\n// Close the long position at the `close` of the trading session's last bar.\nif session.islastbar_regular and barstate.isconfirmed\n    strategy.close(\"Long\", immediately = true)\n```\n\n---\n\n## session.ismarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise.\n\n---\n\n## session.ispostmarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false.\n\n---\n\n## session.ispremarket\n\n**Type:** series bool\n\nReturns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false.\n\n---\n\n## strategy.account_currency\n\n**Type:** simple string\n\nReturns the currency used to calculate results, which can be set in the strategy's properties.\n\n---\n\n## strategy.avg_losing_trade\n\n**Type:** series float\n\nReturns the average amount of money lost per losing trade. Calculated as the sum of losses divided by the number of losing trades.\n\n---\n\n## strategy.avg_losing_trade_percent\n\n**Type:** series float\n\nReturns the average percentage loss per losing trade. Calculated as the sum of loss percentages divided by the number of losing trades.\n\n---",
    "keywords": [
      "session.islastbar",
      "e.g",
      "strategy.entry",
      "strategy.long",
      "barstate.isconfirmed",
      "strategy.close",
      "session.islastbar_regular",
      "session.isfirstbar",
      "session.ismarket",
      "i.e",
      "session.ispostmarket",
      "session.ispremarket",
      "strategy.account_currency",
      "strategy.avg_losing_trade",
      "strategy.avg_losing_trade_percent",
      "strategy",
      "overlay",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-237",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## strategy.avg_trade\n\n**Type:** series float\n\nReturns the average amount of money gained or lost per trade. Calculated as the sum of all profits and losses divided by the number of closed trades.\n\n---\n\n## strategy.avg_trade_percent\n\n**Type:** series float\n\nReturns the average percentage gain or loss per trade. Calculated as the sum of all profit and loss percentages divided by the number of closed trades.\n\n---\n\n## strategy.avg_winning_trade\n\n**Type:** series float\n\nReturns the average amount of money gained per winning trade. Calculated as the sum of profits divided by the number of winning trades.\n\n---\n\n## strategy.avg_winning_trade_percent\n\n**Type:** series float\n\nReturns the average percentage gain per winning trade. Calculated as the sum of profit percentages divided by the number of winning trades.\n\n---\n\n## strategy.closedtrades\n\n**Type:** series int\n\nNumber of trades, which were closed for the whole trading range.\n\n---\n\n## strategy.closedtrades.first_index\n\n**Type:** series int\n\nThe index, or trade number, of the first (oldest) trade listed in the List of Trades. This number is usually zero. If more trades than the allowed limit have been closed, the oldest trades are removed, and this number is the index of the oldest remaining trade.\n\n---\n\n## strategy.equity\n\n**Type:** series float\n\nCurrent equity (strategy.initial_capital + strategy.netprofit + strategy.openprofit).\n\n---\n\n## strategy.eventrades\n\n**Type:** series int\n\nNumber of breakeven trades for the whole trading range.\n\n---\n\n## strategy.grossloss\n\n**Type:** series float\n\nTotal currency value of all completed losing trades.\n\n---\n\n## strategy.grossloss_percent\n\n**Type:** series float\n\nThe total value of all completed losing trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.grossprofit\n\n**Type:** series float\n\nTotal currency value of all completed winning trades.\n\n---\n\n## strategy.grossprofit_percent\n\n**Type:** series float\n\nThe total currency value of all completed winning trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.initial_capital\n\n**Type:** series float\n\nThe amount of initial capital set in the strategy properties.\n\n---\n\n## strategy.losstrades\n\n**Type:** series int\n\nNumber of unprofitable trades for the whole trading range.\n\n---\n\n## strategy.margin_liquidation_price\n\n**Type:** series float\n\nWhen margin is used in a strategy, returns the price point where a simulated margin call will occur and liquidate enough of the position to meet the margin requirements.\n\n### Remarks\nThe variable returns na if the strategy does not use margin, i.e., the strategy declaration statement does not specify an argument for the margin_long or margin_short parameter.",
    "keywords": [
      "strategy.avg_trade",
      "strategy.avg_trade_percent",
      "strategy.avg_winning_trade",
      "strategy.avg_winning_trade_percent",
      "strategy.closedtrades",
      "strategy.equity",
      "strategy.initial_capital",
      "strategy.netprofit",
      "strategy.openprofit",
      "strategy.eventrades",
      "strategy.grossloss",
      "strategy.grossloss_percent",
      "strategy.grossprofit",
      "strategy.grossprofit_percent",
      "strategy.losstrades",
      "strategy.margin_liquidation_price",
      "i.e",
      "strategy",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-238",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25, \n  default_qty_type = strategy.percent_of_equity, default_qty_value = 395)\n\nfloat maFast = ta.sma(close, 14)\nfloat maSlow = ta.sma(close, 28)\n\nif ta.crossover(maFast, maSlow)\n    strategy.entry(\"Long\", strategy.long)\n\nif ta.crossunder(maFast, maSlow)\n    strategy.entry(\"Short\", strategy.short)\n\nchangePercent(v1, v2) => \n    float result = (v1 - v2) * 100 / math.abs(v2)\n\n// exit when we're 10% away from a margin call, to prevent it.\nif math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10\n    strategy.close(\"Long\")\n    strategy.close(\"Short\")\n```\n\n---\n\n## strategy.max_contracts_held_all\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one trade for the whole trading range.\n\n---\n\n## strategy.max_contracts_held_long\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one long trade for the whole trading range.\n\n---\n\n## strategy.max_contracts_held_short\n\n**Type:** series float\n\nMaximum number of contracts/shares/lots/units in one short trade for the whole trading range.\n\n---\n\n## strategy.max_drawdown\n\n**Type:** series float\n\nMaximum equity drawdown value for the whole trading range.\n\n---\n\n## strategy.max_drawdown_percent\n\n**Type:** series float\n\nThe maximum equity drawdown value for the whole trading range, expressed as a percentage and calculated by formula: Lowest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.max_runup\n\n**Type:** series float\n\nMaximum equity run-up value for the whole trading range.\n\n---\n\n## strategy.max_runup_percent\n\n**Type:** series float\n\nThe maximum equity run-up value for the whole trading range, expressed as a percentage and calculated by formula: Highest Value During Trade / (Entry Price x Quantity) * 100.\n\n---\n\n## strategy.netprofit\n\n**Type:** series float\n\nTotal currency value of all completed trades.\n\n---\n\n## strategy.netprofit_percent\n\n**Type:** series float\n\nThe total value of all completed trades, expressed as a percentage of the initial capital.\n\n---\n\n## strategy.openprofit\n\n**Type:** series float\n\nCurrent unrealized profit or loss for all open positions.\n\n---\n\n## strategy.openprofit_percent\n\n**Type:** series float\n\nThe current unrealized profit or loss for all open positions, expressed as a percentage and calculated by formula: openPL / realizedEquity * 100.\n\n---\n\n## strategy.opentrades\n\n**Type:** series int\n\nNumber of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned.\n\n---\n\n## strategy.opentrades.capital_held\n\n**Type:** series float\n\nReturns the capital amount currently held by open trades.\n\n### Remarks\nThis variable returns na if the strategy does not simulate funding trades with a portion of the hypothetical account, i.e., if the strategy function does not include nonzero margin_long or margin_short arguments.",
    "keywords": [
      "strategy.percent_of_equity",
      "ta.sma",
      "ta.crossover",
      "strategy.entry",
      "strategy.long",
      "ta.crossunder",
      "strategy.short",
      "math.abs",
      "strategy.margin_liquidation_price",
      "strategy.close",
      "strategy.max_contracts_held_all",
      "strategy.max_contracts_held_long",
      "strategy.max_contracts_held_short",
      "strategy.max_drawdown",
      "strategy.max_drawdown_percent",
      "strategy.max_runup",
      "strategy.max_runup_percent",
      "strategy.netprofit",
      "strategy.netprofit_percent",
      "strategy.openprofit",
      "strategy.openprofit_percent",
      "strategy.opentrades",
      "i.e",
      "strategy",
      "overlay",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-239",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nstrategy(\n   \"strategy.opentrades.capital_held example\", overlay=false, margin_long=50, margin_short=50, \n   default_qty_type = strategy.percent_of_equity, default_qty_value = 100\n )\n\n// Enter a short position on the first bar.\nif barstate.isfirst\n    strategy.entry(\"Short\", strategy.short)\n\n// Plot the capital held by the short position.\nplot(strategy.opentrades.capital_held, \"Capital held\")\n// Highlight the chart background if the position is completely closed by margin calls.\nbgcolor(bar_index > 0 and strategy.opentrades.capital_held == 0 ? color.new(color.red, 60) : na)\n```\n\n---\n\n## strategy.position_avg_price\n\n**Type:** series float\n\nAverage entry price of current market position. If the market position is flat, 'NaN' is returned.\n\n---\n\n## strategy.position_entry_name\n\n**Type:** series string\n\nName of the order that initially opened current market position.\n\n---\n\n## strategy.position_size\n\n**Type:** series float\n\nDirection and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size).\n\n---\n\n## strategy.wintrades\n\n**Type:** series int\n\nNumber of profitable trades for the whole trading range.\n\n---\n\n## syminfo.basecurrency\n\n**Type:** simple string\n\nReturns a string containing the code representing the symbol's base currency (i.e., the traded currency or coin) if the instrument is a Forex or Crypto pair or a derivative based on such a pair. Otherwise, it returns an empty string. For example, this variable returns \"EUR\" for \"EURJPY\", \"BTC\" for \"BTCUSDT\", \"CAD\" for \"CME:6C1!\", and \"\" for \"NASDAQ:AAPL\".\n\n---\n\n## syminfo.country\n\n**Type:** simple string\n\nReturns the two-letter code of the country where the symbol is traded, in the ISO 3166-1 alpha-2 format, or na if the exchange is not directly tied to a specific country. For example, on \"NASDAQ:AAPL\" it will return \"US\", on \"LSE:AAPL\" it will return \"GB\", and on \"BITSTAMP:BTCUSD it will return na.\n\n---\n\n## syminfo.currency\n\n**Type:** simple string\n\nReturns a string containing the code representing the currency of the symbol's prices. For example, this variable returns \"USD\" for \"NASDAQ:AAPL\" and \"JPY\" for \"EURJPY\".\n\n---\n\n## syminfo.current_contract\n\n**Type:** simple string\n\nThe ticker identifier of the underlying contract, if the current symbol is a continuous futures contract; na otherwise.\n\n---\n\n## syminfo.description\n\n**Type:** simple string\n\nDescription for the current symbol.\n\n---\n\n## syminfo.employees\n\n**Type:** simple int\n\nThe number of employees the company has.",
    "keywords": [
      "strategy.opentrades",
      "strategy.percent_of_equity",
      "barstate.isfirst",
      "strategy.entry",
      "strategy.short",
      "color.new",
      "color.red",
      "strategy.position_avg_price",
      "strategy.position_entry_name",
      "strategy.position_size",
      "strategy.wintrades",
      "syminfo.basecurrency",
      "i.e",
      "syminfo.country",
      "syminfo.currency",
      "syminfo.current_contract",
      "syminfo.description",
      "syminfo.employees",
      "strategy",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-240",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "syminfo.minmove",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.expiration_date\n\n**Type:** simple int\n\nA UNIX timestamp representing the start of the last day of the current futures contract. This variable is only compatible with non-continuous futures symbols. On other symbols, it returns na.\n\n---\n\n## syminfo.industry\n\n**Type:** simple string\n\nReturns the industry of the symbol, or na if the symbol has no industry. Example: \"Internet Software/Services\", \"Packaged software\", \"Integrated Oil\", \"Motor Vehicles\", etc. These are the same values one can see in the chart's \"Symbol info\" window.\n\n### Remarks\nA sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.\n\n---\n\n## syminfo.main_tickerid\n\n**Type:** simple string\n\nA ticker identifier representing the current chart's symbol. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc. Unlike syminfo.tickerid, this variable's value does not change when used in the expression argument of a request.*() function call.\n\n---\n\n## syminfo.mincontract\n\n**Type:** simple float\n\nThe smallest amount of the current symbol that can be traded. This limit is set by the exchange. For cryptocurrencies, it is often less than 1 token. For most other types of asset, it is often 1.\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shareholders",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "syminfo.expiration_date",
      "syminfo.industry",
      "syminfo.main_tickerid",
      "e.g",
      "syminfo.tickerid",
      "syminfo.mincontract",
      "indicator",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-241",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## syminfo.minmove\n\n**Type:** simple int\n\nReturns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the numerator in the syminfo.mintick formula: syminfo.minmove / syminfo.pricescale = syminfo.mintick.\n\n---\n\n## syminfo.mintick\n\n**Type:** simple float\n\nMin tick value for the current symbol.\n\n---\n\n## syminfo.pointvalue\n\n**Type:** simple float\n\nPoint value for the current symbol.\n\n---\n\n## syminfo.prefix\n\n**Type:** simple string\n\nPrefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD').\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.prefix\")\n\n// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, text=syminfo.prefix)\n```\n\n---\n\n## syminfo.pricescale\n\n**Type:** simple int\n\nReturns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the denominator in the syminfo.mintick formula: syminfo.minmove / syminfo.pricescale = syminfo.mintick.\n\n---\n\n## syminfo.recommendations_buy\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Buy\" rating.",
    "keywords": [
      "syminfo.minmove",
      "syminfo.mintick",
      "syminfo.pricescale",
      "syminfo.pointvalue",
      "syminfo.prefix",
      "i.e",
      "barstate.islastconfirmedhistory",
      "label.new",
      "syminfo.recommendations_buy",
      "indicator",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-242",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_buy_strong\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Strong Buy\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-243",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_date\n\n**Type:** series int\n\nThe starting date of the last set of recommendations for the current symbol.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-244",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_hold\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Hold\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-245",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_sell\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Sell\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-246",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_sell_strong\n\n**Type:** series int\n\nThe number of analysts who gave the current symbol a \"Strong Sell\" rating.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-247",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.recommendations_total\n\n**Type:** series int\n\nThe total number of recommendations for the current symbol.",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-248",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "syminfo.sector",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo recommendations\", overlay = true)\n//@variable A table containing information about analyst recommendations.\nvar table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    // Add header cells.\n    table.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)\n    // Recommendation strings\n    string startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")\n    string endDate           = str.format_time(YTD, \"yyyy-MM-dd\")\n    string buyRatings        = str.tostring(syminfo.recommendations_buy)\n    string strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)\n    string sellRatings       = str.tostring(syminfo.recommendations_sell)\n    string strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)\n    string holdRatings       = str.tostring(syminfo.recommendations_hold)\n    string totalRatings      = str.tostring(syminfo.recommendations_total)\n    // Add value cells\n    table.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)\n    table.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)\n```\n\n---\n\n## syminfo.root\n\n**Type:** simple string\n\nRoot for derivatives like futures contract. For other symbols returns the same value as syminfo.ticker.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo.root\")\n\n// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.\nif barstate.islastconfirmedhistory\n    label.new(bar_index, high, syminfo.root)\n```\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "table.cell",
      "color.gray",
      "size.large",
      "color.teal",
      "color.lime",
      "color.maroon",
      "color.red",
      "color.orange",
      "color.silver",
      "str.format_time",
      "syminfo.recommendations_date",
      "str.tostring",
      "syminfo.recommendations_buy",
      "syminfo.recommendations_buy_strong",
      "syminfo.recommendations_sell",
      "syminfo.recommendations_sell_strong",
      "syminfo.recommendations_hold",
      "syminfo.recommendations_total",
      "syminfo.root",
      "syminfo.ticker",
      "label.new",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-249",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## syminfo.sector\n\n**Type:** simple string\n\nReturns the sector of the symbol, or na if the symbol has no sector. Example: \"Electronic Technology\", \"Technology services\", \"Energy Minerals\", \"Consumer Durables\", etc. These are the same values one can see in the chart's \"Symbol info\" window.\n\n### Remarks\nA sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry.\n\n---\n\n## syminfo.session\n\n**Type:** simple string\n\nSession type of the chart main series. Possible values are session.regular, session.extended.\n\n---\n\n## syminfo.shareholders\n\n**Type:** simple int\n\nThe number of shareholders the company has.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.shares_outstanding_float\n\n**Type:** simple float\n\nThe total number of shares outstanding a company has available, excluding any of its restricted shares.",
    "keywords": [
      "syminfo.sector",
      "syminfo.session",
      "session.regular",
      "session.extended",
      "syminfo.shareholders",
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "indicator",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-250",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "syminfo.target_price_average",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---\n\n## syminfo.shares_outstanding_total\n\n**Type:** simple int\n\nThe total number of shares outstanding a company has available, including restricted shares held by insiders, major shareholders, and employees.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo simple\")\n//@variable A table containing information about a company's employees, shareholders, and shares.\nvar result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)\nif barstate.islastconfirmedhistory\n    // Add header cells\n    table.cell(table_id = result_table, column = 0, row = 0, text = \"name\")\n    table.cell(table_id = result_table, column = 1, row = 0, text = \"value\")\n    // Add employee info cells.\n    table.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")\n    table.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))\n    // Add shareholder cells.\n    table.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")\n    table.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))\n    // Add float shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")\n    table.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))\n    // Add total shares outstanding cells.\n    table.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")\n    table.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))\n```\n\n---",
    "keywords": [
      "table.new",
      "position.top_right",
      "barstate.islastconfirmedhistory",
      "table.cell",
      "str.tostring",
      "syminfo.employees",
      "syminfo.shareholders",
      "syminfo.shares_outstanding_float",
      "syminfo.shares_outstanding_total",
      "indicator",
      "var",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-251",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "## syminfo.target_price_average\n\n**Type:** series float\n\nThe average of the last yearly price targets for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_date\n\n**Type:** series int\n\nThe starting date of the last price target prediction for the current symbol.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "syminfo.target_price_average",
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-252",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_estimates\n\n**Type:** series float\n\nThe latest total number of price target predictions for the current symbol.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-253",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_high\n\n**Type:** series float\n\nThe last highest yearly price target for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-254",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_low\n\n**Type:** series float\n\nThe last lowest yearly price target for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-255",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Code Example",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.target_price_median\n\n**Type:** series float\n\nThe median of the last yearly price targets for the symbol predicted by analysts.\n\n### Remarks\nIf analysts supply the targets when the market is closed, the variable can return na until the market opens.",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-256",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "syminfo.volumetype",
    "content": "### Code Example\n```pine\n//@version=6\nindicator(\"syminfo target_price\")\nif barstate.islastconfirmedhistory\n    //@variable The time value one year from the date of the last analyst recommendations.\n    int YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000\n    //@variable A line connecting the current `close` to the highest yearly price estimate.\n    highLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the lowest yearly price estimate.\n    lowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the median yearly price estimate.\n    medianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)\n    //@variable A line connecting the current `close` to the average yearly price estimate.\n    averageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)\n    // Fill the space between targets\n    linefill.new(lowLine, medianLine, color.new(color.red, 90))\n    linefill.new(medianLine, highLine, color.new(color.green, 90))\n    // Create a label displaying the total number of analyst estimates.\n    string estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)\n    label.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)\n```\n\n---\n\n## syminfo.ticker\n\n**Type:** simple string\n\nSymbol name without exchange prefix, e.g. 'MSFT'.\n\n---\n\n## syminfo.tickerid\n\n**Type:** simple string\n\nA ticker identifier representing the chart's symbol or a requested symbol, depending on how the script uses it. The variable's value represents a requested dataset's ticker ID when used in the expression argument of a request.*() function call. Otherwise, it represents the chart's ticker ID. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc.\n\n### Remarks\nBecause the value of this variable does not always use a simple \"prefix:ticker\" format, it is a poor candidate for use in boolean comparisons or string manipulation functions. In those contexts, run the variable's result through ticker.standard to purify it. This will remove any extraneous information and return a ticker ID consistently formatted using the \"prefix:ticker\" structure. To always access the script's main ticker ID, even within another context, use the syminfo.main_tickerid variable.\n\n---\n\n## syminfo.timezone\n\n**Type:** simple string\n\nTimezone of the exchange of the chart main series. Possible values see in timestamp.\n\n---\n\n## syminfo.type\n\n**Type:** simple string\n\nThe type of market the symbol belongs to. The values are \"stock\", \"fund\", \"dr\", \"right\", \"bond\", \"warrant\", \"structured\", \"index\", \"forex\", \"futures\", \"spread\", \"economic\", \"fundamental\", \"crypto\", \"spot\", \"swap\", \"option\", \"commodity\".\n\n---",
    "keywords": [
      "barstate.islastconfirmedhistory",
      "syminfo.target_price_date",
      "timeframe.in_seconds",
      "line.new",
      "syminfo.target_price_high",
      "color.green",
      "xloc.bar_time",
      "syminfo.target_price_low",
      "color.red",
      "syminfo.target_price_median",
      "color.gray",
      "syminfo.target_price_average",
      "color.orange",
      "linefill.new",
      "color.new",
      "str.format",
      "syminfo.target_price_estimates",
      "label.new",
      "color.white",
      "size.large",
      "syminfo.ticker",
      "e.g",
      "syminfo.tickerid",
      "ticker.standard",
      "syminfo.main_tickerid",
      "syminfo.timezone",
      "syminfo.type",
      "indicator",
      "hline",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-257",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "ta.wvad",
    "content": "## syminfo.volumetype\n\n**Type:** simple string\n\nVolume type of the current symbol. Possible values are: \"base\" for base currency, \"quote\" for quote currency, \"tick\" for the number of transactions, and \"n/a\" when there is no volume or its type is not specified.\n\n### Remarks\nOnly some data feed suppliers provide information qualifying volume. As a result, the variable will return a value on some symbols only, mostly in the crypto sector.\n\n---\n\n## ta.accdist\n\n**Type:** series float\n\nAccumulation/distribution index.\n\n---\n\n## ta.iii\n\n**Type:** series float\n\nIntraday Intensity Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Intraday Intensity Index\")\nplot(ta.iii, color=color.yellow)\n\n// the same on pine\nf_iii() =>\n    (2 * close - high - low) / ((high - low) * volume)\n\nplot(f_iii())\n```\n\n---\n\n## ta.nvi\n\n**Type:** series float\n\nNegative Volume Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Negative Volume Index\")\n\nplot(ta.nvi, color=color.yellow)\n\n// the same on pine\nf_nvi() =>\n    float ta_nvi = 1.0\n    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0) ? 1.0 : ta_nvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_nvi := prevNvi\n    else\n        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi\n    result = ta_nvi\n\nplot(f_nvi())\n```\n\n---\n\n## ta.obv\n\n**Type:** series float\n\nOn Balance Volume.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"On Balance Volume\")\nplot(ta.obv, color=color.yellow)\n\n// the same on pine\nf_obv() =>\n    ta.cum(math.sign(ta.change(close)) * volume)\n\nplot(f_obv())\n```\n\n---\n\n## ta.pvi\n\n**Type:** series float\n\nPositive Volume Index.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Positive Volume Index\")\n\nplot(ta.pvi, color=color.yellow)\n\n// the same on pine\nf_pvi() =>\n    float ta_pvi = 1.0\n    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0) ? 1.0 : ta_pvi[1]\n    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0\n        ta_pvi := prevPvi\n    else\n        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi\n    result = ta_pvi\n\nplot(f_pvi())\n```\n\n---\n\n## ta.pvt\n\n**Type:** series float\n\nPrice-Volume Trend.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Price-Volume Trend\")\nplot(ta.pvt, color=color.yellow)\n\n// the same on pine\nf_pvt() =>\n    ta.cum((ta.change(close) / close[1]) * volume)\n\nplot(f_pvt())\n```\n\n---\n\n## ta.tr\n\n**Type:** series float\n\nTrue range, equivalent to ta.tr(handle_na = false). It is calculated as math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1])).\n\n---\n\n## ta.vwap\n\n**Type:** series float\n\nVolume Weighted Average Price. It uses hlc3 as its source series.\n\n---\n\n## ta.wad\n\n**Type:** series float\n\nWilliams Accumulation/Distribution.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams Accumulation/Distribution\")\nplot(ta.wad, color=color.yellow)\n\n// the same on pine\nf_wad() =>\n    trueHigh = math.max(high, close[1])\n    trueLow = math.min(low, close[1])\n    mom = ta.change(close)\n    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0\n    ta.cum(gain)\n\nplot(f_wad())\n```\n\n---",
    "keywords": [
      "syminfo.volumetype",
      "ta.accdist",
      "ta.iii",
      "color.yellow",
      "ta.nvi",
      "ta.obv",
      "ta.cum",
      "math.sign",
      "ta.change",
      "ta.pvi",
      "ta.pvt",
      "ta.tr",
      "math.max",
      "math.abs",
      "ta.vwap",
      "ta.wad",
      "math.min",
      "indicator",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-258",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "timeframe.isminutes",
    "content": "## ta.wvad\n\n**Type:** series float\n\nWilliams Variable Accumulation/Distribution.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Williams Variable Accumulation/Distribution\")\nplot(ta.wvad, color=color.yellow)\n\n// the same on pine\nf_wvad() =>\n    (close - open) / (high - low) * volume\n\nplot(f_wvad())\n```\n\n---\n\n## table.all\n\n**Type:** array<table>\n\nReturns an array filled with all the current tables drawn by the script.\n\n### Remarks\nThe array is read-only. Index zero of the array is the ID of the oldest object on the chart.\n\n### Code Example\n```pine\n//@version=6\nindicator(\"table.all\")\n//delete all tables\ntable.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)\na_allTables = table.all\nif array.size(a_allTables) > 0\n    for i = 0 to array.size(a_allTables) - 1\n        table.delete(array.get(a_allTables, i))\n```\n\n---\n\n## time\n\n**Type:** series int\n\nCurrent bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nNote that this variable returns the timestamp based on the time of the bar's open. Because of that, for overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day. For example, on EURUSD, dayofmonth(time) can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior.\n\n---\n\n## time_close\n\n**Type:** series int\n\nThe time of the current bar's close in UNIX format. It represents the number of milliseconds elapsed since 00:00:00 UTC, 1 January 1970. On tick charts and price-based charts such as Renko, line break, Kagi, point & figure, and range, this variable's series holds an na timestamp for the latest realtime bar (because the future closing time is unpredictable), but valid timestamps for all previous bars.\n\n---\n\n## time_tradingday\n\n**Type:** series int\n\nThe beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970).\n\n### Remarks\nThe variable is useful for overnight sessions, where the current day's session can start on the previous calendar day (e.g., on FXCM:EURUSD the Monday session will start on Sunday, 17:00 in the exchange timezone). Unlike time, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, time_tradingday will return the timestamp for Monday, 00:00 UTC. When used on timeframes higher than 1D, time_tradingday returns the trading day of the last day inside the bar (e.g. on 1W, it will return the last trading day of the week).\n\n---\n\n## timeframe.isdaily\n\n**Type:** simple bool\n\nReturns true if current resolution is a daily resolution, false otherwise.\n\n---\n\n## timeframe.isdwm\n\n**Type:** simple bool\n\nReturns true if current resolution is a daily or weekly or monthly resolution, false otherwise.\n\n---\n\n## timeframe.isintraday\n\n**Type:** simple bool\n\nReturns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise.\n\n---",
    "keywords": [
      "ta.wvad",
      "color.yellow",
      "table.all",
      "table.new",
      "position.top_right",
      "array.size",
      "table.delete",
      "array.get",
      "e.g",
      "timeframe.isdaily",
      "timeframe.isdwm",
      "timeframe.isintraday",
      "indicator",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-259",
    "type": "documentation",
    "source": "reference/variables.md",
    "section": "reference",
    "title": "Remarks",
    "content": "## timeframe.isminutes\n\n**Type:** simple bool\n\nReturns true if current resolution is a minutes resolution, false otherwise.\n\n---\n\n## timeframe.ismonthly\n\n**Type:** simple bool\n\nReturns true if current resolution is a monthly resolution, false otherwise.\n\n---\n\n## timeframe.isseconds\n\n**Type:** simple bool\n\nReturns true if current resolution is a seconds resolution, false otherwise.\n\n---\n\n## timeframe.isticks\n\n**Type:** simple bool\n\nReturns true if current resolution is a ticks resolution, false otherwise.\n\n---\n\n## timeframe.isweekly\n\n**Type:** simple bool\n\nReturns true if current resolution is a weekly resolution, false otherwise.\n\n---\n\n## timeframe.main_period\n\n**Type:** simple string\n\nA string representation of the script's main timeframe. If the script is an indicator that specifies a timeframe value in its declaration statement, this variable holds that value. Otherwise, its value represents the chart's timeframe. Unlike timeframe.period, this variable's value does not change when used in the expression argument of a request.*() function call.\n\n---\n\n## timeframe.multiplier\n\n**Type:** simple int\n\nMultiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12.\n\n---\n\n## timeframe.period\n\n**Type:** simple string\n\nA string representation of the script's main timeframe or a requested timeframe, depending on how the script uses it. The variable's value represents the timeframe of a requested dataset when used in the expression argument of a request.*() function call. Otherwise, its value represents the script's main timeframe (timeframe.main_period), which equals either the timeframe argument of the indicator declaration statement or the chart's timeframe.\n\n### Remarks\nTo always access the script's main timeframe, even within another context, use the timeframe.main_period variable.\n\n---\n\n## timenow\n\n**Type:** series int\n\nCurrent time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.\n\n### Remarks\nPlease note that using this variable/function can cause indicator repainting.\n\n---\n\n## volume\n\n**Type:** series float\n\nCurrent bar volume.\n\n### Remarks\nPrevious values may be accessed with square brackets operator [], e.g. volume[1], volume[2].\n\n---\n\n## weekofyear\n\n**Type:** series int\n\nWeek number of current bar time in exchange timezone.\n\n### Remarks\nNote that this variable returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.\n\n---\n\n## year\n\n**Type:** series int\n\nCurrent bar year in exchange timezone.\n\n### Remarks\nNote that this variable returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day.",
    "keywords": [
      "timeframe.isminutes",
      "timeframe.ismonthly",
      "timeframe.isseconds",
      "timeframe.isticks",
      "timeframe.isweekly",
      "timeframe.main_period",
      "timeframe.period",
      "timeframe.multiplier",
      "e.g",
      "indicator",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-260",
    "type": "documentation",
    "source": "release_notes.md",
    "section": "root",
    "title": "November 2025",
    "content": "# Release notes\n\n### December  2025\n\n#### Updated line  wrapping\n\nScripts now have improved line wrapping behavior. Previously, all multiline text representing a  _single line_  of code required indenting each line after the first by any number of spaces that was  _not_  a multiple of four, because Pine reserved four-space indentation for local code blocks.\n\nWe‚Äôve removed the indentation restriction for all parts of an expression or statement enclosed in  _parentheses_, including operations, function calls, and function parameter declarations. Scripts can now indent wrapped lines enclosed in parentheses by  _zero or more_  spaces, including multiples of four. For example:\n\n### Code Example\n```pine\n//@version=6\n\n// Before the update, wrapped lines in this code that start at multiples of four spaces caused compilation errors.\n\nindicator(\n    \"Line wrapping between parentheses demo\", // Indented by four spaces.\n        overlay = true                        // Indented by eight spaces.\n)                                             // No indentation.\n\nfloat median = 0.5 * (\n    ta.highest(20) + ta.lowest(20) // Indented by four spaces.\n)                                  // No indentation.\n\nplot(\nmedian,              // No indentation.\n  \"Median\",          // Indented by two spaces.\n   chart.fg_color,   // Indented by three spaces.\n    3                // Indented by four spaces.\n)                    // No indentation.\n```\nHowever, if a line-wrapped expression is not enclosed in parentheses, all subsequent lines still require an indentation that is not a multiple of four spaces. For example:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"Invalid line wrap demo\", overlay = true)\n\n// The second line that starts with `*` in this wrapped expression causes a compilation error.\n// For the script to compile successfully, do any of the following:\n// - Move that part of the expression to line 9.\n// - Add another leading space to line 10 so that it doesn't start after a multiple of four spaces.\n// - Enclose the entire expression in another set of parentheses. \nfloat median = 0.5 \n    * ( \n    ta.highest(20) + ta.lowest(20)\n)\n\nplot(median)\n```",
    "keywords": [
      "ta.highest",
      "ta.lowest",
      "chart.fg_color",
      "indicator",
      "overlay",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-261",
    "type": "documentation",
    "source": "release_notes.md",
    "section": "root",
    "title": "October 2025",
    "content": "## November 2025 \n\nWe‚Äôve added a new variable, syminfo.isin, which holds a string containing the 12-character International Securities Identification Number (ISIN) for the security represented by the symbol, or an empty string if no ISIN is available. An ISIN uniquely identifies a security globally and does not vary across exchanges, unlike ticker symbols. As such, programmers can use this variable to identify a symbol‚Äôs underlying stock or other instrument, regardless of the name listed by an exchange. For example:\n\nHolds a string representing a symbol's associated International Securities Identification Number (ISIN), or an empty string if there is no ISIN information available for the symbol. An ISIN is a 12-character alphanumeric code that uniquely identifies a security globally. Unlike ticker symbols, which can vary across exchanges, the ISIN for a security is consistent across exchanges. As such, programmers can use the ISIN to identify an underlying financial instrument, regardless of the exchange or the symbol name listed by an exchange.\nFor example, the ISIN associated with NASDAQ:AAPL and GETTEX:APC is US0378331005, because both symbols refer to the common stock from Apple Inc. In contrast, the ISIN for TSX:AAPL is CA03785Y1007, because the symbol refers to a different instrument: the Apple Inc. Canadian Depositary Receipt (CDR).\n\n### Code Example\n```pine\n//@version=6\nindicator(\"ISIN demo\")\n\n// Define inputs for two symbols to compare.\nstring symbol1Input = input.symbol(\"NASDAQ:AAPL\", \"Symbol 1\")\nstring symbol2Input = input.symbol(\"GETTEX:APC\",  \"Symbol 2\")\n\nif barstate.islastconfirmedhistory\n    // Retrieve ISIN strings for `symbol1Input` and `symbol2Input`.\n    var string isin1 = request.security(symbol1Input, \"\", syminfo.isin)\n    var string isin2 = request.security(symbol2Input, \"\", syminfo.isin)\n\n    // Log the retrieved ISIN codes. \n    log.info(\"Symbol 1 ISIN: \" + isin1)\n    log.info(\"Symbol 2 ISIN: \" + isin2)\n\n    // Log an error message if one of the symbols does not have ISIN information.\n    if isin1 == \"\" or isin2 == \"\"\n        log.error(\"ISIN information is not available for both symbols.\")\n    // If both symbols do have ISIN information, log a message to confirm whether both refer to the same security.\n    else if isin1 == isin2\n        log.info(\"Both symbols refer to the same security.\")\n    else\n        log.info(\"The two symbols refer to different securities.\")\n```",
    "keywords": [
      "syminfo.isin",
      "input.symbol",
      "barstate.islastconfirmedhistory",
      "request.security",
      "log.info",
      "log.error",
      "indicator",
      "input",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-262",
    "type": "documentation",
    "source": "release_notes.md",
    "section": "root",
    "title": "Code Example",
    "content": "## October 2025\n\nThe time() and time_close() functions feature a new parameter: timeframe_bars_back. In contrast to the bars_back parameter, which determines the bar offset on the script‚Äôs main timeframe for the timestamp calculation, timeframe_bars_back determines the bar offset on the separate timeframe specified by the timeframe argument. If the timeframe_bars_back value is positive, the function calculates the timestamp of the past bar that is N bars back on the specified timeframe. If negative, it calculates the expected timestamp of the bar that is N bars forward on that timeframe.\n\nIf a call to time() or time_close() includes arguments for both the bars_back and timeframe_bars_back parameters, it determines the timestamp corresponding to the bars_back offset first. Then, it applies the timeframe_bars_back offset to that time to calculate the final timestamp. For example:\n\n### Code Example\n```pine\n//@version=6\nindicator(\"`bars_back` and `timeframe_bars_back` demo\")\n\n//@variable The number of bars back on the script's main timeframe (chart timeframe).\nint barsBackInput = input.int(10, \"Chart bar offset\")\n//@variable The number of bars back on the \"1M\" timeframe.\nint tfBarsBackInput = input.int(3, \"'1M' bar offset\")\n\n//@variable The opening UNIX timestamp of the current \"1M\" bar.\nint monthTime = time(\"1M\")\n//@variable The opening time of the \"1M\" bar that contains the bar from `barsBackInput` bars back on the main timeframe. \nint offsetTime1 = time(\"1M\", bars_back = barsBackInput)\n//@variable The \"1M\" opening time that is `tfBarsBackInput` monthly bars back, relative to the \"1M\" bar that opens at `offsetTime1`.\n//          This `time()` call first determines the \"1M\" bar time corresponding to `barsBackInput` bars back on the \n//          main timeframe, just like the previous call. Then, it calculates and returns the \"1M\" opening time that is \n//          `tfBarsBackInput` *monthly* bars back relative to that time.\nint offsetTime2 = time(\"1M\", bars_back = barsBackInput, timeframe_bars_back = tfBarsBackInput)\n\n// Plot the values for visual comparison.\nplot(monthTime, \"No offset\")\nplot(offsetTime1, \"`bars_back`\", color.red)\nplot(offsetTime2, \"`bars_back` + `timeframe_bars_back`\", color.purple)\n// Log formatted timestamps in the Pine Logs pane.\nlog.info(\"\\n{0}\\n{1}\\n{2}\", str.format_time(monthTime), str.format_time(offsetTime1), str.format_time(offsetTime2))\n```",
    "keywords": [
      "input.int",
      "color.red",
      "color.purple",
      "log.info",
      "str.format_time",
      "indicator",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-263",
    "type": "documentation",
    "source": "visuals/backgrounds.md",
    "section": "visuals",
    "title": "backgrounds",
    "content": "# [Backgrounds](https://www.tradingview.com/pine-script-docs/visuals/backgrounds/#backgrounds)\n\nThe  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  function changes the color of the script‚Äôs background. If the script is running in  `overlay = true`  mode, then it will color the chart‚Äôs background.\n\nThe function‚Äôs signature is:\n\n```\n\n```\n\nIts  `color`  parameter allows a ‚Äúseries color‚Äù to be used for its argument, so it can be dynamically calculated in an expression.\n\nIf the correct transparency is not part of the color to be used, it can be be generated using the  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color%7Bdot%7Dnew)  function.\n\nHere is a script that colors the background of trading sessions (try it on 30min EURUSD, for example):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Session backgrounds\",  overlay  =  true)  \n  \n// Default color constants using tranparency of 25.  \nBLUE_COLOR  =  #0050FF40  \nPURPLE_COLOR  =  #0000FF40  \nPINK_COLOR  =  #5000FF40  \nNO_COLOR  =  color(na)  \n  \n// Allow user to change the colors.  \npreMarketColor  =  input.color(BLUE_COLOR,  \"Pre-market\")  \nregSessionColor  =  input.color(PURPLE_COLOR,  \"Pre-market\")  \npostMarketColor  =  input.color(PINK_COLOR,  \"Pre-market\")  \n  \n// Function returns `true` when the bar's time is  \ntimeInRange(tf,  session) =>  \ntime(tf,  session) !=  0  \n  \n// Function prints a message at the bottom-right of the chart.  \nf_print(_text) =>  \nvar  table  _t  =  table.new(position.bottom_right,  1,  1)  \ntable.cell(_t,  0,  0,  _text,  bgcolor  =  color.yellow)  \n  \nvar  chartIs30MinOrLess  =  timeframe.isseconds  or (timeframe.isintraday  and  timeframe.multiplier  <=30)  \nsessionColor  =  if  chartIs30MinOrLess  \nswitch  \ntimeInRange(timeframe.period,  \"0400-0930\") =>  preMarketColor  \ntimeInRange(timeframe.period,  \"0930-1600\") =>  regSessionColor  \ntimeInRange(timeframe.period,  \"1600-2000\") =>  postMarketColor  \n=>  NO_COLOR  \nelse  \nf_print(\"No background is displayed.\\nChart timeframe must be <= 30min.\")  \nNO_COLOR  \n  \nbgcolor(sessionColor)  \n``\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Backgrounds-Sessions.CXTYPY8S_22dX0.webp)\n\nNote that:\n\n-   The script only works on chart timeframes of 30min or less. It prints an error message when the chart‚Äôs timeframe is higher than 30min.\n-   When the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure‚Äôs  `else`  branch is used because the chart‚Äôs timeframe is incorrect, the local block returns the  `NO_COLOR`  color so that no background is displayed in that case.\n-   We first initialize constants using our base colors, which include the  `40`  transparency in hex notation at the end. 40 in the hexadecimal notation on the reversed 00-FF scale for transparency corresponds to 75 in Pine Script¬Æ‚Äòs 0-100 decimal scale for transparency.",
    "keywords": [
      "www.tradingview",
      "color.new",
      "tradingview.com",
      "input.color",
      "table.new",
      "position.bottom_right",
      "table.cell",
      "color.yellow",
      "timeframe.isseconds",
      "timeframe.isintraday",
      "timeframe.multiplier",
      "timeframe.period",
      "indicator",
      "overlay",
      "input",
      "bgcolor",
      "var",
      "series",
      "const",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-264",
    "type": "documentation",
    "source": "visuals/backgrounds.md",
    "section": "visuals",
    "title": "backgrounds",
    "content": "-   We provide color inputs allowing script users to change the default colors we propose.\n\nIn our next example, we generate a gradient for the background of a CCI line:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"CCI Background\")  \n  \nbullColor  =  input.color(color.lime,  \"ü†Ö\",  inline  =  \"1\")  \nbearColor  =  input.color(color.fuchsia,  \"ü†á\",  inline  =  \"1\")  \n  \n// Calculate CCI.  \nmyCCI  =  ta.cci(hlc3,  20)  \n// Get relative position of CCI in last 100 bars, on a 0-100% scale.  \nmyCCIPosition  =  ta.percentrank(myCCI,  100)  \n// Generate a bull gradient when position is 50-100%, bear gradient when position is 0-50%.  \nbackgroundColor  =  if  myCCIPosition  >=  50  \ncolor.from_gradient(myCCIPosition,  50,  100,  color.new(bullColor,  75),  bullColor)  \nelse  \ncolor.from_gradient(myCCIPosition,  0,  50,  bearColor,  color.new(bearColor,  75))  \n  \n// Wider white line background.  \nplot(myCCI,  \"CCI\",  color.white,  3)  \n// Think black line.  \nplot(myCCI,  \"CCI\",  color.black,  1)  \n// Zero level.  \nhline(0)  \n// Gradient background.  \nbgcolor(backgroundColor)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Backgrounds-CCI.D0GF9YXt_ZtOoQo.webp)\n\nNote that:\n\n-   We use the  [ta.cci()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta%7Bdot%7Dcci)  built-in function to calculate the indicator value.\n-   We use the  [ta.percentrank()](https://www.tradingview.com/pine-script-reference/v6/#ta.percentrank)  built-in function to calculate  `myCCIPosition`, i.e., the percentage of past  `myCCI`  values in the last 100 bars that are below the current value of  `myCCI`.\n-   To calculate the gradient, we use two different calls of the  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color%7Bdot%7Dfrom_gradient)  built-in: one for the bull gradient when  `myCCIPosition`  is in the 50-100% range, which means that more past values are below its current value, and another for the bear gradient when  `myCCIPosition`  is in the 0-49.99% range, which means that more past values are above it.\n-   We provide inputs so the user can change the bull/bear colors, and we place both color input widgets on the same line using  `inline = \"1\"`  in both  [input.color()](https://www.tradingview.com/pine-script-reference/v6/#fun_input%7Bdot%7Dcolor)  calls.\n-   We plot the CCI signal using two  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  calls to achieve the best contrast over the busy background: the first plot is a 3-pixel wide white background, the second  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call plots the thin, 1-pixel wide black line.\n\nSee the  [Colors](https://www.tradingview.com/pine-script-docs/visuals/colors/)  page for more examples of backgrounds.",
    "keywords": [
      "tradingview.com",
      "input.color",
      "color.lime",
      "color.fuchsia",
      "ta.cci",
      "ta.percentrank",
      "color.from_gradient",
      "color.new",
      "color.white",
      "color.black",
      "www.tradingview",
      "i.e",
      "indicator",
      "input",
      "plot",
      "hline",
      "bgcolor",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-265",
    "type": "documentation",
    "source": "visuals/bar_coloring.md",
    "section": "visuals",
    "title": "bar_coloring",
    "content": "# [Bar  coloring](https://www.tradingview.com/pine-script-docs/visuals/bar-coloring/#bar-coloring)\n\nThe  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor)  function colors bars on the main chart, regardless of whether the script is running in the main chart pane or a separate pane.\n\nThe function‚Äôs signature is:\n\n```\n\n```\n\nThe coloring can be conditional because the  `color`  parameter accepts ‚Äúseries color‚Äù arguments.\n\nThe following script renders  _inside_  and  _outside_  bars in different colors:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/BarColoring-1.BVBRLjUu_2gjXX.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"barcolor example\",  overlay  =  true)  \nisUp  =  close  >  open  \nisDown  =  close  <=  open  \nisOutsideUp  =  high  >  high[1] and  low  <  low[1] and  isUp  \nisOutsideDown  =  high  >  high[1] and  low  <  low[1] and  isDown  \nisInside  =  high  <  high[1] and  low  >  low[1]  \nbarcolor(isInside  ?  color.yellow  :  isOutsideUp  ?  color.aqua  :  isOutsideDown  ?  color.purple  :  na)  \n`\n\nNote that:\n\n-   The  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  value leaves bars as is.\n-   In the  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor)  call, we use embedded  [?:](https://www.tradingview.com/pine-script-reference/v6/#op_%7Bquestion%7D%7Bcolon%7D)  ternary operator expressions to select the color.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.yellow",
      "color.aqua",
      "color.purple",
      "indicator",
      "overlay",
      "barcolor",
      "var",
      "series",
      "if"
    ]
  },
  {
    "id": "doc-266",
    "type": "documentation",
    "source": "visuals/bar_plotting.md",
    "section": "visuals",
    "title": "bar_plotting",
    "content": "Bar plotting\nIntroduction\nThe plotcandle() built-in function is used to plot candles. plotbar() is used to plot conventional bars.\n\nBoth functions require four arguments that will be used for the OHLC prices (open, high, low, close) of the bars they will be plotting. If one of those is na, no bar is plotted.\n\nPlotting candles with ‚Äãplotcandle()‚Äã\nThe signature of plotcandle() is:\n\nplotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display) ‚Üí void\nThis plots simple candles, all in blue, using the habitual OHLC values, in a separate pane:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Single-color candles\")\nplotcandle(open, high, low, close)\nimage\n\nTo color them green or red, we can use the following code:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Example 2\")\npaletteColor = close >= open ? color.lime : color.red\nplotbar(open, high, low, close, color = paletteColor)\nimage\n\nNote that the color parameter accepts ‚Äúseries color‚Äù arguments, so constant values such as color.red, color.lime, \"#FF9090\", as well as expressions that calculate colors at runtime, as is done with the paletteColor variable here, will all work.\n\nYou can build bars or candles using values other than the actual OHLC values. For example you could calculate and plot smoothed candles using the following code, which also colors wicks depending on the position of close relative to the smoothed close (c) of our indicator:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Smoothed candles\", overlay = true)\nlenInput = input.int(9)\nsmooth(source, length) =>\n    ta.sma(source, length)\no = smooth(open, lenInput)\nh = smooth(high, lenInput)\nl = smooth(low, lenInput)\nc = smooth(close, lenInput)\nourWickColor = close > c ? color.green : color.red\nplotcandle(o, h, l, c, wickcolor = ourWickColor)\nimage\n\nYou may find it useful to plot OHLC values taken from a higher timeframe. You can, for example, plot daily bars on an intraday chart:\n\nPine Script¬Æ\nCopied\n// NOTE: Use this script on an intraday chart.\n//@version=6\nindicator(\"Daily bars\", behind_chart = false, overlay = true)\n\n// Use gaps to return data only when the 1D timeframe completes, and to return `na` otherwise.\n[o, h, l, c] = request.security(syminfo.tickerid, \"D\", [open, high, low, close], gaps = barmerge.gaps_on)\n\nconst color UP_COLOR = color.silver\nconst color DN_COLOR = color.blue\ncolor wickColor = c >= o ? UP_COLOR : DN_COLOR\ncolor bodyColor = c >= o ? color.new(UP_COLOR, 70) : color.new(DN_COLOR, 70)\n// Plot candles on intraday timeframes, \n// and when non `na` values are returned by `request.security()` because a HTF bar has completed.\nplotcandle(timeframe.isintraday ? o : na, h, l, c, color = bodyColor, wickcolor = wickColor)\nimage\n\nNote that:\n\nWe set the behind_chart parameter of the indicator() declaration to false. This causes our script‚Äôs candles to appear on top of the chart‚Äôs candles. Selecting ‚ÄúVisual Order/Bring to Front‚Äù from the script‚Äôs ‚ÄúMore‚Äù menu achieves the same result.",
    "keywords": [
      "color.lime",
      "color.red",
      "input.int",
      "ta.sma",
      "color.green",
      "request.security",
      "syminfo.tickerid",
      "barmerge.gaps_on",
      "color.silver",
      "color.blue",
      "color.new",
      "timeframe.isintraday",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-267",
    "type": "documentation",
    "source": "visuals/bar_plotting.md",
    "section": "visuals",
    "title": "bar_plotting",
    "content": "The script displays candles only when two conditions are met:\nThe chart is using an intraday timeframe (see the check on timeframe.isintraday in the plotcandle() call). We do this because it‚Äôs not useful to show a daily value on timeframes higher or equal to 1D.\nThe request.security() function returns non na values (see gaps = barmerge.gaps_on in the function call).\nWe use a tuple ([open, high, low, close]) with request.security() to fetch four values in one call.\nWe create a lighter transparency for the body of our candles in the bodyColor variable initialization, so they don‚Äôt obstruct the chart‚Äôs candles.\nPlotting bars with ‚Äãplotbar()‚Äã\nThe signature of plotbar() is:\n\nplotbar(open, high, low, close, title, color, editable, show_last, display, force_overlay) ‚Üí void\nNote that plotbar() has no parameter for bordercolor or wickcolor, as there are no borders or wicks on conventional bars.\n\nThis plots conventional bars using the same coloring logic as in the second example of the previous section:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Dual-color bars\")\npaletteColor = close >= open ? color.lime : color.red\nplotbar(open, high, low, close, color = paletteColor)\nimage",
    "keywords": [
      "timeframe.isintraday",
      "request.security",
      "barmerge.gaps_on",
      "color.lime",
      "color.red",
      "indicator",
      "overlay",
      "plot",
      "var",
      "for"
    ]
  },
  {
    "id": "doc-268",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Constant  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)",
    "content": "# [Colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#colors)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/visuals/colors/#introduction)\n\nScript visuals can play a critical role in the usability of the indicators we write in Pine Script¬Æ. Well-designed plots and drawings make indicators easier to use and understand. Good visual designs establish a visual hierarchy that allows the more important information to stand out, and the less important one to not get in the way.\n\nUsing colors in Pine can be as simple as you want, or as involved as your concept requires. The 4,294,967,296 possible assemblies of color and transparency available in Pine Script can be applied to:\n\n-   Any element you can plot or draw in an indicator‚Äôs visual space, be it lines, fills, text or candles.\n-   The background of a script‚Äôs visual space, whether the script is running in its own pane, or in overlay mode on the chart.\n-   The color of bars or the body of candles appearing on a chart.\n\nA script can only color the elements it places in its own visual space. The only exception to this rule is that a pane indicator can color chart bars or candles.\n\nPine Script has built-in colors such as  [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green), as well as functions like  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  which allow you to dynamically generate any color in the RGBA color space.\n\n### [Transparency](https://www.tradingview.com/pine-script-docs/visuals/colors/#transparency)\n\nEach color in Pine Script is defined by four values:\n\n-   Its red, green and blue components (0-255), following the  [RGB color model](https://en.wikipedia.org/wiki/RGB_color_space).\n-   Its transparency (0-100), often referred to as the Alpha channel outside Pine, as defined in the  [RGBA color model](https://en.wikipedia.org/wiki/RGBA_color_model). Even though transparency is expressed in the 0-100 range, its value can be a ‚Äúfloat‚Äù when used in functions, which gives you access to the 256 underlying values of the alpha channel.\n\nThe transparency of a color defines how opaque it is: zero is fully opaque, 100 makes the color ‚Äî whichever it is ‚Äî invisible. Modulating transparency can be crucial in more involved color visuals or when using backgrounds, to control which colors dominate the others, and how they mix together when superimposed.",
    "keywords": [
      "www.tradingview",
      "color.green",
      "const_color.green",
      "color.rgb",
      "fun_color.rgb",
      "en.wikipedia",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "simple",
      "const",
      "import",
      "for"
    ]
  },
  {
    "id": "doc-269",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Conditional  coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)",
    "content": "## [Constant  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)\n\nThere are 17 built-in colors in Pine Script. This table lists their names, hexadecimal equivalent, and RGB values as arguments to  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb):\n\nName\n\nHex\n\nRGB values\n\ncolor.aqua\n\n#00BCD4\n\ncolor.rgb(0, 188, 212)\n\ncolor.black\n\n#363A45\n\ncolor.rgb(54, 58, 69)\n\ncolor.blue\n\n#2196F3\n\ncolor.rgb(33, 150, 243)\n\ncolor.fuchsia\n\n#E040FB\n\ncolor.rgb(224, 64, 251)\n\ncolor.gray\n\n#787B86\n\ncolor.rgb(120, 123, 134)\n\ncolor.green\n\n#4CAF50\n\ncolor.rgb(76, 175, 80)\n\ncolor.lime\n\n#00E676\n\ncolor.rgb(0, 230, 118)\n\ncolor.maroon\n\n#880E4F\n\ncolor.rgb(136, 14, 79)\n\ncolor.navy\n\n#311B92\n\ncolor.rgb(49, 27, 146)\n\ncolor.olive\n\n#808000\n\ncolor.rgb(128, 128, 0)\n\ncolor.orange\n\n#FF9800\n\ncolor.rgb(255, 152, 0)\n\ncolor.purple\n\n#9C27B0\n\ncolor.rgb(156, 39, 176)\n\ncolor.red\n\n#F23645\n\ncolor.rgb(242, 54, 69)\n\ncolor.silver\n\n#B2B5BE\n\ncolor.rgb(178, 181, 190)\n\ncolor.teal\n\n#089981\n\ncolor.rgb(8, 153, 129)\n\ncolor.white\n\n#FFFFFF\n\ncolor.rgb(255, 255, 255)\n\ncolor.yellow\n\n#FDD835\n\ncolor.rgb(253, 216, 53)\n\nThe following script shows three different ways to express  [color.olive](https://www.tradingview.com/pine-script-reference/v6/#const_color.olive)  with 40% transparency. All three methods are functionally equivalent:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-Constant-colors-1.CnlC-u-k_1ibe2x.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Constant colors demo\",  overlay  =  true)  \n  \n// Create a plot using the hex color code equivalent for `color.olive` with `99` as the alpha value (60% opacity).  \nplot(ta.sma(close,  10),  \"10-bar SMA\",  #80800099,  3)  \n// Create a plot using `color.new()` to modify `color.olive` with 40% transparency.  \nplot(ta.sma(close,  30),  \"30-bar SMA\",  color.new(color.olive,  40),  3)  \n// Create a plot using `color.rgb()` with the `r`, `g`, and `b` components of `color.olive` and 40% transparency.  \nplot(ta.sma(close,  50),  \"50-bar SMA\",  color.rgb(128,  128,  0,  40),  3)  \n``\n\nNote that:\n\n-   An alpha value of  `99`  in a hexadecimal color code is equivalent to 60% opacity, meaning the resulting color is 40% transparent.\n-   Transparency does  _not_  affect plot outputs in the status line, price scale, or Data Window. All these locations show the color with 0% transparency.\n\nThe colors in the previous script do not vary as the script executes bar to bar. Sometimes, however, colors need to be created as the script executes on each bar because they depend on conditions that are unknown at compile time, or when the script begins execution on bar zero. For those cases, programmers have two options:\n\n1.  Use conditional statements to select colors from a few pre-determined base colors.\n2.  Build new colors dynamically, by calculating them as the script executes bar to bar, to implement color gradients, for example.",
    "keywords": [
      "www.tradingview",
      "color.rgb",
      "fun_color.rgb",
      "color.aqua",
      "color.black",
      "color.blue",
      "color.fuchsia",
      "color.gray",
      "color.green",
      "color.lime",
      "color.maroon",
      "color.navy",
      "color.olive",
      "color.orange",
      "color.purple",
      "color.red",
      "color.silver",
      "color.teal",
      "color.white",
      "color.yellow",
      "const_color.olive",
      "tradingview.com",
      "ta.sma",
      "color.new",
      "indicator",
      "overlay",
      "plot",
      "var",
      "const",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-270",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Calculated  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)",
    "content": "## [Conditional  coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)\n\nLet‚Äôs say you want to color a moving average in different colors, depending on some conditions you define. To do so, you can use a conditional statement that will select a different color for each of your states. Let‚Äôs start by coloring a moving average in a bull color when it‚Äôs rising, and in a bear color when it‚Äôs not:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-1.D1QaF3Y-_ZumNWi.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Conditional colors\",  \"\",  true)  \nint  lengthInput  =  input.int(20,  \"Length\",  minval  =  2)  \ncolor  maBullColorInput  =  input.color(color.green,  \"Bull\")  \ncolor  maBearColorInput  =  input.color(color.maroon,  \"Bear\")  \nfloat  ma  =  ta.sma(close,  lengthInput)  \n// Define our states.  \nbool  maRising  =  ta.rising(ma,  1)  \n// Build our color.  \ncolor  maColor  =  maRising  ?  maBullColorInput  :  maBearColorInput  \nplot(ma,  \"MA\",  maColor,  2)  \n`\n\nNote that:\n\n-   We provide users of our script a selection of colors for our bull/bear colors.\n-   We define an  `maRising`  boolean variable which will hold  `true`  when the moving average is higher on the current bar than it was on the last.\n-   We define an  `maColor`  variable that is assigned one of our two colors, depending on the value of the  `maRising`  variable. We use the  [ternary operator](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator)  to define our conditional expression.\n\nYou can also use conditional colors to avoid plotting under certain conditions. Here, we plot high and low pivots using a line, but we do not want to plot anything when a new pivot comes in, to avoid the joints that would otherwise appear in pivot transitions. To do so, we test for pivot changes and use  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  as the color value when a change is detected, so that no line is plotted on that bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-2.erY98c4P_Z1OwyIO.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Conditional colors\",  \"\",  true)  \nint  legsInput  =  input.int(5,  \"Pivot Legs\",  minval  =  1)  \ncolor  pHiColorInput  =  input.color(color.olive,  \"High pivots\")  \ncolor  pLoColorInput  =  input.color(color.orange,  \"Low pivots\")  \n// Intialize the pivot level variables.  \nvar  float  pHi  =  na  \nvar  float  pLo  =  na  \n// When a new pivot is detected, save its value.  \npHi  :=  nz(ta.pivothigh(legsInput,  legsInput),  pHi)  \npLo  :=  nz(ta.pivotlow( legsInput,  legsInput),  pLo)  \n// When a new pivot is detected, do not plot a color.  \nplot(pHi,  \"High\",  ta.change(pHi) !=  0  ?  na  :  pHiColorInput,  2,  plot.style_line)  \nplot(pLo,  \"Low\",  ta.change(pLo) !=  0  ?  na  :  pLoColorInput,  2,  plot.style_line)  \n`\n\nTo undertand how this code works, one must first know that  [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivothigh)  and  [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivotlow), used as they are here without an argument to the  `source`  parameter, will return a value when they find a  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)/[low](https://www.tradingview.com/pine-script-reference/v6/#var_low)  pivot, otherwise they return  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n\nWhen we test the value returned by the pivot function for  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  using the  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz)  function, we allow the value returned to be assigned to the  `pHi`  or  `pLo`  variables only when it is not  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), otherwise the previous value of the variable is simply reassigned to it, which has no impact on its value. Keep in mind that previous values of  `pHi`  and  `pLo`  are preserved bar to bar because we use the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword when initializing them, which causes the initialization to only occur on the first bar.\n\nAll that‚Äôs left to do next is, when we plot our lines, to insert a ternary conditional statement that will yield  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  for the color when the pivot value changes, or the color selected in the script‚Äôs inputs when the pivot level does not change.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "color.green",
      "color.maroon",
      "ta.sma",
      "ta.rising",
      "color.olive",
      "color.orange",
      "ta.pivothigh",
      "ta.pivotlow",
      "ta.change",
      "plot.style_line",
      "fun_ta.pivothigh",
      "fun_ta.pivotlow",
      "indicator",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-271",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)",
    "content": "## [Calculated  colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)\n\nUsing functions like  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new),  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  and  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient), one can build colors on the fly, as the script executes bar to bar.\n\n[color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  is most useful when you need to generate different transparency levels from a base color.\n\n[color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  is useful when you need to build colors dynamically from red, green, blue, or tranparency components. While  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  creates a color, its sister functions  [color.r()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.r),  [color.g()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.g),  [color.b()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.b)  and  [color.t()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.t)  can be used to extract the red, green, blue or transparency values from a color, which can in turn be used to generate a variant.\n\n[color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  is useful to create linear gradients between two base colors. It determines which intermediary color to use by evaluating a source value against minimum and maximum values.",
    "keywords": [
      "www.tradingview",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "color.r",
      "fun_color.r",
      "color.g",
      "fun_color.g",
      "color.b",
      "fun_color.b",
      "color.t",
      "fun_color.t",
      "var",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-272",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)",
    "content": "### [color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)\n\nLet‚Äôs put  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  to use to create different transparencies for volume columns using one of two bull/bear base colors:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-1.BtEyXAO2_Z2dfpcb.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Volume\")  \n// We name our color constants to make them more readable.  \nvar  color  GOLD_COLOR  =  #CCCC00ff  \nvar  color  VIOLET_COLOR  =  #AA00FFff  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\")  \nint  levelsInput  =  input.int(10,  \"Gradient levels\",  minval  =  1)  \n// We initialize only once on bar zero with `var`, otherwise the count would reset to zero on each bar.  \nvar  float  riseFallCnt  =  0  \n// Count the rises/falls, clamping the range to: 1 to `i_levels`.  \nriseFallCnt  :=  math.max(1,  math.min(levelsInput,  riseFallCnt  +  math.sign(volume  -  nz(volume[1]))))  \n// Rescale the count on a scale of 80, reverse it and cap transparency to <80 so that colors remains visible.  \nfloat  transparency  =  80  -  math.abs(80  *  riseFallCnt  /  levelsInput)  \n// Build the correct transparency of either the bull or bear color.  \ncolor  volumeColor  =  color.new(close  >  open  ?  bullColorInput  :  bearColorInput,  transparency)  \nplot(volume,  \"Volume\",  volumeColor,  1,  plot.style_columns)  \n``\n\nNote that:\n\n-   In the next to last line of our script, we dynamically calculate the column color by varying both the base color used, depending on whether the bar is up or down,  **and**  the transparency level, which is calculated from the cumulative rises or falls of volume.\n-   We offer the script user control over not only the base bull/bear colors used, but also on the number of brightness levels we use. We use this value to determine the maximum number of rises or falls we will track. Giving users the possiblity to manage this value allows them to adapt the indicator‚Äôs visuals to the timeframe or market they use.\n-   We take care to control the maximum level of transparency we use so that it never goes higher than 80. This ensures our colors always retain some visibility.\n-   We also set the minimum value for the number of levels to 1 in the inputs. When the user selects 1, the volume columns will be either in bull or bear color of maximum brightness ‚Äî or transparency zero.",
    "keywords": [
      "color.new",
      "www.tradingview",
      "fun_color.new",
      "tradingview.com",
      "input.color",
      "input.int",
      "math.max",
      "math.min",
      "math.sign",
      "math.abs",
      "plot.style_columns",
      "indicator",
      "input",
      "plot",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-273",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)",
    "content": "### [color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)\n\nIn our next example we use  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  to build colors from RGBA values. We use the result in a holiday season gift for our friends, so they can bring their TradingView charts to parties:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-2.B7PJa61g_ZI19Ev.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Holiday candles\",  \"\",  true)  \nfloat  r  =  math.random(0,  255)  \nfloat  g  =  math.random(0,  255)  \nfloat  b  =  math.random(0,  255)  \nfloat  t  =  math.random(0,  100)  \ncolor  holidayColor  =  color.rgb(r,  g,  b,  t)  \nplotcandle(open,  high,  low,  close,  color  =  holidayColor,  wickcolor  =  holidayColor,  bordercolor  =  holidayColor)  \n`\n\nNote that:\n\n-   We generate values in the zero to 255 range for the red, green and blue channels, and in the zero to 100 range for transparency. Also note that because  [math.random()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random)  returns float values, the float 0.0-100.0 range provides access to the full 0-255 transparency values of the underlying alpha channel.\n-   We use the  [math.random(min, max, seed)](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random)  function to generate pseudo-random values. We do not use an argument for the third parameter of the function:  `seed`. Using it is handy when you want to ensure the repeatability of the function‚Äôs results. Called with the same seed, it will produce the same sequence of values.",
    "keywords": [
      "color.rgb",
      "www.tradingview",
      "fun_color.rgb",
      "tradingview.com",
      "math.random",
      "fun_math.random",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-274",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Mixing  transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)",
    "content": "### [color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)\n\nOur last examples of color calculations will use  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Let‚Äôs first use it in its simplest form, to color a CCI signal in a version of the indicator that otherwise looks like the built-in:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-3.BWe7BFsC_Zg2kjC.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(title=\"CCI line gradient\",  precision=2,  timeframe=\"\")  \nvar  color  GOLD_COLOR  =  #CCCC00  \nvar  color  VIOLET_COLOR  =  #AA00FF  \nvar  color  BEIGE_COLOR  =  #9C6E1B  \nfloat  srcInput  =  input.source(close,  title=\"Source\")  \nint  lenInput  =  input.int(20,  \"Length\",  minval  =  5)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(BEIGE_COLOR,  \"Bear\")  \nfloat  signal  =  ta.cci(srcInput,  lenInput)  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  bearColorInput,  bullColorInput)  \nplot(signal,  \"CCI\",  signalColor)  \nbandTopPlotID  =  hline(100,  \"Upper Band\",  color.silver,  hline.style_dashed)  \nbandBotPlotID  =  hline(-100,  \"Lower Band\",  color.silver,  hline.style_dashed)  \nfill(bandTopPlotID,  bandBotPlotID,  color.new(BEIGE_COLOR,  90),  \"Background\")  \n`\n\nNote that:\n\n-   To calculate the gradient,  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  requires minimum and maximum values against which the argument used for the  `value`  parameter will be compared. The fact that we want a gradient for an unbounded signal like CCI (i.e., without fixed boundaries such as RSI, which always oscillates between 0-100), does not entail we cannot use  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Here, we solve our conundrum by providing values of -200 and 200 as arguments. They do not represent the real minimum and maximum values for CCI, but they are at levels from which we do not mind the colors no longer changing, as whenever the series is outside the  `bottom_value`  and  `top_value`  limits, the colors used for  `bottom_color`  and  `top_color`  will apply.\n-   The color progression calculated by  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  is linear. If the value of the series is halfway between the  `bottom_value`  and  `top_value`  arguments, the generated color‚Äôs RGBA components will also be halfway between those of  `bottom_color`  and  `top_color`.\n-   Many common indicator calculations are available in Pine Script as built-in functions. Here we use  [ta.cci()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.cci)  instead of calculating it the long way.\n\nThe argument used for  `value`  in  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  does not necessarily have to be the value of the line we are calculating. Anything we want can be used, as long as arguments for  `bottom_value`  and  `top_value`  can be supplied. Here, we enhance our CCI indicator by coloring the band using the number of bars since the signal has been above/below the centerline:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-4.-U0l6lwc_Zd5X5K.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(title=\"CCI line gradient\",  precision=2,  timeframe=\"\")  \nvar  color  GOLD_COLOR  =  #CCCC00  \nvar  color  VIOLET_COLOR  =  #AA00FF  \nvar  color  GREEN_BG_COLOR  =  color.new(color.green,  70)  \nvar  color  RED_BG_COLOR  =  color.new(color.maroon,  70)  \nfloat  srcInput  =  input.source(close,  \"Source\")  \nint  lenInput  =  input.int(20,  \"Length\",  minval  =  5)  \nint  stepsInput  =  input.int(50,  \"Gradient levels\",  minval  =  1)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Line: Bull\",  inline  =  \"11\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\",  inline  =  \"11\")  \ncolor  bullBgColorInput  =  input.color(GREEN_BG_COLOR,  \"Background: Bull\",  inline  =  \"12\")  \ncolor  bearBgColorInput  =  input.color(RED_BG_COLOR,  \"Bear\",  inline  =  \"12\")  \n  \n// Plot colored signal line.  \nfloat  signal  =  ta.cci(srcInput,  lenInput)  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  color.new(bearColorInput,  0),  color.new(bullColorInput,  0))  \nplot(signal,  \"CCI\",  signalColor,  2)  \n  \n// Detect crosses of the centerline.  \nbool  signalX  =  ta.cross(signal,  0)  \n// Count no of bars since cross. Capping it to the no of steps from inputs.  \nint  gradientStep  =  math.min(stepsInput,  nz(ta.barssince(signalX)))  \n// Choose bull/bear end color for the gradient.  \ncolor  endColor  =  signal  >  0  ?  bullBgColorInput  :  bearBgColorInput  \n// Get color from gradient going from no color to `endColor`  \ncolor  bandColor  =  color.from_gradient(gradientStep,  0,  stepsInput,  na,  endColor)  \nbandTopPlotID  =  hline(100,  \"Upper Band\",  color.silver,  hline.style_dashed)  \nbandBotPlotID  =  hline(-100,  \"Lower Band\",  color.silver,  hline.style_dashed)  \nfill(bandTopPlotID,  bandBotPlotID,  bandColor,  title  =  \"Band\")  \n``\n\nNote that:\n\n-   The signal plot uses the same base colors and gradient as in our previous example. We have however increased the width of the line from the default 1 to 2. It is the most important component of our visuals; increasing its width is a way to give it more prominence, and ensure users are not distracted by the band, which has become busier than it was in its original, flat beige color.\n-   The fill must remain unobtrusive for two reasons. First, it is of secondary importance to the visuals, as it provides complementary information, i.e., the duration for which the signal has been in bull/bear territory. Second, since fills have a greater z-index than plots, the fill will cover the signal plot. For these reasons, we make the fill‚Äôs base colors fairly transparent, at 70, so they do not mask the plots. The gradient used for the band starts with no color at all (see the  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  used as the argument to  `bottom_color`  in the  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  call), and goes to the base bull/bear colors from the inputs, which the conditional  `endColor`  variable contains.\n-   We provide users with distinct bull/bear color selections for the line and the band.\n-   When we calculate the  `gradientStep`  variable, we use  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz)  on  [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince)  because in early bars of the dataset, when the condition tested has not occurred yet,  [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince)  will return  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Because we use  [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz), the value returned is replaced with zero in those cases.",
    "keywords": [
      "color.from_gradient",
      "www.tradingview",
      "fun_color.from_gradient",
      "tradingview.com",
      "input.source",
      "input.int",
      "input.color",
      "ta.cci",
      "color.silver",
      "hline.style_dashed",
      "color.new",
      "i.e",
      "fun_ta.cci",
      "color.green",
      "color.maroon",
      "ta.cross",
      "math.min",
      "ta.barssince",
      "fun_ta.barssince",
      "indicator",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-275",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "content": "## [Mixing  transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)\n\nIn this example we take our CCI indicator in another direction. We will build dynamically adjusting extremes zone buffers using a Donchian Channel (historical highs/lows) calculated from the CCI. We build the top/bottom bands by making them 1/4 the height of the DC. We will use a dynamically adjusting lookback to calculate the DC. To modulate the lookback, we will calculate a simple measure of volatility by keeping a ratio of a short-period ATR to a long one. When that ratio is higher than 50 of its last 100 values, we consider the volatility high. When the volatility is high/low, we decrease/increase the lookback.\n\nOur aim is to provide users of our indicator with:\n\n-   The CCI line colored using a bull/bear gradient, as we illustrated in our most recent examples.\n-   The top and bottom bands of the Donchian Channel, filled in such a way that their color darkens as a historical high/low becomes older and older.\n-   A way to appreciate the state of our volatility measure, which we will do by painting the background with one color whose intensity increases when volatility increases.\n\nThis is what our indicator looks like using the light theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-1.DJ-yTBxm_1VcSbJ.webp)\n\nAnd with the dark theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-2.BJOvmETq_Z1CqQBv.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"CCI DC\",  precision  =  6)  \ncolor  GOLD_COLOR  =  #CCCC00ff  \ncolor  VIOLET_COLOR  =  #AA00FFff  \nint  lengthInput  =  input.int(20,  \"Length\",  minval  =  5)  \ncolor  bullColorInput  =  input.color(GOLD_COLOR,  \"Bull\")  \ncolor  bearColorInput  =  input.color(VIOLET_COLOR,  \"Bear\")  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function clamps `val` between `min` and `max`.  \nclamp(val,  min,  max) =>  \nmath.max(min,  math.min(max,  val))  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Volatility expressed as 0-100 value.  \nfloat  v  =  ta.atr(lengthInput  /  5) /  ta.atr(lengthInput  *  5)  \nfloat  vPct  =  ta.percentrank(v,  lengthInput  *  5)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Calculate dynamic lookback for DC. It increases/decreases on low/high volatility.  \nbool  highVolatility  =  vPct  >  50  \nvar  int  lookBackMin  =  lengthInput  *  2  \nvar  int  lookBackMax  =  lengthInput  *  10  \nvar  float  lookBack  =  math.avg(lookBackMin,  lookBackMax)  \nlookBack  +=  highVolatility  ?  -2  :  2  \nlookBack  :=  clamp(lookBack,  lookBackMin,  lookBackMax)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Dynamic lookback length Donchian channel of signal.  \nfloat  signal  =  ta.cci(close,  lengthInput)  \n// `lookBack` is a float; need to cast it to int to be used a length.  \nfloat  hiTop  =  ta.highest(signal,  int(lookBack))  \nfloat  loBot  =  ta.lowest( signal,  int(lookBack))  \n// Get margin of 25% of the DC height to build high and low bands.  \nfloat  margin  = (hiTop  -  loBot) /  4  \nfloat  hiBot  =  hiTop  -  margin  \nfloat  loTop  =  loBot  +  margin  \n// Center of DC.  \nfloat  center  =  math.avg(hiTop,  loBot)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Create colors.  \ncolor  signalColor  =  color.from_gradient(signal,  -200,  200,  bearColorInput,  bullColorInput)  \n// Bands: Calculate transparencies so the longer since the hi/lo has changed,  \n// the darker the color becomes. Cap highest transparency to 90.  \nfloat  hiTransp  =  clamp(100  - (100  *  math.max(1,  nz(ta.barssince(ta.change(hiTop) !=  0) +  1)) /  255),  60,  90)  \nfloat  loTransp  =  clamp(100  - (100  *  math.max(1,  nz(ta.barssince(ta.change(loBot) !=  0) +  1)) /  255),  60,  90)  \ncolor  hiColor  =  color.new(bullColorInput,  hiTransp)  \ncolor  loColor  =  color.new(bearColorInput,  loTransp)  \n// Background: Rescale the 0-100 range of `vPct` to 0-25 to create 75-100 transparencies.  \ncolor  bgColor  =  color.new(color.gray,  100  - (vPct  /  4))  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Plots  \n// Invisible lines for band fills.  \nhiTopPlotID  =  plot(hiTop,  color  =  na)  \nhiBotPlotID  =  plot(hiBot,  color  =  na)  \nloTopPlotID  =  plot(loTop,  color  =  na)  \nloBotPlotID  =  plot(loBot,  color  =  na)  \n// Plot signal and centerline.  \np_signal  =  plot(signal,  \"CCI\",  signalColor,  2)  \nplot(center,  \"Centerline\",  color.silver,  1)  \n  \n// Fill the bands.  \nfill(hiTopPlotID,  hiBotPlotID,  hiColor)  \nfill(loTopPlotID,  loBotPlotID,  loColor)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Background.  \nbgcolor(bgColor)  \n``\n\nNote that:\n\n-   We clamp the transparency of the background to a 100-75 range so that it doesn‚Äôt overwhelm. We also use a neutral color that will not distract too much. The darker the background is, the higher our measure of volatility.\n-   We also clamp the transparency values for the band fills between 60 and 90. We use 90 so that when a new high/low is found and the gradient resets, the starting transparency makes the color somewhat visible. We do not use a transparency lower than 60 because we don‚Äôt want those bands to hide the signal line.\n-   We use the very handy  [ta.percentrank()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.percentrank)  function to generate a 0-100 value from our ATR ratio measuring volatility. It is useful to convert values whose scale is unknown into known values that can be used to produce transparencies.\n-   Because we must clamp values three times in our script, we wrote an  `f_clamp()`  function, instead of explicitly coding the logic three times.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "math.max",
      "math.min",
      "ta.atr",
      "ta.percentrank",
      "math.avg",
      "ta.cci",
      "ta.highest",
      "ta.lowest",
      "color.from_gradient",
      "ta.barssince",
      "ta.change",
      "color.new",
      "color.gray",
      "color.silver",
      "fun_ta.percentrank",
      "indicator",
      "input",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "simple",
      "for"
    ]
  },
  {
    "id": "doc-276",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Maintaining automatic color  selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)",
    "content": "## [Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "keywords": [
      "www.tradingview"
    ]
  },
  {
    "id": "doc-277",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Designing usable colors  schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)",
    "content": "### [Maintaining automatic color  selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)\n\nUnder certain conditions, Pine Script can automatically display all of the colors used in a script‚Äôs plots in the ‚ÄúSettings/Style‚Äù menu. These plots are graphics created by all  `plot*()`  functions,  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor). The user can change the colors using a color picker. This feature allows colors in scripts to be customized without any extra code.\n\nFor example, this simple script has a  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  that is colored either teal or red, depending on the relationship between the bar‚Äôs  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  and  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open). The script does not specify that these colors should be editable, nor does it create any color-related inputs. Nevertheless, Pine Script automatically displays the colors in the ‚ÄúSettings/Style‚Äù menu and allows the user to change them, along with the style of the plot:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-1.BHISUteP_LNVpG.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  close  >  open  ?  color.teal  :  color.red  \nplot(close,  color  =  plotColor)  \n`\n\nTipTo prevent the user from changing the color or the type of a plot from a script‚Äôs ‚ÄúSettings/Style‚Äù tab, include  `editable = false`  in the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call.\n\nThe colors in the above script can be automatically displayed in this way because they are  _not dynamically calculated_  and are known as soon as the script has finished compiling. All colors of the  [‚Äúconst‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#const)  type, and all colors of type  [‚Äúinput‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#input)  that are  _not modified_  via the  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  or  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions can be automatically displayed like this.\n\nNoteIf  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  and  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions use a ‚Äúconst color‚Äù and other ‚Äúconst‚Äù parameters, color modifications are calculated during the script‚Äôs compilation, not at its runtime. As a result, they are available when the script finishes compiling and can be displayed in the ‚ÄúSettings/Style‚Äù tab.\n\nHowever, if  _even a single calculated color_  is of type ‚Äúsimple color‚Äù or ‚Äúseries color‚Äù, or if an ‚Äúinput color‚Äù is passed to  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  or  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb),  _all_  colors are calculated in the script‚Äôs runtime, and no color pickers are available in the ‚ÄúStyle‚Äù section.\n\nIn practice, the creation of  [‚Äúsimple‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#simple)  or  [‚Äúseries‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#series)  colors is also most often due to using  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  and  [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb)  functions. The qualifier of the color that these functions return is the strongest qualifier of the values passed to them. If each call to these functions passes only ‚Äúconst‚Äù values, the resulting colors are also ‚Äúconst‚Äù, and the script  _does_  display them in the ‚ÄúStyle‚Äù menu.\n\nNoticeThe  [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient)  function always returns a ‚Äúseries color‚Äù value, regardless of the parameters passed to it. If it‚Äôs used in a script, all of the script‚Äôs colors are calculated at runtime.\n\nFor example, let‚Äôs try to make the plots in the script above semi-transparent by adding a transparency of  `50`  to its colors via  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new). The easiest way to do this is to wrap the  `plotColor`  variable with  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new), like in the example below:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  color.new(close  >  open  ?  color.teal  :  color.red,  50)  \nplot(close,  color  =  plotColor)  \n`\n\nUnfortunately, with these changes the ‚ÄúStyle‚Äù tab does not display a color picker any longer. This is because we use the ‚Äúseries bool‚Äù condition  `close > open`  to decide the color, and then pass the result of this expression to a single  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  call. The qualified type of the calculated color that it returns is ‚Äúseries color‚Äù.\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-2.BO3w97fq_14utEv.webp)\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-3.B0TUMw_p_Z2hnihX.webp)\n\nTo avoid this, we can ensure that every calculated color created by  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  is a ‚Äúconst color‚Äù. Below, we wrap  [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal)  and  [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color.red)  separately with  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  ‚Äî creating two constant calculated colors in the process ‚Äî and then decide which one to assign to  `plotColor`  based on the condition. And while the  `plotColor`  variable is a ‚Äúseries color‚Äù, each  [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new)  call returns a constant color, so the script displays a color picker in the ‚ÄúStyle‚Äù tab:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Color picker showcase\")  \nplotColor  =  close  >  open  ?  color.new(color.teal,  50) :  color.new(color.red,  50)  \nplot(close,  color  =  plotColor)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-4.B7QSrDzd_18UfnH.webp)\n\nTo calculate the colors at runtime, create custom color inputs for all of the colors that are to be editable. This approach requires more effort, but allows significantly more control over what the user can affect. Learn more about creating color inputs on the  [Inputs page](https://www.tradingview.com/pine-script-docs/concepts/inputs/#color-input).",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.teal",
      "color.red",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "const_color.teal",
      "const_color.red",
      "indicator",
      "input",
      "plot",
      "bgcolor",
      "barcolor",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-278",
    "type": "documentation",
    "source": "visuals/colors.md",
    "section": "visuals",
    "title": "[Customize  gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)",
    "content": "### [Designing usable colors  schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)\n\nIf you write scripts intended for other traders, try to avoid colors that will not work well in some environments, whether it be for plots, labels, tables or fills. At a minimum, test your visuals to ensure they perform satisfactorily with both the light and dark TradingView themes; they are the most commonly used. Colors such as black and white, for example, should be avoided.\n\nBuild the appropriate inputs to provide script users the flexibility to adapt your script‚Äôs visuals to their particular environments.\n\nTake care to build a visual hierarchy of the colors you use that matches the relative importance of your script‚Äôs visual components. Good designers understand how to achieve the optimal balance of color and weight so the eye is naturally drawn to the most important elements of the design. When you make everything stand out, nothing does. Make room for some elements to stand out by toning down the visuals surrounding it.\n\nProviding a selection of color presets in your inputs ‚Äî rather than a single color that can be changed ‚Äî can help color-challenged users. Our  [Technical Ratings](https://www.tradingview.com/script/Jdw7wW2g-Technical-Ratings/)  demonstrates one way of achieving this.\n\n### [Plot crisp  lines](https://www.tradingview.com/pine-script-docs/visuals/colors/#plot-crisp-lines)\n\nIt is best to use zero transparency to plot the important lines in your visuals, to keep them crisp. This way, they will show through fills more precisely. Keep in mind that fills have a higher z-index than plots, so they are placed on top of them. A slight increase of a line‚Äôs width can also go a long way in making it stand out.\n\nIf you want a special plot to stand out, you can also give it more importance by using multiple plots for the same line. These are examples where we modulate the successive width and transparency of plots to achieve this:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-PlotCrispLines-1.CJkrlPd__Z1Me4S0.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\")  \nplot(high,  \"\",  color.new(color.orange,  80),  8)  \nplot(high,  \"\",  color.new(color.orange,  60),  4)  \nplot(high,  \"\",  color.new(color.orange,  00),  1)  \n  \nplot(hl2,  \"\",  color.new(color.orange,  60),  4)  \nplot(hl2,  \"\",  color.new(color.orange,  00),  1)  \n  \nplot(low,  \"\",  color.new(color.orange,  0),  1)  \n`\n\n### [Customize  gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)\n\nWhen building gradients, adapt them to the visuals they apply to. If you are using a gradient to color candles, for example, it is usually best to limit the number of steps in the gradient to ten or less, as it is more difficult for the eye to perceive intensity variations of discrete objects. As we did in our examples, cap minimum and maximum transparency levels so your visual elements remain visible and do not overwhelm when it‚Äôs not necessary.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.new",
      "color.orange",
      "indicator",
      "input",
      "plot",
      "fill",
      "var",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-279",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Constant colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)",
    "content": "# [Colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#colors)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/visuals/colors/#introduction)\n\nScript visuals can play a critical role in the usability of the indicators we write in Pine Script¬Æ. Well-designed plots and drawings make indicators easier to use and understand. Good visual designs establish a visual hierarchy that allows the more important information to stand out, and the less important one to not get in the way.\n\nUsing colors in Pine can be as simple as you want, or as involved as your concept requires. The 4,294,967,296 possible assemblies of color and transparency available in Pine Script can be applied to:\n\n-   Any element you can plot or draw in an indicator‚Äôs visual space, be it lines, fills, text or candles.\n-   The background of a script‚Äôs visual space, whether the script is running in its own pane, or in overlay mode on the chart.\n-   The color of bars or the body of candles appearing on a chart.\n\nA script can only color the elements it places in its own visual space. The only exception to this rule is that a pane indicator can color chart bars or candles.\n\nPine Script has built-in colors such as [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green), as well as functions like [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) which allow you to dynamically generate any color in the RGBA color space.\n\n### [Transparency](https://www.tradingview.com/pine-script-docs/visuals/colors/#transparency)\n\nEach color in Pine Script is defined by four values:\n\n-   Its red, green and blue components (0-255), following the [RGB color model](https://en.wikipedia.org/wiki/RGB_color_space).\n-   Its transparency (0-100), often referred to as the Alpha channel outside Pine, as defined in the [RGBA color model](https://en.wikipedia.org/wiki/RGBA_color_model). Even though transparency is expressed in the 0-100 range, its value can be a ‚Äúfloat‚Äù when used in functions, which gives you access to the 256 underlying values of the alpha channel.\n\nThe transparency of a color defines how opaque it is: zero is fully opaque, 100 makes the color ‚Äî whichever it is ‚Äî invisible. Modulating transparency can be crucial in more involved color visuals or when using backgrounds, to control which colors dominate the others, and how they mix together when superimposed.",
    "keywords": [
      "www.tradingview",
      "color.green",
      "const_color.green",
      "color.rgb",
      "fun_color.rgb",
      "en.wikipedia",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "simple",
      "const",
      "import",
      "for"
    ]
  },
  {
    "id": "doc-280",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Conditional coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)",
    "content": "## [Constant colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#constant-colors)\n\nThere are 17 built-in colors in Pine Script. This table lists their names, hexadecimal equivalent, and RGB values as arguments to [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb):\n\nName\n\nHex\n\nRGB values\n\ncolor.aqua\n\n#00BCD4\n\ncolor.rgb(0, 188, 212)\n\ncolor.black\n\n#363A45\n\ncolor.rgb(54, 58, 69)\n\ncolor.blue\n\n#2196F3\n\ncolor.rgb(33, 150, 243)\n\ncolor.fuchsia\n\n#E040FB\n\ncolor.rgb(224, 64, 251)\n\ncolor.gray\n\n#787B86\n\ncolor.rgb(120, 123, 134)\n\ncolor.green\n\n#4CAF50\n\ncolor.rgb(76, 175, 80)\n\ncolor.lime\n\n#00E676\n\ncolor.rgb(0, 230, 118)\n\ncolor.maroon\n\n#880E4F\n\ncolor.rgb(136, 14, 79)\n\ncolor.navy\n\n#311B92\n\ncolor.rgb(49, 27, 146)\n\ncolor.olive\n\n#808000\n\ncolor.rgb(128, 128, 0)\n\ncolor.orange\n\n#FF9800\n\ncolor.rgb(255, 152, 0)\n\ncolor.purple\n\n#9C27B0\n\ncolor.rgb(156, 39, 176)\n\ncolor.red\n\n#F23645\n\ncolor.rgb(242, 54, 69)\n\ncolor.silver\n\n#B2B5BE\n\ncolor.rgb(178, 181, 190)\n\ncolor.teal\n\n#089981\n\ncolor.rgb(8, 153, 129)\n\ncolor.white\n\n#FFFFFF\n\ncolor.rgb(255, 255, 255)\n\ncolor.yellow\n\n#FDD835\n\ncolor.rgb(253, 216, 53)\n\nThe following script shows three different ways to express [color.olive](https://www.tradingview.com/pine-script-reference/v6/#const_color.olive) with 40% transparency. All three methods are functionally equivalent:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-Constant-colors-1.CnlC-u-k_1ibe2x.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Constant colors demo\", overlay = true)\n\n// Create a plot using the hex color code equivalent for `color.olive` with `99` as the alpha value (60% opacity).  \nplot(ta.sma(close, 10), \"10-bar SMA\", #80800099, 3)  \n// Create a plot using `color.new()` to modify `color.olive` with 40% transparency.  \nplot(ta.sma(close, 30), \"30-bar SMA\", color.new(color.olive, 40), 3)  \n// Create a plot using `color.rgb()` with the `r`, `g`, and `b` components of `color.olive` and 40% transparency.  \nplot(ta.sma(close, 50), \"50-bar SMA\", color.rgb(128, 128, 0, 40), 3)  \n``\n\nNote that:\n\n-   An alpha value of `99` in a hexadecimal color code is equivalent to 60% opacity, meaning the resulting color is 40% transparent.\n-   Transparency does _not_ affect plot outputs in the status line, price scale, or Data Window. All these locations show the color with 0% transparency.\n\nThe colors in the previous script do not vary as the script executes bar to bar. Sometimes, however, colors need to be created as the script executes on each bar because they depend on conditions that are unknown at compile time, or when the script begins execution on bar zero. For those cases, programmers have two options:\n\n1.  Use conditional statements to select colors from a few pre-determined base colors.\n2.  Build new colors dynamically, by calculating them as the script executes bar to bar, to implement color gradients, for example.",
    "keywords": [
      "www.tradingview",
      "color.rgb",
      "fun_color.rgb",
      "color.aqua",
      "color.black",
      "color.blue",
      "color.fuchsia",
      "color.gray",
      "color.green",
      "color.lime",
      "color.maroon",
      "color.navy",
      "color.olive",
      "color.orange",
      "color.purple",
      "color.red",
      "color.silver",
      "color.teal",
      "color.white",
      "color.yellow",
      "const_color.olive",
      "tradingview.com",
      "ta.sma",
      "color.new",
      "indicator",
      "overlay",
      "plot",
      "var",
      "const",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-281",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Calculated colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)",
    "content": "## [Conditional coloring](https://www.tradingview.com/pine-script-docs/visuals/colors/#conditional-coloring)\n\nLet‚Äôs say you want to color a moving average in different colors, depending on some conditions you define. To do so, you can use a conditional statement that will select a different color for each of your states. Let‚Äôs start by coloring a moving average in a bull color when it‚Äôs rising, and in a bear color when it‚Äôs not:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-1.D1QaF3Y-_ZumNWi.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Conditional colors\", \"\", true) int lengthInput = input.int(20, \"Length\", minval = 2) color maBullColorInput = input.color(color.green, \"Bull\") color maBearColorInput = input.color(color.maroon, \"Bear\") float ma = ta.sma(close, lengthInput) // Define our states. bool maRising = ta.rising(ma, 1) // Build our color. color maColor = maRising ? maBullColorInput : maBearColorInput plot(ma, \"MA\", maColor, 2)`\n\nNote that:\n\n-   We provide users of our script a selection of colors for our bull/bear colors.\n-   We define an `maRising` boolean variable which will hold `true` when the moving average is higher on the current bar than it was on the last.\n-   We define an `maColor` variable that is assigned one of our two colors, depending on the value of the `maRising` variable. We use the [ternary operator](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator) to define our conditional expression.\n\nYou can also use conditional colors to avoid plotting under certain conditions. Here, we plot high and low pivots using a line, but we do not want to plot anything when a new pivot comes in, to avoid the joints that would otherwise appear in pivot transitions. To do so, we test for pivot changes and use [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) as the color value when a change is detected, so that no line is plotted on that bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-ConditionalColors-2.erY98c4P_Z1OwyIO.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Conditional colors\", \"\", true) int legsInput = input.int(5, \"Pivot Legs\", minval = 1) color pHiColorInput = input.color(color.olive, \"High pivots\") color pLoColorInput = input.color(color.orange, \"Low pivots\") // Intialize the pivot level variables. var float pHi = na var float pLo = na // When a new pivot is detected, save its value. pHi := nz(ta.pivothigh(legsInput, legsInput), pHi) pLo := nz(ta.pivotlow( legsInput, legsInput), pLo) // When a new pivot is detected, do not plot a color. plot(pHi, \"High\", ta.change(pHi) != 0 ? na : pHiColorInput, 2, plot.style_line) plot(pLo, \"Low\", ta.change(pLo) != 0 ? na : pLoColorInput, 2, plot.style_line)`\n\nTo undertand how this code works, one must first know that [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivothigh) and [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.pivotlow), used as they are here without an argument to the `source` parameter, will return a value when they find a [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)/[low](https://www.tradingview.com/pine-script-reference/v6/#var_low) pivot, otherwise they return [na](https://www.tradingview.com/pine-script-reference/v6/#var_na).\n\nWhen we test the value returned by the pivot function for [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) using the [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz) function, we allow the value returned to be assigned to the `pHi` or `pLo` variables only when it is not [na](https://www.tradingview.com/pine-script-reference/v6/#var_na), otherwise the previous value of the variable is simply reassigned to it, which has no impact on its value. Keep in mind that previous values of `pHi` and `pLo` are preserved bar to bar because we use the [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var) keyword when initializing them, which causes the initialization to only occur on the first bar.\n\nAll that‚Äôs left to do next is, when we plot our lines, to insert a ternary conditional statement that will yield [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) for the color when the pivot value changes, or the color selected in the script‚Äôs inputs when the pivot level does not change.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "color.green",
      "color.maroon",
      "ta.sma",
      "ta.rising",
      "color.olive",
      "color.orange",
      "ta.pivothigh",
      "ta.pivotlow",
      "ta.change",
      "plot.style_line",
      "fun_ta.pivothigh",
      "fun_ta.pivotlow",
      "indicator",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-282",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)",
    "content": "## [Calculated colors](https://www.tradingview.com/pine-script-docs/visuals/colors/#calculated-colors)\n\nUsing functions like [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new), [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) and [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient), one can build colors on the fly, as the script executes bar to bar.\n\n[color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) is most useful when you need to generate different transparency levels from a base color.\n\n[color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) is useful when you need to build colors dynamically from red, green, blue, or tranparency components. While [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) creates a color, its sister functions [color.r()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.r), [color.g()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.g), [color.b()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.b) and [color.t()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.t) can be used to extract the red, green, blue or transparency values from a color, which can in turn be used to generate a variant.\n\n[color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) is useful to create linear gradients between two base colors. It determines which intermediary color to use by evaluating a source value against minimum and maximum values.",
    "keywords": [
      "www.tradingview",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "color.r",
      "fun_color.r",
      "color.g",
      "fun_color.g",
      "color.b",
      "fun_color.b",
      "color.t",
      "fun_color.t",
      "var",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-283",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)",
    "content": "### [color.new()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colornew)\n\nLet‚Äôs put [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) to use to create different transparencies for volume columns using one of two bull/bear base colors:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-1.BtEyXAO2_Z2dfpcb.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6 indicator(\"Volume\") // We name our color constants to make them more readable. var color GOLD_COLOR = #CCCC00ff var color VIOLET_COLOR = #AA00FFff color bullColorInput = input.color(GOLD_COLOR, \"Bull\") color bearColorInput = input.color(VIOLET_COLOR, \"Bear\") int levelsInput = input.int(10, \"Gradient levels\", minval = 1) // We initialize only once on bar zero with `var`, otherwise the count would reset to zero on each bar. var float riseFallCnt = 0 // Count the rises/falls, clamping the range to: 1 to `i_levels`. riseFallCnt := math.max(1, math.min(levelsInput, riseFallCnt + math.sign(volume - nz(volume[1])))) // Rescale the count on a scale of 80, reverse it and cap transparency to <80 so that colors remains visible. float transparency = 80 - math.abs(80 * riseFallCnt / levelsInput) // Build the correct transparency of either the bull or bear color. color volumeColor = color.new(close > open ? bullColorInput : bearColorInput, transparency) plot(volume, \"Volume\", volumeColor, 1, plot.style_columns)``\n\nNote that:\n\n-   In the next to last line of our script, we dynamically calculate the column color by varying both the base color used, depending on whether the bar is up or down, **and** the transparency level, which is calculated from the cumulative rises or falls of volume.\n-   We offer the script user control over not only the base bull/bear colors used, but also on the number of brightness levels we use. We use this value to determine the maximum number of rises or falls we will track. Giving users the possiblity to manage this value allows them to adapt the indicator‚Äôs visuals to the timeframe or market they use.\n-   We take care to control the maximum level of transparency we use so that it never goes higher than 80. This ensures our colors always retain some visibility.\n-   We also set the minimum value for the number of levels to 1 in the inputs. When the user selects 1, the volume columns will be either in bull or bear color of maximum brightness ‚Äî or transparency zero.",
    "keywords": [
      "color.new",
      "www.tradingview",
      "fun_color.new",
      "tradingview.com",
      "input.color",
      "input.int",
      "math.max",
      "math.min",
      "math.sign",
      "math.abs",
      "plot.style_columns",
      "indicator",
      "input",
      "plot",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-284",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)",
    "content": "### [color.rgb()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorrgb)\n\nIn our next example we use [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) to build colors from RGBA values. We use the result in a holiday season gift for our friends, so they can bring their TradingView charts to parties:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-2.B7PJa61g_ZI19Ev.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Holiday candles\", \"\", true) float r = math.random(0, 255) float g = math.random(0, 255) float b = math.random(0, 255) float t = math.random(0, 100) color holidayColor = color.rgb(r, g, b, t) plotcandle(open, high, low, close, color = holidayColor, wickcolor = holidayColor, bordercolor = holidayColor)`\n\nNote that:\n\n-   We generate values in the zero to 255 range for the red, green and blue channels, and in the zero to 100 range for transparency. Also note that because [math.random()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random) returns float values, the float 0.0-100.0 range provides access to the full 0-255 transparency values of the underlying alpha channel.\n-   We use the [math.random(min, max, seed)](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random) function to generate pseudo-random values. We do not use an argument for the third parameter of the function: `seed`. Using it is handy when you want to ensure the repeatability of the function‚Äôs results. Called with the same seed, it will produce the same sequence of values.",
    "keywords": [
      "color.rgb",
      "www.tradingview",
      "fun_color.rgb",
      "tradingview.com",
      "math.random",
      "fun_math.random",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-285",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Mixing transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)",
    "content": "### [color.from_gradient()](https://www.tradingview.com/pine-script-docs/visuals/colors/#colorfrom_gradient)\n\nOur last examples of color calculations will use [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Let‚Äôs first use it in its simplest form, to color a CCI signal in a version of the indicator that otherwise looks like the built-in:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-3.BWe7BFsC_Zg2kjC.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(title=\"CCI line gradient\", precision=2, timeframe=\"\") var color GOLD_COLOR = #CCCC00 var color VIOLET_COLOR = #AA00FF var color BEIGE_COLOR = #9C6E1B float srcInput = input.source(close, title=\"Source\") int lenInput = input.int(20, \"Length\", minval = 5) color bullColorInput = input.color(GOLD_COLOR, \"Bull\") color bearColorInput = input.color(BEIGE_COLOR, \"Bear\") float signal = ta.cci(srcInput, lenInput) color signalColor = color.from_gradient(signal, -200, 200, bearColorInput, bullColorInput) plot(signal, \"CCI\", signalColor) bandTopPlotID = hline(100, \"Upper Band\", color.silver, hline.style_dashed) bandBotPlotID = hline(-100, \"Lower Band\", color.silver, hline.style_dashed) fill(bandTopPlotID, bandBotPlotID, color.new(BEIGE_COLOR, 90), \"Background\")`\n\nNote that:\n\n-   To calculate the gradient, [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) requires minimum and maximum values against which the argument used for the `value` parameter will be compared. The fact that we want a gradient for an unbounded signal like CCI (i.e., without fixed boundaries such as RSI, which always oscillates between 0-100), does not entail we cannot use [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient). Here, we solve our conundrum by providing values of -200 and 200 as arguments. They do not represent the real minimum and maximum values for CCI, but they are at levels from which we do not mind the colors no longer changing, as whenever the series is outside the `bottom_value` and `top_value` limits, the colors used for `bottom_color` and `top_color` will apply.\n-   The color progression calculated by [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) is linear. If the value of the series is halfway between the `bottom_value` and `top_value` arguments, the generated color‚Äôs RGBA components will also be halfway between those of `bottom_color` and `top_color`.\n-   Many common indicator calculations are available in Pine Script as built-in functions. Here we use [ta.cci()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.cci) instead of calculating it the long way.\n\nThe argument used for `value` in [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) does not necessarily have to be the value of the line we are calculating. Anything we want can be used, as long as arguments for `bottom_value` and `top_value` can be supplied. Here, we enhance our CCI indicator by coloring the band using the number of bars since the signal has been above/below the centerline:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-CalculatingColors-4.-U0l6lwc_Zd5X5K.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(title=\"CCI line gradient\", precision=2, timeframe=\"\")  \nvar color GOLD_COLOR = #CCCC00  \nvar color VIOLET_COLOR = #AA00FF  \nvar color GREEN_BG_COLOR = color.new(color.green, 70)  \nvar color RED_BG_COLOR = color.new(color.maroon, 70)  \nfloat srcInput = input.source(close, \"Source\")  \nint lenInput = input.int(20, \"Length\", minval = 5)  \nint stepsInput = input.int(50, \"Gradient levels\", minval = 1)  \ncolor bullColorInput = input.color(GOLD_COLOR, \"Line: Bull\", inline = \"11\")  \ncolor bearColorInput = input.color(VIOLET_COLOR, \"Bear\", inline = \"11\")  \ncolor bullBgColorInput = input.color(GREEN_BG_COLOR, \"Background: Bull\", inline = \"12\")  \ncolor bearBgColorInput = input.color(RED_BG_COLOR, \"Bear\", inline = \"12\")\n\n// Plot colored signal line.  \nfloat signal = ta.cci(srcInput, lenInput)  \ncolor signalColor = color.from_gradient(signal, -200, 200, color.new(bearColorInput, 0), color.new(bullColorInput, 0))  \nplot(signal, \"CCI\", signalColor, 2)\n\n// Detect crosses of the centerline.  \nbool signalX = ta.cross(signal, 0)  \n// Count no of bars since cross. Capping it to the no of steps from inputs.  \nint gradientStep = math.min(stepsInput, nz(ta.barssince(signalX)))  \n// Choose bull/bear end color for the gradient.  \ncolor endColor = signal > 0 ? bullBgColorInput : bearBgColorInput  \n// Get color from gradient going from no color to `endColor`  \ncolor bandColor = color.from_gradient(gradientStep, 0, stepsInput, na, endColor)  \nbandTopPlotID = hline(100, \"Upper Band\", color.silver, hline.style_dashed)  \nbandBotPlotID = hline(-100, \"Lower Band\", color.silver, hline.style_dashed)  \nfill(bandTopPlotID, bandBotPlotID, bandColor, title = \"Band\")  \n``\n\nNote that:\n\n-   The signal plot uses the same base colors and gradient as in our previous example. We have however increased the width of the line from the default 1 to 2. It is the most important component of our visuals; increasing its width is a way to give it more prominence, and ensure users are not distracted by the band, which has become busier than it was in its original, flat beige color.\n-   The fill must remain unobtrusive for two reasons. First, it is of secondary importance to the visuals, as it provides complementary information, i.e., the duration for which the signal has been in bull/bear territory. Second, since fills have a greater z-index than plots, the fill will cover the signal plot. For these reasons, we make the fill‚Äôs base colors fairly transparent, at 70, so they do not mask the plots. The gradient used for the band starts with no color at all (see the [na](https://www.tradingview.com/pine-script-reference/v6/#var_na) used as the argument to `bottom_color` in the [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) call), and goes to the base bull/bear colors from the inputs, which the conditional `endColor` variable contains.\n-   We provide users with distinct bull/bear color selections for the line and the band.\n-   When we calculate the `gradientStep` variable, we use [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz) on [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince) because in early bars of the dataset, when the condition tested has not occurred yet, [ta.barssince()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.barssince) will return [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Because we use [nz()](https://www.tradingview.com/pine-script-reference/v6/#fun_nz), the value returned is replaced with zero in those cases.",
    "keywords": [
      "color.from_gradient",
      "www.tradingview",
      "fun_color.from_gradient",
      "tradingview.com",
      "input.source",
      "input.int",
      "input.color",
      "ta.cci",
      "color.silver",
      "hline.style_dashed",
      "color.new",
      "i.e",
      "fun_ta.cci",
      "color.green",
      "color.maroon",
      "ta.cross",
      "math.min",
      "ta.barssince",
      "fun_ta.barssince",
      "indicator",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-286",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "content": "## [Mixing transparencies](https://www.tradingview.com/pine-script-docs/visuals/colors/#mixing-transparencies)\n\nIn this example we take our CCI indicator in another direction. We will build dynamically adjusting extremes zone buffers using a Donchian Channel (historical highs/lows) calculated from the CCI. We build the top/bottom bands by making them 1/4 the height of the DC. We will use a dynamically adjusting lookback to calculate the DC. To modulate the lookback, we will calculate a simple measure of volatility by keeping a ratio of a short-period ATR to a long one. When that ratio is higher than 50 of its last 100 values, we consider the volatility high. When the volatility is high/low, we decrease/increase the lookback.\n\nOur aim is to provide users of our indicator with:\n\n-   The CCI line colored using a bull/bear gradient, as we illustrated in our most recent examples.\n-   The top and bottom bands of the Donchian Channel, filled in such a way that their color darkens as a historical high/low becomes older and older.\n-   A way to appreciate the state of our volatility measure, which we will do by painting the background with one color whose intensity increases when volatility increases.\n\nThis is what our indicator looks like using the light theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-1.DJ-yTBxm_1VcSbJ.webp)\n\nAnd with the dark theme:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MixingTransparencies-2.BJOvmETq_Z1CqQBv.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"CCI DC\", precision = 6)  \ncolor GOLD_COLOR = #CCCC00ff  \ncolor VIOLET_COLOR = #AA00FFff  \nint lengthInput = input.int(20, \"Length\", minval = 5)  \ncolor bullColorInput = input.color(GOLD_COLOR, \"Bull\")  \ncolor bearColorInput = input.color(VIOLET_COLOR, \"Bear\")\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function clamps `val` between `min` and `max`.  \nclamp(val, min, max) =>  \nmath.max(min, math.min(max, val))\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Volatility expressed as 0-100 value.  \nfloat v = ta.atr(lengthInput / 5) / ta.atr(lengthInput * 5)  \nfloat vPct = ta.percentrank(v, lengthInput * 5)\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Calculate dynamic lookback for DC. It increases/decreases on low/high volatility.  \nbool highVolatility = vPct > 50  \nvar int lookBackMin = lengthInput * 2  \nvar int lookBackMax = lengthInput * 10  \nvar float lookBack = math.avg(lookBackMin, lookBackMax)  \nlookBack += highVolatility ? -2 : 2  \nlookBack := clamp(lookBack, lookBackMin, lookBackMax)\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Dynamic lookback length Donchian channel of signal.  \nfloat signal = ta.cci(close, lengthInput)  \n// `lookBack` is a float; need to cast it to int to be used a length.  \nfloat hiTop = ta.highest(signal, int(lookBack))  \nfloat loBot = ta.lowest( signal, int(lookBack))  \n// Get margin of 25% of the DC height to build high and low bands.  \nfloat margin = (hiTop - loBot) / 4  \nfloat hiBot = hiTop - margin  \nfloat loTop = loBot + margin  \n// Center of DC.  \nfloat center = math.avg(hiTop, loBot)\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Create colors.  \ncolor signalColor = color.from_gradient(signal, -200, 200, bearColorInput, bullColorInput)  \n// Bands: Calculate transparencies so the longer since the hi/lo has changed,  \n// the darker the color becomes. Cap highest transparency to 90.  \nfloat hiTransp = clamp(100 - (100 * math.max(1, nz(ta.barssince(ta.change(hiTop) != 0) + 1)) / 255), 60, 90)  \nfloat loTransp = clamp(100 - (100 * math.max(1, nz(ta.barssince(ta.change(loBot) != 0) + 1)) / 255), 60, 90)  \ncolor hiColor = color.new(bullColorInput, hiTransp)  \ncolor loColor = color.new(bearColorInput, loTransp)  \n// Background: Rescale the 0-100 range of `vPct` to 0-25 to create 75-100 transparencies.  \ncolor bgColor = color.new(color.gray, 100 - (vPct / 4))\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Plots  \n// Invisible lines for band fills.  \nhiTopPlotID = plot(hiTop, color = na)  \nhiBotPlotID = plot(hiBot, color = na)  \nloTopPlotID = plot(loTop, color = na)  \nloBotPlotID = plot(loBot, color = na)  \n// Plot signal and centerline.  \np_signal = plot(signal, \"CCI\", signalColor, 2)  \nplot(center, \"Centerline\", color.silver, 1)\n\n// Fill the bands.  \nfill(hiTopPlotID, hiBotPlotID, hiColor)  \nfill(loTopPlotID, loBotPlotID, loColor)\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Background.  \nbgcolor(bgColor)  \n``\n\nNote that:\n\n-   We clamp the transparency of the background to a 100-75 range so that it doesn‚Äôt overwhelm. We also use a neutral color that will not distract too much. The darker the background is, the higher our measure of volatility.\n-   We also clamp the transparency values for the band fills between 60 and 90. We use 90 so that when a new high/low is found and the gradient resets, the starting transparency makes the color somewhat visible. We do not use a transparency lower than 60 because we don‚Äôt want those bands to hide the signal line.\n-   We use the very handy [ta.percentrank()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.percentrank) function to generate a 0-100 value from our ATR ratio measuring volatility. It is useful to convert values whose scale is unknown into known values that can be used to produce transparencies.\n-   Because we must clamp values three times in our script, we wrote an `f_clamp()` function, instead of explicitly coding the logic three times.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.color",
      "math.max",
      "math.min",
      "ta.atr",
      "ta.percentrank",
      "math.avg",
      "ta.cci",
      "ta.highest",
      "ta.lowest",
      "color.from_gradient",
      "ta.barssince",
      "ta.change",
      "color.new",
      "color.gray",
      "color.silver",
      "fun_ta.percentrank",
      "indicator",
      "input",
      "plot",
      "fill",
      "bgcolor",
      "var",
      "simple",
      "for"
    ]
  },
  {
    "id": "doc-287",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Maintaining automatic color selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)",
    "content": "## [Tips](https://www.tradingview.com/pine-script-docs/visuals/colors/#tips)",
    "keywords": [
      "www.tradingview"
    ]
  },
  {
    "id": "doc-288",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Designing usable colors schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)",
    "content": "### [Maintaining automatic color selectors](https://www.tradingview.com/pine-script-docs/visuals/colors/#maintaining-automatic-color-selectors)\n\nUnder certain conditions, Pine Script can automatically display all of the colors used in a script‚Äôs plots in the ‚ÄúSettings/Style‚Äù menu. These plots are graphics created by all `plot*()` functions, [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), and [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor). The user can change the colors using a color picker. This feature allows colors in scripts to be customized without any extra code.\n\nFor example, this simple script has a [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) that is colored either teal or red, depending on the relationship between the bar‚Äôs [close](https://www.tradingview.com/pine-script-reference/v6/#var_close) and [open](https://www.tradingview.com/pine-script-reference/v6/#var_open). The script does not specify that these colors should be editable, nor does it create any color-related inputs. Nevertheless, Pine Script automatically displays the colors in the ‚ÄúSettings/Style‚Äù menu and allows the user to change them, along with the style of the plot:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-1.BHISUteP_LNVpG.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Color picker showcase\") plotColor = close > open ? color.teal : color.red plot(close, color = plotColor)`\n\nTipTo prevent the user from changing the color or the type of a plot from a script‚Äôs ‚ÄúSettings/Style‚Äù tab, include `editable = false` in the [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot) call.\n\nThe colors in the above script can be automatically displayed in this way because they are _not dynamically calculated_ and are known as soon as the script has finished compiling. All colors of the [‚Äúconst‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#const) type, and all colors of type [‚Äúinput‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#input) that are _not modified_ via the [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) or [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) functions can be automatically displayed like this.\n\nNoteIf [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) and [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) functions use a ‚Äúconst color‚Äù and other ‚Äúconst‚Äù parameters, color modifications are calculated during the script‚Äôs compilation, not at its runtime. As a result, they are available when the script finishes compiling and can be displayed in the ‚ÄúSettings/Style‚Äù tab.\n\nHowever, if _even a single calculated color_ is of type ‚Äúsimple color‚Äù or ‚Äúseries color‚Äù, or if an ‚Äúinput color‚Äù is passed to [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) or [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb), _all_ colors are calculated in the script‚Äôs runtime, and no color pickers are available in the ‚ÄúStyle‚Äù section.\n\nIn practice, the creation of [‚Äúsimple‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#simple) or [‚Äúseries‚Äù](https://www.tradingview.com/pine-script-docs/language/type-system/#series) colors is also most often due to using [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) and [color.rgb()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.rgb) functions. The qualifier of the color that these functions return is the strongest qualifier of the values passed to them. If each call to these functions passes only ‚Äúconst‚Äù values, the resulting colors are also ‚Äúconst‚Äù, and the script _does_ display them in the ‚ÄúStyle‚Äù menu.\n\nNoticeThe [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.from_gradient) function always returns a ‚Äúseries color‚Äù value, regardless of the parameters passed to it. If it‚Äôs used in a script, all of the script‚Äôs colors are calculated at runtime.\n\nFor example, let‚Äôs try to make the plots in the script above semi-transparent by adding a transparency of `50` to its colors via [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new). The easiest way to do this is to wrap the `plotColor` variable with [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new), like in the example below:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Color picker showcase\") plotColor = color.new(close > open ? color.teal : color.red, 50) plot(close, color = plotColor)`\n\nUnfortunately, with these changes the ‚ÄúStyle‚Äù tab does not display a color picker any longer. This is because we use the ‚Äúseries bool‚Äù condition `close > open` to decide the color, and then pass the result of this expression to a single [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) call. The qualified type of the calculated color that it returns is ‚Äúseries color‚Äù.\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-2.BO3w97fq_14utEv.webp)\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-3.B0TUMw_p_Z2hnihX.webp)\n\nTo avoid this, we can ensure that every calculated color created by [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) is a ‚Äúconst color‚Äù. Below, we wrap [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal) and [color.red](https://www.tradingview.com/pine-script-reference/v6/#const_color.red) separately with [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) ‚Äî creating two constant calculated colors in the process ‚Äî and then decide which one to assign to `plotColor` based on the condition. And while the `plotColor` variable is a ‚Äúseries color‚Äù, each [color.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_color.new) call returns a constant color, so the script displays a color picker in the ‚ÄúStyle‚Äù tab:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6 indicator(\"Color picker showcase\") plotColor = close > open ? color.new(color.teal, 50) : color.new(color.red, 50) plot(close, color = plotColor)`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-MaintainAutomaticColorSelection-4.B7QSrDzd_18UfnH.webp)\n\nTo calculate the colors at runtime, create custom color inputs for all of the colors that are to be editable. This approach requires more effort, but allows significantly more control over what the user can affect. Learn more about creating color inputs on the [Inputs page](https://www.tradingview.com/pine-script-docs/concepts/inputs/#color-input).",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.teal",
      "color.red",
      "color.new",
      "fun_color.new",
      "color.rgb",
      "fun_color.rgb",
      "color.from_gradient",
      "fun_color.from_gradient",
      "const_color.teal",
      "const_color.red",
      "indicator",
      "input",
      "plot",
      "bgcolor",
      "barcolor",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-289",
    "type": "documentation",
    "source": "visuals/fills.md",
    "section": "visuals",
    "title": "[Customize gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)",
    "content": "### [Designing usable colors schemes](https://www.tradingview.com/pine-script-docs/visuals/colors/#designing-usable-colors-schemes)\n\nIf you write scripts intended for other traders, try to avoid colors that will not work well in some environments, whether it be for plots, labels, tables or fills. At a minimum, test your visuals to ensure they perform satisfactorily with both the light and dark TradingView themes; they are the most commonly used. Colors such as black and white, for example, should be avoided.\n\nBuild the appropriate inputs to provide script users the flexibility to adapt your script‚Äôs visuals to their particular environments.\n\nTake care to build a visual hierarchy of the colors you use that matches the relative importance of your script‚Äôs visual components. Good designers understand how to achieve the optimal balance of color and weight so the eye is naturally drawn to the most important elements of the design. When you make everything stand out, nothing does. Make room for some elements to stand out by toning down the visuals surrounding it.\n\nProviding a selection of color presets in your inputs ‚Äî rather than a single color that can be changed ‚Äî can help color-challenged users. Our [Technical Ratings](https://www.tradingview.com/script/Jdw7wW2g-Technical-Ratings/) demonstrates one way of achieving this.\n\n### [Plot crisp lines](https://www.tradingview.com/pine-script-docs/visuals/colors/#plot-crisp-lines)\n\nIt is best to use zero transparency to plot the important lines in your visuals, to keep them crisp. This way, they will show through fills more precisely. Keep in mind that fills have a higher z-index than plots, so they are placed on top of them. A slight increase of a line‚Äôs width can also go a long way in making it stand out.\n\nIf you want a special plot to stand out, you can also give it more importance by using multiple plots for the same line. These are examples where we modulate the successive width and transparency of plots to achieve this:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Colors-PlotCrispLines-1.CJkrlPd__Z1Me4S0.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\")  \nplot(high, \"\", color.new(color.orange, 80), 8)  \nplot(high, \"\", color.new(color.orange, 60), 4)  \nplot(high, \"\", color.new(color.orange, 00), 1)\n\nplot(hl2, \"\", color.new(color.orange, 60), 4)  \nplot(hl2, \"\", color.new(color.orange, 00), 1)\n\nplot(low, \"\", color.new(color.orange, 0), 1)  \n`\n\n### [Customize gradients](https://www.tradingview.com/pine-script-docs/visuals/colors/#customize-gradients)\n\nWhen building gradients, adapt them to the visuals they apply to. If you are using a gradient to color candles, for example, it is usually best to limit the number of steps in the gradient to ten or less, as it is more difficult for the eye to perceive intensity variations of discrete objects. As we did in our examples, cap minimum and maximum transparency levels so your visual elements remain visible and do not overwhelm when it‚Äôs not necessary.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.new",
      "color.orange",
      "indicator",
      "input",
      "plot",
      "fill",
      "var",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-290",
    "type": "documentation",
    "source": "visuals/levels.md",
    "section": "visuals",
    "title": "[Fills between  levels](https://www.tradingview.com/pine-script-docs/visuals/levels/#fills-between-levels)",
    "content": "# [Levels](https://www.tradingview.com/pine-script-docs/visuals/levels/#levels)\n\n## [‚Äã`hline()`‚Äã levels](https://www.tradingview.com/pine-script-docs/visuals/levels/#hline-levels)\n\nLevels are lines plotted using the  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  function. It is designed to plot  **horizontal**  levels using a  **single color**, i.e., it does not change on different bars. See the  [Levels](https://www.tradingview.com/pine-script-docs/visuals/plots/#levels)  section of the page on  [plot()](https://www.tradingview.com/pine-script-reference/v6/#plot)  for alternative ways to plot levels when  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  won‚Äôt do what you need.\n\nThe function has the following signature:\n\n```\n\n```\n\n[hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  has a few constraints when compared to  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot):\n\n-   Since the function‚Äôs objective is to plot horizontal lines, its  `price`  parameter requires an ‚Äúinput int/float‚Äù argument, which means that ‚Äúseries float‚Äù values such as  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  or dynamically-calculated values cannot be used.\n-   Its  `color`  parameter requires an ‚Äúinput color‚Äù argument, which precludes the use of dynamic colors, i.e., colors calculated on each bar ‚Äî or ‚Äúseries color‚Äù values.\n-   Three different line styles are supported through the  `linestyle`  parameter:  [hline.style_solid](https://www.tradingview.com/pine-script-reference/v6/#const_hline.style_solid),  [hline.style_dotted](https://www.tradingview.com/pine-script-reference/v6/#const_hline.style_dotted)  and  [hline.style_dashed](https://www.tradingview.com/pine-script-reference/v6/#const_hline.style_dashed).\n\nLet‚Äôs see  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  in action in the ‚ÄúTrue Strength Index‚Äù indicator:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"TSI\")  \nmyTSI  =  100  *  ta.tsi(close,  25,  13)  \n  \nhline( 50,  \"+50\",  color.lime)  \nhline( 25,  \"+25\",  color.green)  \nhline( 0,  \"Zero\",  color.gray,  linestyle  =  hline.style_dotted)  \nhline(-25,  \"-25\",  color.maroon)  \nhline(-50,  \"-50\",  color.red)  \n  \nplot(myTSI)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Levels-HlineLevels-01.DkWkzgaN_R6tzp.webp)\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Levels-HlineLevels-02.rezExM6T_1CI5EH.webp)\n\nNote that:\n\n-   We display 5 levels, each of a different color.\n-   We use a different line style for the zero centerline.\n-   We choose colors that will work well on both light and dark themes.\n-   The usual range for the indicator‚Äôs values is +100 to -100. Since the  [ta.tsi()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta%7Bdot%7Dtsi)  built-in returns values in the +1 to -1 range, we make the adjustment in our code.",
    "keywords": [
      "www.tradingview",
      "i.e",
      "hline.style_solid",
      "const_hline.style_solid",
      "hline.style_dotted",
      "const_hline.style_dotted",
      "hline.style_dashed",
      "const_hline.style_dashed",
      "tradingview.com",
      "ta.tsi",
      "color.lime",
      "color.green",
      "color.gray",
      "color.maroon",
      "color.red",
      "indicator",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-291",
    "type": "documentation",
    "source": "visuals/levels.md",
    "section": "visuals",
    "title": "[Fills between  levels](https://www.tradingview.com/pine-script-docs/visuals/levels/#fills-between-levels)",
    "content": "## [Fills between  levels](https://www.tradingview.com/pine-script-docs/visuals/levels/#fills-between-levels)\n\nThe space between two levels plotted with  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  can be colored using  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill). Keep in mind that  **both**  plots must have been plotted with  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline).\n\nLet‚Äôs put some background colors in our TSI indicator:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"TSI\")  \nmyTSI  =  100  *  ta.tsi(close,  25,  13)  \n  \nplus50Hline  =  hline( 50,  \"+50\",  color.lime)  \nplus25Hline  =  hline( 25,  \"+25\",  color.green)  \nzeroHline  =  hline( 0,  \"Zero\",  color.gray,  linestyle  =  hline.style_dotted)  \nminus25Hline  =  hline(-25,  \"-25\",  color.maroon)  \nminus50Hline  =  hline(-50,  \"-50\",  color.red)  \n  \n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function returns a color in a light shade for use as a background.  \nfillColor(color  col) =>  \ncolor.new(col,  90)  \n  \nfill(plus50Hline,  plus25Hline,  fillColor(color.lime))  \nfill(plus25Hline,  zeroHline,  fillColor(color.teal))  \nfill(zeroHline,  minus25Hline,  fillColor(color.maroon))  \nfill(minus25Hline,  minus50Hline,  fillColor(color.red))  \n  \nplot(myTSI)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Levels-FillBetweenLevels-01.xe2ic_uc_Z2mX9Cm.webp)\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Levels-FillBetweenLevels-02.CUTgokP3_Z2tYq6M.webp)\n\nNote that:\n\n-   We have now used the return value of our  [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)  function calls, which is of the  [hline](https://www.tradingview.com/pine-script-docs/language/type-system/#plot-and-hline)  special type. We use the  `plus50Hline`,  `plus25Hline`,  `zeroHline`,  `minus25Hline`  and  `minus50Hline`  variables to store those ‚Äúhline‚Äù IDs because we will need them in our  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill)  calls later.\n-   To generate lighter color shades for the background colors, we declare a  `fillColor()`  function that accepts a color and returns its 90 transparency. We use calls to that function for the  `color`  arguments in our  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill)  calls.\n-   We make our  [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill)  calls for each of the four different fills we want, between four different pairs of levels.\n-   We use  [color.teal](https://www.tradingview.com/pine-script-reference/v6/#const_color.teal)  in our second fill because it produces a green that fits the color scheme better than the  [color.green](https://www.tradingview.com/pine-script-reference/v6/#const_color.green)  used for the 25 level",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "ta.tsi",
      "color.lime",
      "color.green",
      "color.gray",
      "hline.style_dotted",
      "color.maroon",
      "color.red",
      "color.new",
      "color.teal",
      "const_color.teal",
      "const_color.green",
      "indicator",
      "plot",
      "hline",
      "fill",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-292",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Lines and boxes\nIntroduction\nPine Script¬Æ facilitates drawing lines, boxes, and other geometric formations from code using the line, box, and polyline types. These types provide utility for programmatically drawing support and resistance levels, trend lines, price ranges, and other custom formations on a chart.\n\nUnlike plots, the flexibility of these types makes them particularly well-suited for visualizing current calculated data at virtually any available point on the chart, irrespective of the chart bar the script executes on.\n\nLines, boxes, and polylines are objects, like labels, tables, and other special types. Scripts reference objects of these types using IDs, which act like pointers. As with other objects, line, box, and polyline IDs are qualified as ‚Äúseries‚Äù values, and all functions that manage these objects accept ‚Äúseries‚Äù arguments.\n\nTip\nUsing the types we discuss on this page often involves working with arrays, especially when creating polylines or managing active drawings on the chart. Therefore, we recommend reading and understanding the Arrays page to make the most of these drawing types in your scripts.\n\nLines drawn by a script may be vertical, horizontal, or angled. Boxes are always rectangular. Polylines sequentially connect multiple vertical, horizontal, angled, or curved line segments. Although all of these drawing types have different characteristics, they do have some things in common:\n\nLines, boxes, and polylines can have coordinates at any available location on the chart, including ones at future times beyond the last chart bar.\nObjects of these types can use chart.point instances to set their coordinates.\nThe x-coordinates of each object can be bar index or time values, depending on their specified xloc property.\nEach object can have one of multiple predefined line styles.\nScripts can call the functions that manage these objects from within the scopes of loops and conditional structures, allowing iterative and conditional control of their drawings.\nThere are limits on the number of these objects that a script can reference and display on the chart. A single script instance can display up to 500 lines, 500 boxes, and 100 polylines. Users can specify the maximum number allowed for each type via the max_lines_count, max_boxes_count, and max_polylines_count parameters of the script‚Äôs indicator() or strategy() declaration statement. If unspecified, the default is ~50. As with label and table types, lines, boxes, and polylines utilize a garbage collection mechanism that deletes the oldest objects on the chart when the total number of drawings exceeds the script‚Äôs limit.\nNote\nThe Supercharts interface features a set of drawing tools that enable users to draw on the chart using mouse actions. Although some of those drawings might resemble the outputs of a script‚Äôs drawing objects, it‚Äôs crucial to understand that they are unrelated entities. Scripts cannot interact with the chart‚Äôs drawing tools. Additionally, mouse actions do not directly affect a script‚Äôs drawing objects.",
    "keywords": [
      "chart.point",
      "indicator",
      "strategy",
      "plot",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-293",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Lines\nThe built-ins in the line.* namespace control the creation and management of line objects:\n\nThe line.new() function creates a new line.\nThe line.set_*() functions modify line properties.\nThe line.get_*() functions retrieve values from a line instance.\nThe line.copy() function clones a line instance.\nThe line.delete() function deletes an existing line instance.\nThe line.all variable references a read-only array containing the IDs of all lines displayed by the script. The array‚Äôs size depends on the max_lines_count of the indicator() or strategy() declaration statement and the number of lines the script has drawn.\nScripts can call line.set_*(), line.get_*(), line.copy(), and line.delete() built-ins as functions or methods.\n\nCreating lines\nThe line.new() function creates a new line instance to display on the chart. It has the following signatures:\n\nline.new(first_point, second_point, xloc, extend, color, style, width, force_overlay) ‚Üí series line\n\nline.new(x1, y1, x2, y2, xloc, extend, color, style, width, force_overlay) ‚Üí series line\nThe first overload of this function contains the first_point and second_point parameters. The first_point is a chart.point representing the start of the line, and the second_point is a chart.point representing the line‚Äôs end. The function copies the information from these chart points to determine the line‚Äôs coordinates. Whether it uses the index or time fields from the first_point and second_point as x-coordinates depends on the function‚Äôs xloc value.\n\nThe second overload specifies x1, y1, x2, and y2 values independently, where x1 and x2 are int values representing the starting and ending x-coordinates of the line, and y1 and y2 are float values representing the y-coordinates. Whether the line considers the x values as bar indices or timestamps depends on the xloc value in the function call.\n\nBoth overloads share the same additional parameters:\n\nxloc\n\nControls whether the x-coordinates of the new line use bar index or time values. Its default value is xloc.bar_index.\n\nWhen calling the first overload, using an xloc value of xloc.bar_index tells the function to use the index fields of the first_point and second_point, and a value of xloc.bar_time tells the function to use the time fields of the points.\n\nWhen calling the second overload, an xloc value of xloc.bar_index prompts the function to treat the x1 and x2 arguments as bar index values. When using xloc.bar_time, the function will treat x1 and x2 as time values.\n\nWhen the specified x-coordinates represent bar index values, it‚Äôs important to note that the minimum x-coordinate allowed is bar_index - 10000. For larger offsets, one can use xloc.bar_time.\n\nextend\n\nDetermines whether the drawn line will infinitely extend beyond its defined start and end coordinates. It accepts one of the following values: extend.left, extend.right, extend.both, or extend.none (default).",
    "keywords": [
      "line.new",
      "line.set_",
      "line.get_",
      "line.copy",
      "line.delete",
      "line.all",
      "chart.point",
      "xloc.bar_index",
      "xloc.bar_time",
      "extend.left",
      "extend.right",
      "extend.both",
      "extend.none",
      "indicator",
      "strategy",
      "overlay",
      "var",
      "series",
      "import",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-294",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "color\n\nSpecifies the color of the line drawing. The default is color.blue.\n\nstyle\n\nSpecifies the line‚Äôs style, which can be any of the options listed in this page‚Äôs Line styles section. The default value is line.style_solid.\n\nwidth\n\nControls the width of the line, in pixels. The default value is 1.\n\nforce_overlay\n\nIf true, the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is false.\n\nThe example below demonstrates how one can draw lines in their simplest form. This script draws a new vertical line connecting the open and close prices at the horizontal center of each chart bar:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Creating lines demo\", overlay = true)\n\n//@variable The `chart.point` for the start of the line. Contains `index` and `time` information.\nfirstPoint = chart.point.now(open)\n//@variable The `chart.point` for the end of the line. Contains `index` and `time` information.\nsecondPoint = chart.point.now(close)\n\n// Draw a basic line with a `width` of 5 connecting the `firstPoint` to the `secondPoint`.\n// This line uses the `index` field from each point for its x-coordinates.\nline.new(firstPoint, secondPoint, width = 5)\n\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nNote that:\n\nIf the firstPoint and secondPoint reference identical coordinates, the script will not display a line since there is no distance between them to draw. However, the line ID will still exist.\nThe script will only display approximately the last 50 lines on the chart, as it does not have a specified max_lines_count in the indicator() function call. Line drawings persist on the chart until deleted using line.delete() or removed by the garbage collector.\nThe script redraws the line on the open chart bar (i.e., the bar with an orange background highlight) until it closes. After the bar closes, it will no longer update the drawing.\nLet‚Äôs look at a more involved example. This script uses the previous bar‚Äôs hl2 price and the current bar‚Äôs high and low prices to draw a fan with a user-specified number of lines projecting a range of hypothetical price values for the following chart bar. It calls line.new() within a for loop to create linesPerBar lines on each bar:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Creating lines demo\", \"Simple projection fan\", true, max_lines_count = 500)\n\n//@variable The number of fan lines drawn on each chart bar.\nint linesPerBar = input.int(20, \"Line drawings per bar\", 2, 100)\n\n//@variable The distance between each y point on the current bar.\nfloat step = (high - low) / (linesPerBar - 1)\n\n//@variable The `chart.point` for the start of each line. Does not contain `time` information.",
    "keywords": [
      "color.blue",
      "line.style_solid",
      "chart.point",
      "line.new",
      "barstate.isconfirmed",
      "color.new",
      "color.orange",
      "line.delete",
      "i.e",
      "input.int",
      "indicator",
      "overlay",
      "input",
      "bgcolor",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-295",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "firstPoint = chart.point.from_index(bar_index - 1, hl2[1])\n//@variable The `chart.point` for the end of each line. Does not contain `time` information.\nsecondPoint = chart.point.from_index(bar_index + 1, float(na))\n\n//@variable The stepped y value on the current bar for `secondPoint.price` calculation, starting from the `low`.\nfloat barValue = low\n// Loop to draw the fan.\nfor i = 1 to linesPerBar\n    // Update the `price` of the `secondPoint` using the difference between the `barValue` and `firstPoint.price`.\n    secondPoint.price := 2.0 * barValue - firstPoint.price\n    //@variable Is `color.aqua` when the line's slope is positive, `color.fuchsia` otherwise.\n    color lineColor = secondPoint.price > firstPoint.price ? color.aqua : color.fuchsia\n    // Draw a new `lineColor` line connecting the `firstPoint` and `secondPoint` coordinates.\n    // This line uses the `index` field from each point for its x-coordinates.\n    line.new(firstPoint, secondPoint, color = lineColor)\n    // Add the `step` to the `barValue`.\n    barValue += step\n\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nNote that:\n\nWe‚Äôve included max_lines_count = 500 in the indicator() function call, meaning the script preserves up to 500 lines on the chart.\nEach line.new() call copies the information from the chart.point referenced by the firstPoint and secondPoint variables. As such, the script can change the price field of the secondPoint on each loop iteration without affecting the y-coordinates in other lines.\nModifying lines\nThe line.* namespace contains multiple setter functions that modify the properties of line instances:\n\nline.set_first_point() and line.set_second_point() respectively update the start and end points of the id line using information from the specified point.\nline.set_x1() and line.set_x2() set one of the x-coordinates of the id line to a new x value, which can represent a bar index or time value depending on the line‚Äôs xloc property.\nline.set_y1() and line.set_y2() set one of the y-coordinates of the id line to a new y value.\nline.set_xy1() and line.set_xy2() update one of the id line‚Äôs points with new x and y values.\nline.set_xloc() sets the xloc of the id line and updates both of its x-coordinates with new x1 and x2 values.\nline.set_extend() sets the extend property of the id line.\nline.set_color() updates the id line‚Äôs color value.\nline.set_style() changes the style of the id line.\nline.set_width() sets the width of the id line.\nAll setter functions directly modify the id line passed into the call and do not return any value. Each setter function accepts ‚Äúseries‚Äù arguments, as a script can change a line‚Äôs properties throughout its execution.\n\nThe following example draws lines connecting the opening price of a timeframe to its closing price. The script uses the var keyword to declare periodLine and the variables that reference chart.point objects (openPoint and closePoint) only on the first chart bar, and it assigns new references to these variables over its execution. After detecting a new bar on the specified timeframe with timeframe.change, the script uses line.set_color() to set the color property of the current line referenced by periodLine, creates new chart points for openPoint and closePoint using chart.point.now(), calls line.new() to create another line anchored to those points, then assigns the new line‚Äôs reference to periodLine.",
    "keywords": [
      "chart.point",
      "color.aqua",
      "color.fuchsia",
      "line.new",
      "barstate.isconfirmed",
      "color.new",
      "color.orange",
      "line.set_first_point",
      "line.set_second_point",
      "line.set_x",
      "line.set_y",
      "line.set_xy",
      "line.set_xloc",
      "line.set_extend",
      "line.set_color",
      "line.set_style",
      "line.set_width",
      "timeframe.change",
      "line.set_x1",
      "line.set_x2",
      "line.set_y1",
      "line.set_y2",
      "line.set_xy1",
      "line.set_xy2",
      "indicator",
      "bgcolor",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-296",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "On other bars where the periodLine reference is not na, the script assigns a new chart.point reference to the closePoint variable, then uses line.set_second_point() and line.set_color() as methods to update the end coordinate and color of the latest line:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Modifying lines demo\", overlay = true)\n\n//@variable The size of each period.\nstring timeframe = input.timeframe(\"D\", \"Timeframe\")\n\n//@variable A line connecting the period's opening and closing prices.\nvar line periodLine = na\n\n//@variable The first point of the line. Contains `time` and `index` information.\nvar chart.point openPoint = chart.point.now(open)\n//@variable The closing point of the line. Contains `time` and `index` information.\nvar chart.point closePoint = chart.point.now(close)\n\nif timeframe.change(timeframe)\n    //@variable The final color of the `periodLine`.\n    color finalColor = switch\n        closePoint.price > openPoint.price => color.green\n        closePoint.price < openPoint.price => color.red\n        =>                                    color.gray\n\n    // Update the color of the current `periodLine` to the `finalColor`.\n    line.set_color(periodLine, finalColor)\n\n    // Assign new points to the `openPoint` and `closePoint`.\n    openPoint  := chart.point.now(open)\n    closePoint := chart.point.now(close)\n    // Assign a new line to the `periodLine`. Uses `time` fields from the `openPoint` and `closePoint` as x-coordinates.\n    periodLine := line.new(openPoint, closePoint, xloc.bar_time, style = line.style_arrow_right, width = 3)\n\nelse if not na(periodLine)\n    // Assign a new point to the `closePoint`.\n    closePoint := chart.point.now(close)\n\n    //@variable The color of the developing `periodLine`.\n    color developingColor = switch\n        closePoint.price > openPoint.price => color.aqua\n        closePoint.price < openPoint.price => color.fuchsia\n        =>                                    color.gray\n\n    // Update the coordinates of the line's second point using the new `closePoint`.\n    // It uses the `time` field from the point for its new x-coordinate.\n    periodLine.set_second_point(closePoint)\n    // Update the color of the line using the `developingColor`.\n    periodLine.set_color(developingColor)\nNote that:\n\nEach line drawing in this example uses the line.style_arrow_right style. See the Line styles section below for an overview of all available style settings.\nLine styles\nUsers can control the style of their scripts‚Äô line drawings by passing one of the following variables as the style argument in their line.new() or line.set_style() function calls:\n\nArgument\tLine\nline.style_solid\tline_style_solid\nline.style_dotted\tline_style_dotted\nline.style_dashed\tline_style_dashed\nline.style_arrow_left\tline_style_arrow_left\nline.style_arrow_right\tline_style_arrow_right",
    "keywords": [
      "chart.point",
      "line.set_second_point",
      "line.set_color",
      "input.timeframe",
      "timeframe.change",
      "color.green",
      "color.red",
      "color.gray",
      "line.new",
      "xloc.bar_time",
      "line.style_arrow_right",
      "color.aqua",
      "color.fuchsia",
      "line.set_style",
      "line.style_solid",
      "line.style_dotted",
      "line.style_dashed",
      "line.style_arrow_left",
      "indicator",
      "overlay",
      "input",
      "var",
      "method",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-297",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "line.style_arrow_both\tline_style_arrow_both\nNote that:\n\nPolylines can also use any of these variables as their line_style value. See the Creating polylines section of this page.\nReading line values\nThe line.* namespace includes getter functions, which allow a script to retrieve values from a line object for further use:\n\nline.get_x1() and line.get_x2() respectively get the first and second x-coordinate from the id line. Whether the value returned represents a bar index or time value depends on the line‚Äôs xloc property.\nline.get_y1() and line.get_y2() respectively get the id line‚Äôs first and second y-coordinate.\nline.get_price() retrieves the price (y-coordinate) from a line id at a specified x value, including at bar indices outside the line‚Äôs start and end points. This function is only compatible with lines that use xloc.bar_index as the xloc value.\nThe script below draws a new line upon the onset of a rising or falling price pattern forming over length bars. It uses the var keyword to declare the directionLine variable on the first chart bar. The line reference assigned to directionLine persists over subsequent bars until the newDirection condition occurs, in which case the script assigns a creates a new line with line.new and assigns that line‚Äôs reference to the variable.\n\nOn every bar, the script calls the line.get_y2(), line.get_y1(), line.get_x2(), and line.get_x1() getters as methods to retrieve values from the current line referenced by directionLine and calculate its slope, then uses the result to determine the color of each drawing and plot. The script retrieves an extended value of the current line from beyond its second point using line.get_price() and plots the returned value on the chart:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Reading line values demo\", overlay = true)\n\n//@variable The number of bars for rising and falling calculations.\nint length = input.int(2, \"Length\", 2)\n\n//@variable A line that's drawn whenever `hlc3` starts rising or falling over `length` bars.\nvar line directionLine = na\n\n//@variable Is `true` when `hlc3` is rising over `length` bars, `false` otherwise.\nbool rising = ta.rising(hlc3, length)\n//@variable Is `true` when `hlc3` is falling over `length` bars, `false` otherwise.\nbool falling = ta.falling(hlc3, length)\n//@variable Is `true` when a rising or falling pattern begins, `false` otherwise.\nbool newDirection = (rising and not rising[1]) or (falling and not falling[1])\n\n// Update the `directionLine` when `newDirection` is `true`. The line uses the default `xloc.bar_index`.\nif newDirection\n    directionLine := line.new(bar_index - length, hlc3[length], bar_index, hlc3, width = 3)\n\n//@variable The slope of the `directionLine`.\nfloat slope = (directionLine.get_y2() - directionLine.get_y1()) / (directionLine.get_x2() - directionLine.get_x1())",
    "keywords": [
      "line.style_arrow_both",
      "line.get_x",
      "line.get_y",
      "line.get_price",
      "xloc.bar_index",
      "line.new",
      "input.int",
      "ta.rising",
      "ta.falling",
      "line.get_x1",
      "line.get_x2",
      "line.get_y1",
      "line.get_y2",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-298",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "//@variable The value extrapolated from the `directionLine` at the `bar_index`.\nfloat lineValue = line.get_price(directionLine, bar_index)\n\n//@variable Is `color.green` when the `slope` is positive, `color.red` otherwise.\ncolor slopeColor = slope > 0 ? color.green : color.red\n\n// Update the color of the `directionLine`.\ndirectionLine.set_color(slopeColor)\n// Plot the `lineValue`.\nplot(lineValue, \"Extrapolated value\", slopeColor, 3, plot.style_circles)\nNote that:\n\nThis example calls the second overload of the line.new() function, which uses x1, y1, x2, and y2 parameters to define the start and end points of the line. The x1 value is length bars behind the current bar_index, and the y1 value is the hlc3 value at that index. The x2 and y2 in the function call use the current bar‚Äôs bar_index and hlc3 values.\nThe line.get_price() function call treats the directionLine as though it extends infinitely, regardless of its extend property.\nThe script only displays approximately the last 50 lines on the chart, but the plot of extrapolated values spans throughout the chart‚Äôs history.\nCloning lines\nScripts can clone a line id and all its properties with the line.copy() function. Any changes to the copied line instance do not affect the original.\n\nFor example, this script creates a horizontal line at the the bar‚Äôs open price once every length bars, which it assigns to a mainLine variable. On all other bars, it creates a copiedLine using line.copy() and calls line.set_*() functions to modify its properties. As we see below, altering the copiedLine does not affect the mainLine in any way:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Cloning lines demo\", overlay = true, max_lines_count = 500)\n\n//@variable The number of bars between each new mainLine assignment.\nint length = input.int(20, \"Length\", 2, 500)\n\n//@variable The first `chart.point` used by the `mainLine`. Contains `index` and `time` information.\nfirstPoint = chart.point.now(open)\n//@variable The second `chart.point` used by the `mainLine`. Does not contain `time` information.\nsecondPoint = chart.point.from_index(bar_index + length, open)\n\n//@variable A horizontal line drawn at the `open` price once every `length` bars.\nvar line mainLine = na\n\nif bar_index % length == 0\n    // Assign a new line to the `mainLine` that connects the `firstPoint` to the `secondPoint`.\n    // This line uses the `index` fields from both points as x-coordinates.\n    mainLine := line.new(firstPoint, secondPoint, color = color.purple, width = 2)\n\n//@variable A copy of the `mainLine`. Changes to this line do not affect the original.\nline copiedLine = line.copy(mainLine)\n\n// Update the color, style, and second point of the `copiedLine`.\nline.set_color(copiedLine, color.orange)\nline.set_style(copiedLine, line.style_dotted)\nline.set_second_point(copiedLine, chart.point.now(close))",
    "keywords": [
      "line.get_price",
      "color.green",
      "color.red",
      "plot.style_circles",
      "line.new",
      "line.copy",
      "line.set_",
      "input.int",
      "chart.point",
      "color.purple",
      "line.set_color",
      "color.orange",
      "line.set_style",
      "line.style_dotted",
      "line.set_second_point",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-299",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Note that:\n\nThe index field of the secondPoint is length bars beyond the current bar_index. Since the maximum x-coordinate allowed with xloc.bar_index is bar_index + 500, we‚Äôve set the maxval of the length input to 500.\nDeleting lines\nTo delete a line drawn by a script, use the line.delete() function. This function removes the line instance from the script and its drawing on the chart.\n\nDeleting line instances is often handy when one wants to only keep a specific number of lines on the chart at any given time or conditionally remove drawings as a chart progresses.\n\nFor example, this script creates a horizontal line with the extend property set to extend.right whenever an RSI crosses its EMA.\n\nThe script stores all line IDs in a lines array that it uses as a queue to display only a specified number of lines on the chart. When the size of the array exceeds the specified numberOfLines value, the script removes the array‚Äôs oldest line ID using array.shift() and deletes it with line.delete():\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\n\n//@variable The maximum number of lines allowed on the chart.\nconst int MAX_LINES_COUNT = 500\n\nindicator(\"Deleting lines demo\", \"RSI cross levels\", max_lines_count = MAX_LINES_COUNT)\n\n//@variable The length of the RSI.\nint rsiLength = input.int(14, \"RSI length\", 2)\n//@variable The length of the RSI's EMA.\nint emaLength = input.int(28, \"RSI average length\", 2)\n//@variable The maximum number of lines to keep on the chart.\nint numberOfLines = input.int(20, \"Lines on the chart\", 0, MAX_LINES_COUNT)\n\n//@variable An array containing the IDs of lines on the chart.\nvar array<line> lines = array.new<line>()\n\n//@variable An `rsiLength` RSI of `close`.\nfloat rsi = ta.rsi(close, rsiLength)\n//@variable A `maLength` EMA of the `rsi`.\nfloat rsiMA = ta.ema(rsi, emaLength)\n\nif ta.cross(rsi, rsiMA)\n    //@variable The color of the horizontal line.\n    color lineColor = rsi > rsiMA ? color.green : color.red\n    // Draw a new horizontal line. Uses the default `xloc.bar_index`.\n    newLine = line.new(bar_index, rsiMA, bar_index + 1, rsiMA, extend = extend.right, color = lineColor, width = 2)\n    // Push the `newLine` into the `lines` array.\n    lines.push(newLine)\n    // Delete the oldest line when the size of the array exceeds the specified `numberOfLines`.\n    if array.size(lines) > numberOfLines\n        line.delete(lines.shift())\n\n// Plot the `rsi` and `rsiMA`.\nplot(rsi, \"RSI\", color.new(color.blue, 40))\nplot(rsiMA, \"EMA of RSI\", color.new(color.gray, 30))\nNote that:\n\nWe declared a MAX_LINES_COUNT variable with the ‚Äúconst int‚Äù qualified type, which the script uses as the max_lines_count in the indicator() function and the maxval of the input.int() assigned to the numberOfLines variable.\nThis example uses the second overload of the line.new() function, which specifies x1, y1, x2, and y2 coordinates independently.",
    "keywords": [
      "xloc.bar_index",
      "line.delete",
      "extend.right",
      "array.shift",
      "input.int",
      "array.new",
      "ta.rsi",
      "ta.ema",
      "ta.cross",
      "color.green",
      "color.red",
      "line.new",
      "lines.push",
      "array.size",
      "lines.shift",
      "color.new",
      "color.blue",
      "color.gray",
      "indicator",
      "input",
      "plot",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-300",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Filling the space between lines\nScripts can fill the space between two line drawings by creating a linefill object that references them with the linefill.new() function. Linefills automatically determine their fill boundaries using the properties from the line1 and line2 IDs that they reference.\n\nFor example, this script calculates a simple linear regression channel. On the first chart bar, the script declares the basisLine, upperLine, and lowerLine variables to reference the channel‚Äôs line IDs, then it makes two linefill.new() calls to create linefill objects that fill the upper and lower portions of the channel. The first linefill fills the space between the basisLine and the upperLine, and the second fills the space between the basisLine and lowerLine.\n\nThe script updates the coordinates of the lines across subsequent bars. However, notice that the script never needs to update the linefills declared on the first bar. They automatically update their fill regions based on the coordinates of their assigned lines:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Filling the space between lines demo\", \"Simple linreg channel\", true)\n\n//@variable The number of bars in the linear regression calculation.\nint lengthInput = input.int(100)\n\n//@variable The basis line of the regression channel.\nvar line basisLine = line.new(na, na, na, na, extend = extend.right, color = chart.fg_color, width = 2)\n//@variable The channel's upper line.\nvar line upperLine = line.new(na, na, na, na, extend = extend.right, color = color.teal, width = 2)\n//@variable The channel's lower line.\nvar line lowerLine = line.new(na, na, na, na, extend = extend.right, color = color.maroon, width = 2)\n\n//@variable A linefill instance that fills the space between the `basisLine` and `upperLine`.\nvar linefill upperFill = linefill.new(basisLine, upperLine, color.new(color.teal, 80))\n//@variable A linefill instance that fills the space between the `basisLine` and `lowerLine`.\nvar linefill lowerFill = linefill.new(basisLine, lowerLine, color.new(color.maroon, 80))\n\n// Update the `basisLine` coordinates with current linear regression values.\nbasisLine.set_xy1(bar_index + 1 - lengthInput, ta.linreg(close, lengthInput, lengthInput - 1))\nbasisLine.set_xy2(bar_index, ta.linreg(close, lengthInput, 0))\n\n//@variable The channel's standard deviation.\nfloat stDev = 0.0\nfor i = 0 to lengthInput - 1\n    stDev += math.pow(close[i] - line.get_price(basisLine, bar_index - i), 2)\nstDev := math.sqrt(stDev / lengthInput) * 2.0\n\n// Update the `upperLine` and `lowerLine` using the values from the `basisLine` and the `stDev`.\nupperLine.set_xy1(basisLine.get_x1(), basisLine.get_y1() + stDev)\nupperLine.set_xy2(basisLine.get_x2(), basisLine.get_y2() + stDev)\nlowerLine.set_xy1(basisLine.get_x1(), basisLine.get_y1() - stDev)",
    "keywords": [
      "linefill.new",
      "input.int",
      "line.new",
      "extend.right",
      "chart.fg_color",
      "color.teal",
      "color.maroon",
      "color.new",
      "ta.linreg",
      "math.pow",
      "line.get_price",
      "math.sqrt",
      "indicator",
      "input",
      "fill",
      "var",
      "simple",
      "for"
    ]
  },
  {
    "id": "doc-301",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "lowerLine.set_xy2(basisLine.get_x2(), basisLine.get_y2() - stDev)\nTo learn more about the linefill type, see this section of the Fills page.\n\nBoxes\nThe built-ins in the box.* namespace create and manage box objects:\n\nThe box.new() function creates a new box.\nThe box.set_*() functions modify box properties.\nThe box.get_*() functions retrieve values from a box instance.\nThe box.copy() function clones a box instance.\nThe box.delete() function deletes a box instance.\nThe box.all variable references a read-only array containing the IDs of all boxes displayed by the script. The array‚Äôs size depends on the max_boxes_count of the indicator() or strategy() declaration statement and the number of boxes the script has drawn.\nAs with lines, users can call box.set_*(), box.get_*(), box.copy(), and box.delete() built-ins as functions or methods.\n\nCreating boxes\nThe box.new() function creates a new box object to display on the chart. It has the following signatures:\n\nbox.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) ‚Üí series box\n\nbox.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) ‚Üí series box\nThis function‚Äôs first overload includes the top_left and bottom_right parameters, which accept chart.point objects representing the top-left and bottom-right corners of the box, respectively. The function copies the information from these chart points to set the coordinates of the box‚Äôs corners. Whether it uses the index or time fields of the top_left and bottom_right points as x-coordinates depends on the function‚Äôs xloc value.\n\nThe second overload specifies left, top, right, and bottom edges of the box. The left and right parameters accept int values specifying the box‚Äôs left and right x-coordinates, which can be bar index or time values depending on the xloc value in the function call. The top and bottom parameters accept float values representing the box‚Äôs top and bottom y-coordinates.\n\nThe function‚Äôs additional parameters are identical in both overloads:\n\nborder_color\n\nSpecifies the color of all four of the box‚Äôs borders. The default is color.blue.\n\nborder_width\n\nSpecifies the width of the borders, in pixels. Its default value is 1.\n\nborder_style\n\nSpecifies the style of the borders, which can be any of the options in the Box styles section of this page.\n\nextend\n\nDetermines whether the box‚Äôs borders extend infinitely beyond the left or right x-coordinates. It accepts one of the following values: extend.left, extend.right, extend.both, or extend.none (default).",
    "keywords": [
      "box.new",
      "box.set_",
      "box.get_",
      "box.copy",
      "box.delete",
      "box.all",
      "chart.point",
      "color.blue",
      "extend.left",
      "extend.right",
      "extend.both",
      "extend.none",
      "indicator",
      "strategy",
      "overlay",
      "fill",
      "bgcolor",
      "var",
      "series",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-302",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "xloc\n\nDetermines whether the left and right edges of the box use bar index or time values as x-coordinates. The default is xloc.bar_index.\n\nIn the first overload, an xloc value of xloc.bar_index means that the function will use the index fields of the top_left and bottom_right chart points, and an xloc value of xloc.bar_time means that it will use their time fields.\n\nIn the second overload, using an xloc value of xloc.bar_index means the function treats the left and right values as bar indices, and xloc.bar_time means it will treat them as timestamps.\n\nWhen the specified x-coordinates represent bar index values, it‚Äôs important to note that the minimum x-coordinate allowed is bar_index - 10000. For larger offsets, one can use xloc.bar_time.\n\nbgcolor\n\nSpecifies the background color of the space inside the box. The default value is color.blue.\n\ntext\n\nThe text to display inside the box. By default, its value is an empty string.\n\ntext_size\n\nSpecifies the size of the text within the box. It accepts both ‚Äúint‚Äù size values and ‚Äústring‚Äù size.* constants. The ‚Äúint‚Äù size can be any positive integer. The size.* constants and their equivalent ‚Äúint‚Äù sizes are: size.auto (0), size.tiny (8), size.small (10), size.normal (14), size.large (20), and size.huge (36). The default value is size.auto.\n\ntext_color\n\nControls the color of the text. Its default is color.black.\n\ntext_halign\n\nSpecifies the horizontal alignment of the text within the box‚Äôs boundaries. It accepts one of the following: text.align_left, text.align_right, or text.align_center (default).\n\ntext_valign\n\nSpecifies the vertical alignment of the text within the box‚Äôs boundaries. It accepts one of the following: text.align_top, text.align_bottom, or text.align_center (default).\n\ntext_wrap\n\nDetermines whether the box will wrap the text within it. If its value is text.wrap_auto, the box wraps the text to ensure it does not span past its vertical borders. It also clips the wrapped text when it extends past the bottom. If the value is text.wrap_none, the box displays the text on a single line that can extend beyond its borders. The default is text.wrap_none.\n\ntext_font_family\n\nDefines the font family of the box‚Äôs text. Using font.family_default displays the box‚Äôs text with the system‚Äôs default font. The font.family_monospace displays the text in a monospace format. The default value is font.family_default.\n\nforce_overlay\n\nIf true, the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is false.\n\ntext_formatting\n\nSpecifies the formatting of the box‚Äôs text. Using text.format_none displays the text with no special formatting. This parameter also accepts the arguments text.format_bold or text.format_italic. Using text.format_bold + text.format_italic applies both formats together to display text that is both bold and italicized. The default value is text.format_none.",
    "keywords": [
      "xloc.bar_index",
      "xloc.bar_time",
      "color.blue",
      "size.auto",
      "size.tiny",
      "size.small",
      "size.normal",
      "size.large",
      "size.huge",
      "color.black",
      "text.align_left",
      "text.align_right",
      "text.align_center",
      "text.align_top",
      "text.align_bottom",
      "text.wrap_auto",
      "text.wrap_none",
      "font.family_default",
      "font.family_monospace",
      "text.format_none",
      "text.format_bold",
      "text.format_italic",
      "overlay",
      "bgcolor",
      "const",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-303",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Let‚Äôs write a simple script to display boxes on a chart. The example below draws a box projecting each bar‚Äôs high and low values from the horizontal center of the current bar to the center of the next available bar.\n\nOn each bar, the script creates topLeft and bottomRight points via chart.point.now() and chart.point.from_index(), then calls box.new() to construct a new box and display it on the chart. It also highlights the background on the unconfirmed chart bar using bgcolor() to indicate that it redraws that box until the bar‚Äôs last update:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Creating boxes demo\", overlay = true)\n\n//@variable The `chart.point` for the top-left corner of the box. Contains `index` and `time` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right corner of the box. Does not contain `time` information.\nbottomRight = chart.point.from_index(bar_index + 1, low)\n\n// Draw a box using the `topLeft` and `bottomRight` corner points. Uses the `index` fields as x-coordinates.\nbox.new(topLeft, bottomRight, color.purple, 2, bgcolor = color.new(color.gray, 70))\n\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nNote that:\n\nThe bottomRight point‚Äôs index field is one bar greater than the index in the topLeft. If the x-coordinates of the corners were equal, the script would draw a vertical line at the horizontal center of each bar, resembling the example in this page‚Äôs Creating lines section.\nSimilar to lines, if the topLeft and bottomRight contained identical coordinates, the box wouldn‚Äôt display on the chart since there would be no space between them to draw. However, its ID would still exist.\nThis script only displays approximately the last 50 boxes on the chart, as we have not specified a max_boxes_count in the indicator() function call.\nModifying boxes\nMultiple setter functions exist in the box.* namespace, allowing scripts to modify the properties of box objects:\n\nbox.set_top_left_point() and box.set_bottom_right_point() respectively update the top-left and bottom-right coordinates of the id box using information from the specified point.\nbox.set_left() and box.set_right() set the left or right x-coordinate of the id box to a new left/right value, which can be a bar index or time value depending on the box‚Äôs xloc property.\nbox.set_top() and box.set_bottom() set the top or bottom y-coordinate of the id box to a new top/bottom value.\nbox.set_lefttop() sets the left and top coordinates of the id box, and box.set_rightbottom() sets its right and bottom coordinates.\nbox.set_xloc() sets the xloc property of the id box and updates its x-coordinates to new left and right values, which represent bar index or time values accordingly.",
    "keywords": [
      "chart.point",
      "box.new",
      "color.purple",
      "color.new",
      "color.gray",
      "barstate.isconfirmed",
      "color.orange",
      "box.set_top_left_point",
      "box.set_bottom_right_point",
      "box.set_left",
      "box.set_right",
      "box.set_top",
      "box.set_bottom",
      "box.set_lefttop",
      "box.set_rightbottom",
      "box.set_xloc",
      "indicator",
      "overlay",
      "bgcolor",
      "var",
      "simple",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-304",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "box.set_border_color(), box.set_border_width() and box.set_border_style() respectively update the color, width, and style of the id box‚Äôs border.\nbox.set_extend() sets the horizontal extend property of the id box.\nbox.set_bgcolor() sets the color of the space inside the id box to a new color.\nbox.set_text(), box.set_text_size(), box.set_text_color(), box.set_text_halign(), box.set_text_valign(), box.set_text_wrap(), box.set_text_font_family(), and box.set_text_formatting() update the id box‚Äôs text-related properties.\nAs with setter functions in the line.* namespace, all box setters modify the id box directly without returning a value, and each setter function accepts ‚Äúseries‚Äù arguments.\n\nThis example uses boxes to visualize the ranges of upward and downward bars with the highest volume over a user-defined timeframe. When the script detects a new bar on the specified timeframe with timeframe.change(), it assigns new boxes to the upBox and downBox variables, resets the upVolume and downVolume values, and highlights the chart background.\n\nWhen an upward or downward bar‚Äôs volume exceeds the upVolume or downVolume, the script updates the volume-tracking variables and calls box.set_top_left_point() and box.set_bottom_right_point() to update the upBox or downBox coordinates. The setters use the information from the chart points created with chart.point.now() and chart.point.from_time() to project that bar‚Äôs high and low values from the current time to the closing time of the specified timeframe:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Modifying boxes demo\", \"High volume boxes\", true, max_boxes_count = 100)\n\n//@variable The timeframe of the calculation.\nstring timeframe = input.timeframe(\"D\", \"Timeframe\")\n\n//@variable A box projecting the range of the upward bar with the highest `volume` over the `timeframe`.\nvar box upBox = na\n//@variable A box projecting the range of the downward bar with the lowest `volume` over the `timeframe`.\nvar box downBox = na\n//@variable The highest volume of upward bars over the `timeframe`.\nvar float upVolume = na\n//@variable The highest volume of downward bars over the `timeframe`.\nvar float downVolume = na\n\n// Color variables.\nvar color upBorder   = color.teal\nvar color upFill     = color.new(color.teal, 90)\nvar color downBorder = color.maroon\nvar color downFill   = color.new(color.maroon, 90)\n\n//@variable The closing time of the `timeframe`.\nint closeTime = time_close(timeframe)\n//@variable Is `true` when a new bar starts on the `timeframe`.\nbool changeTF = timeframe.change(timeframe)\n\n//@variable The `chart.point` for the top-left corner of the boxes. Contains `index` and `time` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right corner of the boxes. Does not contain `index` information.",
    "keywords": [
      "box.set_border_color",
      "box.set_border_width",
      "box.set_border_style",
      "box.set_extend",
      "box.set_bgcolor",
      "box.set_text",
      "box.set_text_size",
      "box.set_text_color",
      "box.set_text_halign",
      "box.set_text_valign",
      "box.set_text_wrap",
      "box.set_text_font_family",
      "box.set_text_formatting",
      "timeframe.change",
      "box.set_top_left_point",
      "box.set_bottom_right_point",
      "chart.point",
      "input.timeframe",
      "color.teal",
      "color.new",
      "color.maroon",
      "indicator",
      "input",
      "fill",
      "bgcolor",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-305",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "bottomRight = chart.point.from_time(closeTime, low)\n\nif changeTF and not na(volume)\n    if close > open\n        // Update `upVolume` and `downVolume` values.\n        upVolume   := volume\n        downVolume := 0.0\n        // Draw a new `upBox` using `time` and `price` info from the `topLeft` and `bottomRight` points.\n        upBox := box.new(topLeft, bottomRight, upBorder, 3, xloc = xloc.bar_time, bgcolor = upFill)\n        // Draw a new `downBox` with `na` coordinates.\n        downBox := box.new(na, na, na, na, downBorder, 3, xloc = xloc.bar_time, bgcolor = downFill)\n    else\n        // Update `upVolume` and `downVolume` values.\n        upVolume   := 0.0\n        downVolume := volume\n        // Draw a new `upBox` with `na` coordinates.\n        upBox := box.new(na, na, na, na, upBorder, 3, xloc = xloc.bar_time, bgcolor = upFill)\n        // Draw a new `downBox` using `time` and `price` info from the `topLeft` and `bottomRight` points.\n        downBox := box.new(topLeft, bottomRight, downBorder, 3, xloc = xloc.bar_time, bgcolor = downFill)\n// Update the ``upVolume`` and change the ``upBox`` coordinates when volume increases on an upward bar.\nelse if close > open and volume > upVolume\n    upVolume := volume\n    box.set_top_left_point(upBox, topLeft)\n    box.set_bottom_right_point(upBox, bottomRight)\n// Update the ``downVolume`` and change the ``downBox`` coordinates when volume increases on a downward bar.\nelse if close <= open and volume > downVolume\n    downVolume := volume\n    box.set_top_left_point(downBox, topLeft)\n    box.set_bottom_right_point(downBox, bottomRight)\n\n// Highlight the background when a new `timeframe` bar starts.\nbgcolor(changeTF ? color.new(color.orange, 70) : na, title = \"Timeframe change highlight\")\nNote that:\n\nThe indicator() function call contains max_boxes_count = 100, meaning the script will preserve the last 100 boxes on the chart.\nWe utilized both overloads of box.new() in this example. On the first bar of the timeframe, the script calls the first overload for the upBox when the bar is rising, and it calls that overload for the downBox when the bar is falling. It uses the second overload to assign a new box with na values to the other box variable on that bar.\nBox styles\nUsers can include one of the following line.style_* variables in their box.new() or box.set_border_style() function calls to set the border styles of boxes drawn by their scripts:\n\nArgument\tBox\nline.style_solid\tbox_style_solid\nline.style_dotted\tbox_style_dotted\nline.style_dashed\tbox_style_dashed\nReading box values\nThe box.* namespace features getter functions that allow scripts to retrieve coordinate values from a box instance:\n\nbox.get_left() and box.get_right() respectively get the x-coordinates of the left and right edges of the id box. Whether the value returned represents a bar index or time value depends on the box‚Äôs xloc property.",
    "keywords": [
      "chart.point",
      "box.new",
      "xloc.bar_time",
      "box.set_top_left_point",
      "box.set_bottom_right_point",
      "color.new",
      "color.orange",
      "line.style_",
      "box.set_border_style",
      "line.style_solid",
      "line.style_dotted",
      "line.style_dashed",
      "box.get_left",
      "box.get_right",
      "indicator",
      "fill",
      "bgcolor",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-306",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "box.get_top() and box.get_bottom() respectively get the top and bottom y-coordinates of the id box.\nThe example below draws boxes to visualize hypothetical price ranges over a period of length bars. At the start of each new period, it uses the average candle range multiplied by the scaleFactor input to calculate the corner points of a box centered at the hl2 price with an initialRange height. After drawing the first box, it creates numberOfBoxes - 1 new boxes inside a for loop.\n\nWithin each loop iteration, the script gets the lastBoxDrawn reference by retrieving the last element from the read-only box.all array, then calls box.get_top() and box.get_bottom() to get the y-coordinates of the referenced box. It uses these values to calculate the coordinates for a new box that‚Äôs scaleFactor times taller than the previous:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Reading box values demo\", \"Nested boxes\", overlay = true, max_boxes_count = 500)\n\n//@variable The number of bars in the range calculation.\nint length = input.int(10, \"Length\", 2, 500)\n//@variable The number of nested boxes drawn on each period.\nint numberOfBoxes = input.int(5, \"Nested box count\", 1)\n//@variable The scale factor applied to each box.\nfloat scaleFactor = input.float(1.6, \"Scale factor\", 1)\n\n//@variable The initial box range.\nfloat initialRange = scaleFactor * ta.sma(high - low, length)\n\nif bar_index % length == 0\n    //@variable The top-left `chart.point` for the initial box. Does not contain `time` information.\n    topLeft = chart.point.from_index(bar_index, hl2 + initialRange / 2)\n    //@variable The bottom-right `chart.point` for the initial box. Does not contain `time` information.\n    bottomRight = chart.point.from_index(bar_index + length, hl2 - initialRange / 2)\n\n    // Calculate border and fill colors of the boxes.\n    borderColor = color.rgb(math.random(100, 255), math.random(0, 100), math.random(100, 255))\n    bgColor = color.new(borderColor, math.max(100 * (1 - 1/numberOfBoxes), 90))\n\n    // Draw a new box using the `topLeft` and `bottomRight` points. Uses their `index` fields as x-coordinates.\n    box.new(topLeft, bottomRight, borderColor, 2, bgcolor = bgColor)\n\n    if numberOfBoxes > 1\n        // Loop to create additional boxes.\n        for i = 1 to numberOfBoxes - 1\n            //@variable The last box drawn by the script.\n            box lastBoxDrawn = box.all.last()\n\n            //@variable The top price of the last box.\n            float top = box.get_top(lastBoxDrawn)\n            //@variable The bottom price of the last box.\n            float bottom = box.get_bottom(lastBoxDrawn)\n\n            //@variable The scaled range of the new box.\n            float newRange = scaleFactor * (top - bottom) * 0.5\n\n            // Update the `price` fields of the `topLeft` and `bottomRight` points.",
    "keywords": [
      "box.get_top",
      "box.get_bottom",
      "box.all",
      "input.int",
      "input.float",
      "ta.sma",
      "chart.point",
      "color.rgb",
      "math.random",
      "color.new",
      "math.max",
      "box.new",
      "indicator",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-307",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "// This does not affect the coordinates of previous boxes.\n            topLeft.price     := hl2 + newRange\n            bottomRight.price := hl2 - newRange\n\n            // Draw a new box using the updated `topLeft` and `bottomRight` points.\n            box.new(topLeft, bottomRight, borderColor, 2, bgcolor = bgColor)\nNote that:\n\nThe indicator() function call uses max_boxes_count = 500, meaning the script can display up to 500 boxes on the chart.\nEach drawing has a right index length bars beyond the left index. Since the x-coordinates of these drawings can be up to 500 bars into the future, we‚Äôve set the maxval of the length input to 500.\nOn each new period, the script uses randomized color.rgb() values for the border_color and bgcolor of the boxes.\nEach box.new() call copies the coordinates from the chart.point objects assigned to the topLeft and bottomRight variables, which is why the script can modify their price fields on each loop iteration without affecting the other boxes.\nCloning boxes\nTo clone a specific box id, use box.copy(). This function copies the box and its properties. Any changes to the copied box do not affect the original.\n\nFor example, this script declares an originalBox variable on the first bar and assigns a new box reference to it once every length bars. On other bars, it uses box.copy() to create a copy of the box, assigns that copy to the copiedBox variable, then calls box.set_*() functions to modify the copy‚Äôs properties. As shown on the chart below, changes to the copied box do not modify the box referenced by originalBox:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Cloning boxes demo\", overlay = true, max_boxes_count = 500)\n\n//@variable The number of bars between each new mainLine assignment.\nint length = input.int(20, \"Length\", 2)\n\n//@variable The `chart.point` for the top-left of the `originalBox`. Contains `time` and `index` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right of the `originalBox`. Does not contain `time` information.\nbottomRight = chart.point.from_index(bar_index + 1, low)\n\n//@variable A new box with `topLeft` and `bottomRight` corners on every `length` bars.\nvar box originalBox = na\n\n//@variable Is teal when the bar is rising, maroon when it's falling.\ncolor originalColor = close > open ? color.teal : color.maroon\n\nif bar_index % length == 0\n    // Assign a new box using the `topLeft` and `bottomRight` info to the `originalBox`.\n    // This box uses the `index` fields from the points as x-coordinates.\n    originalBox := box.new(topLeft, bottomRight, originalColor, 2, bgcolor = color.new(originalColor, 60))\nelse\n    //@variable A clone of the `originalBox`.\n    box copiedBox = box.copy(originalBox)\n    // Modify the `copiedBox`. These changes do not affect the `originalBox`.",
    "keywords": [
      "box.new",
      "color.rgb",
      "chart.point",
      "box.copy",
      "box.set_",
      "input.int",
      "color.teal",
      "color.maroon",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "bgcolor",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-308",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "box.set_top(copiedBox, high)\n    box.set_bottom_right_point(copiedBox, bottomRight)\n    box.set_border_color(copiedBox, color.gray)\n    box.set_border_width(copiedBox, 1)\n    box.set_bgcolor(copiedBox, na)\nDeleting boxes\nTo delete boxes drawn by a script, use box.delete(). As with *.delete() functions in other drawing namespaces, this function is handy for conditionally removing boxes or maintaining a specific number of boxes on the chart.\n\nThis example displays boxes representing periodic cumulative volume values. The script creates a new box ID and stores it in a boxes array once every length bars. If the array‚Äôs size exceeds the numberOfBoxes value, the script removes the oldest box from the array using array.shift() and deletes it using box.delete().\n\nOn other bars, it accumulates volume over each period by modifying the top property of the last box in the boxes array. The script then uses `for` loops to find the highestTop of all the array‚Äôs boxes and set the bgcolor of each box with a gradient color created using color.from_gradient() based on its box.get_top() value relative to the highestTop:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\n\n//@variable The maximum number of boxes to show on the chart.\nconst int MAX_BOXES_COUNT = 500\n\nindicator(\"Deleting boxes demo\", \"Cumulative volume boxes\", format = format.volume, max_boxes_count = MAX_BOXES_COUNT)\n\n//@variable The number of bars in each period.\nint length = input.int(20, \"Length\", 1)\n//@variable The maximum number of volume boxes in the calculation.\nint numberOfBoxes = input.int(10, \"Number of boxes\", 1, MAX_BOXES_COUNT)\n\n//@variable An array containing the ID of each box displayed by the script.\nvar boxes = array.new<box>()\n\nif bar_index % length == 0\n    // Push a new box into the `boxes` array. The box has the default `xloc.bar_index` property.\n    boxes.push(box.new(bar_index, 0, bar_index + 1, 0, #000000, 2, text_color = #000000))\n    // Shift the oldest box out of the array and delete it when the array's size exceeds the `numberOfBoxes`.\n    if boxes.size() > numberOfBoxes\n        box.delete(boxes.shift())\n\n//@variable The last box drawn by the script as of the current chart bar.\nbox lastBox = boxes.last()\n// Add the current bar's volume to the top of the `lastBox` and update the `right` index.\nlastBox.set_top(lastBox.get_top() + volume)\nlastBox.set_right(bar_index + 1)\n// Display the top of the `lastBox` as volume-formatted text.\nlastBox.set_text(str.tostring(lastBox.get_top(), format.volume))\n\n//@variable The highest `top` of all boxes in the `boxes` array.\nfloat highestTop = 0.0\nfor id in boxes\n    highestTop := math.max(id.get_top(), highestTop)\n\n// Set the `bgcolor` of each `id` in `boxes` with a gradient based on the ratio of its `top` to the `highestTop`.\nfor id in boxes\n    id.set_bgcolor(color.from_gradient(id.get_top() / highestTop, 0, 1, color.purple, color.orange))",
    "keywords": [
      "box.set_top",
      "box.set_bottom_right_point",
      "box.set_border_color",
      "color.gray",
      "box.set_border_width",
      "box.set_bgcolor",
      "box.delete",
      "array.shift",
      "color.from_gradient",
      "box.get_top",
      "format.volume",
      "input.int",
      "array.new",
      "xloc.bar_index",
      "boxes.push",
      "box.new",
      "boxes.size",
      "boxes.shift",
      "boxes.last",
      "str.tostring",
      "math.max",
      "id.get_top",
      "id.set_bgcolor",
      "color.purple",
      "color.orange",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-309",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "Note that:\n\nAt the top of the code, we‚Äôve declared a MAX_BOXES_COUNT variable with the ‚Äúconst int‚Äù qualified type. We use this value as the max_boxes_count in the indicator() function and the maximum possible value of the numberOfBoxes input.\nThis script uses the second overload of the box.new() function, which specifies the box‚Äôs left, top, right, and bottom coordinates separately.\nWe‚Äôve included format.volume as the format argument in the indicator() call, which tells the script that the y-axis of the chart pane represents volume values. Each box also displays its top coordinate as volume-formatted text.\nPolylines\nPine Script polylines are advanced drawings that sequentially connect the coordinates from an array of chart.point instances using straight or curved line segments.\n\nThese powerful drawings can connect up to 10,000 points at any available location on the chart, allowing scripts to draw custom series, polygons, and other complex geometric formations that are otherwise difficult or impossible to draw using line or box objects.\n\nThe polyline.* namespace features the following built-ins for creating and managing polyline objects:\n\nThe polyline.new() function creates a new polyline instance.\nThe polyline.delete() function deletes an existing polyline instance.\nThe polyline.all variable references a read-only array containing the IDs of all polylines displayed by the script. The array‚Äôs size depends on the max_polylines_count of the indicator() or strategy() declaration statement and the number of polylines drawn by the script.\nUnlike lines or boxes, polylines do not have functions for modification or reading their properties. To redraw a polyline on the chart, one can delete the existing instance and create a new polyline with the desired changes.\n\nCreating polylines\nThe polyline.new() function creates a new polyline instance to display on the chart. It has the following signature:\n\npolyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width, force_overlay) ‚Üí series polyline\nThe following eight parameters affect the behavior of a polyline drawing:\n\npoints\n\nAccepts an array of chart.point objects that determine the coordinates of each point in the polyline. The drawing connects the coordinates from each element in the array sequentially, starting from the first. Whether the polyline uses the index or time field from each chart point for its x-coordinates depends on the xloc value in the function call.\n\ncurved\n\nSpecifies whether the drawing uses curved line segments to connect each chart.point in the points array. The default value is false, meaning it uses straight line segments.\n\nclosed\n\nControls whether the polyline will connect the last chart.point in the points array to the first, forming a closed polyline. The default value is false.",
    "keywords": [
      "box.new",
      "format.volume",
      "chart.point",
      "polyline.new",
      "polyline.delete",
      "polyline.all",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "fill",
      "var",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-310",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "xloc\n\nSpecifies which field from each chart.point in the points array the polyline uses for its x-coordinates. When its value is xloc.bar_index, the function uses the index fields to create the polyline. When its value is xloc.bar_time, the function uses the time fields. The default value is xloc.bar_index.\n\nline_color\n\nSpecifies the color of all line segments in the polyline drawing. The default is color.blue.\n\nfill_color\n\nControls the color of the closed space filled by the polyline drawing. Its default value is na.\n\nline_style\n\nSpecifies the style of the polyline, which can be any of the available options in the Line styles section of this page. The default is line.style_solid.\n\nline_width\n\nSpecifies the width of the polyline, in pixels. The default value is 1.\n\nforce_overlay\n\nIf true, the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is false.\n\nThis script demonstrates a simple example of drawing a polyline on the chart. It uses array.push to push the reference of a new chart.point object with an alternating price value into a points array and colors the background with bgcolor() once every length bars.\n\nOn the last confirmed historical bar, where barstate.islastconfirmedhistory is true, the script creates a new polyline with polyline.new(). The polyline drawing passes through the coordinates of each chart point in the points array in order, starting from the first point:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Creating polylines demo\", \"Oscillating polyline\")\n\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n\n//@variable The y-coordinate of each point in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n\n//@variable Is `true` once every `length` bars, `false` otherwise.\nbool newPoint = bar_index % length == 0\n\nif newPoint\n    // Push a new `chart.point` into the `points`. The new point contains `time` and `index` info.\n    points.push(chart.point.now(yValue))\n    // Change the sign of the `yValue`.\n    yValue *= -1\n\n// Draw a new `polyline` on the last confirmed historical chart bar.\n// The polyline uses the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\n    polyline.new(points, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nNote that:\n\nThis script uses only one polyline to connect each chart point from the array with straight line segments, and this drawing spans throughout the available chart data, starting from the first bar.",
    "keywords": [
      "chart.point",
      "xloc.bar_index",
      "xloc.bar_time",
      "color.blue",
      "line.style_solid",
      "array.push",
      "barstate.islastconfirmedhistory",
      "polyline.new",
      "input.int",
      "array.new",
      "points.push",
      "color.new",
      "color.gray",
      "indicator",
      "overlay",
      "input",
      "fill",
      "bgcolor",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-311",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "While one can achieve a similar effect using lines, doing so would require a new line instance on each occurrence of the newPoint condition, and such a drawing would be limited to a maximum of 500 line segments. This single unclosed polyline drawing, on the other hand, can contain up to 9,999 line segments.\nCurved drawings\nPolylines can draw curves that are otherwise impossible to produce with lines or boxes. When enabling the curved parameter of the polyline.new() function, the resulting polyline interpolates nonlinear values between the coordinates from each chart.point in its array of points to generate a curvy effect.\n\nFor instance, the ‚ÄúOscillating polyline‚Äù script in our previous example uses straight line segments to produce a drawing resembling a triangle wave, meaning a waveform that zig-zags between its peaks and valleys. If we set the curved parameter in the polyline.new() call from that example to true, the resulting drawing would connect the points using curved segments, producing a smooth, nonlinear shape similar to a sine wave:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Curved drawings demo\", \"Smooth oscillating polyline\")\n\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n\n//@variable The y-coordinate of each point in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n\n//@variable Is `true` once every `length` bars, `false` otherwise.\nbool newPoint = bar_index % length == 0\n\nif newPoint\n    // Push a new `chart.point` into the `points`. The new point contains `time` and `index` info.\n    points.push(chart.point.now(yValue))\n    // Change the sign of the `yValue`.\n    yValue *= -1\n\n// Draw a new curved `polyline` on the last confirmed historical chart bar.\n// The polyline uses the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\n    polyline.new(points, curved = true, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nNotice that in this example, the smooth curves have relatively consistent behavior, and no portion of the drawing extends past its defined coordinates, which is not always the case when drawing curved polylines. The data used to construct a polyline heavily impacts the smooth, piecewise function it interpolates between its points. In some cases, the interpolated curve can reach beyond its actual coordinates.\n\nLet‚Äôs add some variation to the chart points in our example‚Äôs points array to demonstrate this behavior. In the version below, the script multiplies yValue by a pseudorandom value in each chart.point.now() call.",
    "keywords": [
      "polyline.new",
      "chart.point",
      "input.int",
      "array.new",
      "points.push",
      "barstate.islastconfirmedhistory",
      "xloc.bar_time",
      "color.new",
      "color.gray",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "const",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-312",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "To visualize the behavior, this script also creates a horizontal line at the price value from each chart.point instance in the points array, and it displays another polyline connecting the same points with straight line segments. As we see on the chart, both polylines pass through all coordinates from the points array. However, the curvy polyline occasionally reaches beyond the vertical boundaries indicated by the horizontal lines, whereas the polyline drawn using straight segments does not:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Curved drawings demo\", \"Random oscillating polylines\")\n\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n\n//@variable The sign of each `price` in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n\n//@variable Is `true` once every `length` bars.\nbool newPoint = bar_index % length == 0\n\nif newPoint\n    // Push a new `chart.point` with a randomized `price` into the `points`.\n    // The new point contains `time` and `index` info.\n    points.push(chart.point.now(yValue * math.random()))\n    // Change the sign of the `yValue`.\n    yValue *= -1\n\n    //@variable The newest `chart.point`.\n    lastPoint = points.last()\n    // Draw a horizontal line at the `lastPoint.price`. This line uses the default `xloc.bar_index`.\n    line.new(lastPoint.index - length, lastPoint.price, lastPoint.index + length, lastPoint.price, color = color.red)\n\n// Draw two `polyline` instances on the last confirmed chart bar.\n// Both polylines use the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\n    polyline.new(points, curved = false, xloc = xloc.bar_time, line_color = #EB8A3B, line_width = 2)\n    polyline.new(points, curved = true, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nClosed shapes\nSince a single polyline can contain numerous straight or curved line segments, and the closed parameter allows the drawing to connect the coordinates from the first and last chart.point in its array of points, programmers can use polylines to draw many different types of closed polygonal shapes.\n\nLet‚Äôs draw some polygons in Pine. The following script periodically draws randomized polygons centered at hl2 price values.\n\nOn each occurrence of the newPolygon condition, the script clears the points array with array.clear(), calculates numberOfSides and rotationOffset values based on values from math.random() calls, then uses a `for` loop to push numberOfSides new chart points into the array. The chart points contain stepped coordinates from an elliptical path with xScale and yScale semi-axes. The script draws the polygon by connecting each point from the points array using a closed polyline with straight line segments:",
    "keywords": [
      "chart.point",
      "input.int",
      "array.new",
      "points.push",
      "math.random",
      "points.last",
      "xloc.bar_index",
      "line.new",
      "color.red",
      "barstate.islastconfirmedhistory",
      "polyline.new",
      "xloc.bar_time",
      "color.new",
      "color.gray",
      "array.clear",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-313",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "image\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Closed shapes demo\", \"N-sided polygons\", true)\n\n//@variable The size of the horizontal semi-axis.\nfloat xScale = input.float(3.0, \"X scale\", 1.0)\n//@variable The size of the vertical semi-axis.\nfloat yScale = input.float(1.0, \"Y scale\") * ta.atr(2)\n\n//@variable An array of `chart.point` objects containing vertex coordinates.\nvar points = array.new<chart.point>()\n\n//@variable The condition that triggers a new polygon drawing. Based on the horizontal axis to prevent overlaps.\nbool newPolygon = bar_index % int(math.round(2 * xScale)) == 0 and barstate.isconfirmed\n\nif newPolygon\n    // Clear the `points` array.\n    points.clear()\n\n    //@variable The number of sides and vertices in the new polygon.\n    int numberOfSides = int(math.random(3, 7))\n    //@variable A random rotation offset applied to the new polygon, in radians.\n    float rotationOffset = math.random(0.0, 2.0) * math.pi\n    //@variable The size of the angle between each vertex, in radians.\n    float step = 2 * math.pi / numberOfSides\n\n    //@variable The counter-clockwise rotation angle of each vertex.\n    float angle = rotationOffset\n\n    for i = 1 to numberOfSides\n        //@variable The approximate x-coordinate from an ellipse at the `angle`, rounded to the nearest integer.\n        int xValue = int(math.round(xScale * math.cos(angle))) + bar_index\n        //@variable The y-coordinate from an ellipse at the `angle`.\n        float yValue = yScale * math.sin(angle) + hl2\n\n        // Push a new `chart.point` containing the `xValue` and `yValue` into the `points` array.\n        // The new point does not contain `time` information.\n        points.push(chart.point.from_index(xValue, yValue))\n        // Add the `step` to the `angle`.\n        angle += step\n\n    // Draw a closed polyline connecting the `points`.\n    // The polyline uses the `index` field from each `chart.point` in the `points` array.\n    polyline.new(\n         points, closed = true, line_color = color.navy, fill_color = color.new(color.orange, 50), line_width = 3\n     )\nNote that:\n\nThis example shows the last ~50 polylines on the chart, as we have not specified a max_polylines_count value in the indicator() function call.\nThe yScale calculation multiplies an input.float() by ta.atr(2) to adapt the vertical scale of the drawings to recent price ranges.\nThe resulting polygons have a maximum width of twice the horizontal semi-axis (2 * xScale), rounded to the nearest integer. The newPolygon condition uses this value to prevent the polygon drawings from overlapping.\nThe script rounds the xValue calculation to the nearest integer because the index field of a chart.point only accepts an int value, as the x-axis of the chart does not include fractional bar indices.\nDeleting polylines\nTo delete a specific polyline, use polyline.delete(). This function removes the polyline object from the script and its drawing on the chart.",
    "keywords": [
      "input.float",
      "ta.atr",
      "chart.point",
      "array.new",
      "math.round",
      "barstate.isconfirmed",
      "points.clear",
      "math.random",
      "math.pi",
      "math.cos",
      "math.sin",
      "points.push",
      "polyline.new",
      "color.navy",
      "color.new",
      "color.orange",
      "polyline.delete",
      "indicator",
      "input",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-314",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "As with other drawing objects, we can use polyline.delete() to maintain a specific number of polyline drawings or conditionally remove drawings from a chart.\n\nFor example, the script below periodically draws approximate arithmetic spirals and stores their polyline references in an array, which it uses as a queue to manage the number of drawings it displays.\n\nWhen the newSpiral condition occurs, the script creates a points array and adds chart points within a `for` loop. On each loop iteration, it calls the spiralPoint() user-defined function to create a new chart.point containing stepped values from an elliptical path that grows with respect to the angle value. The script then creates a randomly colored curved polyline connecting the coordinates from the points and pushes its reference into the polylines array.\n\nWhen the array‚Äôs size exceeds the numberOfSpirals value, the script removes the oldest polyline reference using array.shift() and deletes the object using polyline.delete():\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\n\n//@variable The maximum number of polylines allowed on the chart.\nconst int MAX_POLYLINES_COUNT = 100\n\nindicator(\"Deleting polylines example\", \"Spirals\", true, max_polylines_count = MAX_POLYLINES_COUNT)\n\n//@variable The number of spiral drawings on the chart.\nint numberOfSpirals = input.int(10, \"Spirals shown\", 1, MAX_POLYLINES_COUNT)\n//@variable The number of full spiral rotations to draw.\nint rotations = input.int(5, \"Rotations\", 1)\n//@variable The scale of the horizontal semi-axis.\nfloat xScale = input.float(1.0, \"X scale\")\n//@variable The scale of the vertical semi-axis.\nfloat yScale = input.float(0.2, \"Y scale\") * ta.atr(2)\n\n//@function Calculates an approximate point from an elliptically-scaled arithmetic spiral.\n//@returns  A `chart.point` with `index` and `price` information.\nspiralPoint(float angle, int xOffset, float yOffset) =>\n    result = chart.point.from_index(\n         int(math.round(angle * xScale * math.cos(angle))) + xOffset,\n         angle * yScale * math.sin(angle) + yOffset\n     )\n\n//@variable An array of polylines.\nvar polylines = array.new<polyline>()\n\n//@variable The condition to create a new spiral.\nbool newSpiral = bar_index % int(math.round(4 * math.pi * rotations * xScale)) == 0\n\nif newSpiral\n    //@variable An array of `chart.point` objects for the `spiral` drawing.\n    points = array.new<chart.point>()\n    //@variable The counter-clockwise angle between calculated points, in radians.\n    float step = math.pi / 2\n    //@variable The rotation angle of each calculated point on the spiral, in radians.\n    float theta = 0.0\n    // Loop to create the spiral's points. Creates 4 points per full rotation.\n    for i = 0 to rotations * 4\n        //@variable A new point on the calculated spiral.\n        chart.point newPoint = spiralPoint(theta, bar_index, ohlc4)",
    "keywords": [
      "polyline.delete",
      "chart.point",
      "array.shift",
      "input.int",
      "input.float",
      "ta.atr",
      "math.round",
      "math.cos",
      "math.sin",
      "array.new",
      "math.pi",
      "indicator",
      "input",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-315",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "// Add the `newPoint` to the `points` array.\n        points.push(newPoint)\n        // Add the `step` to the `theta` angle.\n        theta += step\n\n    //@variable A random color for the new `spiral` drawing.\n    color spiralColor = color.rgb(math.random(150, 255), math.random(0, 100), math.random(150, 255))\n    //@variable A new polyline connecting the spiral points. Uses the `index` field from each point as x-coordinates.\n    polyline spiral = polyline.new(points, true, line_color = spiralColor, line_width = 3)\n\n    // Push the new `spiral` into the `polylines` array.\n    polylines.push(spiral)\n    // Shift the first polyline out of the array and delete it when the array's size exceeds the `numberOfSpirals`.\n    if polylines.size() > numberOfSpirals\n        polyline.delete(polylines.shift())\n\n// Highlight the background when `newSpiral` is `true`.\nbgcolor(newSpiral ? color.new(color.blue, 70) : na, title = \"New drawing highlight\")\nNote that:\n\nWe declared a MAX_POLYLINES_COUNT global variable with a constant value of 100. The script uses this constant as the max_polylines_count value in the indicator() function and the maxval of the numberOfSpirals input.\nAs with our ‚ÄúN-sided polygons‚Äù example in the previous section, we round the calculation of x-coordinates to the nearest integer since the index field of a chart.point can only accept an int value.\nDespite the smooth appearance of the drawings, each polyline‚Äôs points array only contains four chart.point objects per spiral rotation. Since the polyline.new() call includes curved = true, each polyline uses smooth curves to connect their points, producing a visual approximation of the spiral‚Äôs actual curvature.\nThe width of each spiral is approximately 4 * math.pi * rotations * xScale, rounded to the nearest integer. We use this value in the newSpiral condition to space each drawing and prevent overlaps.\nRedrawing polylines\nIt may be desirable in some cases to change a polyline drawing throughout a script‚Äôs execution. While the polyline.* namespace does not contain built-in setter functions, we can redraw polylines referenced by variables or collections by deleting the existing polylines and assigning new instances with the desired changes.\n\nThe following example uses polyline.delete() and polyline.new() calls to update the value of a polyline variable.\n\nThis script draws closed polylines that connect the open, high, low, and close points of periods containing length bars. It creates a currentDrawing variable on the first bar and assigns a polyline reference to it on every chart bar. It uses the openPoint, highPoint, lowPoint, and closePoint variables to reference chart points that track the period‚Äôs developing OHLC values. As new values emerge, the script assigns new chart.point objects to the variables, collects them in an array using array.from(), then creates a new polyline connecting the coordinates from the array‚Äôs points with polyline.new().",
    "keywords": [
      "points.push",
      "color.rgb",
      "math.random",
      "polyline.new",
      "polylines.push",
      "polylines.size",
      "polyline.delete",
      "polylines.shift",
      "color.new",
      "color.blue",
      "chart.point",
      "math.pi",
      "array.from",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "const",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-316",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "When the newPeriod condition is false (i.e., the current period is not complete), the script deletes the polyline referenced by the currentDrawing variable before creating a new one, resulting in a dynamic drawing that changes over the developing period:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Redrawing polylines demo\", \"OHLC polygons\", true, max_polylines_count = 100)\n\n//@variable The length of the period.\nint length = input.int(100, \"Length\", 1)\n\n//@variable A `chart.point` representing the start of each period.\nvar chart.point openPoint = na\n//@variable A `chart.point` representing the highest point of each period.\nvar chart.point highPoint = na\n//@variable A `chart.point` representing the lowest point of each period.\nvar chart.point lowPoint = na\n//@variable A `chart.point` representing the current bar's closing point.\nclosePoint = chart.point.now(close)\n\n//@variable The current period's polyline drawing.\nvar polyline currentDrawing = na\n\n//@variable Is `true` once every `length` bars.\nbool newPeriod = bar_index % length == 0\n\nif newPeriod\n    // Assign new chart points to the `openPoint`, `highPoint`, and `closePoint`.\n    openPoint := chart.point.now(open)\n    highPoint := chart.point.now(high)\n    lowPoint  := chart.point.now(low)\nelse\n    // Assign a new `chart.point` to the `highPoint` when the `high` is greater than its `price`.\n    if high > highPoint.price\n        highPoint := chart.point.now(high)\n    // Assign a new `chart.point` to the `lowPoint` when the `low` is less than its `price`.\n    if low < lowPoint.price\n        lowPoint := chart.point.now(low)\n\n//@variable Is teal when the `closePoint.price` is greater than the `openPoint.price`, maroon otherwise.\ncolor drawingColor = closePoint.price > openPoint.price ? color.teal : color.maroon\n\n// Delete the polyline assigned to the `currentDrawing` if it's not a `newPeriod`.\nif not newPeriod\n    polyline.delete(currentDrawing)\n// Assign a new polyline to the `currentDrawing`.\n// Uses the `index` field from each `chart.point` in its array as x-coordinates.\ncurrentDrawing := polyline.new(\n     array.from(openPoint, highPoint, closePoint, lowPoint), closed = true,\n     line_color = drawingColor, fill_color = color.new(drawingColor, 60)\n )\nRealtime behavior\nLines, boxes, and polylines are subject to both commit and rollback actions, which affect the behavior of a script when it executes on a realtime bar. See the page on Pine Script‚Äôs Execution model.\n\nThis script demonstrates the effect of rollback when it executes on the realtime, unconfirmed chart bar:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Realtime behavior demo\", overlay = true)\n\n//@variable Is orange when the `line` is subject to rollback and gray after the `line` is committed.\ncolor lineColor = barstate.isconfirmed ? color.gray : color.orange",
    "keywords": [
      "i.e",
      "input.int",
      "chart.point",
      "color.teal",
      "color.maroon",
      "polyline.delete",
      "polyline.new",
      "array.from",
      "color.new",
      "barstate.isconfirmed",
      "color.gray",
      "color.orange",
      "indicator",
      "overlay",
      "input",
      "fill",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-317",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "line.new(bar_index, hl2, bar_index + 1, hl2, color = lineColor, width = 4)\nThe line.new() call in this example creates a new line ID on each iteration when values change on the unconfirmed bar. The script automatically deletes the objects created on each change in that bar because of the rollback before each iteration. It only commits the last line created before the bar closes, and that line instance is the one that persists on the confirmed bar.\n\nLimitations\nTotal number of objects\nLines, boxes, and polylines consume server resources, which is why there are limits on the total number of drawings per script. When a script creates more drawing objects than the allowed limit, the Pine Script runtime automatically deletes the oldest ones in a process referred to as garbage collection.\n\nA single script can contain up to 500 lines, 500 boxes, and 100 polylines. Users can control the garbage collection limits by specifying the max_lines_count, max_boxes_count, and max_polylines_count values in their script‚Äôs indicator() or strategy() declaration statement.\n\nThis script demonstrates how garbage collection works in Pine. It creates a new line, box, and polyline on each chart bar. We haven‚Äôt specified values for the max_lines_count, max_boxes_count, or max_polylines_count parameters in the indicator() function call, so the script will maintain the most recent ~50 lines, boxes, and polylines on the chart, as this is the default setting for each parameter:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Garbage collection demo\", overlay = true)\n\n//@variable A new `chart.point` at the current `bar_index` and `high`.\nfirstPoint = chart.point.now(high)\n//@variable A new `chart.point` one bar into the future at the current `low`.\nsecondPoint = chart.point.from_index(bar_index + 1, low)\n//@variable A new `chart.point` one bar into the future at the current `high`.\nthirdPoint = chart.point.from_index(bar_index + 1, high)\n\n// Draw a new `line` connecting the `firstPoint` to the `secondPoint`.\nline.new(firstPoint, secondPoint, color = color.red, width = 2)\n// Draw a new `box` with the `firstPoint` top-left corner and `secondPoint` bottom-right corner.\nbox.new(firstPoint, secondPoint, color.purple, 2, bgcolor = na)\n// Draw a new `polyline` connecting the `firstPoint`, `secondPoint`, and `thirdPoint` sequentially.\npolyline.new(array.from(firstPoint, secondPoint, thirdPoint), true, line_width = 2)\nNote that:\n\nWe‚Äôve used TradingView‚Äôs ‚ÄúMeasure‚Äù drawing tool to measure the number of bars covered by the script‚Äôs drawing objects.\nPast and future references with ‚Äãxloc.bar_index‚Äã\nObjects positioned using xloc.bar_index can contain x-coordinates no further than 500 bars into the future or 10,000 bars into the past.\n\nOther contexts\nScripts cannot use lines, boxes, or polylines in request.*() functions. Instances of these types can use the values from request.*() calls, but scripts can only create and draw them in the chart‚Äôs context.",
    "keywords": [
      "line.new",
      "chart.point",
      "color.red",
      "box.new",
      "color.purple",
      "polyline.new",
      "array.from",
      "xloc.bar_index",
      "indicator",
      "strategy",
      "overlay",
      "bgcolor",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-318",
    "type": "documentation",
    "source": "visuals/lines_and_boxes.md",
    "section": "visuals",
    "title": "lines_and_boxes",
    "content": "This limitation is also why drawing objects will not work when using the timeframe parameter in the indicator() declaration statement.\n\nHistorical buffer and ‚Äãmax_bars_back‚Äã\nUsing barstate.isrealtime in combination with drawings may sometimes produce unexpected results. For example, the intention of this script is to ignore all historical bars and draw horizontal lines spanning 300 bars back on realtime bars:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Historical buffer demo\", overlay = true)\n\n//@variable A `chart.point` at the `bar_index` from 300 bars ago and current `close`.\nfirstPoint = chart.point.from_index(bar_index[300], close)\n//@variable The current bar's `chart.point` containing the current `close`.\nsecondPoint = chart.point.now(close)\n\n// Draw a new line on realtime bars.\nif barstate.isrealtime\n    line.new(firstPoint, secondPoint)\nHowever, it will fail at runtime and raise an error. The script fails because it cannot determine the buffer size for historical values of the underlying time series. Although the code doesn‚Äôt contain the built-in time variable, the built-in bar_index uses the time series in its inner workings. Therefore, accessing the value of the bar_index from 300 bars back requires the history buffer of the time series to be at least 300 bars.\n\nPine Script includes a mechanism that detects the required historical buffer size automatically in most cases. It works by letting the script access historical values any number of bars back for a limited duration. In this script‚Äôs case, using barstate.isrealtime to control the drawing of lines prevents it from accessing the historical series, so it cannot infer the required historical buffer size, and the script fails.\n\nThe simple solution to this issue is to use the max_bars_back() function to explicitly define the historical buffer of the time series before evaluating the conditional structure:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Historical buffer demo\", overlay = true)\n\n//@variable A `chart.point` at the `bar_index` from 300 bars ago and current `close.\nfirstPoint = chart.point.from_index(bar_index[300], close)\n//@variable The current bar's `chart.point` containing the current `close`.\nsecondPoint = chart.point.now(close)\n\n// Explicitly set the historical buffer of the `time` series to 300 bars.\nmax_bars_back(time, 300)\n\n// Draw a new line on realtime bars.\nif barstate.isrealtime\n    line.new(firstPoint, secondPoint)\nSuch issues can be confusing, but they‚Äôre quite rare. The Pine Script team hopes to eliminate them over time.",
    "keywords": [
      "barstate.isrealtime",
      "chart.point",
      "line.new",
      "indicator",
      "overlay",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-319",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Overview\nIntroduction\nWell-designed visuals make indicators and strategies easier to use and less cluttered. Each visual element presents data differently:\n\nPlot visuals include all plot*() functions, horizontal levels, background and bar coloring, and fills.\nDrawing visuals include lines, polylines, linefills, boxes, labels, and tables.\nScripts can configure where and how the visual elements appear by using the script-wide visual settings.\n\nBy understanding when to use each tool effectively, programmers can pick the best visual for the task to make the most of the power of Pine Script¬Æ.\n\nNote\nUsers can draw directly on TradingView charts using the Drawing Tools. While such drawings might sometimes resemble visuals created by Pine scripts, they are unrelated entities. Pine scripts cannot interact with drawing tools from the chart interface, and cursor actions do not modify Pine drawing objects.\n\nThis page describes plots and drawings, and what their differences are. It includes all the available visual constructs and examples of their use in built-in indicators (for more details about a specific visual element, refer to its User Manual page).\n\nScript-wide visual settings\nSome visual settings control how all of the script‚Äôs outputs collectively appear on the chart, regardless of their individual properties. These script-wide visual settings are parameters in the indicator() or strategy() declaration statement.\n\n‚Äãoverlay‚Äã\nThe overlay parameter controls whether the script‚Äôs outputs appear in the main pane or a separate pane. By default, its value is false, so adding a script to the chart displays its visual outputs in a separate pane to the main chart series.\n\nWhereas the overlay parameter affects the script as a whole, the force_overlay parameter controls the pane location for individual elements. Using force_overlay = true displays the specified element in the main pane, even if the script‚Äôs overlay argument is false. This allows a script occupying a separate pane to overlay only some visuals on the main chart. The force_overlay parameter is available for all plot*() functions, bgcolor(), and all drawing *.new() constructor functions (box.new(), label.new(), etc.).\n\nFor example, the built-in Seasonality indicator uses overlay = false to display in a separate pane, where it displays its primary visual of a table, but draws boxes on the main chart with force_overlay = true:\n\nimage\n\n‚Äãscale‚Äã\nA script‚Äôs scale parameter specifies the y-axis scale that its pane visuals use. By default, scripts overlayed in the main pane use the existing chart scale (scale.none). Specifying a scale.right or scale.left argument in overlayed scripts generates a new scale distinct from the main chart‚Äôs price scale. Scripts displaying in a separate pane generate their own scale by default, which they can also set to the left or right position. For instance, this image shows an overlayed indicator using a distinct right-side scale, and a separate pane indicator using a left-side scale:",
    "keywords": [
      "box.new",
      "label.new",
      "scale.none",
      "scale.right",
      "scale.left",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "fill",
      "bgcolor",
      "series",
      "const",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-320",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "image\n\n‚Äãbehind_chart‚Äã\nThe behind_chart parameter specifies whether a script‚Äôs visuals appear behind or in front of the main chart series. By default, its value is true, so visuals overlayed in the main pane appear behind the chart bars. When behind_chart is false, visuals appear in front of the bars, which may obscure bars, depending on the type of visual and its color transparency:\n\nimage\n\nChanging settings\nTo adjust the visual settings of a script on the chart, click the ‚ÄúMore‚Äù menu (three dots icon) in the script‚Äôs status line. Options are available to adjust the script‚Äôs visual order, move it to another pane, and change its y-axis scale:\n\nimage\n\nNotice\nScripts evaluate the visual settings in the indicator() or strategy() declaration statement only once, when the script first loads on the chart. Updating parameters like overlay or scale in the code of a script instance that is already active on the chart does not update its existing display. Add a new script instance to the chart to apply updated visual settings.\n\nPlot visuals\nThe outputs of the following functions are classified as plot visuals:\n\nAll plot*() functions:\nData series plots using plot()\nShape plots using plotshape()\nCharacter plots using plotchar()\nArrow plots using plotarrow()\nBar plots using plotbar()\nCandle plots using plotcandle()\nBar coloring using barcolor()\nBackground coloring using bgcolor()\nHorizontal levels using hline()\nFills for plots and horizontal levels using fill()\nPlots are serial visuals that always return a result on each bar ‚Äî although the result can be na. One plot therefore forms a series. By contrast, drawing visuals instantiate individual objects. A single plot visual function call can display results on all the bars in the main series, no matter how many bars display in the series, while drawings adhere to a drawing limit of approximately ~500 objects.\n\nA script creates plot visuals sequentially as it executes across the chart bars, so it cannot draw them into the past or future all at once like drawings. For example, plot(close) plots the current close on the current bar. Pine‚Äôs execution model then repeats this for every bar in the dataset.\n\nScripts create plots with offsets in exactly the same way. They appear to end at past or future bars because the script executes the same plot call on each bar and simply displays each result the same fixed number of bars forwards or backwards.\n\nDisplay in other locations\nPlots can display results in locations other than the chart pane, unlike drawings. The last numeric value of a plot can display in the price scale. The script‚Äôs status line and the Data Window can display plot values for specific bars, and the values update as the user hovers over different bars:\n\nimage\n\nIn one script, plots can display their results in different places by using different arguments for the display parameter for each plot function. For example, a script can display one plot‚Äôs results in all locations, display another plot everywhere but the status line, and create a third plot with no visible display.",
    "keywords": [
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "barcolor",
      "series",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-321",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "The plot*() functions accept multiple display.* arguments and support addition and subtraction to combine arguments for further customization. Other, numerically simpler plot visuals like horizontal levels, fills, and coloring functions have only two display states: they either display a pane visual (display.all) or are hidden (display.none).\n\nThis simple demonstration script uses various plot visuals and display locations to plot the open and close prices, plot the difference between them (barCO), and to signal when that difference is greater than 5:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Plot visuals display demo\", overlay = false)\n\n//@variable The difference between the bar's `open` and `close` prices.  \nfloat barCO = close - open\n\n// Horizontal lines and fills have only two possible `display` states. \nh1 = hline(125, \"Level 125\", linewidth = 2, display = display.none)\nh2 = hline(100, \"Level 100\", linewidth = 2, display = display.all)\nfill(h1, h2, color = color.new(color.blue, 90), display = display.all)\n\n// `plot*()` visuals accept multiple `display` options and support addition and subtraction.\nplot(close, \"Close\", color.blue,   3, display = display.all)\nplot(open,  \"Open\",  color.orange, 3, display = display.all - display.pane)\nplotarrow(barCO, \"Bar CO\", color.green, color.red, display = display.status_line + display.data_window)\nplotshape(barCO > 5, \"Large CO\", shape.circle, location.abovebar, color.fuchsia, display = display.pane)\nNote that:\n\nAlthough there are no arrows visible in the script pane, the plotarrow() call still calculates and plots the barCO values on every bar, as indicated by the ‚ÄúBar CO‚Äù result in the Data Window and the matching green result in the status line.\nSince plotshape(barCO > 5) uses a ‚Äúbool‚Äù series, the plot‚Äôs numeric results can only be 1 or 0 on any bar. We set it to display only in the chart pane because that‚Äôs our most useful visual signal for this plot. Being selective with display options can help to keep results in any one location free from clutter.\nTip\nScripts can also use display.* arguments to show or hide input values next to the script title in the status line and Data Window.\n\nThe format and precision parameters of plot*() functions can further customize how numeric results appear in the status line, price scale, and Data Window. The format parameter specifies whether to format plot values as prices, percentages, or volume. The precision parameter specifies the number of decimal digits that plot values include for non-volume formats. See the `plot()` parameters section of the Plots page to learn more.\n\nAdditionally, users can manage whether numeric plot results are visible for a given indicator or chart by using settings at both the indicator and chart level, without editing any source code (see the Help Center article on how to hide values of indicators for more). An indicator‚Äôs settings control whether any plot values appear in that indicator‚Äôs status line and price scale. A chart‚Äôs settings control whether status line and price scale values appear at all in any indicators on that chart. Disabling the indicator settings overrides the script‚Äôs per-plot display properties, while the chart settings override both.",
    "keywords": [
      "display.all",
      "display.none",
      "color.new",
      "color.blue",
      "color.orange",
      "display.pane",
      "color.green",
      "color.red",
      "display.status_line",
      "display.data_window",
      "shape.circle",
      "location.abovebar",
      "color.fuchsia",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-322",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Users can also customize the visibility, color, and style of plot visuals without needing to create new inputs or edit the script. Settings are automatically generated in the indicator‚Äôs ‚ÄúStyle‚Äù tab for every plot visual in the script, regardless of their display state:\n\nimage\n\nNote that if the script generates any dynamic colors, the color pickers in the ‚ÄúStyle‚Äù settings do not display. See the Maintaining automatic color selectors section of the Colors page to learn more.\n\nThe display.* arguments represent the default state of the script‚Äôs plot visuals. Disabling a plot from the indicator‚Äôs ‚ÄúStyle‚Äù settings and then reactivating it causes the plot to revert to display.all, unless the indicator is reset to its default settings.\n\nTip\nTo prevent users from changing a plot‚Äôs properties from the script‚Äôs ‚ÄúSettings/Style‚Äù tab, set the plot*() call‚Äôs editable argument to false.\n\nThe ability to display outputs in several locations and to visually track a series across the chart bars makes plot visuals useful debugging tools. See the Plots and chart colors section of the Debugging page for more information.\n\nExternal uses: exports, alerts, and more\nUnlike drawings, plots have uses outside the script: exporting data, creating alerts, setting another indicator‚Äôs source input, and scanning watchlists using the Pine Screener.\n\nThese uses for plot results function regardless of a plot‚Äôs display.* state on the chart and do not require special code for the outputs. Indeed, when creating plots for use in alerts or data exports, using display.none can keep a script‚Äôs visuals clutter-free and avoid distorting the chart scale.\n\nUsers can export plots using the ‚ÄúExport chart data‚Äù feature, which generates a comma-separated values (CSV) file of the chart data (see the section on exporting indicator data to a file in the Indicators FAQ page). The exported data includes the symbol‚Äôs OHLC (open, high, low, and close) values and any numeric plot results generated by active scripts on the chart, including those displayed only in the Data Window or status line. Drawings and hidden scripts are excluded from exports.\n\nAn alert can use any plot*() call executing on the chart as its trigger condition. Users can create alerts based on plots even if the script does not include any alert-specific code such as alert() or alertcondition(). See the Help Center article on how to create alerts from the user interface. Users can also include the dynamic results from up to 20 plot*() series in an alert‚Äôs message using placeholders, as explained in the Help Center article on using variable values in alerts.\n\nA script can use plots that are output by other indicators on the chart as a source input. The input.source() function creates a ‚ÄúSource‚Äù dropdown in the script‚Äôs ‚ÄúInputs‚Äù settings, from which users can then select any plots displayed on the chart as the input source. Any calculated plots can act as source inputs even if they are hidden from the current chart display (e.g., the unseen plotarrow(barCO) plot from the example in the display in other locations section above, or any hidden indicators). Using a source input links both scripts, so changes to the original plot subsequently alter the input plot, and removing the source indicator from the chart removes the dependent script.",
    "keywords": [
      "display.all",
      "display.none",
      "input.source",
      "e.g",
      "indicator",
      "input",
      "plot",
      "alert",
      "alertcondition",
      "var",
      "series",
      "export",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-323",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "The Pine Screener uses an indicator‚Äôs plots to scan a watchlist of symbols. It generates columns showing the results of the indicator‚Äôs plot() and alertcondition() calls for each symbol. Users can also choose to filter screener results based on plot conditions. See this Help Center article on the Pine Screener to learn more.\n\nLimitations\nScripts can plot visuals only in the global scope. Unlike drawings, plots cannot be included in the local scopes of loops, conditional structures, or user-defined functions and methods, and plot calls can only accept variables and literals that are declared globally. However, a script can still create visuals that plot conditionally by using na values for a plot‚Äôs series or color arguments, thus hiding the plot on certain bars.\n\nWhile plot visuals are well suited for displaying dynamically-calculated series, those that support text, like plotshape() and plotchar(), cannot display dynamic text. The parameters of these functions accept ‚Äúconst string‚Äù arguments, so the same text displays on all the bars, and it cannot change during execution or be an input value, unlike the text supported in drawing visuals.\n\nPlots can be offset into the past or future, but only by a fixed number of bars. This makes plotted shapes, for example, suitable for marking Williams fractals, which confirm after a known number of bars, but unsuitable for marking more complex types of events that confirm after an arbitrary number of bars.\n\nEach script instance can create a maximum of 64 plots. Depending on the complexity of the plot and its arguments, one function call can count more than once towards the plot count limit. See the plot limits section of the Limitations page for more information.\n\nDrawing visuals\nPine drawings display in a script‚Äôs pane, and provide the flexibility to represent graphical data beyond plotting series. The following elements are classified as drawing visuals:\n\nLines\nPolylines\nLinefills\nBoxes\nLabels\nTables\nDrawings are objects, unlike plots, which are serial visuals, so calling a drawing function does not create a visual that always returns a persistent result on every bar in the dataset. Instead, a drawing function references one instance of a drawing object, which can be at an arbitrary location relative to the bar on which the script called the function.\n\nSince drawings are not serialized, scripts can call the same drawing function several times on one bar to create multiple drawings at different locations on the chart at once.\n\nEach drawing visual has its own namespace with built-in functions for creating and managing the drawing objects. Most drawing parameters accept ‚Äúseries‚Äù types, which allows the visuals to use dynamic positions, colors, styles, etc. Drawing parameters support input values and complex expressions as arguments, and can update these arguments as the script executes from bar to bar. Drawings like labels, boxes, and tables can also display dynamic text.",
    "keywords": [
      "indicator",
      "input",
      "plot",
      "fill",
      "alert",
      "alertcondition",
      "var",
      "series",
      "const",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-324",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Scripts can create and manage drawing visuals from local scopes, so programmers can include drawing calls in conditional structures, loops, and user-defined functions or methods, unlike plot calls. While scripts can call drawing functions globally, it‚Äôs rarely necessary to execute drawings on every bar. Further, because scripts that create drawing objects on each bar are likely to reach the limit for that drawing type, it‚Äôs more usual to create drawings in local scopes.\n\nThe ability of drawing functions to display dynamic data at any available chart location and to run in local scopes makes them useful debugging tools. See the Pine drawings section of the Debugging page for more information.\n\nDisplay and customization\nUnlike plots, drawings do not display in other locations ‚Äî they display a visual only in the chart pane. Therefore, they cannot show any numeric results in the script‚Äôs status line, price scale, or Data Window, or by hovering over the drawing. Likewise, using drawings in a script does not automatically generate color/style customization options in the indicator‚Äôs ‚ÄúStyle‚Äù tab.\n\nInstead, the ‚ÄúStyle‚Äù settings generate a checkbox for each drawing type used by a script, which toggles the visibility of all objects of that type in that indicator:\n\nimage\n\nHowever, since drawings accept ‚Äúseries‚Äù arguments, scripts can use inputs to create fully customizable drawing visuals. For example, this script uses string inputs, color inputs, and integer inputs to allow users to easily customize the appearance of the table and label visuals from the indicator‚Äôs ‚ÄúInputs‚Äù tab:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Customizable drawings demo\", overlay = true)\n\n// Input `group` headers to distinguish the table style inputs and the label style inputs.\nconst string G1 = \"Table Style\"\nconst string G2 = \"Label Style\"\n// Create user inputs for customizing `table` style (position, colors, text size).\nstring tbVerticalInput   = input.string(\"Top\", \"Position\", [\"Top\", \"Middle\", \"Bottom\"], inline = \"Pos\", group = G1)\nstring tbHorizontalInput = input.string(\"Right\", \"Center\", [\"Left\", \"Center\", \"Right\"], inline = \"Pos\", group = G1)\ncolor  tbBackgroundInput = input.color(#ffeb3bb3,  \"Background color\", inline = \"Col\", group = G1)\ncolor  tbBorderInput     = input.color(color.white,\"Border color\",     inline = \"Col\", group = G1)\nstring tbTextSizeInput   = input.string(size.large, \"Text size\", inline = \"Txt\", group = G1,\n     options = [size.tiny, size.small, size.normal, size.large, size.huge, size.auto])\ncolor tbTextColorInput = input.color(color.black, \"Text color\", inline = \"Txt\", group = G1)\n// Create user inputs for customizing `label` style (size, colors).\nint   lblSizeInput      = input.int(16, \"Label size\", minval = 0, inline = \"Lbl\", group = G2)\ncolor lblColorInput     = input.color(color.orange, \"Label color\", inline = \"Lbl\", group = G2)",
    "keywords": [
      "input.string",
      "input.color",
      "color.white",
      "size.large",
      "size.tiny",
      "size.small",
      "size.normal",
      "size.huge",
      "size.auto",
      "color.black",
      "input.int",
      "color.orange",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "const",
      "method",
      "type",
      "for",
      "while"
    ]
  },
  {
    "id": "doc-325",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "color lblTextColorInput = input.color(color.white, \"Text color\", group = G2)\n\n// On last confirmed bar, draw a table to show the `open` and `close` prices, and a label to show their difference.\nif barstate.islastconfirmedhistory\n    //@variable The table's `position` argument based on the values of `tbVerticalInput` and `tbHorizontalInput`.\n    string tbPos = switch\n        tbVerticalInput == \"Top\"    and tbHorizontalInput == \"Left\"   => position.top_left\n        tbVerticalInput == \"Top\"    and tbHorizontalInput == \"Center\" => position.top_center\n        tbVerticalInput == \"Top\"    and tbHorizontalInput == \"Right\"  => position.top_right\n        tbVerticalInput == \"Middle\" and tbHorizontalInput == \"Left\"   => position.middle_left\n        tbVerticalInput == \"Middle\" and tbHorizontalInput == \"Center\" => position.middle_center\n        tbVerticalInput == \"Middle\" and tbHorizontalInput == \"Right\"  => position.middle_right\n        tbVerticalInput == \"Bottom\" and tbHorizontalInput == \"Left\"   => position.bottom_left\n        tbVerticalInput == \"Bottom\" and tbHorizontalInput == \"Center\" => position.bottom_center\n        tbVerticalInput == \"Bottom\" and tbHorizontalInput == \"Right\"  => position.bottom_right\n    //@variable A table showing the last confirmed bar's `open` and `close` prices. Inputs customize the table's style.\n    var table displayTable = table.new(tbPos, 2, 2, tbBackgroundInput, border_color = tbBorderInput, border_width = 1) \n    displayTable.cell(0, 0, \"Open\",              text_color = tbTextColorInput, text_size = tbTextSizeInput)\n    displayTable.cell(1, 0, str.tostring(open),  text_color = tbTextColorInput, text_size = tbTextSizeInput)\n    displayTable.cell(0, 1, \"Close\",             text_color = tbTextColorInput, text_size = tbTextSizeInput)\n    displayTable.cell(1, 1, str.tostring(close), text_color = tbTextColorInput, text_size = tbTextSizeInput)\n    //@variable The label text, containing the difference between the bar's `open` and `close` prices.\n    string lblText = \"Bar body = \" + str.tostring(close - open)\n    label.new(bar_index, high, lblText, color = lblColorInput, textcolor = lblTextColorInput, size = lblSizeInput)\nLimitations\nThere are limits to the total number of drawing visuals a script can display on the chart. A single script instance can draw a maximum of approximately 500 lines, boxes, and labels, and a maximum of 100 polylines. If the number of drawings exceeds the limit, a garbage collection mechanism deletes the oldest drawings to keep only the most recent visuals on the chart.\n\nThe max_lines_count, max_boxes_count, max_labels_count, and max_polylines_count parameters in the indicator() or strategy() declaration statement control the total number of drawings the script can display for each object type. The default value for each max_*_count parameter is 50, so if a script does not specify this parameter, it displays the 50 most recent drawings of each type.",
    "keywords": [
      "input.color",
      "color.white",
      "barstate.islastconfirmedhistory",
      "position.top_left",
      "position.top_center",
      "position.top_right",
      "position.middle_left",
      "position.middle_center",
      "position.middle_right",
      "position.bottom_left",
      "position.bottom_center",
      "position.bottom_right",
      "table.new",
      "str.tostring",
      "label.new",
      "indicator",
      "strategy",
      "input",
      "var",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-326",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Most drawing types have x and y coordinates, so drawing objects move as the user scrolls the chart or zooms in or out. The only exception is tables, which are anchored to one of nine fixed positions in the pane itself. See the Tables section below for more details about their unique characteristics.\n\nThe leftmost (earliest) x coordinate of a drawing object can be no more than approximately 9999 bars before or 500 bars after the bar on which the script draws it. See this entry in the Techniques FAQ to learn how to work around this issue.\n\nUnlike plots, Pine drawings do not have external uses like creating alerts or exporting data.\n\nZ-index\nAll visual elements on the chart occupy a position along the z-axis, meaning that some elements appear on top of others. The z-index is a value that represents the relative position of elements on the z-axis. Elements with a higher z-index appear on top of elements with a lower z-index.\n\nPine elements are divided into z-index groups based on their visual type. Each group has its own position in the z-space, and within the same group, elements created last in the script‚Äôs logic appear on top of other elements from the same group.\n\nThis list orders the visual element groups by ascending z-index, i.e., background colors are always at the bottom of z-space, and tables always appear on top of all other elements:\n\nBackground colors\nFills\nPlots\nHorizontal levels\nLinefills\nLines\nBoxes\nLabels\nTables\nAn element cannot be placed outside the region of z-space that its group occupies ‚Äî for example, a plot can never appear on top of a table, because tables have the highest z-index. The sole exception to this rule is that programmers can choose to arrange plot*(), hline(), and fill() visuals (and only these types of visuals) in z-space in the order in which they appear in the script, by using explicit_plot_zorder = true in indicator() or strategy() declaration statements.\n\nWhen to use\nKnowing the strengths of each type of visual element, and how they compare to each other, helps programmers develop efficient scripts that look good. The sections below describe some useful features of each visual element and spotlight a few built-in use cases. For more details about a specific visual element, refer to its User Manual page.\n\n‚Äãplot()‚Äã\nThe plot() function displays a data series across the chart. A single plot() visual registers one value for every bar in the main series.\n\nUnlike line and polyline drawings, which connect two or more chart points independent of the bar series, each data point in a plot() series relates to a specific chart bar, and only one point can exist per bar within the same plot series. Plotted ‚Äúint‚Äù and ‚Äúfloat‚Äù series can represent a variety of constant values, inputs, built-in series like close, and dynamically-calculated results like ta.sma().",
    "keywords": [
      "i.e",
      "ta.sma",
      "indicator",
      "strategy",
      "input",
      "plot",
      "hline",
      "fill",
      "alert",
      "var",
      "series",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-327",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "The function offers multiple plot styles, including lines, step lines, histograms, areas, crosses, and circles (see the `plot()` parameters section of the Plots page for all available style options). Like other plot visuals, plot() outputs can display numeric results in locations other than the main chart pane, such as the status line, price scale, and Data Window.\n\nMost built-in indicators generate plots in their outputs, e.g., RSI, EMA, and Bollinger Bands. Indicators can use several plot styles in the same script to display different kinds of data simultaneously, like the MACD indicator does with its line and histogram plots:\n\nimage\n\nScripts can also use plot() to create horizontal levels in cases where the dedicated hline() function is not suitable, for example, to display a dynamically-calculated level, or to create a fill between a horizontal line and a fluctuating series.\n\nUnlike `plotshape()` and `plotchar()`, the plot() function cannot display text and doesn‚Äôt support ‚Äúbool‚Äù series. However, it can create conditional plots by setting the plot‚Äôs series values or colors to na on certain bars.\n\n‚Äãplotshape()‚Äã and ‚Äãplotchar()‚Äã\nThe plotshape() and plotchar() functions plot a series across the chart, like plot(), but using a wide range of shapes and characters.\n\nThe plotshape() function displays specific shape.* styles like crosses, circles, and triangles, while plotchar() displays any single alphanumeric or symbol Unicode character. See the table in the `plotshape()` section of the Text and shapes page for all available shape.* styles.\n\nLike other plot visuals, these plots are connected to the main series. They produce one plot value per bar, which can also appear in the status line and Data Window. Both functions accept ‚Äúint‚Äù and ‚Äúfloat‚Äù series, like plot(), and additionally support ‚Äúbool‚Äù series to display conditional plots.\n\nFor instance, the built-in Moon phases indicator uses plotshape() to conditionally draw circles above or below the chart bars, which represent when a new or full moon occurs:\n\nimage\n\nBoth plotshape() and plotchar() have several location options, which can use either relative or absolute chart positions:\n\nThey can plot graphics at absolute price positions, corresponding to each series value.\nThey can position graphics near each bar in the main series, either above or below the bars.\nThey can anchor graphics to the pane itself, either at the top or bottom of the pane.\nThe Moon Phases indicator above uses location.abovebar and location.belowbar arguments to position the circle plots near each bar at an automatic, consistent distance, regardless of the bar‚Äôs price fluctuation or the plotshape() series value.\n\nRelative positioning also makes plotchar() and plotshape() useful for debugging numeric values or conditions. These functions can plot series values at a different scale than the chart bars without interfering with the chart scale, unlike plot() series. Hovering over a bar can verify its numeric series value in the status line or Data Window ‚Äî these locations show 0 as the numeric result if there is no visual marker on this particular bar. The functions do not display a visual marker when the series value is false or na, and they also hide the marker for a 0 value in ‚Äúint‚Äù/‚Äúfloat‚Äù series when using relative positioning.",
    "keywords": [
      "e.g",
      "location.abovebar",
      "location.belowbar",
      "indicator",
      "plot",
      "hline",
      "fill",
      "series",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-328",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "For example, suppose we have a script overlayed in the main pane, and part of its logic generates an ‚Äúint‚Äù series of 0 or 1 values based on some testCondition. Using plotchar() with a relative location argument quickly verifies that the condition occurs where expected as the function plots a visual marker only when the series value is 1. Otherwise, plotting with the absolute series locations would distort the main price scale to accommodate a marker appearing on every bar at the low price levels 0.00 and 1.00:\n\nPine Script¬Æ\nCopied\n//@variable An \"int\" series where the value is either `0` or `1`.\nint mySeries = testCondition ? 1 : 0 \n\n// To verify `mySeries`, plot a \"!\" character at the bottom of the pane only if `mySeries` is `1`.\nplotchar(mySeries, \"Debugging series\", \"!\", location = location.bottom)\nThe plotshape() and plotchar() functions can also display text alongside their shapes. Unlike for labels, the string must be of type ‚Äúconst‚Äù, so the value cannot be dynamic and cannot represent series: the same text appears for all the points in the plot.\n\n‚Äãplotarrow()‚Äã\nSimilar to `plotshape()` and `plotchar()`, the plotarrow() function plots a series across the chart that presents graphic information using an arrow shape.\n\nA single plotarrow() call plots an arrow on every bar, setting each arrow‚Äôs direction, position, and length based on the bar‚Äôs value in the plot series. Like other plot visuals, an arrow‚Äôs numeric value can also display in the script‚Äôs status line and Data Window.\n\nThe plotarrow() function is useful for visualizing changes in the directionality and magnitude of ‚Äúint‚Äù or ‚Äúfloat‚Äù series values across the chart. The underlying series can be at a different scale than the chart bars without visually distorting the main chart scale.\n\nUnlike plotchar() or plotshape(), the plotarrow() function cannot display text and doesn‚Äôt accept ‚Äúbool‚Äù series. However, the function can still achieve a conditional arrow plot by using na values for its series on certain bars.\n\nThis simple example indicator uses plotarrow() to visualize a barGap series, where each arrow represents the price difference between the current bar‚Äôs open and the previous bar‚Äôs close. The function call automatically sets the locations of all the arrows, plotting positive-value arrows below bars and negative-value arrows above bars, and adjusts their lengths relative to the other values in the barGap series:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"`plotarrow()` demo\", overlay = true)\n\n//@variable The difference between the current `open` and previous `close`.\nfloat barGap = open - close[1]\nplotarrow(barGap, \"Bar gap\", color.rgb(0, 187, 212, 40), color.rgb(223, 64, 251, 40))\n‚Äãplotbar()‚Äã and ‚Äãplotcandle()‚Äã\nThe plotbar() and plotcandle() functions create custom bar or candle sets on the chart. One call to either function registers four values ‚Äî the bar or candle‚Äôs open, high, low, and close values ‚Äî on every bar of the main chart series. As a result, a single plotbar() or plotcandle() call generates at least four plots counting towards a script‚Äôs total plot limit.",
    "keywords": [
      "location.bottom",
      "color.rgb",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-329",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Indicators can use these functions to plot a new series separate from the main series, or to build new visuals for the main series itself, like the built-in Bollinger Bars indicator does to create candles with thicker wicks:\n\nimage\n\nAs with other plot visuals, the plotbar() and plotcandle() outputs can display in other locations: their numeric results in the script‚Äôs status line and Data Window (four values per plot) and their latest close value on the price scale.\n\nSee the Bar plotting page for more information about these functions.\n\nHorizontal levels\nThe hline() function creates a horizontal level across the script pane at a defined price. The horizontal level extends fully across the visible space of the chart in both directions.\n\nUnlike other plot visuals, a horizontal level‚Äôs only output is the line drawn in the script pane; it does not display values in the status line, price scale, or Data Window.\n\nThis visual element is useful for displaying minimum or maximum prices, thresholds, or support and resistance levels. Many built-in indicators like RSI, CCI, and Stochastic use horizontal levels to represent fixed boundaries for oscillator plots. For example, in the RSI indicator, the horizontal levels are upper and lower bands that represent the oversold and overbought boundaries:\n\nimage\n\nSome built-in indicators also use horizontal levels with fills to create colored bands, which can help to visually distinguish the typical value ranges from outlier ranges, as seen above.\n\nA horizontal level uses a single, fixed price value, so it cannot use a dynamically-calculated value or a ‚Äúseries‚Äù type like close. Instead, scripts can use plot() to produce similar horizontal lines for dynamically-calculated levels.\n\nBecause an hline() call plots only a fixed level in a single color, it is often more performant than similar plot() lines. Adding a horizontal level does not count towards a script‚Äôs plot limit because the hline() function doesn‚Äôt create a plot series internally or externally to generate its visual output.\n\nBackground and bar coloring\nThe bgcolor() function sets the background color of the chart space behind a bar, while the barcolor() function sets the body color of a candle.\n\nThe functions accept both constant colors and dynamically-calculated colors, so they can use conditional coloring for bars or backgrounds. For instance, the built-in Moon Phases indicator uses bgcolor() to conditionally set the background color of the bars to highlight waxing and waning moon phases:\n\nimage\n\nA bgcolor() call, like most visuals, affects the script pane by default. It sets the background color behind the main bar series only when it‚Äôs overlayed in the main pane ‚Äî when overlay = true for the script or force_overlay = true for bgcolor() ‚Äî otherwise it sets the background for the equivalent space in a separate pane.",
    "keywords": [
      "indicator",
      "overlay",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "barcolor",
      "series",
      "const",
      "type",
      "for",
      "while"
    ]
  },
  {
    "id": "doc-330",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "By contrast, the barcolor() function always colors the main bar series in the main pane, even when called by a script executing in a separate pane.\n\nAs barcolor() only affects the main chart series, scripts cannot use it to alter the colors of new bars or candles created using plotbar() or plotcandle().\n\nThis simple example uses arbitrary bar_index and price conditions to set conditional background and bar colors:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"`bgcolor()` and `barcolor()` demo\")\n\n// Plot a new candle series for this script, separate to the main pane. Candles are set to main series OHLC values.\nplotcandle(open, high, low, close, color = color.silver)\n\n// Set the background color of the script pane. Color is set conditionally depending on divisibility of `bar_index` by 10 or 6.\nbgcolor(bar_index % 10 == 0 ? color.new(color.purple, 60) : bar_index % 6 == 0 ? color.new(color.teal, 60) : na)   \n\n// Set the bar color for the main series. Although script executes in a separate pane, this call executes on the main pane.\n// Bar's body color is set conditionally to highlight bars with price move of 10 or more.\nbarcolor(math.abs(close - open) >= 10  ? color.orange : color.white)\nNote that:\n\nThe script executes in a separate pane, but the barcolor() function colors the main series.\nThe barcolor() call does not affect the new candles plotted in the script pane.\nFills\nScripts can use fills to set the background color of the space between a pair of plots or horizontal levels. The fill() function accepts both constant and dynamically-calculated colors. There is also a fill() function overload that can create color gradient fills.\n\nFills between plots are commonly used in built-in indicators to visualize calculated channels or bands, like those used in the Bollinger Bands indicator, which signify the upper and lower standard deviations from its SMA line:\n\nimage\n\nFills between horizontal levels are often used in built-in oscillators to highlight chart regions of interest or to differentiate between typical and outlier ranges. For example, the Stochastic Momentum Index (SMI) indicator fills the background between horizontal levels that signify overbought and oversold boundaries, which can help easily identify signs of bullish or bearish trends beyond the filled regions:\n\nimage\n\nThe SMI indicator also uses the fill() function‚Äôs color gradient overload to gradually color the space within the plot lines green or red as they enter the overbought or oversold zones respectively.\n\nOther Pine visuals have their own dedicated fills, like linefills for setting the fill color between two lines, and built-in fill color arguments for drawing objects like boxes and polylines. See the Fills page for more information about the different fill mechanisms available.",
    "keywords": [
      "color.silver",
      "color.new",
      "color.purple",
      "color.teal",
      "math.abs",
      "color.orange",
      "color.white",
      "indicator",
      "plot",
      "fill",
      "bgcolor",
      "barcolor",
      "series",
      "simple",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-331",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Note\nA single fill() function call cannot color the space between a plot and a horizontal level. It can only color the region between either a pair of plots or a pair of horizontal levels.\n\nLines and polylines\nScripts can draw lines to visually connect any two points on the chart horizontally, vertically, or diagonally.\n\nLike other drawing visuals, lines are independent from the main series, so scripts can draw them at any available chart locations from any bar.\n\nProgrammers can specify a line‚Äôs start and end coordinates using any of the following:\n\nA bar_index x-coordinate and price y-coordinate.\nA UNIX timestamp x-coordinate and price y-coordinate.\nA chart point object, where the x-coordinate is a bar index or time value.\nLines can also extend to the left or right of the chart, like those used in the built-in Auto Fib Extension indicator to visualize projected price levels:\n\nimage\n\nScripts can specify line coordinates at dynamic offsets from the bars on which they‚Äôre calculated, to draw lines at varying lengths and distances. For instance, the built-in Zig Zag indicator draws straight, angled lines to connect calculated high and low pivots alternatingly across the chart, connecting the last leg to the last available bar. The indicator confirms a point as a high/low pivot only when the price reverses by a specified percentage over time. Therefore, it always draws its lines into the past from a different bar than that of the pivot point, and the number of bars between two sequential pivots is not predictable or consistent:\n\nimage\n\nWhile a line object can connect only two points with a straight line, a polyline can connect multiple points on the chart consecutively to create a straight or curved line drawing. A polyline uses an array of chart points to set the coordinates of its sequential line segments, which can contain up to 10,000 chart points.\n\nPolylines can create more complex graphic formations than lines or boxes. A script can connect chart points together with closed polylines to draw polygons, or leave them open-ended to draw geometric series across the chart. Scripts can also use open-ended, curved polylines to draw chart patterns like the Cup and Handle pattern, which identifies a U-shape price trend that is difficult to produce with other drawing visuals:\n\nimage\n\nA script can replicate the visuals made by drawing several sequential line objects with just one polyline object instead. Using polylines can thus help a script to stay under the limits for the total number of lines.\n\nFor example, we can use a simplified version of the Zig Zag indicator‚Äôs logic to illustrate this. Here, we use one polyline drawing to connect pivot points across the chart. The script stores the high and low pivots together in one chart.point array, and creates the polyline object only on the last confirmed historical bar, using barstate.islastconfirmedhistory, drawing it retrospectively across the chart:",
    "keywords": [
      "chart.point",
      "barstate.islastconfirmedhistory",
      "indicator",
      "plot",
      "fill",
      "var",
      "series",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-332",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "image\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Polyline drawing demo\", overlay = true)\n\n//@variable The left and right strength of the pivot.\nint pivotLegsInput = input.int(5, \"Pivot leg length\", minval = 1)\n//@variable Switches the `polyline` drawing to a straight or curved line drawing.\nbool isCurvedPolyline = input.bool(false, \"Use curved polyline\")\n\n//@variable A persistent array that stores high and low pivots for the polyline.\nvar array<chart.point> pointsArray = array.new<chart.point>()\n// Calculate the high and low pivot prices using `ta.pivot*()` functions.\nfloat pivotHigh = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nfloat pivotLow = ta.pivotlow(pivotLegsInput, pivotLegsInput)\n// Add all high and low pivot points sequentially to `pointsArray`, and draw labels at pivots to show prices.\nif not na(pivotHigh)\n    chart.point highPoint = chart.point.from_index(bar_index - pivotLegsInput, pivotHigh)\n    pointsArray.push(highPoint)\n    label.new(highPoint, \"Pivot: \" + str.tostring(pivotHigh, \"##.##\"))\nif not na(pivotLow)\n    chart.point lowPoint = chart.point.from_index(bar_index - pivotLegsInput, pivotLow)\n    pointsArray.push(lowPoint)\n    label.new(lowPoint, \"Pivot: \" + str.tostring(pivotLow, \"##.##\"), style = label.style_label_up)\n\n// On the last confirmed bar, draw a polyline across the chart to connect all pivots in `pointsArray`. \nif barstate.islastconfirmedhistory\n    // First, remove chart points that are too far from the current bar, to prevent errors.\n    // Iterate backwards to avoid index shifting issues when removing items.\n    for i = (pointsArray.size() - 1) to 0\n        chart.point point = pointsArray.get(i)\n        if (bar_index - point.index) > 9999\n            pointsArray.remove(i)\n\n    polyline.new(pointsArray, curved = isCurvedPolyline, line_color = color.purple, line_width = 4)\n    // For reference, display the total number of polyline drawings created by the script in a table cell on the chart.\n    table displayTable = table.new(position.bottom_right, 1, 1, color.purple)\n    displayTable.cell(0, 0, \"Total polyline drawings: \" + str.tostring(array.size(polyline.all)), \n         text_color = color.white, text_size = size.large) \nNote that:\n\nTo avoid runtime errors due to the polyline trying to draw points more than approximately 9999 bars back from the current bar, one alternative is to use chart.point.from_time() to set x-coordinates with UNIX timestamps. Here, we instead use a loop to remove chart.point objects that are too far from the current bar, before drawing the polyline. Note that to accurately remove more than one element from an array using a loop, scripts must iterate backwards through the array.\nA polyline‚Äôs curved parameter accepts a ‚Äúseries‚Äù argument, so scripts can use Boolean inputs like isCurvedPolyline in our example to easily switch between straight or curved line drawings from an indicator‚Äôs settings.",
    "keywords": [
      "input.int",
      "input.bool",
      "chart.point",
      "array.new",
      "ta.pivot",
      "ta.pivothigh",
      "ta.pivotlow",
      "label.new",
      "str.tostring",
      "label.style_label_up",
      "barstate.islastconfirmedhistory",
      "point.index",
      "polyline.new",
      "color.purple",
      "table.new",
      "position.bottom_right",
      "array.size",
      "polyline.all",
      "color.white",
      "size.large",
      "indicator",
      "overlay",
      "input",
      "var",
      "series",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-333",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Scripts can fill the closed space of a polyline drawing using the polyline.new() function‚Äôs fill_color parameter. To fill the space between two lines with a specified color, use linefill objects, which are described in the next section.\n\nLinefills\nA linefill is a drawing object, unlike the fills for plots and horizontal levels. Calling the linefill.new() function instantiates an object of type ‚Äúlinefill‚Äù. Scripts can store linefill objects and manipulate them with functions, e.g., to set the associated fill color or retrieve the pair of lines.\n\nSimilar to plot fills, linefills are useful for highlighting regions of interest, like calculated channels or trend zones, between two lines on the chart. For example, the built-in Linear Regression indicator uses two linefills between its baseline and its support and resistance lines, which signify the expected price movement ranges. Highlighting the upper and lower channels can make it easier to visually register the price reversal signals:\n\nimage\n\nThe exact dimensions occupied by a linefill object are defined by the pair of lines it‚Äôs attached to. Moving one line farther away, for example, automatically widens the attached linefill. Only one linefill instance can exist between a pair of lines, and it covers only the common space between them. If a pair of lines both extend in the same direction, the linefill can also extend infinitely, as seen in the Auto Pitchfork indicator:\n\nimage\n\nLinefills can fill the space only between two ‚Äúline‚Äù objects. For polylines, the polyline.new() function has a fill_color parameter to fill the polyline drawing‚Äôs closed space.\n\nBoxes\nScripts can use boxes to create custom rectangle drawings on the chart. Like other drawing visuals, a box is a flexible object type, not a series visual, so a script can draw multiple boxes on the same bar, and can set box coordinates at any allowed chart locations ahead or behind the current bar.\n\nProgrammers can specify box coordinates using either two diagonal corner points or all four edges of the box, and can define the x-coordinates using bar_index or UNIX timestamp values.\n\nBoxes can be useful for highlighting chart areas of interest, showing price ranges, or visually grouping bars. For example, the built-in Multi-time period charts indicator overlays boxes on the current chart to visualize the corresponding higher timeframe candles:\n\nimage\n\nBoxes can also display text as part of their drawings, as shown in the Seasonality indicator below. Scripts can customize a box‚Äôs text formatting, alignment, and wrapping, with auto-scaling and auto-wrapping options available to design boxes that are responsive to a user‚Äôs chart adjustments:\n\nimage\n\nLabels\nLabels are drawing objects that can display dynamic text on the chart. They accept ‚Äúseries string‚Äù arguments, so they can use changeable text values that aren‚Äôt known at the start of execution, like inputs or conditionally-calculated expressions, unlike the text displayed by `plotshape()` and `plotchar()`.",
    "keywords": [
      "polyline.new",
      "linefill.new",
      "e.g",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-334",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "Scripts can manage labels in local scopes and draw them at historical or future positions, like other drawing visuals. Each label‚Äôs position is anchored to the chart‚Äôs x and y scales at a specific price and bar/time value. However, this position is flexible, as a script can modify a label‚Äôs coordinates any number of times.\n\nIn the built-in Zig Zag indicator, text labels display the calculated pivot prices and, depending on the selected inputs, can also display the reversal price and cumulative volume data within these same labels. The indicator takes advantage of several dynamic label features when building the concatenated label text and setting each label‚Äôs high/low position, color, and variable offset:\n\nimage\n\nMany label.style_* options are available to customize a label‚Äôs visual appearance, including standard pointing labels and shape-based labels like crosses, triangles, arrows, or flags. The indicator above uses the label.style_none style to display the text on the chart without a visible label shape or outline. See the table in the positioning labels section of the Text and shapes page for all available label styles.\n\nThe versatility of labels also makes them particularly useful for debugging scripts. A label can easily show calculated numeric values, strings, or test conditions directly on the chart with little extra code. Scripts can even display empty labels without text to create quick visual markers, for example, to verify that conditions occur on their expected bars.\n\nTables\nTables are special drawing objects useful for displaying customized, organized information that isn‚Äôt connected to the chart‚Äôs price or bar scales.\n\nTables are anchored to the pane space itself, not to any x or y chart coordinates. As such, they remain fixed in size and position when zooming into or scrolling across the chart, even if they are overlayed in the main pane. Like other drawing visuals, tables do not change the data they display when the user hovers over different bars.\n\nScripts can draw tables in one of nine fixed pane positions, specified by the top, middle, or bottom vertical region of the pane and the corresponding left, center, or right horizontal region:\n\nimage\n\nIf a script displays more than one table in the same location, the table that is drawn latest in the code replaces any previous tables.\n\nSimilar to other drawings, tables have various features that scripts can modify during execution using setter functions. These include table-specific features like the frame, border, and height/width in the pane, as well as cell-specific features like background color, alignment, and text formatting.\n\nA customization feature unique to tables is that, within the same table object, each cell can have different visual properties.\n\nFor example, the built-in Performance indicator shows the price percentage change at multiple timeframes for a group of symbols. It uses a variable color intensity for the cell background colors to represent each value‚Äôs absolute strength. The tabular format and dynamic cell colors make it easy to compare values across symbols and timeframes at a glance:",
    "keywords": [
      "label.style_",
      "label.style_none",
      "indicator",
      "overlay",
      "input",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-335",
    "type": "documentation",
    "source": "visuals/overview.md",
    "section": "visuals",
    "title": "overview",
    "content": "image\n\nUnlike for lines, boxes, and labels, scripts cannot use getter functions to retrieve properties for tables drawn on the chart. To refer to an attribute of a table later in a script, first store the value in a separate variable.\n\nThe Performance indicator above draws its table only once during initial execution, on the last bar. This improves script performance and is recommended because a table only displays its last state. Tables are thus useful for displaying annotations or general information that won‚Äôt change during execution, like selected settings, release notes, misconfigurations, etc.\n\nThe following example script displays labels for the start and end of each daily trading session. As such, it supports only intraday data and does not display any labels on a ‚Äú1D‚Äù timeframe or higher. The script displays a single-cell table if timeframe.isdwm is true, to notify users of this information:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Timeframe warning table demo\", overlay = true, max_labels_count = 500, behind_chart = false) \n\n// Input for the trading session (e.g., \"0930-1600\" for US stocks regular hours)\nsessionInput = input.session(\"0930-1600\", \"Trading Session\")\n\n// Display `warningTable` on last bar if the chart timeframe is not intraday.\nif barstate.islastconfirmedhistory and timeframe.isdwm\n    //@variable A single-cell `table` that inform users about the unsupported timeframe.\n    var table warningTable = table.new(position.middle_center, 1, 1, color.yellow)\n    warningTable.cell(0, 0, \n         \"Warning: This indicator supports only intraday timeframes.\\n Switch to a lower timeframe to see output.\", \n         text_size = size.large)\n\n// Plot a label at the opening price when the session starts\nif timeframe.isintraday and na(time(\"\", sessionInput)[1]) and not na(time(\"\", sessionInput))\n    label.new(bar_index, open, \"Session Open: \" + str.tostring(open, \"#.##\"), yloc = yloc.abovebar, \n      color = color.green, style = label.style_label_down)\n\n// Plot a label at the closing price on the last bar of the session\nif timeframe.isintraday and not na(time(\"\", sessionInput)[1]) and na(time(\"\", sessionInput))\n    label.new(bar_index[1], close[1], \"Session Close: \" + str.tostring(close[1], \"#.##\"), yloc = yloc.belowbar, \n      color = color.red, style = label.style_label_up)\nNote that:\n\nUsing a table in this case ensures that users clearly see the warning, because it appears directly in the chart pane regardless of how their chart is scaled.\nLastly, a table‚Äôs organized format and fixed pane positions also makes it useful for debugging scripts. See the Tables section of the Debugging page for more details.",
    "keywords": [
      "timeframe.isdwm",
      "e.g",
      "input.session",
      "barstate.islastconfirmedhistory",
      "table.new",
      "position.middle_center",
      "color.yellow",
      "size.large",
      "timeframe.isintraday",
      "label.new",
      "str.tostring",
      "yloc.abovebar",
      "color.green",
      "label.style_label_down",
      "yloc.belowbar",
      "color.red",
      "label.style_label_up",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-336",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "Plots\nIntroduction\nThe plot() function is the most frequently used function used to display information calculated using Pine scripts. It is versatile and can plot different styles of lines, histograms, areas, columns (like volume columns), fills, circles or crosses.\n\nThe use of plot() to create fills is explained in the page on Fills.\n\nThis script showcases a few different uses of plot() in an overlay script:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"`plot()`\", \"\", true)\nplot(high, \"Dashed blue `high` line\", linestyle = plot.linestyle_dashed)\nplot(math.avg(close, open), \"Crosses in body center\", close > open ? color.lime : color.purple, 6, plot.style_cross)\nplot(math.min(open, close), \"Navy step line on body low point\", color.navy, 3, plot.style_stepline)\nplot(low, \"Gray dot on `low`\", color.gray, 3, plot.style_circles)\n\ncolor VIOLET = #AA00FF\ncolor GOLD   = #CCCC00\nma = ta.alma(hl2, 40, 0.85, 6)\nvar almaColor = color.silver\nalmaColor := ma > ma[2] ? GOLD : ma < ma[2]  ? VIOLET : almaColor\nplot(ma, \"Two-color ALMA\", almaColor, 2)\nNote that:\n\nThe first plot() call plots a blue line across the bar highs with a dashed line style. The line uses the default width of 1 pixel.\nThe second call plots crosses at the mid-point of candle bodies. The crosses are colored lime for up bars and purple for down bars. The argument 6 used for linewidth is a relative size, not a pixel value.\nThe third call plots a 3-pixel-wide step line following the lowest point of candle bodies.\nThe fourth call plots a gray circle at the bars‚Äô low.\nThe last plot requires some preparation. We first define our bull/bear colors, calculate an Arnaud Legoux Moving Average, then make our color calculations. We initialize our color variable on bar zero only, using var. We initialize it to color.silver, so on the dataset‚Äôs first bars, until the line is higher/lower than its value two bars ago, it is silver. Looking two bars back creates smoother color transitions than one bar back.\nThe next script shows other uses of plot() in a separate pane:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Volume change\", format = format.volume)\n\ncolor GREEN         = #008000\ncolor GREEN_LIGHT   = color.new(GREEN, 50)\ncolor GREEN_LIGHTER = color.new(GREEN, 85)\ncolor PINK          = #FF0080\ncolor PINK_LIGHT    = color.new(PINK, 50)\ncolor PINK_LIGHTER  = color.new(PINK, 90)\n\nbool  barUp = ta.rising(close, 1)\nbool  barDn = ta.falling(close, 1)\nfloat volumeChange = ta.change(volume)\n\nvolumeColor = barUp ? GREEN_LIGHTER : barDn ? PINK_LIGHTER : color.gray\nplot(volume, \"Volume columns\", volumeColor, style = plot.style_columns)\n\nvolumeChangeColor = barUp ? volumeChange > 0 ? GREEN : GREEN_LIGHT : volumeChange > 0 ? PINK : PINK_LIGHT\nplot(volumeChange, \"Volume change columns\", volumeChangeColor, 12, plot.style_histogram)",
    "keywords": [
      "plot.linestyle_dashed",
      "math.avg",
      "color.lime",
      "color.purple",
      "plot.style_cross",
      "math.min",
      "color.navy",
      "plot.style_stepline",
      "color.gray",
      "plot.style_circles",
      "ta.alma",
      "color.silver",
      "format.volume",
      "color.new",
      "ta.rising",
      "ta.falling",
      "ta.change",
      "plot.style_columns",
      "plot.style_histogram",
      "indicator",
      "overlay",
      "plot",
      "fill",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-337",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "plot(0, \"Zero line\", color.gray)\nNote that:\n\nWe are plotting normal volume values as wide columns above the zero line (see the style = plot.style_columns in our plot() call).\nBefore plotting the columns we calculate our volumeColor by using the values of the barUp and barDn boolean variables. They become respectively true when the current bar‚Äôs close is higher/lower than the previous one. Note that the ‚ÄúVolume‚Äù built-in does not use the same condition; it identifies an up bar with close > open. We use the GREEN_LIGHTER and PINK_LIGHTER colors for the volume columns.\nBecause the first plot() call plots columns, we do not use the linewidth parameter, as it has no effect on columns.\nOur script‚Äôs second plot is the change in volume, which we calculate using ta.change(volume). This value is plotted as a histogram, for which the linewidth parameter controls the width of the column. We make this width 12 so that histogram elements are thinner than the columns of the first plot. Positive/negative volumeChange values plot above/below the zero line; no manipulation is required to achieve this effect.\nBefore plotting the histogram of volumeChange values, we calculate its color value, which can be one of four different colors. We use the bright GREEN or PINK colors when the bar is up/down and the volume has increased since the last bar (volumeChange > 0). Because volumeChange is positive in this case, the histogram‚Äôs element is plotted above the zero line. We use the bright GREEN_LIGHT or PINK_LIGHT colors when the bar is up/down and the volume has not increased since the last bar. Because volumeChange is negative in this case, the histogram‚Äôs element is plotted below the zero line.\nFinally, we plot a zero line. As an alternative, using hline(0) achieves the same effect.\nWe use format = format.volume in our indicator() call so that large values displayed for this script are abbreviated like those of the built-in ‚ÄúVolume‚Äù indicator.\nA plot() call must always be in the script‚Äôs global scope, i.e., at the beginning of a non-indented line. Scripts cannot call the plot() function from the indented (local) blocks of user-defined functions or conditional structures like if blocks, for loops, etc. Calls to plot() can, however, be designed to plot conditionally in two ways, which we cover in the Plotting conditionally section of this page.\n\nIf the plot() call includes force_overlay = true, the result always displays on the main chart pane, even if the script is running in a separate pane. Otherwise, the script displays the plot in the same pane in which it runs. By contrast, scripts can only color bars in the main chart pane, regardless of where they run.\n\n‚Äãplot()‚Äã parameters\nThe plot() function has the following signature:\n\nplot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display, format, precision, force_overlay, linestyle) ‚Üí plot",
    "keywords": [
      "color.gray",
      "plot.style_columns",
      "ta.change",
      "format.volume",
      "i.e",
      "indicator",
      "overlay",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-338",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "The parameters of plot() are:\n\nseries\n\nIt is the only mandatory parameter. Its argument must be of ‚Äúseries int/float‚Äù type. Note that because the auto-casting rules in Pine Script¬Æ convert in the ‚Äúint‚Äù ü†Ü ‚Äúfloat‚Äù ü†Ü ‚Äúbool‚Äù direction, a ‚Äúbool‚Äù type variable cannot be used as is for the series; it must be converted to an equivalent ‚Äúint‚Äù or ‚Äúfloat‚Äù type argument. For example, to plot a series based on a ‚Äúbool‚Äù variable newDay, we can pass newDay ? 1 : 0 as the series argument to plot 1 when the variable is true and 0 when it is false.\n\ntitle\n\nRequires a ‚Äúconst string‚Äù argument, so it must be known at compile time. The string appears:\n\nIn the script‚Äôs scale when the ‚ÄúChart settings/Scales/Indicator Name Label‚Äù field is checked.\nIn the Data Window.\nIn the ‚ÄúSettings/Style‚Äù tab.\nIn the dropdown of input.source() fields.\nIn the ‚ÄúCondition‚Äù field of the ‚ÄúCreate Alert‚Äù dialog box, when the script is selected.\nAs the column header when exporting chart data to a CSV file.\ncolor\n\nAccepts ‚Äúseries color‚Äù, so can be calculated on the fly, bar by bar. Plotting with na as the color, or any color with a transparency of 100, is one way to hide plots when they are not needed.\n\nlinewidth\n\nIs the plotted element‚Äôs size, but it does not apply to all styles. When a line is plotted, the unit is pixels. It has no impact when plot.style_columns is used.\n\nstyle\n\nThe available arguments are:\n\nplot.style_line (the default): It plots a continous line using the linewidth argument in pixels for its width. It does not plot any na values, but does draw a line through them by joining the most recent non-na value to the next non-na value. comes in.\nplot.style_linebr: Allows the plotting of discontinuous lines by not plotting on na values, and not joining such gaps.\nplot.style_stepline: Plots using a staircase effect. Transitions between changes in values are done using a vertical line drawn in middle of bars, as opposed to a point-to-point diagonal joining the midpoints of bars. Can also be used to achieve an effect similar to that of plot.style_linebr, but only if care is taken to plot no color on na values.\nplot.style_area: Plots a line of linewidth width, filling the area between the line and the histbase. The color argument is used for both the line and the fill. You can make the line a different color by using another plot() call. Positive values are plotted above the histbase, negative values below it.\nplot.style_areabr: This is similar to plot.style_area but it doesn‚Äôt bridge over na values. Another difference is how the indicator‚Äôs scale is calculated. Only the plotted values serve in the calculation of the y range of the script‚Äôs visual space. If only high values situated far away from the histbase are plotted, for example, those values will be used to calculate the y scale of the script‚Äôs visual space. Positive values are plotted above the histbase, negative values below it.",
    "keywords": [
      "input.source",
      "plot.style_columns",
      "plot.style_line",
      "plot.style_linebr",
      "plot.style_stepline",
      "plot.style_area",
      "plot.style_areabr",
      "indicator",
      "input",
      "plot",
      "fill",
      "alert",
      "var",
      "series",
      "const",
      "export",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-339",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "plot.style_columns: Plots columns similar to those of the ‚ÄúVolume‚Äù built-in indicator. The linewidth value does not affect the width of the columns. Positive values are plotted above the histbase, negative values below it. Always includes the value of histbase in the y scale of the script‚Äôs visual space.\nplot.style_histogram: Plots columns similar to those of the ‚ÄúVolume‚Äù built-in indicator, except that the linewidth value is used to determine the width of the histogram‚Äôs bars in pixels. Note that since linewidth requires an ‚Äúinput int‚Äù value, the width of the histogram‚Äôs bars cannot vary bar to bar. Positive values are plotted above the histbase, negative values below it. Always includes the value of histbase in the y scale of the script‚Äôs visual space.\nplot.style_circles and plot.style_cross: These plot a shape that is not joined across bars unless join = true is also used. For these styles, the linewidth argument becomes a relative sizing measure ‚Äî its units are not pixels.\ntrackprice\n\nThe default value of this is false. When it is true, a dotted line made up of small squares will be plotted the full width of the script‚Äôs visual space. It is often used in conjuction with show_last = 1, offset = -99999 to hide the actual plot and only leave the residual dotted line.\n\nhistbase\n\nIt is the reference point used with plot.style_area, plot.style_columns and plot.style_histogram. It determines the level separating positive and negative values of the series argument. It cannot be calculated dynamically, as an ‚Äúinput int/float‚Äù is required.\n\noffset\n\nThis allows shifting the plot in the past/future using a negative/positive offset in bars. The value cannot change during the script‚Äôs execution.\n\njoin\n\nThis only affect styles plot.style_circles or plot.style_cross. When true, the shapes are joined by a one-pixel line.\n\neditable\n\nThis boolean parameter controls whether or not the plot‚Äôs properties can be edited in the ‚ÄúSettings/Style‚Äù tab. Its default value is true.\n\nshow_last\n\nControls the number of bars on which the plot values are visible, counting backward from the last bar. Bars beyond the specified amount show na values for this plot. It accepts an ‚Äúinput int‚Äù type argument, so it cannot be calculated dynamically.\n\ndisplay\n\nControls the locations where plot values appear, which include the script pane, status line, price scale, and Data Window. The default is display.all. This parameter supports addition and subtraction of display.* options, e.g., display.all - display.pane hides the pane visuals but displays the plot‚Äôs numeric results everywhere else, while display.status_line + display.data_window displays results only in those two locations.\n\nWhen this parameter is set to display.none, the script calculates the plot values, but does not display them in the script pane, status line, or Data Window, and the hidden plot does not affect the scale of the script‚Äôs visual space. This display option can be useful for plots intended for use as external inputs for other scripts, or for plots used with the {{plot(\"[plot_title]\")}} placeholder in alertcondition() calls, e.g.:",
    "keywords": [
      "plot.style_columns",
      "plot.style_histogram",
      "plot.style_circles",
      "plot.style_cross",
      "plot.style_area",
      "display.all",
      "e.g",
      "display.pane",
      "display.status_line",
      "display.data_window",
      "display.none",
      "indicator",
      "input",
      "plot",
      "alert",
      "alertcondition",
      "var",
      "series",
      "type",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-340",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "Pine Script¬Æ\nCopied\n//@version=6\nindicator(\"\")\nr = ta.rsi(close, 14)\nxUp = ta.crossover(r, 50)\nplot(r, \"RSI\", display = display.none)\nalertcondition(xUp, \"xUp alert\", message = 'RSI is bullish at: {{plot(\"RSI\")}}')\nformat\n\nSpecifies the numeric format used to represent plot values in the status line, Data Window, and price scale. It accepts one of the following values: format.price, format.percent, or format.volume.\n\nBy default, the plot uses the same format as the script‚Äôs indicator() or strategy() declaration statement. If the plot and declaration use different formats, then the plot‚Äôs format argument takes precedence.\n\nprecision\n\nSpecifies the number of digits included after the decimal point for the plot‚Äôs numeric values. It accepts a positive integer argument from 0 to 16. This precision affects the results displayed in the status line, Data Window, and price scale.\n\nBy default, the plot uses the same precision as the script‚Äôs indicator() or strategy() declaration statement. If the plot and declaration use different precisions, then the plot‚Äôs precision argument takes precedence.\n\nThe precision parameter does not affect plot results formatted using the format.volume argument, because the decimal precision rules of the volume formatting take precedence.\n\nforce_overlay\n\nIf true, the plotted results display on the main chart pane, even when the script occupies a separate pane. Optional. The default is false.\n\nlinestyle\n\nControls the style of plotted lines, using one of the following arguments: plot.linestyle_solid, plot.linestyle_dashed, or plot.linestyle_dotted.\n\nThis parameter only modifies lines, so the style parameter must use one of the following arguments: plot.style_line (the default), plot.style_linebr, plot.style_stepline, plot.style_stepline_diamond, or plot.style_area for it to take effect.\n\nPlotting conditionally\nScripts cannot call the plot() function from conditional structures such as if blocks, but can control plots by varying their plotted values or their color. When no plot is required, you can either plot na values, or plot values using na color or any color with 100 transparency (which also makes it invisible).\n\nValue control\nOne way to control the display of plots is to plot na values when no plot is needed. Sometimes, values returned by functions such as request.security() will return na values, when gaps = barmerge.gaps_on is used, for example. In both these cases it is sometimes useful to plot discontinuous lines. This script shows a few ways to do it:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Discontinuous plots\", \"\", true)\nbool plotValues = bar_index % 3 == 0\nplot(plotValues ? high : na, color = color.fuchsia, linewidth = 6, style = plot.style_linebr)\nplot(plotValues ? high : na)\nplot(plotValues ? math.max(open, close) : na, color = color.navy, linewidth = 6, style = plot.style_cross)",
    "keywords": [
      "ta.rsi",
      "ta.crossover",
      "display.none",
      "format.price",
      "format.percent",
      "format.volume",
      "plot.linestyle_solid",
      "plot.linestyle_dashed",
      "plot.linestyle_dotted",
      "plot.style_line",
      "plot.style_linebr",
      "plot.style_stepline",
      "plot.style_stepline_diamond",
      "plot.style_area",
      "request.security",
      "barmerge.gaps_on",
      "color.fuchsia",
      "math.max",
      "color.navy",
      "plot.style_cross",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "alert",
      "alertcondition",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-341",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "plot(plotValues ? math.min(open, close) : na, color = color.navy, linewidth = 6, style = plot.style_circles)\nplot(plotValues ? low : na, color = plotValues ? color.green : na, linewidth = 6, style = plot.style_stepline)\nNote that:\n\nWe define the condition determining when we plot using bar_index % 3 == 0, which becomes true when the remainder of the division of the bar index by 3 is zero. This will happen every three bars.\nIn the first plot, we use plot.style_linebr, which plots the fuchsia line on highs. It is centered on the bar‚Äôs horizontal midpoint.\nThe second plot shows the result of plotting the same values, but without using special care to break the line. What‚Äôs happening here is that the thin blue line of the plain plot() call is automatically bridged over na values (or gaps), so the plot does not interrupt.\nWe then plot navy blue crosses and circles on the body tops and bottoms. The plot.style_circles and plot.style_cross style are a simple way to plot discontinuous values, e.g., for stop or take profit levels, or support & resistance levels.\nThe last plot in green on the bar lows is done using plot.style_stepline. Note how its segments are wider than the fuchsia line segments plotted with plot.style_linebr. Also note how on the last bar, it only plots halfway until the next bar comes in.\nThe plotting order of each plot is controlled by their order of appearance in the script.\nThis script shows how you can restrict plotting to bars after a user-defined date. We use the input.time() function to create an input widget allowing script users to select a date and time, using Jan 1st 2021 as its default value:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"\", \"\", true)\nstartInput = input.time(timestamp(\"2021-01-01\"))\nplot(time > startInput ? close : na)\nColor control\nThe Conditional coloring section of the Colors page discusses color control for plots. We‚Äôll look here at a few examples.\n\nThe value of the color parameter in plot() can be a constant, such as one of the built-in constant colors or a color literal. In Pine Script, the qualified type of such colors is called ‚Äúconst color‚Äù (see the Type system page). They are known at compile time:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"\", \"\", true)\nplot(close, color = color.gray)\nThe color of a plot can also be determined using information that is only known when the script begins execution on the first historical bar of a chart (bar zero, i.e., bar_index == 0 or barstate.isfirst == true), as will be the case when the information needed to determine a color depends on the chart the script is running on. Here, we calculate a plot color using the syminfo.type built-in variable, which returns the type of the chart‚Äôs symbol. The qualified type of plotColor in this case will be ‚Äúsimple color‚Äù:\n\nPine Script¬Æ",
    "keywords": [
      "math.min",
      "color.navy",
      "plot.style_circles",
      "color.green",
      "plot.style_stepline",
      "plot.style_linebr",
      "plot.style_cross",
      "e.g",
      "input.time",
      "color.gray",
      "i.e",
      "barstate.isfirst",
      "syminfo.type",
      "indicator",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-342",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "Copied\n//@version=6\nindicator(\"\", \"\", true)\nplotColor = switch syminfo.type\n    \"stock\"     => color.purple\n    \"futures\"   => color.red\n    \"index\"     => color.gray\n    \"forex\"     => color.fuchsia\n    \"crypto\"    => color.lime\n    \"fund\"      => color.orange\n    \"dr\"        => color.aqua\n    \"cfd\"       => color.blue\nplot(close, color = plotColor)\nprintTable(txt) => var table t = table.new(position.middle_right, 1, 1), table.cell(t, 0, 0, txt, bgcolor = color.yellow)\nprintTable(syminfo.type)\nPlot colors can also be chosen through a script‚Äôs inputs. In this case, the lineColorInput variable is of the ‚Äúinput color‚Äù type:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"\", \"\", true)\ncolor lineColorInput  = input(#1848CC, \"Line color\")\nplot(close, color = lineColorInput)\nFinally, plot colors can also be dynamic values, i.e., calculated values that can change on each bar. These values are of the ‚Äúseries color‚Äù type:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"\", \"\", true)\nplotColor = close >= open ? color.lime : color.red\nplot(close, color = plotColor)\nWhen plotting pivot levels, one common requirement is to avoid plotting level transitions. Using lines is one alternative, but you can also use plot() like this:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Pivot plots\", \"\", true)\npivotHigh = fixnan(ta.pivothigh(3,3))\nplot(pivotHigh, \"High pivot\", ta.change(pivotHigh) != 0 ? na : color.olive, 3)\nplotchar(ta.change(pivotHigh), \"ta.change(pivotHigh)\", \"‚Ä¢\", location.top, size = size.small)\nNote that:\n\nWe use pivotHigh = fixnan(ta.pivothigh(3,3)) to hold our pivot values. Because ta.pivothigh() only returns a value when a new pivot is found, we use fixnan() to fill the gaps with the last pivot value returned. The gaps here refer to the na values ta.pivothigh() returns when no new pivot is found.\nOur pivots are detected three bars after they occur because we use the argument 3 for both the leftbars and rightbars parameters in our ta.pivothigh() call.\nThe last plot is plotting a continuous value, but it is setting the plot‚Äôs color to na when the pivot‚Äôs value changes, so the plot isn‚Äôt visible then. Because of this, a visible plot will only appear on the bar following the one where we plotted using na color.\nThe blue dot indicates when a new high pivot is detected and no plot is drawn between the preceding bar and that one. Note how the pivot on the bar indicated by the arrow has just been detected in the realtime bar, three bars later, and how no plot is drawn. The plot will only appear on the next bar, making the plot visible four bars after the actual pivot.\nLevels\nThe hline() function plots horizontal lines at fixed levels (see the page on Levels). The hline() function is useful because it has some unique line styles that are not available with plot(), and is often more performant than similar plot() lines. However, it also has some limitations, namely that it does not accept ‚Äúseries color‚Äù arguments, and that its price parameter requires an ‚Äúinput int/float‚Äù type, so it cannot vary during the script‚Äôs execution. In cases where scripts need to use dynamically calculated prices or colors, the plot() function can create similar horizontal levels.",
    "keywords": [
      "syminfo.type",
      "color.purple",
      "color.red",
      "color.gray",
      "color.fuchsia",
      "color.lime",
      "color.orange",
      "color.aqua",
      "color.blue",
      "table.new",
      "position.middle_right",
      "table.cell",
      "color.yellow",
      "i.e",
      "ta.pivothigh",
      "ta.change",
      "color.olive",
      "location.top",
      "size.small",
      "indicator",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "var",
      "series",
      "type",
      "switch",
      "for"
    ]
  },
  {
    "id": "doc-343",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "You can plot levels with plot() in a few different ways. This script shows a CCI indicator with levels plotted using plot():\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"CCI levels with `plot()`\")\nplot(ta.cci(close, 20))\nplot(0,  \"Zero\", color.gray, 1, plot.style_circles)\nplot(bar_index % 2 == 0 ?  100 : na,  \"100\", color.lime, 1, plot.style_linebr)\nplot(bar_index % 2 == 0 ? -100 : na, \"-100\", color.fuchsia, 1, plot.style_linebr)\nplot( 200,  \"200\", color.green, 2, trackprice = true, show_last = 1, offset = -99999)\nplot(-200, \"-200\", color.red,   2, trackprice = true, show_last = 1, offset = -99999)\nplot( 300,  \"300\", color.new(color.green, 50), 1)\nplot(-300, \"-300\", color.new(color.red, 50),   1)\nNote that:\n\nThe zero level is plotted using plot.style_circles.\nThe 100 levels are plotted using a conditional value that only plots every second bar. In order to prevent the na values from being bridged, we use the plot.style_linebr line style.\nThe 200 levels are plotted using trackprice = true to plot a distinct pattern of small squares that extends the full width of the script‚Äôs visual space. The show_last = 1 in there displays only the last plotted value, which would appear as a one-bar straight line if the next trick wasn‚Äôt also used: the offset = -99999 pushes that one-bar segment far away in the past so that it is never visible.\nThe 300 levels are plotted using a continuous line, but a lighter transparency is used to make them less prominent.\nOffsets\nThe offset parameter specifies the number of bars into the past or future that a script plots a given series. By default, a plot‚Äôs offset is zero, so each plot point aligns with its bar. Negative offsets display plots on bars before the current bar, while positive offsets display them on future bars.\n\nFor example, this script plots two close series. It displays the values in the red series five bars to the left because its offset argument is negative, while displaying the values in the green series five bars to the right because its offset is positive:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"\", \"\", true)\nplot(close, \"Offset of -5 (in the past)\",   color = color.red, offset = -5)\nplot(close, \"Offset of +5 (in the future)\", color = color.lime, offset = 5)\nNote that:\n\nThe argument for the offset parameter cannot be of type ‚Äúseries‚Äù; it must be a ‚Äúsimple‚Äù value, which does not change during script execution.\nPlot count limit\nEach script is limited to a maximum plot count of 64. All plot*() calls and alertcondition() calls count towards the plot count of a script. Depending on the complexity of the plot and its arguments, certain calls count as more than one plot in the total plot count.\n\nFor example, a plot() call counts as one plot in the total plot count if it uses a ‚Äúconst color‚Äù argument for its color parameter, because the color is known at compile time:",
    "keywords": [
      "ta.cci",
      "color.gray",
      "plot.style_circles",
      "color.lime",
      "plot.style_linebr",
      "color.fuchsia",
      "color.green",
      "color.red",
      "color.new",
      "indicator",
      "plot",
      "alert",
      "alertcondition",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-344",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "Pine Script¬Æ\nCopied\nplot(close, color = color.green)\nA plot() call counts as two plots in the total plot count if it uses a stronger qualified type for its color argument, such as any one of the following, because the resulting color is dynamic:\n\nPine Script¬Æ\nCopied\nplot(close, color = syminfo.mintick > 0.0001 ? color.green : color.red) //ü†Ü \"simple color\"\nplot(close, color = input.color(color.purple)) //ü†Ü \"input color\"\nplot(close, color = close > open ? color.green : color.red) //ü†Ü \"series color\"\nplot(close, color = color.new(color.silver, close > open ? 40 : 0)) //ü†Ü \"series color\"\nSee the Plot limits section of the Limitations page for more information.\n\nScale\nNot all values can be plotted everywhere. Your script‚Äôs visual space is always bound by upper and lower limits that are dynamically adjusted with the values plotted. An RSI indicator will plot values between 0 and 100, which is why it is usually displayed in a distinct pane ‚Äî or area ‚Äî above or below the chart. If RSI values were plotted as an overlay on the chart, the effect would be to distort the symbol‚Äôs normal price scale, unless it just hapenned to be close to RSI‚Äôs 0 to 100 range. This shows an RSI signal line and a centerline at the 50 level, with the script running in a separate pane:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"RSI\")\nmyRSI = ta.rsi(close, 20)\nbullColor = color.from_gradient(myRSI, 50, 80, color.new(color.lime, 70), color.new(color.lime, 0))\nbearColor = color.from_gradient(myRSI, 20, 50, color.new(color.red,   0), color.new(color.red, 70))\nmyRSIColor = myRSI > 50 ? bullColor : bearColor\nplot(myRSI, \"RSI\", myRSIColor, 3)\nhline(50)\nNote that the y axis of our script‚Äôs visual space is automatically sized using the range of values plotted, i.e., the values of RSI. See the page on Colors for more information on the color.from_gradient() function used in the script.\n\nIf we try to plot the symbol‚Äôs close values in the same space by adding the following line to our script:\n\nPine Script¬Æ\nCopied\nplot(close)\nThis is what happens:\n\nimage\n\nThe chart is on the BTCUSD symbol, whose close prices are around 40000 during this period. Plotting values in the 40000 range makes our RSI plots in the 0 to 100 range indiscernible. The same distorted plots would occur if we placed the RSI indicator on the chart as an overlay.\n\nMerging two indicators\nIf you are planning to merge two signals in one script, first consider the scale of each. It is impossible, for example, to correctly plot an RSI and a MACD in the same script‚Äôs visual space because RSI has a fixed range (0 to 100) while MACD doesn‚Äôt, as it plots moving averages calculated on price.\n\nIf both your indicators used fixed ranges, you can shift the values of one of them so they do not overlap. We could, for example, plot both RSI (0 to 100) and the True Strength Indicator (TSI) (-100 to +100) by displacing one of them. Our strategy here will be to compress and shift the TSI values so they plot over RSI:",
    "keywords": [
      "color.green",
      "syminfo.mintick",
      "color.red",
      "input.color",
      "color.purple",
      "color.new",
      "color.silver",
      "ta.rsi",
      "color.from_gradient",
      "color.lime",
      "i.e",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "hline",
      "series",
      "simple",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-345",
    "type": "documentation",
    "source": "visuals/plots.md",
    "section": "visuals",
    "title": "plots",
    "content": "image\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"RSI and TSI\")\nmyRSI = ta.rsi(close, 20)\nbullColor = color.from_gradient(myRSI, 50, 80, color.new(color.lime, 70), color.new(color.lime, 0))\nbearColor = color.from_gradient(myRSI, 20, 50, color.new(color.red,   0), color.new(color.red, 70))\nmyRSIColor = myRSI > 50 ? bullColor : bearColor\nplot(myRSI, \"RSI\", myRSIColor, 3)\nhline(100)\nhline(50)\nhline(0)\n\n// 1. Compress TSI's range from -100/100 to -50/50.\n// 2. Shift it higher by 150, so its -50 min value becomes 100.\nmyTSI = 150 + (100 * ta.tsi(close, 13, 25) / 2)\nplot(myTSI, \"TSI\", color.blue, 2)\nplot(ta.ema(myTSI, 13), \"TSI EMA\", #FF006E)\nhline(200)\nhline(150)\nNote that:\n\nWe have added levels using hline to situate both signals.\n\nIn order for both signal lines to oscillate on the same range of 100, we divide the TSI value by 2 because it has a 200 range (-100 to +100). We then shift this value up by 150 so it oscillates between 100 and 200, making 150 its centerline.\n\nThe manipulations we make here are typical of the compromises required to bring two indicators with different scales in the same visual space, even when their values, contrary to MACD, are bounded in a fixed range.",
    "keywords": [
      "ta.rsi",
      "color.from_gradient",
      "color.new",
      "color.lime",
      "color.red",
      "ta.tsi",
      "color.blue",
      "ta.ema",
      "indicator",
      "plot",
      "hline",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-346",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "Tables\nIntroduction\nTables are objects that can be used to position information in specific and fixed locations in a script‚Äôs visual space. Contrary to all other plots or objects drawn in Pine Script¬Æ, tables are not anchored to specific bars; they float in a script‚Äôs space, whether in overlay or pane mode, in studies or strategies, independently of the chart bars being viewed or the zoom factor used.\n\nTables contain cells arranged in columns and rows, much like a spreadsheet. They are created and populated in two distincts steps:\n\nA table‚Äôs structure and key attributes are defined using table.new(), which returns a table ID that acts like a pointer to the table, just like label, line, or array IDs do. The table.new() call will create the table object but does not display it.\nOnce created, and for it to display, the table must be populated using one table.cell() call for each cell. Table cells can contain text, or not. This second step is when the width and height of cells are defined.\nMost attributes of a previously created table can be changed using table.set_*() setter functions. Attributes of previously populated cells can be modified using table.cell_set_*() functions.\n\nA table is positioned in an indicator‚Äôs space by anchoring it to one of nine references: the four corners or midpoints, including the center. Tables are positioned by expanding the table from its anchor, so a table anchored to the position.middle_right reference will be drawn by expanding up, down and left from that anchor.\n\nTwo modes are available to determine the width/height of table cells:\n\nA default automatic mode calculates the width/height of cells in a column/row using the widest/highest text in them.\nAn explicit mode allows programmers to define the width/height of cells using a percentage of the indicator‚Äôs available x/y space.\nDisplayed table contents always represent the last state of the table, as it was drawn on the script‚Äôs last execution, on the dataset‚Äôs last bar. Contrary to values displayed in the Data Window or in indicator values, variable contents displayed in tables will thus not change as a script user moves his cursor over specific chart bars. For this reason, it is strongly recommended to always restrict execution of all table.*() calls to either the first or last bars of the dataset. Accordingly:\n\nUse the var keyword to declare tables.\nEnclose all other calls inside an if barstate.islast block.\nMultiple tables can be used in one script, as long as they are each anchored to a different position. Each table object is identified by its own ID. Limits on the quantity of cells in all tables are determined by the total number of cells used in one script.\n\nCreating tables\nWhen creating a table using table.new(), three parameters are mandatory: the table‚Äôs position and its number of columns and rows. Five other parameters are optional: the table‚Äôs background color, the color and width of the table‚Äôs outer frame, and the color and width of the borders around all cells, excluding the outer frame. All table attributes except its number of columns and rows can be modified using setter functions: table.set_position(), table.set_bgcolor(), table.set_frame_color(), table.set_frame_width(), table.set_border_color() and table.set_border_width().",
    "keywords": [
      "table.new",
      "table.cell",
      "table.set_",
      "table.cell_set_",
      "position.middle_right",
      "barstate.islast",
      "table.set_position",
      "table.set_bgcolor",
      "table.set_frame_color",
      "table.set_frame_width",
      "table.set_border_color",
      "table.set_border_width",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-347",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "Tables can be deleted using table.delete(), and their content can be selectively removed using table.clear().\n\nWhen populating cells using table.cell(), you must supply an argument for four mandatory parameters: the table id the cell belongs to, its column and row index using indices that start at zero, and the text string the cell contains, which can be null. Other parameters are optional: the width and height of the cell, the text‚Äôs attributes (color, horizontal and vertical alignment, size, formatting), and the cell‚Äôs background color. All cell attributes can be modified using setter functions: table.cell_set_text(), table.cell_set_width(), table.cell_set_height(), table.cell_set_text_color(), table.cell_set_text_halign(), table.cell_set_text_valign(), table.cell_set_text_size(), table.cell_set_text_formatting(), and table.cell_set_bgcolor().\n\nKeep in mind that each successive call to table.cell() redefines all the cell‚Äôs properties, deleting any properties set by previous table.cell() calls on the same cell.\n\nPlacing a single value in a fixed position\nLet‚Äôs create our first table, which will place the value of ATR in the upper-right corner of the chart. We first create a one-cell table, then populate that cell:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"ATR\", \"\", true)\n// We use `var` to only initialize the table on the first bar.\nvar table atrDisplay = table.new(position.top_right, 1, 1)\n// We call `ta.atr()` outside the `if` block so it executes on each bar.\nmyAtr = ta.atr(14)\nif barstate.islast\n    // We only populate the table on the last bar.\n    table.cell(atrDisplay, 0, 0, str.tostring(myAtr))\nimage\n\nNote that:\n\nWe use the var keyword when creating the table with table.new().\nWe populate the cell inside an if barstate.islast block using table.cell().\nWhen populating the cell, we do not specify the width or height. The width and height of our cell will thus adjust automatically to the text it contains.\nWe call ta.atr(14) prior to entry in our if block so that it evaluates on each bar. Had we used str.tostring(ta.atr(14)) inside the if block, the function would not have evaluated correctly because it would be called on the dataset‚Äôs last bar without having calculated the necessary values from the previous bars.\nLet‚Äôs improve the usability and aesthethics of our script:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"ATR\", \"\", true)\natrPeriodInput = input.int(14,  \"ATR period\", minval = 1, tooltip = \"Using a period of 1 yields True Range.\")\n\nvar table atrDisplay = table.new(position.top_right, 1, 1, bgcolor = color.gray, frame_width = 2, frame_color = color.black)\nmyAtr = ta.atr(atrPeriodInput)\nif barstate.islast\n    table.cell(atrDisplay, 0, 0, str.tostring(myAtr, format.mintick), text_color = color.white)\nimage\n\nNote that:\n\nWe used table.new() to define a background color, a frame color and its width.",
    "keywords": [
      "table.delete",
      "table.clear",
      "table.cell",
      "table.cell_set_text",
      "table.cell_set_width",
      "table.cell_set_height",
      "table.cell_set_text_color",
      "table.cell_set_text_halign",
      "table.cell_set_text_valign",
      "table.cell_set_text_size",
      "table.cell_set_text_formatting",
      "table.cell_set_bgcolor",
      "table.new",
      "position.top_right",
      "ta.atr",
      "barstate.islast",
      "str.tostring",
      "input.int",
      "color.gray",
      "color.black",
      "format.mintick",
      "color.white",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-348",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "When populating the cell with table.cell(), we set the text to display in white.\nWe pass format.mintick as a second argument to the str.tostring() function to restrict the precision of ATR to the chart‚Äôs tick precision.\nWe now use an input to allow the script user to specify the period of ATR. The input also includes a tooltip, which the user can see when he hovers over the ‚Äúi‚Äù icon in the script‚Äôs ‚ÄúSettings/Inputs‚Äù tab.\nColoring the chart‚Äôs background\nThis example uses a one-cell table to color the chart‚Äôs background on the bull/bear state of RSI:\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Chart background\", \"\", true)\nbullColorInput = input.color(color.new(color.green, 95), \"Bull\", inline = \"1\")\nbearColorInput = input.color(color.new(color.red, 95), \"Bear\", inline = \"1\")\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function colors chart bg on RSI bull/bear state.\ncolorChartBg(bullColor, bearColor) =>\n    var table bgTable = table.new(position.middle_center, 1, 1)\n    float r = ta.rsi(close, 20)\n    color bgColor = r > 50 ? bullColor : r < 50 ? bearColor : na\n    if barstate.islast\n        table.cell(bgTable, 0, 0, width = 100, height = 100, bgcolor = bgColor)\n\ncolorChartBg(bullColorInput, bearColorInput)\nNote that:\n\nWe provide users with inputs allowing them to specify the bull/bear colors to use for the background, and send those input colors as arguments to our colorChartBg() function.\nWe create a new table only once, using the var keyword to declare the table.\nWe use table.cell() on the last bar only, to specify the cell‚Äôs properties. We make the cell the width and height of the indicator‚Äôs space, so it covers the whole chart.\nCreating a display panel\nTables are ideal to create sophisticated display panels. Not only do they make it possible for display panels to always be visible in a constant position, they provide more flexible formatting because each cell‚Äôs properties are controlled separately: background, text color, size and alignment, etc.\n\nHere, we create a basic display panel showing a user-selected quantity of MAs values. We display their period in the first column, then their value with a green/red/gray background that varies with price‚Äôs position with regards to each MA. When price is above/below the MA, the cell‚Äôs background is colored with the bull/bear color. When the MA falls between the current bar‚Äôs open and close, the cell‚Äôs background is of the neutral color:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Price vs MA\", \"\", true)\n\nvar string GP1 = \"Moving averages\"\nint     masQtyInput    = input.int(20, \"Quantity\", minval = 1, maxval = 40, group = GP1, tooltip = \"1-40\")\nint     masStartInput  = input.int(20, \"Periods begin at\", minval = 2, maxval = 200, group = GP1, tooltip = \"2-200\")\nint     masStepInput   = input.int(20, \"Periods increase by\", minval = 1, maxval = 100, group = GP1, tooltip = \"1-100\")",
    "keywords": [
      "table.cell",
      "format.mintick",
      "str.tostring",
      "input.color",
      "color.new",
      "color.green",
      "color.red",
      "table.new",
      "position.middle_center",
      "ta.rsi",
      "barstate.islast",
      "input.int",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-349",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "var string GP2 = \"Display\"\nstring  tableYposInput = input.string(\"top\", \"Panel position\", inline = \"11\", options = [\"top\", \"middle\", \"bottom\"], group = GP2)\nstring  tableXposInput = input.string(\"right\", \"\", inline = \"11\", options = [\"left\", \"center\", \"right\"], group = GP2)\ncolor   bullColorInput = input.color(color.new(color.green, 30), \"Bull\", inline = \"12\", group = GP2)\ncolor   bearColorInput = input.color(color.new(color.red, 30), \"Bear\", inline = \"12\", group = GP2)\ncolor   neutColorInput = input.color(color.new(color.gray, 30), \"Neutral\", inline = \"12\", group = GP2)\n\n//@variable The table's `position.*` argument based on the chosen `tableXposInput` and `tableYposInput`.\nvar string tablePosition = switch\n    tableXposInput == \"left\"   and tableYposInput == \"top\"    => position.top_left\n    tableXposInput == \"left\"   and tableYposInput == \"middle\" => position.middle_left\n    tableXposInput == \"left\"   and tableYposInput == \"bottom\" => position.bottom_left\n    tableXposInput == \"center\" and tableYposInput == \"top\"    => position.top_center\n    tableXposInput == \"center\" and tableYposInput == \"middle\" => position.middle_center\n    tableXposInput == \"center\" and tableYposInput == \"bottom\" => position.bottom_center\n    tableXposInput == \"right\"  and tableYposInput == \"top\"    => position.top_right\n    tableXposInput == \"right\"  and tableYposInput == \"middle\" => position.middle_right\n    tableXposInput == \"right\"  and tableYposInput == \"bottom\" => position.bottom_right\n\nvar table panel = table.new(tablePosition, 2, masQtyInput + 1)\nif barstate.islast\n    // Table header.\n    table.cell(panel, 0, 0, \"MA\", bgcolor = neutColorInput)\n    table.cell(panel, 1, 0, \"Value\", bgcolor = neutColorInput)\n\nint period = masStartInput\nfor i = 1 to masQtyInput\n    // ‚Äî‚Äî‚Äî‚Äî‚Äî Call MAs on each bar.\n    float ma = ta.sma(close, period)\n    // ‚Äî‚Äî‚Äî‚Äî‚Äî Only execute table code on last bar.\n    if barstate.islast\n        // Period in left column.\n        table.cell(panel, 0, i, str.tostring(period), bgcolor = neutColorInput)\n        // If MA is between the open and close, use neutral color. If close is lower/higher than MA, use bull/bear color.\n        bgColor = close > ma ? open < ma ? neutColorInput : bullColorInput : open > ma ? neutColorInput : bearColorInput\n        // MA value in right column.\n        table.cell(panel, 1, i, str.tostring(ma, format.mintick), text_color = color.black, bgcolor = bgColor)\n    period += masStepInput\nNote that:\n\nUsers can select the table‚Äôs position from the inputs, as well as the bull/bear/neutral colors to be used for the background of the right column‚Äôs cells.\nThe table‚Äôs quantity of rows is determined using the number of MAs the user chooses to display. We add one row for the column headers.\nEven though we populate the table cells on the last bar only, we need to execute the calls to ta.sma() on every bar so they produce the correct results. The compiler warning that appears when you compile the code can be safely ignored.",
    "keywords": [
      "input.string",
      "input.color",
      "color.new",
      "color.green",
      "color.red",
      "color.gray",
      "position.top_left",
      "position.middle_left",
      "position.bottom_left",
      "position.top_center",
      "position.middle_center",
      "position.bottom_center",
      "position.top_right",
      "position.middle_right",
      "position.bottom_right",
      "table.new",
      "barstate.islast",
      "table.cell",
      "ta.sma",
      "str.tostring",
      "format.mintick",
      "color.black",
      "input",
      "bgcolor",
      "var",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-350",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "We separate our inputs in two sections using group, and join the relevant ones on the same line using inline. We supply tooltips to document the limits of certain fields using tooltip.\nDisplaying a heatmap\nOur next project is a heatmap, which will indicate the bull/bear relationship of the current price relative to its past values. To do so, we will use a table positioned at the bottom of the chart. We will display colors only, so our table will contain no text; we will simply color the background of its cells to produce our heatmap. The heatmap uses a user-selectable lookback period. It loops across that period to determine if price is above/below each bar in that past, and displays a progressively lighter intensity of the bull/bear color as we go further in the past:\n\nimage\n\nPine Script¬Æ\nCopied\n//@version=6\nindicator(\"Price vs Past\", \"\", true)\n\nvar int MAX_LOOKBACK = 300\n\nint     lookBackInput  = input.int(150, minval = 1, maxval = MAX_LOOKBACK, step = 10)\ncolor   bullColorInput = input.color(#00FF00ff, \"Bull\", inline = \"11\")\ncolor   bearColorInput = input.color(#FF0080ff, \"Bear\", inline = \"11\")\n\n// ‚Äî‚Äî‚Äî‚Äî‚Äî Function draws a heatmap showing the position of the current `_src` relative to its past `_lookBack` values.\ndrawHeatmap(src, lookBack) =>\n    // float src     : evaluated price series.\n    // int   lookBack: number of past bars evaluated.\n    // Dependency: MAX_LOOKBACK\n\n    // Force historical buffer to a sufficient size.\n    max_bars_back(src, MAX_LOOKBACK)\n    // Only run table code on last bar.\n    if barstate.islast\n        var heatmap = table.new(position.bottom_center, lookBack, 1)\n        for i = 1 to lookBackInput\n            float transp = 100. * i / lookBack\n            if src > src[i]\n                table.cell(heatmap, lookBack - i, 0, bgcolor = color.new(bullColorInput, transp))\n            else\n                table.cell(heatmap, lookBack - i, 0, bgcolor = color.new(bearColorInput, transp))\n\ndrawHeatmap(high, lookBackInput)\nNote that:\n\nWe define a maximum lookback period as a MAX_LOOKBACK constant. This is an important value and we use it for two purposes: to specify the number of columns we will create in our one-row table, and to specify the lookback period required for the _src argument in our function, so that we force Pine Script to create a historical buffer size that will allow us to refer to the required quantity of past values of _src in our for loop.\nWe offer users the possibility of configuring the bull/bear colors in the inputs and we use inline to place the color selections on the same line.\nInside our function, we enclose our table-creation code in an if barstate.islast construct so that it only runs on the last bar of the chart.\nThe initialization of the table is done inside the if statement. Because of that, and the fact that it uses the var keyword, initialization only occurs the first time the script executes on a last bar. Note that this behavior is different from the usual var declarations in the script‚Äôs global scope, where initialization occurs on the first bar of the dataset, at bar_index zero.",
    "keywords": [
      "input.int",
      "input.color",
      "barstate.islast",
      "table.new",
      "position.bottom_center",
      "table.cell",
      "color.new",
      "indicator",
      "input",
      "bgcolor",
      "var",
      "series",
      "const",
      "import",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-351",
    "type": "documentation",
    "source": "visuals/tables.md",
    "section": "visuals",
    "title": "tables",
    "content": "We do not specify an argument to the text parameter in our table.cell() calls, so an empty string is used.\nWe calculate our transparency in such a way that the intensity of the colors decreases as we go further in history.\nWe use dynamic color generation to create different transparencies of our base colors as needed.\nContrary to other objects displayed in Pine scripts, this heatmap‚Äôs cells are not linked to chart bars. The configured lookback period determines how many table cells the heatmap contains, and the heatmap will not change as the chart is panned horizontally, or scaled.\nThe maximum number of cells that can be displayed in the script‚Äôs visual space will depend on your viewing device‚Äôs resolution and the portion of the display used by your chart. Higher resolution screens and wider windows will allow more table cells to be displayed.\nTips\nWhen creating tables in strategy scripts, keep in mind that unless the strategy uses calc_on_every_tick = true, table code enclosed in if barstate.islast blocks will not execute on each realtime update, so the table will not display as you expect.\nKeep in mind that successive calls to table.cell() overwrite the cell‚Äôs properties specified by previous table.cell() calls. Use the setter functions to modify a cell‚Äôs properties.\nRemember to control the execution of your table code wisely by restricting it to the necessary bars only. This saves server resources and your charts will display faster, so everybody wins.",
    "keywords": [
      "table.cell",
      "barstate.islast",
      "strategy",
      "if"
    ]
  },
  {
    "id": "doc-352",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Introduction](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#introduction)",
    "content": "# [Text and  shapes](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#text-and-shapes)",
    "keywords": [
      "www.tradingview"
    ]
  },
  {
    "id": "doc-353",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[‚Äã`plotchar()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotchar)",
    "content": "## [Introduction](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#introduction)\n\nPine Script¬Æ features five different ways to display text or shapes on the chart:\n\n-   [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)\n-   [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)\n-   [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)\n-   Labels created with  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)\n-   Tables created with  [table.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.new)  (see  [Tables](https://www.tradingview.com/pine-script-docs/visuals/tables/))\n\nWhich one to use depends on your needs:\n\n-   Tables can display text in various relative positions on a chart, which do not move as users zoom in or scroll the chart horizontally. Their content is not tethered to bars. In contrast, text displayed with  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar),  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  or  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  is always tethered to a specific bar, so it will move with the bar‚Äôs position on the chart. See the page on  [Tables](https://www.tradingview.com/pine-script-docs/visuals/tables/)  for more information on them.\n-   Three elements can display pre-defined shapes:  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape),  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  and labels created with  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new).\n-   [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  cannot display text, only up or down arrows.\n-   [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  can display non-dynamic text on any bar or all bars of the chart.\n-   [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  can only display one character while  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  can display strings, including line breaks.\n-   [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  can display a maximum of 500 labels on the chart. Its text  **can**  contain dynamic text, or ‚Äúseries strings‚Äù. Line breaks are also supported in label text.\n-   While  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  can display text at a fixed offset in the past or the future, which cannot change during the script‚Äôs execution, each  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  call can use a ‚Äúseries‚Äù offset that can be calculated on the fly.\n\nThese are a few things to keep in mind concerning Pine Script  [strings](https://www.tradingview.com/pine-script-docs/concepts/strings/):\n\n-   Since the  `text`  parameter in both  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  require a ‚Äúconst string‚Äù argument, it cannot contain values such as prices that can only be known on the bar (‚Äúseries string‚Äù).\n-   To include ‚Äúseries‚Äù values in text displayed using  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new), they will first need to be converted to strings using  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring).\n-   The concatenation operator for strings in Pine is  `+`. It is used to join string components into one string, e.g.,  `msg = \"Chart symbol: \" + syminfo.tickerid`  (where  [syminfo.tickerid](https://www.tradingview.com/pine-script-reference/v6/#var_syminfo.tickerid)  is a built-in variable that returns the chart‚Äôs exchange and symbol information in string format).\n-   Characters displayed by all these functions can be Unicode characters, which may include Unicode symbols. See this  [Exploring Unicode](https://www.tradingview.com/script/0rFQOCKf-Exploring-Unicode/)  script to get an idea of what can be done with Unicode characters.\n-   Some functions have parameters that can specify the color, size, font family, and formatting of displayed text. For example, drawing objects like  [labels](https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels),  [tables](https://www.tradingview.com/pine-script-docs/concepts/tables/), and  [boxes](https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#boxes)  support text formatting such as bold, italics, and monospace.\n-   Pine scripts display strings using the system default font. The exact font may vary based on the user‚Äôs operating system.\n\nThis script displays text using the four methods available in Pine Script:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Four displays of text\",  overlay  =  true)  \nplotchar(ta.rising(close,  5),  \"`plotchar()`\",  \"ü†Ö\",  location.belowbar,  color.lime,  size  =  size.small)  \nplotshape(ta.falling(close,  5),  \"`plotchar()`\",  location  =  location.abovebar,  color  =  na,  text  =  \"‚Ä¢`plotshape()‚Ä¢`\\nü†á\",  textcolor  =  color.fuchsia,  size  =  size.huge)  \n  \nif  bar_index  %  25  ==  0  \nlabel.new(bar_index,  na,  \"‚Ä¢LABEL‚Ä¢\\nHigh = \"  +  str.tostring(high,  format.mintick) +  \"\\nü†á\",  yloc  =  yloc.abovebar,  style  =  label.style_none,  textcolor  =  color.black,  size  =  size.normal)  \n  \nprintTable(txt) =>  var  table  t  =  table.new(position.middle_right,  1,  1),  table.cell(t,  0,  0,  txt,  bgcolor  =  color.yellow)  \nprintTable(\"‚Ä¢TABLE‚Ä¢\\n\"  +  str.tostring(bar_index  +  1) +  \" bars\\nin the dataset\")  \n``\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Introduction-01.Caf7GxqL_Z22HKK1.webp)\n\nNote that:\n\n-   The method used to display each text string is shown with the text, except for the lime up arrows displayed using  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar), as it can only display one character.\n-   Label and table calls can be inserted in conditional structures to control when their are executed, whereas  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  cannot. Their conditional plotting must be controlled using their first argument, which is a ‚Äúseries bool‚Äù whose  `true`  or  `false`  value determines when the text is displayed.\n-   Numeric values displayed in the table and labels is first converted to a string using  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring).\n-   We use the  `+`  operator to concatenate string components.\n-   [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  is designed to display a shape with accompanying text. Its  `size`  parameter controls the size of the shape, not of the text. We use  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  for its  `color`  argument so that the shape is not visible.\n-   Contrary to other texts, the table text will not move as you scroll or scale the chart.\n-   Some text strings contain the ü†á Unicode arrow (U+1F807).\n-   Some text strings contain the  `\\n`  sequence that represents a new line.",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "table.new",
      "fun_table.new",
      "str.tostring",
      "fun_str.tostring",
      "e.g",
      "syminfo.tickerid",
      "var_syminfo.tickerid",
      "tradingview.com",
      "ta.rising",
      "location.belowbar",
      "color.lime",
      "size.small",
      "ta.falling",
      "location.abovebar",
      "color.fuchsia",
      "size.huge",
      "format.mintick",
      "yloc.abovebar",
      "label.style_none",
      "color.black",
      "size.normal",
      "position.middle_right",
      "table.cell",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "series",
      "const",
      "method",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-354",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[‚Äã`plotshape()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotshape)",
    "content": "## [‚Äã`plotchar()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotchar)\n\nThis function is useful to display a single character on bars. It has the following syntax:\n\n```\n\n```\n\nSee the Reference Manual entry for  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  for details on its parameters.\n\nAs explained in the  [Plotting without affecting the scale](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-without-affecting-the-scale)  section of our page on  [Debugging](https://www.tradingview.com/pine-script-docs/writing/debugging/), the function can be used to display and inspect values in the Data Window or in the indicator values displayed to the right of the script‚Äôs name on the chart:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nplotchar(bar_index,  \"Bar index\",  \"\",  location.top)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotchar-01.Bocx9V6g_Z13RLu0.webp)\n\nNote that:\n\n-   The cursor is on the chart‚Äôs last bar.\n-   The value of  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  on  **that**  bar is displayed in indicator values (1) and in the Data Window (2).\n-   We use  [location.top](https://www.tradingview.com/pine-script-reference/v6/#const_location.top)  because the default  [location.abovebar](https://www.tradingview.com/pine-script-reference/v6/#const_location.abovebar)  will put the price into play in the script‚Äôs scale, which will often interfere with other plots.\n\n[plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  also works well to identify specific points on the chart or to validate that conditions are  `true`  when we expect them to be. This example displays an up arrow under bars where  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  and  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume)  have all been rising for two bars:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nbool  longSignal  =  ta.rising(close,  2) and  ta.rising(high,  2) and (na(volume) or  ta.rising(volume,  2))  \nplotchar(longSignal,  \"Long\",  \"‚ñ≤\",  location.belowbar,  color  =  na(volume) ?  color.gray  :  color.blue,  size  =  size.tiny)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotchar-02.CP9gwRwQ_cuUlM.webp)\n\nNote that:\n\n-   We use  `(na(volume) or ta.rising(volume, 2))`  so our script will work on symbols without  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume)  data. If we did not make provisions for when there is no  [volume](https://www.tradingview.com/pine-script-reference/v6/#var_volume)  data, which is what  `na(volume)`  does by being  `true`  when there is no volume, the  `longSignal`  variable‚Äôs value would never be  `true`  because  `ta.rising(volume, 2)`  yields  `false`  in those cases.\n-   We display the arrow in gray when there is no volume, to remind us that all three base conditions are not being met.\n-   Because  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  is now displaying a character on the chart, we use  `size = size.tiny`  to control its size.\n-   We have adapted the  `location`  argument to display the character under bars.\n\nIf you don‚Äôt mind plotting only circles, you could also use  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  to achieve a similar effect:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nlongSignal  =  ta.rising(close,  2) and  ta.rising(high,  2) and (na(volume) or  ta.rising(volume,  2))  \nplot(longSignal  ?  low  -  ta.tr  :  na,  \"Long\",  color.blue,  2,  plot.style_circles)  \n`\n\nThis method has the inconvenience that, since there is no relative positioning mechanism with  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  one must shift the circles down using something like  [ta.tr](https://www.tradingview.com/pine-script-reference/v6/#var_ta.tr)  (the bar‚Äôs ‚ÄúTrue Range‚Äù):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotchar-03.lnUtjJIt_5GDoG.webp)",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "location.top",
      "const_location.top",
      "location.abovebar",
      "const_location.abovebar",
      "ta.rising",
      "location.belowbar",
      "color.gray",
      "color.blue",
      "size.tiny",
      "ta.tr",
      "plot.style_circles",
      "var_ta.tr",
      "indicator",
      "plot",
      "var",
      "const",
      "method",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-355",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[‚Äã`plotarrow()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotarrow)",
    "content": "## [‚Äã`plotshape()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotshape)\n\nThis function is useful to display pre-defined shapes and/or text on bars. It has the following syntax:\n\n```\n\n```\n\nSee the Reference Manual entry for  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  for details on its parameters.\n\nLet‚Äôs use the function to achieve more or less the same result as with our second example of the previous section:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nlongSignal  =  ta.rising(close,  2) and  ta.rising(high,  2) and (na(volume) or  ta.rising(volume,  2))  \nplotshape(longSignal,  \"Long\",  shape.arrowup,  location.belowbar)  \n`\n\nNote that here, rather than using an arrow character, we are using the  `shape.arrowup`  argument for the  `style`  parameter.\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotshape-01.JOPpSRCa_1wGGd4.webp)\n\nIt is possible to use different  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  calls to superimpose text on bars. You need to use the newline character sequence,  `\\n`. The newline needs to be the  **last**  one in the string for text going up, and the  **first**  one when you are plotting under the bar and text is going down:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Lift text\",  \"\",  true)  \nplotshape(true,  \"\",  shape.arrowup,  location.abovebar,  color.green,  text  =  \"A\")  \nplotshape(true,  \"\",  shape.arrowup,  location.abovebar,  color.lime,  text  =  \"B\\n\")  \nplotshape(true,  \"\",  shape.arrowdown,  location.belowbar,  color.red,  text  =  \"C\")  \nplotshape(true,  \"\",  shape.arrowdown,  location.belowbar,  color.maroon,  text  =  \"‚Äã\\nD\")  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotshape-02.CuvXGcSI_3Ad17.webp)\n\nThe available shapes you can use with the  `style`  parameter are:\n\nArgument\n\nShape\n\nWith Text\n\nArgument\n\nShape\n\nWith Text\n\n`shape.xcross`\n\n![Plotshape_xcross](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_xcross.CqpTSatD_12B5cN.webp)\n\n![Xcross_with_text](https://www.tradingview.com/pine-script-docs/_astro/Xcross_with_text.CsITFsrT_1pTrdp.webp)\n\n`shape.arrowup`\n\n![Plotshape_arrowup](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_arrowup.CW1yrDMp_Z1rr90M.webp)\n\n![Arrowup_with_text](https://www.tradingview.com/pine-script-docs/_astro/Arrowup_with_text.DZDHU0_8_1FaupX.webp)\n\n`shape.cross`\n\n![Plotshape_cross](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_cross.CKH3VPKx_Z2n6Nlr.webp)\n\n![Cross_with_text](https://www.tradingview.com/pine-script-docs/_astro/Cross_with_text.CtReU8CU_ZIyc6H.webp)\n\n`shape.arrowdown`\n\n![Plotshape_arrowdown](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_arrowdown.B-q2lOyW_Z1DPN2R.webp)\n\n![Arrowdown_with_text](https://www.tradingview.com/pine-script-docs/_astro/Arrowdown_with_text.DjuzMvwv_liley.webp)\n\n`shape.circle`\n\n![Plotshape_circle](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_circle.C1i8wH61_Z1r7VpY.webp)\n\n![Circle_with_text](https://www.tradingview.com/pine-script-docs/_astro/Circle_with_text.WA6whkZO_Z2ss0o7.webp)\n\n`shape.square`\n\n![Plotshape_square](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_square.C0HqeKpT_Z2vP0aj.webp)\n\n![Square_with_text](https://www.tradingview.com/pine-script-docs/_astro/Square_with_text.Cs7f7vtU_ZQ5w6n.webp)\n\n`shape.triangleup`\n\n![Plotshape_triangleup](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_triangleup.DSdn-Z9j_Z1evkl7.webp)\n\n![Triangleup_with_text](https://www.tradingview.com/pine-script-docs/_astro/Triangleup_with_text.QVon6H1r_Z1B8FDq.webp)\n\n`shape.diamond`\n\n![Plotshape_diamond](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_diamond.CPu2rKgV_MWJwF.webp)\n\n![Diamond_with_text](https://www.tradingview.com/pine-script-docs/_astro/Diamond_with_text.CGBBjhsU_1Mzs8I.webp)\n\n`shape.triangledown`\n\n![Plotshape_triangledown](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_triangledown.D3CZ8Iw5_1K890M.webp)\n\n![Triangledown_with_text](https://www.tradingview.com/pine-script-docs/_astro/Triangledown_with_text.BNalFnw6_Z26gke6.webp)\n\n`shape.labelup`\n\n![Plotshape_labelup](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_labelup.BEl-5lc0_Z2kYQOT.webp)\n\n![Labelup_with_text](https://www.tradingview.com/pine-script-docs/_astro/Labelup_with_text.BZCbEuFR_Z1DJ1iU.webp)\n\n`shape.flag`\n\n![Plotshape_flag](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_flag.Cj1OxWfL_1Hh1UW.webp)\n\n![Flag_with_text](https://www.tradingview.com/pine-script-docs/_astro/Flag_with_text.PGNhrE2y_29i1uf.webp)\n\n`shape.labeldown`\n\n![Plotshape_labeldown](https://www.tradingview.com/pine-script-docs/_astro/Plotshape_labeldown.CoBObOmO_Z2sHwUh.webp)\n\n![Labeldown_with_text](https://www.tradingview.com/pine-script-docs/_astro/Labeldown_with_text.lJXVqT03_Z2nweNY.webp)",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "ta.rising",
      "shape.arrowup",
      "location.belowbar",
      "location.abovebar",
      "color.green",
      "color.lime",
      "shape.arrowdown",
      "color.red",
      "color.maroon",
      "shape.xcross",
      "shape.cross",
      "shape.circle",
      "shape.square",
      "shape.triangleup",
      "shape.diamond",
      "shape.triangledown",
      "shape.labelup",
      "shape.flag",
      "shape.labeldown",
      "indicator",
      "plot",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-356",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)",
    "content": "## [‚Äã`plotarrow()`‚Äã](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#plotarrow)\n\nThe  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  function displays up or down arrows of variable length, based on the relative value of the series used in the function‚Äôs first argument. It has the following syntax:\n\n```\n\n```\n\nSee the Reference Manual entry for  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  for details on its parameters.\n\nThe  `series`  parameter in  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  is not a ‚Äúseries bool‚Äù as in  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape); it is a ‚Äúseries int/float‚Äù and there‚Äôs more to it than a simple  `true`  or  `false`  value determining when the arrows are plotted. This is the logic governing how the argument supplied to  `series`  affects the behavior of  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow):\n\n-   `series > 0`: An up arrow is displayed, the length of which will be proportional to the relative value of the series on that bar in relation to other series values.\n-   `series < 0`: A down arrow is displayed, proportionally-sized using the same rules.\n-   `series == 0 or na(series)`: No arrow is displayed.\n\nThe maximum and minimum possible sizes for the arrows (in pixels) can be controlled using the  `minheight`  and  `maxheight`  parameters.\n\nHere is a simple script illustrating how  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  works:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nbody  =  close  -  open  \nplotarrow(body,  colorup  =  color.teal,  colordown  =  color.orange)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotarrow-01.KkXXJXUI_Z1LV4X8.webp)\n\nNote how the height of arrows is proportional to the relative size of the bar bodies.\n\nYou can use any series to plot the arrows. Here we use the value of the ‚ÄúChaikin Oscillator‚Äù to control the location and size of the arrows:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Chaikin Oscillator Arrows\",  overlay  =  true)  \nfastLengthInput  =  input.int(3,  minval  =  1)  \nslowLengthInput  =  input.int(10,  minval  =  1)  \nosc  =  ta.ema(ta.accdist,  fastLengthInput) -  ta.ema(ta.accdist,  slowLengthInput)  \nplotarrow(osc)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-Plotarrow-02.ChRmPIiy_Zb0OYl.webp)\n\nNote that we display the actual ‚ÄúChaikin Oscillator‚Äù in a pane below the chart, so you can see what values are used to determine the position and size of the arrows.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.teal",
      "color.orange",
      "input.int",
      "ta.ema",
      "ta.accdist",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for"
    ]
  },
  {
    "id": "doc-357",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Creating and modifying  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#creating-and-modifying-labels)",
    "content": "## [Labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)\n\nLabels are only available in v4 and higher versions of Pine Script. They work very differently than  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape).\n\nLabels are objects, like  [lines and boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/), or  [tables](https://www.tradingview.com/pine-script-docs/visuals/tables/). Like them, they are referred to using an ID, which acts like a pointer. Label IDs are of ‚Äúlabel‚Äù type. As with other objects, labels IDs are ‚Äútime series‚Äù and all the functions used to manage them accept ‚Äúseries‚Äù arguments, which makes them very flexible.\n\nNoteThe Supercharts interface features a set of  _drawing tools_  that enable users to draw on the chart using mouse actions. Although some of those drawings might resemble the outputs of a script‚Äôs drawing objects, it‚Äôs crucial to understand that they are  **unrelated**  entities. Scripts cannot interact with the chart‚Äôs drawing tools. Additionally, mouse actions do not directly affect a script‚Äôs drawing objects.\n\nLabels are advantageous because:\n\n-   They allow ‚Äúseries‚Äù values to be converted to text and placed on charts. This means they are ideal to display values that cannot be known before time, such as price values, support and resistance levels, of any other values that your script calculates.\n-   Their positioning options are more flexible that those of the  `plot*()`  functions.\n-   They offer more display modes.\n-   Contrary to  `plot*()`  functions, label-handling functions can be inserted in conditional or loop structures, making it easier to control their behavior.\n-   You can add tooltips to labels.\n\nOne drawback to using labels versus  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  is that you can only draw a limited quantity of them on the chart. The default is ~50, but you can use the  `max_labels_count`  parameter in your  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement to specify up to 500. Labels, like  [lines and boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/), are managed using a garbage collection mechanism which deletes the oldest ones on the chart, such that only the most recently drawn labels are visible.\n\nYour toolbox of built-ins to manage labels are all in the  `label`  namespace. They include:\n\n-   [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  to create labels.\n-   `label.set_*()`  functions to modify the properties of an existing label.\n-   `label.get_*()`  functions to read the properties of an existing label.\n-   [label.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.delete)  to delete labels\n-   The  [label.all](https://www.tradingview.com/pine-script-reference/v6/#var_label.all)  array which always contains the IDs of all the visible labels on the chart. The array‚Äôs size will depend on the maximum label count for your script and how many of those you have drawn.  `aray.size(label.all)`  will return the array‚Äôs size.",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "label.set_",
      "label.get_",
      "label.delete",
      "fun_label.delete",
      "label.all",
      "var_label.all",
      "aray.size",
      "indicator",
      "strategy",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-358",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Positioning  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#positioning-labels)",
    "content": "### [Creating and modifying  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#creating-and-modifying-labels)\n\nThe  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  function creates a new label object on the chart. It has the following signatures:\n\n```\n\n```\n\nThe difference between the two signatures is how they specify the label‚Äôs coordinates on the chart. The first signature uses a  `point`  parameter, which accepts a  [chart point](https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points)  object. The second signature uses  `x`  and  `y`  parameters, which accept ‚Äúseries int/float‚Äù values. For both signatures, the x-coordinate of a label can be either a bar index or time value, depending on the  `xloc`  property.\n\nThe  _setter_  functions allowing you to change a label‚Äôs properties are:\n\n-   [label.set_x()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_x)\n-   [label.set_y()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_y)\n-   [label.set_xy()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xy)\n-   [label.set_point()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_point)\n-   [label.set_text()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_text)\n-   [label.set_xloc()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xloc)\n-   [label.set_yloc()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_yloc)\n-   [label.set_color()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_color)\n-   [label.set_style()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_style)\n-   [label.set_textcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_textcolor)\n-   [label.set_size()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_size)\n-   [label.set_textalign()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_textalign)\n-   [label.set_tooltip()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_tooltip)\n-   [label.set_text_font_family()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_text_font_family)\n-   [label.set_text_formatting()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_text_formatting)\n\nThey all have a similar signature. The one for  [label.set_color()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_color)  is:\n\n```\n\n```\n\nwhere:\n\n-   `id`  is the ID of the label whose property is to be modified.\n-   The next parameter is the property of the label to modify. It depends on the setter function used.  [label.set_xy()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xy)  changes two properties, so it has two such parameters.\n\nThis is how you can create labels in their simplest form:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nlabel.new(bar_index,  high)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-CreatingLabels-01.BHaO-o78_Y8WYV.webp)\n\nNote that:\n\n-   The label is created with the parameters  `x = bar_index`  (the index of the current bar,  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)) and  `y = high`  (the bar‚Äôs  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  value).\n-   We do not supply an argument for the function‚Äôs  `text`  parameter. Its default value being an empty string, no text is displayed.\n-   No logic controls our  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  call, so labels are created on every bar.\n-   Only the last 54 labels are displayed because our  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  call does not use the  `max_labels_count`  parameter to specify a value other than the ~50 default.\n-   Labels persist on bars until your script deletes them using  [label.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.delete), or garbage collection removes them.\n\nIn the next example we display a label on the bar with the highest  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  value in the last 50 bars:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"\",  \"\",  true)  \n  \n// Find the highest `high` in last 50 bars and its offset. Change it's sign so it is positive.  \nLOOKBACK  =  50  \nhi  =  ta.highest(LOOKBACK)  \nhighestBarOffset  =  -  ta.highestbars(LOOKBACK)  \n  \n// Create label on bar zero only.  \nvar  lbl  =  label.new(na,  na,  \"\",  color  =  color.orange,  style  =  label.style_label_lower_left)  \n// When a new high is found, move the label there and update its text and tooltip.  \nif  ta.change(hi) !=  0  \n// Build label and tooltip strings.  \nlabelText  =  \"High: \"  +  str.tostring(hi,  format.mintick)  \ntooltipText  =  \"Offest in bars: \"  +  str.tostring(highestBarOffset) +  \"\\nLow: \"  +  str.tostring(low[highestBarOffset],  format.mintick)  \n// Update the label's position, text and tooltip.  \nlabel.set_xy(lbl,  bar_index[highestBarOffset],  hi)  \nlabel.set_text(lbl,  labelText)  \nlabel.set_tooltip(lbl,  tooltipText)  \n``\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-CreatingLabels-02.CaxmDfMG_1vmoqQ.webp)\n\nNote that:\n\n-   We create the label on the first bar only by using the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword to declare the  `lbl`  variable that contains the label‚Äôs ID. The  `x`,  `y`  and  `text`  arguments in that  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  call are irrelevant, as the label will be updated on further bars. We do, however, take care to use the  `color`  and  `style`  we want for the labels, so they don‚Äôt need updating later.\n-   On every bar, we detect if a new high was found by testing for changes in the value of  `hi`\n-   When a change in the high value occurs, we update our label with new information. To do this, we use three  `label.set*()`  calls to change the label‚Äôs relevant information. We refer to our label using the  `lbl`  variable, which contains our label‚Äôs ID. The script is thus maintaining the same label throughout all bars, but moving it and updating its information when a new high is detected.\n\nHere we create a label on each bar, but we set its properties conditionally, depending on the bar‚Äôs polarity:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nlbl  =  label.new(bar_index,  na)  \nif  close  >=  open  \nlabel.set_text( lbl,  \"green\")  \nlabel.set_color(lbl,  color.green)  \nlabel.set_yloc( lbl,  yloc.belowbar)  \nlabel.set_style(lbl,  label.style_label_up)  \nelse  \nlabel.set_text( lbl,  \"red\")  \nlabel.set_color(lbl,  color.red)  \nlabel.set_yloc( lbl,  yloc.abovebar)  \nlabel.set_style(lbl,  label.style_label_down)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-CreatingLabels-03.ClglPmUL_Z1Jm6jL.webp)",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "label.set_x",
      "fun_label.set_x",
      "label.set_y",
      "fun_label.set_y",
      "label.set_xy",
      "fun_label.set_xy",
      "label.set_point",
      "fun_label.set_point",
      "label.set_text",
      "fun_label.set_text",
      "label.set_xloc",
      "fun_label.set_xloc",
      "label.set_yloc",
      "fun_label.set_yloc",
      "label.set_color",
      "fun_label.set_color",
      "label.set_style",
      "fun_label.set_style",
      "label.set_textcolor",
      "fun_label.set_textcolor",
      "label.set_size",
      "fun_label.set_size",
      "label.set_textalign",
      "fun_label.set_textalign",
      "label.set_tooltip",
      "fun_label.set_tooltip",
      "label.set_text_font_family",
      "fun_label.set_text_font_family",
      "label.set_text_formatting",
      "fun_label.set_text_formatting",
      "tradingview.com",
      "label.delete",
      "fun_label.delete",
      "ta.highest",
      "ta.highestbars",
      "color.orange",
      "label.style_label_lower_left",
      "ta.change",
      "str.tostring",
      "format.mintick",
      "label.set",
      "color.green",
      "yloc.belowbar",
      "label.style_label_up",
      "color.red",
      "yloc.abovebar",
      "label.style_label_down",
      "indicator",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-359",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Reading label  properties](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#reading-label-properties)",
    "content": "### [Positioning  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#positioning-labels)\n\nLabels are positioned on the chart according to  _x_  (bars) and  _y_  (price) coordinates. Five parameters affect this behavior:  `x`,  `y`,  `xloc`,  `yloc`  and  `style`:\n\n`x`\n\nIs either a bar index or a time value. When a bar index is used, the value can be offset in the past or in the future (up to a maximum of 500 bars in the future and 10,000 bars in the past). Past or future offsets can also be calculated when using time values. The  `x`  value of an existing label can be modified using  [label.set_x()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_x)  or  [label.set_xy()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xy).\n\n`xloc`\n\nIs either  [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_index)  (the default) or  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_time). It determines which type of argument must be used with  `x`. With  [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_index),  `x`  must be an absolute bar index. With  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_time),  `x`  must be a UNIX time in milliseconds corresponding to the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  value of a bar‚Äôs  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open). The  `xloc`  value of an existing label can be modified using  [label.set_xloc()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xloc).\n\n`y`\n\nIs the price level where the label is positioned. It is only taken into account with the default  `yloc`  value of  [yloc.price](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.price). If  `yloc`  is  [yloc.abovebar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.abovebar)  or  [yloc.belowbar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.belowbar)  then the  `y`  argument is ignored. The  `y`  value of an existing label can be modified using  [label.set_y()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_y)  or  [label.set_xy()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_xy).\n\n`yloc`\n\nCan be  [yloc.price](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.price)  (the default),  [yloc.abovebar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.abovebar)  or  [yloc.belowbar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.belowbar). The argument used for  `y`  is only taken into account with  [yloc.price](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.price). The  `yloc`  value of an existing label can be modified using  [label.set_yloc()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_yloc).\n\n`style`\n\nThe argument used has an impact on the visual appearance of the label and on its position relative to the reference point determined by either the  `y`  value or the top/bottom of the bar when  [yloc.abovebar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.abovebar)  or  [yloc.belowbar](https://www.tradingview.com/pine-script-reference/v6/#const_yloc.belowbar)  are used. The  `style`  of an existing label can be modified using  [label.set_style()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_style).\n\nThese are the available  `style`  arguments:\n\nArgument\n\nLabel\n\nLabel with text\n\nArgument\n\nLabel\n\nLabel with text\n\n`label.style_xcross`\n\n![label_style_xcross](https://www.tradingview.com/pine-script-docs/_astro/label.style_xcross.C9JSUQRE_v14T2.webp)\n\n![label_style_xcross_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_xcross_t.DPHiuTMd_ZArsHs.webp)\n\n`label.style_label_up`\n\n![label_style_label_up](https://www.tradingview.com/pine-script-docs/_astro/label.style_labelup.BwgLLtO1_Z1l1um8.webp)\n\n![label_style_label_up_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_labelup_t.BGJ7MtwJ_xL0VI.webp)\n\n`label.style_cross`\n\n![label_style_cross](https://www.tradingview.com/pine-script-docs/_astro/label.style_cross.rv8J58or_Uz067.webp)\n\n![label_style_cross_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_cross_t.CMucKs6T_ZSh4W0.webp)\n\n`label.style_label_down`\n\n![label_style_label_down](https://www.tradingview.com/pine-script-docs/_astro/label.style_labeldown.BFAq-8ZE_ZIvq7L.webp)\n\n![label_style_label_down_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_labeldown_t.L-NIjl15_k2Tfr.webp)\n\n`label.style_flag`\n\n![label_style_flag](https://www.tradingview.com/pine-script-docs/_astro/label.style_flag.B5SqpJOR_ZNiesK.webp)\n\n![label_style_flag_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_flag_t.Yd9se8TY_ZcPibj.webp)\n\n`label.style_label_left`\n\n![label_style_label_left](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelleft.CoJwMI_X_ZHLCfA.webp)\n\n![label_style_label_left_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelleft_t.CMNu0DBH_Z1Mtkbi.webp)\n\n`label.style_circle`\n\n![label_style_circle](https://www.tradingview.com/pine-script-docs/_astro/label.style_circle.B1NdiRhT_15VqGC.webp)\n\n![label_style_circle_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_circle_t.DfdC3pj7_ZP9V9R.webp)\n\n`label.style_label_right`\n\n![label_style_label_right](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelright.DgXGrRa9_ipC7A.webp)\n\n![label_style_label_right_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelright_t.D44pTqgu_2umAQq.webp)\n\n`label.style_square`\n\n![label_style_square](https://www.tradingview.com/pine-script-docs/_astro/label.style_square.CUNIiJ9b_ZlvPE0.webp)\n\n![label_style_square_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_square_t.-OUB179q_Z1BAnvM.webp)\n\n`label.style_label_lower_left`\n\n![label_style_label_lower_left](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labellowerleft.D2hZptp3_ZUxi8P.webp)\n\n![label_style_label_lower_left_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labellowerleft_t.Kwxk7klP_Z18eq2A.webp)\n\n`label.style_diamond`\n\n![label_style_diamond](https://www.tradingview.com/pine-script-docs/_astro/label.style_diamond.COncn0Zi_1lDxHq.webp)\n\n![label_style_diamond_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_diamond_t.e7SsTV_d_VN69k.webp)\n\n`label.style_label_lower_right`\n\n![label_style_label_lower_right](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labellowerright.GvDkEi7V_Z2o0oHI.webp)\n\n![label_style_label_lower_right_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labellowerright_t.CT8ecmHn_2dYi27.webp)\n\n`label.style_triangleup`\n\n![label_style_triangleup](https://www.tradingview.com/pine-script-docs/_astro/label.style_triangleup.DHU9hA18_19xNp4.webp)\n\n![label_style_triangleup_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_triangleup_t.C6XS8y_c_12VNsS.webp)\n\n`label.style_label_upper_left`\n\n![label_style_label_upper_left](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelupperleft.DzaMZ6Lm_Z2jdeMW.webp)\n\n![label_style_label_upper_left_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelupperleft_t.jBf41_qj_1z9Nuv.webp)\n\n`label.style_triangledown`\n\n![label_style_triangledown](https://www.tradingview.com/pine-script-docs/_astro/label.style_triangledown.CVD8jP47_AOqWU.webp)\n\n![label_style_triangledown_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_triangledown_t.Ds2S1BfO_hU5ru.webp)\n\n`label.style_label_upper_right`\n\n![label_style_label_upper_right](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelupperright.Cs_tEjae_1q9D6Y.webp)\n\n![label_style_label_upper_right_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelupperright_t.gHx7FqVU_2jKzoK.webp)\n\n`label.style_arrowup`\n\n![label_style_arrowup](https://www.tradingview.com/pine-script-docs/_astro/label.style_arrowup.Bnnvniie_Zvzaa5.webp)\n\n![label_style_arrowup_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_arrowup_t.CSukCsAU_Z2kIGh6.webp)\n\n`label.style_label_center`\n\n![label_style_label_center](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelcenter.BDNM-3_M_Z1yvaCH.webp)\n\n![label_style_label_center_t](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-LabelStyles-labelcenter_t.DGjIAaki_VY0Yv.webp)\n\n`label.style_arrowdown`\n\n![label_style_arrowdown](https://www.tradingview.com/pine-script-docs/_astro/label.style_arrowdown.DHUuQ7Xu_Z8bfOV.webp)\n\n![label_style_arrowdown_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_arrowdown_t.BsY5apvs_iNdTw.webp)\n\n`label.style_none`\n\n![label_style_none_t](https://www.tradingview.com/pine-script-docs/_astro/label.style_none_t.iibFInW6_1QhWd.webp)\n\nWhen using  [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_time), the  `x`  value must be a UNIX timestamp in milliseconds. See the page on  [Time](https://www.tradingview.com/pine-script-docs/concepts/time/)  for more information. The start time of the current bar can be obtained from the  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  built-in variable. The bar time of previous bars is  `time[1]`,  `time[2]`  and so on. Time can also be set to an absolute value with the  [timestamp()](https://www.tradingview.com/pine-script-reference/v6/#fun_timestamp)  function. You may add or subtract periods of time to achieve relative time offset.\n\nLet‚Äôs position a label one day ago from the date on the last bar:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\")  \ndaysAgoInput  =  input.int(1,  tooltip  =  \"Use negative values to offset in the future\")  \nif  barstate.islast  \nMS_IN_ONE_DAY  =  24  *  60  *  60  *  1000  \noneDayAgo  =  time  - (daysAgoInput  *  MS_IN_ONE_DAY)  \nlabel.new(oneDayAgo,  high,  xloc  =  xloc.bar_time,  style  =  label.style_label_right)  \n`\n\nNote that because of varying time gaps and missing bars when markets are closed, the positioning of the label may not always be exact. Time offsets of the sort tend to be more reliable on 24x7 markets.\n\nYou can also offset using a bar index for the  `x`  value, e.g.:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`label.new(bar_index  +  10,  high)  \nlabel.new(bar_index  -  10,  high[10])  \nlabel.new(bar_index[10],  high[10])  \n`",
    "keywords": [
      "www.tradingview",
      "label.set_x",
      "fun_label.set_x",
      "label.set_xy",
      "fun_label.set_xy",
      "xloc.bar_index",
      "const_xloc.bar_index",
      "xloc.bar_time",
      "const_xloc.bar_time",
      "label.set_xloc",
      "fun_label.set_xloc",
      "yloc.price",
      "const_yloc.price",
      "yloc.abovebar",
      "const_yloc.abovebar",
      "yloc.belowbar",
      "const_yloc.belowbar",
      "label.set_y",
      "fun_label.set_y",
      "label.set_yloc",
      "fun_label.set_yloc",
      "label.set_style",
      "fun_label.set_style",
      "label.style_xcross",
      "label.style_xcross_t",
      "label.style_label_up",
      "label.style_labelup",
      "label.style_labelup_t",
      "label.style_cross",
      "label.style_cross_t",
      "label.style_label_down",
      "label.style_labeldown",
      "label.style_labeldown_t",
      "label.style_flag",
      "label.style_flag_t",
      "label.style_label_left",
      "label.style_circle",
      "label.style_circle_t",
      "label.style_label_right",
      "label.style_square",
      "label.style_square_t",
      "label.style_label_lower_left",
      "label.style_diamond",
      "label.style_diamond_t",
      "label.style_label_lower_right",
      "label.style_triangleup",
      "label.style_triangleup_t",
      "label.style_label_upper_left",
      "labelupperleft_t.j",
      "label.style_triangledown",
      "label.style_triangledown_t",
      "label.style_label_upper_right",
      "labelupperright_t.g",
      "label.style_arrowup",
      "label.style_arrowup_t",
      "label.style_label_center",
      "label.style_arrowdown",
      "label.style_arrowdown_t",
      "label.style_none",
      "label.style_none_t",
      "tradingview.com",
      "input.int",
      "barstate.islast",
      "label.new",
      "e.g",
      "indicator",
      "input",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-360",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Deleting  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#deleting-labels)",
    "content": "### [Reading label  properties](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#reading-label-properties)\n\nThe following  _getter_  functions are available for labels:\n\n-   [label.get_x()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.get_x)\n-   [label.get_y()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.get_y)\n-   [label.get_text()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.get_text)\n\nThey all have a similar signature. The one for  [label.get_text()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.get_text)  is:\n\n```\n\n```\n\nwhere  `id`  is the label whose text is to be retrieved.\n\n### [Cloning  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#cloning-labels)\n\nThe  [label.copy()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.copy)  function is used to clone labels. Its syntax is:\n\n```\n\n```",
    "keywords": [
      "www.tradingview",
      "label.get_x",
      "fun_label.get_x",
      "label.get_y",
      "fun_label.get_y",
      "label.get_text",
      "fun_label.get_text",
      "label.copy",
      "fun_label.copy",
      "for"
    ]
  },
  {
    "id": "doc-361",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Realtime  behavior](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#realtime-behavior)",
    "content": "### [Deleting  labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#deleting-labels)\n\nThe  [label.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.delete)  function is used to delete labels. Its syntax is:\n\n```\n\n```\n\nTo keep only a user-defined quantity of labels on the chart, one could use code like this:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nMAX_LABELS  =  500  \nindicator(\"\",  max_labels_count  =  MAX_LABELS)  \nqtyLabelsInput  =  input.int(5,  \"Labels to keep\",  minval  =  0,  maxval  =  MAX_LABELS)  \nmyRSI  =  ta.rsi(close,  20)  \nif  myRSI  >  ta.highest(myRSI,  20)[1]  \nlabel.new(bar_index,  myRSI,  str.tostring(myRSI,  \"#.00\"),  style  =  label.style_none)  \nif  array.size(label.all) >  qtyLabelsInput  \nlabel.delete(array.get(label.all,  0))  \nplot(myRSI)  \n`\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/TextAndShapes-DeletingLabels-01.CQiqGcEC_ZRD1mW.webp)\n\nNote that:\n\n-   We define a  `MAX_LABELS`  constant to hold the maximum quantity of labels a script can accommodate. We use that value to set the  `max_labels_count`  parameter‚Äôs value in our  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  call, and also as the  `maxval`  value in our  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int)  call to cap the user value.\n-   We create a new label when our RSI breaches its highest value of the last 20 bars. Note the offset of  `[1]`  we use in  `if myRSI > ta.highest(myRSI, 20)[1]`. This is necessary. Without it, the value returned by  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  would always include the current value of  `myRSI`, so  `myRSI`  would never be higher than the function‚Äôs return value.\n-   After that, we delete the oldest label in the  [label.all](https://www.tradingview.com/pine-script-reference/v6/#var_label.all)  array that is automatically maintained by the Pine Script runtime and contains the ID of all the visible labels drawn by our script. We use the  [array.get()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.get)  function to retrieve the array element at index zero (the oldest visible label ID). We then use  [label.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.delete)  to delete the label linked with that ID.\n\nNote that if one wants to position a label on the last bar only, it is unnecessary and inefficent to create and delete the label as the script executes on all bars, so that only the last label remains:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`// INEFFICENT!  \n//@version=6  \nindicator(\"\",  \"\",  true)  \nlbl  =  label.new(bar_index,  high,  str.tostring(high,  format.mintick))  \nlabel.delete(lbl[1])  \n`\n\nThis is the efficient way to realize the same task:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nif  barstate.islast  \n// Create the label once, the first time the block executes on the last bar.  \nvar  lbl  =  label.new(na,  na)  \n// On all iterations of the script on the last bar, update the label's information.  \nlabel.set_xy(lbl,  bar_index,  high)  \nlabel.set_text(lbl,  str.tostring(high,  format.mintick))  \n`",
    "keywords": [
      "www.tradingview",
      "label.delete",
      "fun_label.delete",
      "tradingview.com",
      "input.int",
      "ta.rsi",
      "ta.highest",
      "label.new",
      "str.tostring",
      "label.style_none",
      "array.size",
      "label.all",
      "array.get",
      "fun_input.int",
      "fun_ta.highest",
      "var_label.all",
      "fun_array.get",
      "format.mintick",
      "barstate.islast",
      "label.set_xy",
      "label.set_text",
      "indicator",
      "input",
      "plot",
      "var",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-362",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Text  formatting](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#text-formatting)",
    "content": "### [Realtime  behavior](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#realtime-behavior)\n\nLabels are subject to both  _commit_  and  _rollback_  actions, which affect the behavior of a script when it executes on the realtime bar. See the  [Execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/)  page to learn more.\n\nThis script demonstrates the effect of rollback when running on the realtime bar:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"\",  \"\",  true)  \nlabel.new(bar_index,  high)  \n`\n\nOn realtime bars,  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  creates a new label on every script update, but because of the rollback process, the label created on the previous update on the same bar is deleted. Only the last label created before the realtime bar‚Äôs close will be committed, and thus persist.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "label.new",
      "fun_label.new",
      "indicator",
      "for"
    ]
  },
  {
    "id": "doc-363",
    "type": "documentation",
    "source": "visuals/texts_and_shapes.md",
    "section": "visuals",
    "title": "[Text  formatting](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#text-formatting)",
    "content": "## [Text  formatting](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#text-formatting)\n\nDrawing objects like  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels),  [tables](https://www.tradingview.com/pine-script-docs/visuals/tables/), and  [boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#boxes)  have text-related properties that allow users to customize how an object‚Äôs text appears on the chart. Some common properties include the text color, size, font family, and typographic emphasis.\n\nProgrammers can set an object‚Äôs text properties when initializing it using the  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new),  [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.new), or  [table.cell()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.cell)  parameters. Alternatively, they can use the corresponding setter functions, e.g.,  [label.set_text_font_family()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.set_text_font_family),  [table.cell_set_text_color()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.cell_set_text_color),  [box.set_text_halign()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_text_halign), etc.\n\nAll three drawing objects have a  `text_formatting`  parameter, which sets the typographic emphasis to display  **bold**,  _italicized_, or unformatted text. It accepts the constants  [text.format_bold](https://www.tradingview.com/pine-script-reference/v6/#const_text.format_bold),  [text.format_italic](https://www.tradingview.com/pine-script-reference/v6/#const_text.format_italic), or  [text.format_none](https://www.tradingview.com/pine-script-reference/v6/#const_text.format_none)  (no special formatting; default value). It also accepts  `text.format_bold + text.format_italic`  to display text that is both  _**bold and italicized**_.\n\nThe  `size`  parameter in  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  and the  `text_size`  parameter in  [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.new)  and  [table.cell()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.cell)  specify the size of the text displayed in the drawn objects. The parameters accept both ‚Äústring‚Äù  `size.*`  constants and ‚Äúint‚Äù typographic sizes. A ‚Äústring‚Äù  `size.*`  constant represents one of six fixed sizing options. An ‚Äúint‚Äù size value can be any positive integer, allowing scripts to replicate the  `size.*`  values or use other customized sizing.\n\nThis table lists the  `size.*`  constants and their equivalent ‚Äúint‚Äù sizes for  [tables](https://www.tradingview.com/pine-script-docs/concepts/tables/),  [boxes](https://www.tradingview.com/pine-script-docs/concepts/lines-and-boxes/#boxes), and  [labels](https://www.tradingview.com/pine-script-docs/concepts/text-and-shapes/#labels):\n\n‚Äústring‚Äù constant\n\n‚Äùint‚Äù  `text_size`  in tables and boxes\n\n‚Äùint‚Äù  `size`  in labels\n\n`size.auto`\n\n0\n\n0\n\n`size.tiny`\n\n8\n\n~7\n\n`size.small`\n\n10\n\n~10\n\n`size.normal`\n\n14\n\n12\n\n`size.large`\n\n20\n\n18\n\n`size.huge`\n\n36\n\n24\n\nThe example below creates a  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  and  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table)  on the last available bar. The label displays a string representation of the current  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value. The single-cell table displays a string representing the price and percentage difference between the current  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  and  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open)  values. The label‚Äôs text size is defined by a  [string input](https://www.tradingview.com/pine-script-docs/concepts/inputs/#string-input)  that returns the value of a built-in  `size.*`  constant, and the table‚Äôs text size is defined by an  [integer input](https://www.tradingview.com/pine-script-docs/concepts/inputs/#integer-input). Additionally, the script creates a  [box](https://www.tradingview.com/pine-script-reference/v6/#type_box)  that visualizes the range from the highest to lowest price over the last 20 bars. The box displays custom text, with a constant  `text_size`  of 19, to show the distance from the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value to the current highest or lowest price. The two  [Boolean inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/#boolean-input)  specify whether all three drawings apply bold and italic text formats to their displayed text:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Text-and-shapes-Text-formatting-1.BNSgpIL__1Wx9IL.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Text formatting demo\",  overlay  =  true)  \n  \n//@variable The size of the `closeLabel` text, set using \"string\" `size.*` constants.  \nstring  closeLabelSize  =  input.string(size.large,  \"Label text size\",  \n[size.auto,  size.tiny,  size.small,  size.normal,  size.large,  size.huge],  group  =  \"Text size\")  \n//@variable The size of the `barMoveTable` text, set using \"int\" sizes.  \nint  tableTextSize  =  input.int(25,  \"Table text size\",  minval  =  0,  group  =  \"Text size\")  \n  \n// Toggles for the text formatting of all the drawing objects (`label`, `table` cell, and `box` texts).  \nbool  formatBold  =  input.bool(false,  \"Bold emphasis\",  group  =  \"Text formatting (all objects)\")  \nbool  formatItalic  =  input.bool(true,  \"Italic emphasis\",  group  =  \"Text formatting (all objects)\")  \n  \n// Track the highest and lowest prices in 20 bars. Used to draw a `box` of the high-low range.  \nfloat  recentHighest  =  ta.highest(20)  \nfloat  recentLowest  =  ta.lowest(20)  \n  \nif  barstate.islast  \n//@variable Label displaying `close` price on last bar. Text size is set using \"string\" constants.  \nlabel  closeLabel  =  label.new(bar_index,  close,  \"Close price: \"  +  str.tostring(close,  \"$0.00\"),  \ncolor  =  #EB9514D8,  style  =  label.style_label_left,  size  =  closeLabelSize)  \n  \n// Create a `table` cell to display the bar move (difference between `open` and `close` price).  \nfloat  barMove  =  close  -  open  \n//@variable Single-cell table displaying the `barMove`. Cell text size is set using \"int\" values.  \nvar  table  barMoveTable  =  table.new(position.bottom_right,  1,  1,  bgcolor  =  barMove  >  0  ?  #31E23FCC  :  #EE4040CC)  \nbarMoveTable.cell(0,  0,  \"Bar move = \"  +  str.tostring(barMove,  \"$0.00\") +  \"\\n Percent = \"  \n+  str.tostring(barMove  /  open,  \"0.00%\"),  text_halign  =  text.align_right,  text_size  =  tableTextSize)  \n  \n// Draw a box to show where current price falls in the range of `recentHighest` to `recentLowest`.  \n//@variable Box drawing the range from `recentHighest` to `recentLowest` in last 20 bars. Text size is set at 19.  \nbox  rangeBox  =  box.new(bar_index  -  20,  recentHighest,  bar_index  +  1,  recentLowest,  text_size  =  19,  \nbgcolor  =  #A4B0F826,  text_valign  =  text.align_top,  text_color  =  #4A07E7D8)  \n// Set box text to display how far current price is from the high or low of the range, depending on which is closer.  \nrangeBox.set_text(\"Current price is \"  +  \n(close  >= (recentHighest  +  recentLowest) /  2  ?  str.tostring(recentHighest  -  close,  \"$0.00\") +  \" from box high\"  \n:  str.tostring(close  -  recentLowest,  \"$0.00\") +  \" from box low\"))  \n  \n// Set the text formatting of the `closeLabel`, `barMoveTable` cell, and `rangeBox` objects.  \n// `formatBold` and `formatItalic` can both be `true` to combine formats, or both `false` for no special formatting.  \nswitch  \nformatBold  and  formatItalic  =>  \ncloseLabel.set_text_formatting(text.format_bold  +  text.format_italic)  \nbarMoveTable.cell_set_text_formatting(0,  0,  text.format_bold  +  text.format_italic)  \nrangeBox.set_text_formatting(text.format_bold  +  text.format_italic)  \nformatBold  =>  \ncloseLabel.set_text_formatting(text.format_bold)  \nbarMoveTable.cell_set_text_formatting(0,  0,  text.format_bold)  \nrangeBox.set_text_formatting(text.format_bold)  \nformatItalic  =>  \ncloseLabel.set_text_formatting(text.format_italic)  \nbarMoveTable.cell_set_text_formatting(0,  0,  text.format_italic)  \nrangeBox.set_text_formatting(text.format_italic)  \n=>  \ncloseLabel.set_text_formatting(text.format_none)  \nbarMoveTable.cell_set_text_formatting(0,  0,  text.format_none)  \nrangeBox.set_text_formatting(text.format_none)``",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "box.new",
      "fun_box.new",
      "table.cell",
      "fun_table.cell",
      "e.g",
      "label.set_text_font_family",
      "fun_label.set_text_font_family",
      "table.cell_set_text_color",
      "fun_table.cell_set_text_color",
      "box.set_text_halign",
      "fun_box.set_text_halign",
      "text.format_bold",
      "const_text.format_bold",
      "text.format_italic",
      "const_text.format_italic",
      "text.format_none",
      "const_text.format_none",
      "size.auto",
      "size.tiny",
      "size.small",
      "size.normal",
      "size.large",
      "size.huge",
      "tradingview.com",
      "input.string",
      "input.int",
      "input.bool",
      "ta.highest",
      "ta.lowest",
      "barstate.islast",
      "str.tostring",
      "label.style_label_left",
      "table.new",
      "position.bottom_right",
      "text.align_right",
      "text.align_top",
      "indicator",
      "overlay",
      "input",
      "bgcolor",
      "var",
      "const",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-364",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Common debug  outputs](https://www.tradingview.com/pine-script-docs/writing/debugging/#common-debug-outputs)",
    "content": "# [Debugging](https://www.tradingview.com/pine-script-docs/writing/debugging/#debugging)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/writing/debugging/#introduction)\n\nTradingView‚Äôs close integration between the Pine Editor and the Supercharts interface enables efficient, interactive debugging of Pine Script¬Æ code. Pine scripts can create dynamic outputs in multiple locations, on and off the chart. Programmers can use these outputs to validate their scripts‚Äô behaviors and ensure everything works as expected.\n\nUnderstanding the most effective tools and methods for inspecting a script helps programmers quickly find and fix potential problems in their code, which improves the overall coding experience. This page explains the script outputs that are the most useful for debugging, along with helpful tips and techniques.\n\nTipEffective debugging in the Pine Script environment requires an understanding of the  [Execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/),  [Time series](https://www.tradingview.com/pine-script-docs/language/execution-model/#time-series)  structure, and  [Type system](https://www.tradingview.com/pine-script-docs/language/type-system/). We recommend reviewing these topics, along with  [string formatting](https://www.tradingview.com/pine-script-docs/concepts/strings/#string-conversion-and-formatting), which the following techniques often use.",
    "keywords": [
      "www.tradingview",
      "series",
      "method",
      "type",
      "for"
    ]
  },
  {
    "id": "doc-365",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Pine  Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)",
    "content": "## [Common debug  outputs](https://www.tradingview.com/pine-script-docs/writing/debugging/#common-debug-outputs)\n\nPine scripts can create outputs in several ways, each of which has different advantages. While programmers can use any of them to debug their code, some outputs are more optimal for debugging than others.\n\nThe functions in the  `log.*`  namespace log  _interactive messages_  in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane. These logging functions are the most convenient and flexible tools for debugging Pine code. Scripts can call  `log.*()`  functions on any execution from global or local scopes, enabling programmers to analyze historical and realtime script behaviors in depth with minimal code, for example:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Common-debug-outputs-1.BHcS65Yd_1uSzSw.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Common debug outputs - Pine Logs\")  \n  \n//@variable The natural logarithm of the current `high - low` range.  \nfloat  logRange  =  math.log(high  -  low)  \n  \n// Plot the `logRange`.  \nplot(logRange,  \"logRange\")  \n  \nif  barstate.isconfirmed  \n// Generate an \"error\" or \"info\" message on the confirmed bar, depending on whether `logRange` is defined.  \nswitch  \nna(logRange) =>  log.error(\"Undefined `logRange` value.\")  \n=>  log.info(\"`logRange` value: \"  +  str.tostring(logRange))  \nelse  \n// Generate a \"warning\" message for unconfirmed values.  \nlog.warning(\"Unconfirmed `logRange` value: \"  +  str.tostring(logRange))  \n``\n\nPine  [drawings](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-drawings)  display visuals in the main chart pane or the script‚Äôs separate pane. Although they do not output results in other locations, such as the Data Window or Pine Logs pane, drawings provide convenient ways to visualize a script‚Äôs data and logic within global or local scopes.  [Labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  are the most flexible drawings for debugging, because they can display colored shapes with formatted text and tooltips at any available chart location, for example:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Common-debug-outputs-2.CKqA9BHP_Z1uVzW9.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Common debug outputs - Pine drawings\",  overlay  =  true)  \n  \n//@variable Is `true` when a new bar opens on the \"1D\" timeframe.  \nbool  newDailyBar  =  timeframe.change(\"1D\")  \n//@variable The previous bar's `bar_index` from when `newDailyBar` last occurred.  \nint  closedIndex  =  ta.valuewhen(newDailyBar,  bar_index  -  1,  0)  \n//@variable The previous bar's `close` from when `newDailyBar` last occurred.  \nfloat  closedPrice  =  ta.valuewhen(newDailyBar,  close[1],  0)  \n  \nif  newDailyBar  \n// Draw a line from the previous `closedIndex` and `closedPrice` to the current values.  \nline.new(closedIndex[1],  closedPrice[1],  closedIndex,  closedPrice,  width  =  2)  \n//@variable A string containing debug information to display in a label.  \nstring  debugText  =  \"'1D' bar closed at: \\n(\"  +  str.tostring(closedIndex) +  \", \"  +  str.tostring(closedPrice) +  \")\"  \n//@variable Draws a label at the current `closedIndex` and `closedPrice`.  \nlabel  debugLabel  =  label.new(closedIndex,  closedPrice,  debugText,  color  =  color.purple,  textcolor  =  color.white)  \n``\n\nThe  `plot*()`  functions can help to debug numeric values, conditions, and colors from a script‚Äôs global scope. They can output results in up to  _four_  locations: the main chart pane or the script‚Äôs pane, the status line, the price scale, and the Data Window. The display on the chart provides a quick view of the series‚Äô history, and the numbers in the other output locations show calculated information for specific bars:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Common-debug-outputs-3.CzcytxBb_Z2bBFEK.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Common debug outputs - Plots\")  \n  \n// Plot the `bar_index` in all available locations.  \nplot(bar_index,  \"bar_index\",  color.teal,  3)  \n``\n\nThe  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  function displays colors in the background of the main chart pane or the script‚Äôs pane. The  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor)  function colors the main chart‚Äôs bars or candles. Although these outputs are less flexible than Pine Logs, drawings, and plots, they provide a quick way to inspect calculated colors and visualize conditions from the global scope:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Common-debug-outputs-4.B7ERq33__1pA6gm.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Common debug outputs - Background and bar colors\")  \n  \n//@variable Is `true` if the `close` is rising over 2 bars.  \nbool  risingPrice  =  ta.rising(close,  2)  \n  \n// Highlight the chart background and color the main chart bars based on `risingPrice`.  \nbgcolor(risingPrice  ?  color.new(color.green,  70) :  na,  title=  \"`risingPrice` highlight\")  \nbarcolor(risingPrice  ?  color.aqua  :  chart.bg_color,  title  =  \"`risingPrice` bar color\")  \n``\n\nProgrammers can use any of these outputs individually or in combination to debug their scripts, depending on the data types and structures that require inspection. See the sections below for detailed information about these outputs and various debugging techniques.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "math.log",
      "barstate.isconfirmed",
      "log.error",
      "log.info",
      "str.tostring",
      "log.warning",
      "timeframe.change",
      "ta.valuewhen",
      "line.new",
      "label.new",
      "color.purple",
      "color.white",
      "color.teal",
      "ta.rising",
      "color.new",
      "color.green",
      "color.aqua",
      "chart.bg_color",
      "indicator",
      "overlay",
      "plot",
      "bgcolor",
      "barcolor",
      "var",
      "series",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-366",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Creating  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#creating-logs)",
    "content": "## [Pine  Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)\n\n_Pine Logs_  are interactive, user-defined messages that scripts can create from within global or local scopes at  _any point_  during code executions on the chart‚Äôs dataset or requested datasets. They provide a simple, powerful way for programmers to inspect a script‚Äôs calculations, logic, and execution flow with human-readable text. Using Pine Logs is the primary, most universal technique for debugging Pine Script code.\n\nPine Logs do not appear on the chart or in the Data Window. Instead, scripts print logged messages with prefixed date and time information in the dedicated  _Pine Logs pane_. The  [inspection](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-logs)  and  [filtering](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)  options in the Pine Logs pane help users analyze and navigate logs efficiently.\n\nTo access the pane, select ‚ÄúPine Logs‚Äù from the Pine Editor‚Äôs ‚ÄúMore‚Äù menu or from the ‚ÄúMore‚Äù menu in the status line of a script on the chart that uses the  `log.*()`  functions:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-1.BKWDgKSp_1nRFYd.webp)\n\nNoticeOnly  _personal_  scripts can generate Pine Logs. A published script  **cannot**  create logs, even if its source code contains  `log.*()`  function calls. Published  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  can export functions containing  `log.*()`  calls for use in personal scripts, but they cannot generate logs directly.",
    "keywords": [
      "www.tradingview",
      "simple",
      "export",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-367",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Inspecting  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-logs)",
    "content": "### [Creating  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#creating-logs)\n\nScripts create Pine Logs by calling the functions in the  `log.*`  namespace:  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info),  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning), or  [log.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.error). All these logging functions have the following two signatures:\n\n```\n\n```\n\nWhere:\n\n-   The first overload prints the specified ‚Äústring‚Äù  `message`  in the Pine Logs pane.\n-   The second overload creates a  [formatted string](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  based on its  `formatString`  and additional arguments, similar to  [str.format()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.format), then displays the resulting text inside the pane.\n\nEach  `log.*()`  function has a different  _logging level_, allowing programmers to  _categorize_  the messages shown in the Pine Logs pane:\n\n-   The  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  function creates a message with the ‚Äúinfo‚Äù level (gray text).\n-   The  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning)  function creates a message with the ‚Äúwarning‚Äù level (orange text).\n-   The  [log.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.error)  function creates a message with the ‚Äúerror‚Äù level (red text).\n\nThis simple script demonstrates the difference between all three  `log.*()`  functions. It calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info),  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning), and  [log.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.error)  on the first chart bar to print the values of three  [literal strings](https://www.tradingview.com/pine-script-docs/concepts/strings/#literal-strings)  in the Pine Logs pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Creating-logs-1.FAyoXrvo_Z1E0n8e.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Logging levels demo\",  overlay  =  true)  \n  \n// Display logs with all three logging levels in the Pine Logs pane on the first bar.  \nif  barstate.isfirst  \nlog.info(\"This is an 'info' message.\")  \nlog.warning(\"This is a 'warning' message.\")  \nlog.error(\"This is an 'error' message.\")  \n`\n\nNote that:\n\n-   The Pine Logs pane can  _filter_  messages by their logging level using the menu accessible from the rightmost icon above the logs. See the  [Filtering logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)  section to learn more.\n\nScripts can generate logs at  _any point_  during their executions, allowing programmers to track information from historical bars, and monitor script behaviors on open realtime bars.\n\nDuring historical executions, scripts log a new message  _once_  for each  `log.*()`  call on any bar. During realtime executions, scripts can call the  `log.*()`  functions to log messages for  _any available tick_, regardless of whether the bar is confirmed. The logs created on realtime ticks are  _not_  subject to  [rollback](https://www.tradingview.com/pine-script-docs/language/execution-model/#executions-on-realtime-bars). All logs remain available in the Pine Logs pane until the script restarts.\n\nThe example script below calculates the average ratio of each bar‚Äôs  `close - open`  value to its  `high - low`  range. When the range is nonzero, the script prints the values of the calculation‚Äôs variables in the Pine Logs pane using  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  if the bar is confirmed or  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning)  if the bar is still open (_unconfirmed_). If the bar‚Äôs range is zero, making the calculated ratio  _undefined_, the script logs an ‚Äúerror‚Äù message using  [log.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.error):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Creating-logs-2.BvPUb-vU_Z2iPvlc.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Historical and realtime logs demo\",  \"Average bar ratio\")  \n  \n//@variable The current bar's change from the `open` to `close`.  \nfloat  numerator  =  close  -  open  \n//@variable The current bar's `low` to `high` range.  \nfloat  denominator  =  high  -  low  \n//@variable The ratio of the bar's open-to-close change to its full range.  \nfloat  ratio  =  numerator  /  denominator  \n//@variable The average `ratio` over 10 *non-na* values.  \nfloat  average  =  ta.sma(ratio,  10)  \n  \n// Plot the `average`.  \nplot(average,  \"average\",  color.purple,  3)  \n  \nif  barstate.isconfirmed  \nswitch  denominator  \n// Log an \"error\" message when the `denominator` is 0.  \n0.0  =>  log.error(\"Division by 0 on confirmed bar!\\nBar excluded from the average.\")  \n// Otherwise, log an \"info\" message containing a formatted representation of the variables' confirmed values.  \n=>  log.info(  \n\"Values (Confirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nelse  \nswitch  denominator  \n// Log an \"error\" message for the unconfirmed bar when the `denominator` is 0.  \n0.0  =>  log.error(\"Division by 0 on unconfirmed bar!\")  \n// Otherwise, log a \"warning\" message containing a formatted representation of the unconfirmed values.  \n=>  log.warning(  \n\"Values (unconfirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \n``\n\nNote that:\n\n-   Programmers can use  [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed)  in the conditions that trigger  `log.*()`  calls to allow logs for any realtime bar only once, on its  _closing tick_, as shown in the example code.\n-   Users can pause realtime logs by selecting the ‚ÄúDisable logging‚Äù button at the top of the Pine Logs pane.\n-   Allowing logging on any tick of an open bar can result in a large number of logged messages over time. Therefore, we recommend including unique information in the messages or using different logging levels for easy  _filtering_  from the Pine Logs pane.\n-   The Pine Logs pane can display the most recent 10,000 logs for historical bars. If a programmer needs to view earlier logs, they can add logic in the code to filter specific  `log.*()`  calls. See the  [Custom code filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)  section for an example.\n\nThe following sections use the example script above to demonstrate the Pine Logs pane‚Äôs log  [inspection](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-logs)  and  [filtering](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)  features.",
    "keywords": [
      "www.tradingview",
      "log.info",
      "fun_log.info",
      "log.warning",
      "fun_log.warning",
      "log.error",
      "fun_log.error",
      "str.format",
      "fun_str.format",
      "tradingview.com",
      "barstate.isfirst",
      "ta.sma",
      "color.purple",
      "barstate.isconfirmed",
      "var_barstate.isconfirmed",
      "indicator",
      "overlay",
      "plot",
      "var",
      "simple",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-368",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Filtering  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)",
    "content": "## [Inspecting  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-logs)\n\nWhen a script generates a log by calling any  `log.*()`  function call, the Pine Logs pane automatically prefixes the logged message with an  [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations)  _timestamp_  representing the log‚Äôs assigned time, expressed in the  [chart‚Äôs time zone](https://www.tradingview.com/pine-script-docs/concepts/time/#time-zones). The timestamp prefixed to a log on a historical bar represents the bar‚Äôs  _opening time_, whereas the timestamp for a realtime log represents the  _system time_  of the log event:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Inspecting-logs-1.8xpvIK8H_ZRFiym.webp)\n\nAdditionally, each log includes ‚ÄúSource code‚Äù and ‚ÄúScroll to bar‚Äù options, which appear when hovering over the message in the Pine Logs pane. These features provide convenient ways for users to inspect and verify a log‚Äôs conditions:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Inspecting-logs-2.jaYYYDxx_Z15QxA8.webp)\n\nThe ‚ÄúSource code‚Äù option opens the script in the Pine Editor and highlights the code line containing the specific  `log.*()`  call that triggered the log event:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Inspecting-logs-3.Dxr9Y90y_Zxn0Xn.webp)\n\nThe ‚ÄúScroll to bar‚Äù option navigates the chart to the bar where the  `log.*()`  call occurred, then displays a temporary label above the bar, containing its date and time information:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Inspecting-logs-4.CnvC925K_Z1zJvwq.webp)\n\nNote that:\n\n-   The label‚Äôs time information depends on the chart‚Äôs timeframe. For example, the label on a ‚Äú1D‚Äù chart contains only the weekday and date, whereas the label on an intraday chart also includes the time of day.\n\nIt‚Äôs important to note that every script on the chart that generates logs maintains an  _independent_  log history. The Pine Logs pane shows logs for only  _one_  script at a time. To inspect the logs from a specific script when multiple are on the chart, select its title from the dropdown menu at the top of the pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Inspecting-logs-5.ClRTwv_F_wt4Ks.webp)",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-369",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Character and pattern  search](https://www.tradingview.com/pine-script-docs/writing/debugging/#character-and-pattern-search)",
    "content": "## [Filtering  logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)\n\nThe Pine Logs pane displays up to 10,000 logged messages from script executions on historical bars. It then appends a new log for each  `log.*()`  call executed on  _any_  realtime tick.\n\nTo help users navigate high volumes of logs efficiently, the pane includes  _filters_  that isolate logs based on  [logging level](https://www.tradingview.com/pine-script-docs/writing/debugging/#logging-level),  [start date and time](https://www.tradingview.com/pine-script-docs/writing/debugging/#start-date), or  [search queries](https://www.tradingview.com/pine-script-docs/writing/debugging/#character-and-pattern-search). Users can apply these log filters individually or in combination to show only the messages that meet specific criteria. The filters are accessible from the icons below the ‚Äúx‚Äù in the top-right portion of the pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-1.Qt-I6kcm_czrNs.webp)\n\nFor custom filtering options, programmers can use conditional logic to activate specific  `log.*()`  calls selectively across a script‚Äôs executions. See the  [Custom code filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)  section below to learn more.\n\n### [Logging  level](https://www.tradingview.com/pine-script-docs/writing/debugging/#logging-level)\n\nSelecting the rightmost icon above the messages in the Pine Logs pane opens a ‚ÄúFilter levels‚Äù dropdown menu containing checkboxes for each logging level (‚ÄúInfo‚Äù, ‚ÄúWarning‚Äù, and ‚ÄúError‚Äù). To remove logs with a specific logging level from the displayed results, uncheck the level from this menu.\n\nIn the example below, we deactivated the ‚Äúinfo‚Äù and ‚Äúwarning‚Äù levels for our script‚Äôs logs, allowing only ‚Äúerror‚Äù messages in the Pine Logs pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Logging-level-1.CqbnhwLx_1LsDVq.webp)\n\nNote that:\n\n-   Deactivating logging levels in this menu hides the relevant messages but  _does not_  stop the execution of those  `log.*()`  calls in the code. For instance, a  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call still executes and adds to the historical log count even when the ‚ÄúInfo‚Äù option is unchecked.\n\n### [Start  date](https://www.tradingview.com/pine-script-docs/writing/debugging/#start-date)\n\nThe ‚ÄúStart date‚Äù option above the logs in the Pine Logs pane opens a dialog box where users can specify a starting date and time to filter the displayed messages:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Start-date-1.IZNVl8zX_1IJI6K.webp)\n\nAfter the user sets the filter in the dialog box, a tag showing the selected date and time appears above the logs, indicating it is active. With this filter, only logs with prefixed timestamps from the specified start point onward appear in the Pine Logs pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Start-date-2.BDbP45dS_Z2gRUox.webp)",
    "keywords": [
      "www.tradingview",
      "log.info",
      "fun_log.info",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-370",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Custom code  filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)",
    "content": "### [Character and pattern  search](https://www.tradingview.com/pine-script-docs/writing/debugging/#character-and-pattern-search)\n\nThe ‚ÄúSearch‚Äù option above the logs in the Pine Logs pane opens a search bar where users can  _match_  logs containing specific character sequences or patterns, similar to the Pine Editor‚Äôs ‚ÄúFind/Replace‚Äù tool for matching code.\n\nWhen the search bar is not empty, the pane shows only the messages that fully or partially match the text or pattern, with the matched portion of each message highlighted in blue for visual reference.\n\nBelow, we searched ‚ÄúConfirmed‚Äù to identify all logs from our example script that contain the term anywhere in their text:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-1.D-1crEOA_3Qle8.webp)\n\nNote that:\n\n-   The filtered results include logs containing ‚Äúconfirmed‚Äù with a lowercase ‚Äúc‚Äù because the search filter performs  _case-insensitive_  matching on ASCII characters by default.\n-   The results also include logs containing ‚Äúunconfirmed‚Äù because the default filter behavior does not exclusively match  _whole-word_  terms.\n\nThe rightmost icon in the search bar opens a dropdown menu containing three options to adjust the search filter‚Äôs behavior:  [Match case](https://www.tradingview.com/pine-script-docs/writing/debugging/#match-case),  [Whole word](https://www.tradingview.com/pine-script-docs/writing/debugging/#whole-word), and  [Regex](https://www.tradingview.com/pine-script-docs/writing/debugging/#regex):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-2.CGclA-al_Z1shTsN.webp)\n\n#### [Match  case](https://www.tradingview.com/pine-script-docs/writing/debugging/#match-case)\n\nThe ‚ÄúMatch case‚Äù search option activates  _case-sensitive_  matching. With this setting, the filter‚Äôs results include only the logs containing the search query with identical cases for ASCII letter characters.\n\nHere, we enabled the ‚ÄúMatch case‚Äù setting for our ‚ÄúConfirmed‚Äù search, preventing all the script‚Äôs logs containing ‚Äúconfirmed‚Äù with a  _lowercase_  ‚Äúc‚Äù from appearing in the results:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-Match-case-1.BprO1bQS_ZS51dB.webp)\n\nNote that:\n\n-   The ‚ÄúMatch case‚Äù setting  _does not_  affect the search behavior for Unicode letter characters outside the ASCII range (U+0000 - U+007F).\n\n#### [Whole  word](https://www.tradingview.com/pine-script-docs/writing/debugging/#whole-word)\n\nThe ‚ÄúWhole word‚Äù search option activates  _whole-word_  matching. With this setting enabled, the filter includes logs containing the searched term, but only if it is separated from other text by  _whitespace_  characters or any of the following non-word characters:  `.`  (period),  `,`  (comma),  `:`  (colon),  `;`  (semicolon),  `'`  (apostrophe), or  `\"`  (quotation mark).\n\nFor example, searching for ‚ÄúConfirmed‚Äù in our script‚Äôs logs with the ‚ÄúWhole word‚Äù setting prevents the messages containing ‚Äúunconfirmed‚Äù from appearing in the results:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-Whole-word-1.-3nPjDxx_2fuj3g.webp)\n\nNote that:\n\n-   With the ‚ÄúWhole word‚Äù setting active, the search filter  _cannot_  match terms containing whitespaces or the other non-word characters listed above.\n-   Whole-word search queries can include other Unicode characters outside the ASCII range.\n\n#### [Regex](https://www.tradingview.com/pine-script-docs/writing/debugging/#regex)\n\nThe ‚ÄúRegex‚Äù search option enables advanced, flexible log filtering with  [regular expressions (regex)](https://en.wikipedia.org/wiki/Regular_expression). In contrast to plain text searches, which only match  _literal_  character sequences, regex searches can match variable  _text patterns_  based on the rules defined by the query‚Äôs syntax.\n\nWith regular expressions, the Pine Logs search filter can isolate logs containing various text structures, simple or complex, such as dates and times with a defined format, alphanumeric sequences with varying digits or letters, sequences of characters within specified Unicode subsets, and more.\n\nFor instance, this regex search query specifies that the displayed logs must contain ‚Äúaverage:‚Äù, with optional trailing whitespace characters, followed by a sequence of characters representing a number greater than 0.5 and less than or equal to 1.0:\n\n```\n\n```\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-Regex-1.CnCNzCEk_ZbCaXx.webp)\n\nThe more advanced search query below specifies that the logs must contain prefixed timestamps representing any time of day equal to or after 09:30 and before 16:00 in the chart‚Äôs time zone:\n\n```\n\n```\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Character-and-pattern-search-Regex-2.BubI1o13_2wLk1s.webp)\n\nFor more information about regular expressions, consult the  [Regex syntax reference](https://www.tradingview.com/pine-script-docs/concepts/strings/#regex-syntax-reference)  in this manual‚Äôs  [Strings](https://www.tradingview.com/pine-script-docs/concepts/strings/)  page. Most of the described syntax works the same within the Pine Logs search filter, with a few notable differences:\n\n-   The strings used as  `regex`  arguments in  [str.match()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.match)  calls require  _two_  consecutive backslashes (`\\\\`) for specifying escape sequences in the pattern (e.g.,  `\"\\\\w\"`  means the regex matches a character from the  `\\w`  class). In contrast, the Pine Logs search filter requires only a  _single_  backslash for escape sequences. Double backslashes in the search bar match the literal  `\\`  character.\n-   The regex search query can use the syntax  `\\xhh`  or  `\\uhhhh`  to reference Unicode code points in the  [Basic Multilingual Plane](https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane), where each  `h`  is a  _hexadecimal_  digit (e.g.,  `\\x67`  and  `\\u0067`  refer to U+0067, the  `a`  character). However, the full-range syntax (`\\x{...}`) is not supported.\n-   The search query  _cannot_  use Unicode property references, such as  `\\p{Lu}`,  `\\p{IsGreek}`, etc.\n-   The search query can use only the  `^`  and  `$`  _boundary assertions_  to match a logged message‚Äôs start and end boundaries. The  `\\A`,  `\\Z`, and  `\\z`  assertions are  _not_  supported.\n-   The search query cannot use  _pattern modifiers_  globally (e.g.,  `(?m)^abc`). However, it can use some modifiers locally inside  _non-capturing groups_  (e.g.,  `(?m:^abc)`).",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "str.match",
      "fun_str.match",
      "e.g",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-371",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Pine  drawings](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-drawings)",
    "content": "### [Custom code  filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)\n\nIf the filtering options in the Pine Logs pane are not sufficient, programmers can control specific  `log.*()`  calls using  [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/)  and conditional logic.\n\nThe script below calculates an RMA of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  prices and creates a compound condition from four distinct individual conditions. It plots the RMA on the chart and highlights the background when the  `compoundCondition`  value is  `true`. For debugging, the script uses  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  to display a formatted string representing the  `close`  and  `rma`  values, the values of all the ‚Äúbool‚Äù variables that form the compound condition, and the final  `compoundCondition`  value.\n\nThe  `filterLogsInput`,  `logStartInput`, and  `logEndInput`  variables define a custom  _time filter_  for generating logs. When  `filterLogsInput`  is  `true`, the script uses the  [time inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/#time-input)  assigned to  `logStartInput`  and  `logEndInput`  to filter the  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  calls, allowing a new log only when the bar‚Äôs  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  is within the specified range:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-logs-Filtering-logs-Custom-code-filters-1.BDemxPLh_ZSKvHT.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Custom code filters demo\",  overlay  =  true)  \n  \n//@variable The length for moving average calculations.  \nint  lengthInput  =  input.int(20,  \"Length\",  2)  \n  \n//@variable If `true`, only allows logs within the input time range.  \nbool  filterLogsInput  =  input.bool(true,  \"Only log in time range\",  group  =  \"Log filter\")  \n//@variable The starting time for logs if `filterLogsInput` is `true`.  \nint  logStartInput  =  input.time(0,  \"Start time\",  group  =  \"Log filter\",  confirm  =  true)  \n//@variable The ending time for logs if `filterLogsInput` is `true`.  \nint  logEndInput  =  input.time(0,  \"End time\",  group  =  \"Log filter\",  confirm  =  true)  \n  \n//@variable The RMA of `close` prices.  \nfloat  rma  =  ta.rma(close,  lengthInput)  \n  \n//@variable Is `true` when `close` exceeds the `rma`.  \nbool  priceBelow  =  close  <=  rma  \n//@variable Is `true` when the current `close` is greater than the max of the previous `hl2` and `close`.  \nbool  priceRising  =  close  >  math.max(hl2[1],  close[1])  \n//@variable Is `true` when the `rma` is positively accelerating.  \nbool  rmaAccelerating  =  rma  -  2.0  *  rma[1] +  rma[2] >  0.0  \n//@variable Is `true` when the difference between `rma` and `close` exceeds 2 times the current ATR.  \nbool  closeAtThreshold  =  rma  -  close  >  ta.atr(lengthInput) *  2.0  \n//@variable Is `true` when all the above conditions occur.  \nbool  compoundCondition  =  priceBelow  and  priceRising  and  rmaAccelerating  and  closeAtThreshold  \n  \n// Plot the `rma`.  \nplot(rma,  \"RMA\",  color.teal,  3)  \n// Highlight the chart background when the `compoundCondition` occurs.  \nbgcolor(compoundCondition  ?  color.new(color.aqua,  80) :  na,  title  =  \"Compound condition highlight\")  \n  \n//@variable If `filterLogsInput` is `true`, is only `true` in the input time range. Otherwise, always `true`.  \nbool  showLog  =  filterLogsInput  ?  time  >=  logStartInput  and  time  <=  logEndInput  :  true  \n  \n// Log results for a confirmed bar when `showLog` is `true`.  \nif  barstate.isconfirmed  and  showLog  \nlog.info(  \n\"\\nclose:‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ{0,number,#.#####}  \n\\nrma:‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ{1,number,#.#####}  \n\\npriceBelow:‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ{2}  \n\\npriceRising:‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ{3}  \n\\nrmaAccelerating:‚ÄÉ‚ÄÉ‚ÄÉ{4}  \n\\ncloseAtThreshold:‚ÄÉ‚ÄÉ{5}  \n\\n  \n\\ncompoundCondition:‚ÄÉ{6}\",  \nclose,  rma,  priceBelow,  priceRising,  rmaAccelerating,  closeAtThreshold,  compoundCondition  \n)  \n``\n\nNote that:\n\n-   The  `input.*()`  calls assigned to the  `filterLogsInput`,  `logStartInput`, and  `logEndInput`  variables include a  `group`  argument to group the inputs in the ‚ÄúSettings/Inputs‚Äù tab.\n-   Users can adjust time input values directly on the chart by selecting the script‚Äôs status line and moving the displayed time markers with the mouse pointer. Additionally, users can select ‚ÄúReset points‚Äù in the script‚Äôs ‚ÄúMore‚Äù menu to clear the inputs and choose new values.\n-   The  `formatString`  argument of the  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call uses the Em Space character (U+2003) to align the represented values vertically in the logged text. In contrast to the standard space and tab characters, leading or repeated Em and En spaces are  _not_  removed from the Pine Logs pane‚Äôs displayed messages.",
    "keywords": [
      "www.tradingview",
      "log.info",
      "fun_log.info",
      "tradingview.com",
      "input.int",
      "input.bool",
      "input.time",
      "ta.rma",
      "math.max",
      "ta.atr",
      "color.teal",
      "color.new",
      "color.aqua",
      "barstate.isconfirmed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-372",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Labels](https://www.tradingview.com/pine-script-docs/writing/debugging/#labels)",
    "content": "## [Pine  drawings](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-drawings)\n\nPine‚Äôs  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  create chart drawings with specified properties. Scripts can place drawings at any valid chart location during code executions on any bar. Programmers can use these types in a script‚Äôs global or local scopes to visualize numeric data, conditions, colors, and strings on the chart. The flexibility of Pine drawings makes them helpful for debugging scripts when other methods do not suffice, namely when a programmer wants to inspect information graphically outside the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane.\n\nHowever, before debugging a script using drawings, it is crucial to note the following limitations:\n\n-   The  `expression`  argument of a  `request.*()`  call  _cannot_  depend on code that creates or modifies drawings. Likewise, an indicator that specifies another context in its declaration statement cannot create drawings from  _anywhere_  in the code. To debug code that executes on requested data, use  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  instead.\n-   In contrast to Pine Logs, drawings do not have built-in navigation features. Therefore, users must manually scroll across the chart to inspect drawings created on specific bars.\n-   Scripts can maintain only a  _limited_  number of objects of each drawing type. When the number of drawings exceeds the limit, Pine‚Äôs garbage collector automatically  _removes_  the oldest ones.\n\nThe sections below explain some simple debugging methods using  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  and  [tables](https://www.tradingview.com/pine-script-docs/visuals/tables/). These drawings, especially  _labels_, are the most effective for on-chart debugging because they can use dynamic  [strings](https://www.tradingview.com/pine-script-docs/concepts/strings/)  to express information from other data types as custom text.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "simple",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-373",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Tables](https://www.tradingview.com/pine-script-docs/writing/debugging/#tables)",
    "content": "### [Labels](https://www.tradingview.com/pine-script-docs/writing/debugging/#labels)\n\n[Labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  display colored shapes and text at specified chart coordinates. In contrast to the outputs of the  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  and  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  functions, labels can display text from ‚Äúseries string‚Äù values that change across script executions. Programmers often use labels to visualize the logic of  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  and show text representing information from a script‚Äôs global or local scopes.\n\nThe most common techniques for debugging with labels include:\n\n-   Drawing a label containing key information anchored to  _every_  bar that requires inspection.\n-   Drawing a single label containing information from specific executions at the  _end_  of the dataset or visible chart.\n\n#### [Drawing on successive  bars](https://www.tradingview.com/pine-script-docs/writing/debugging/#drawing-on-successive-bars)\n\nWhen inspecting values of varying magnitudes or different types across bars, a simple approach is to create  [formatted strings](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  containing the necessary debug information and display them in  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  on each bar requiring analysis.\n\nIn this example, we‚Äôve modified the ‚ÄúAverage bar ratio‚Äù script from the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  section above. Instead of creating formatted text and displaying information using  `log.*()`  function calls, this script formats the values separately, then calls  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  to show the results on the chart within labels anchored to each bar‚Äôs  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-drawings-Labels-Drawing-on-successive-bars-1.Y0IdYgw-_Z1vuQ7m.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Drawing on successive bars demo\",  \"Average bar ratio\")  \n  \n//@variable The current bar's change from the `open` to `close`.  \nfloat  numerator  =  close  -  open  \n//@variable The current bar's `low` to `high` range.  \nfloat  denominator  =  high  -  low  \n//@variable The ratio of the bar's open-to-close change to its full range.  \nfloat  ratio  =  numerator  /  denominator  \n//@variable The average `ratio` over 10 *non-na* values.  \nfloat  average  =  ta.sma(ratio,  10)  \n  \n// Plot the `average`.  \nplot(average,  \"average\",  color.purple,  3)  \n  \nif  barstate.isconfirmed  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on confirmed bar!\\nBar excluded from the average.\"  \nlabel.new(bar_index,  high,  debugText,  color  =  color.red,  textcolor  =  #000000,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (Confirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  debugText,  textcolor  =  #ffffff,  force_overlay  =  true)  \nelse  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on unconfirmed bar!\"  \nlabel.new(bar_index,  high,  debugText,  color  =  color.red,  textcolor  =  #000000,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (unconfirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  debugText,  color  =  color.orange,  textcolor  =  #000000,  force_overlay  =  true)  \n``\n\nNote that:\n\n-   The  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  calls include  `force_overlay = true`, meaning the labels always appear on the main chart pane.\n-   Unlike the example in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  section, this script‚Äôs outputs  **are**  subject to  _rollback_, meaning the information shown on a bar reflects only the bar‚Äôs  _latest_  data. The script does  **not**  show information for  _all_  realtime bar updates.\n\nThe above example allows users to inspect the script‚Äôs confirmed values or latest updates on any bar that has a  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  drawing. However, each bar‚Äôs results are legible only when the labels do not  _overlap_.\n\nAn alternative, more  _compact_  way to display text with labels on successive bars is to utilize the  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  function‚Äôs  `tooltip`  parameter instead of the  `text`  parameter, as labels show their tooltips only when the mouse pointer  _hovers_  over them.\n\nIn the script version below, we changed all the  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  calls to use  `debugText`  as the  `tooltip`  argument instead of the  `text`  argument. Now, we can view a specific bar‚Äôs information without visual clutter from other nearby labels:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-drawings-Labels-Drawing-on-successive-bars-2.oXxEu_CI_Z15EA3a.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Drawing tooltips on successive bars demo\",  \"Average bar ratio\")  \n  \n//@variable The current bar's change from the `open` to `close`.  \nfloat  numerator  =  close  -  open  \n//@variable The current bar's `low` to `high` range.  \nfloat  denominator  =  high  -  low  \n//@variable The ratio of the bar's open-to-close change to its full range.  \nfloat  ratio  =  numerator  /  denominator  \n//@variable The average `ratio` over 10 *non-na* values.  \nfloat  average  =  ta.sma(ratio,  10)  \n  \n// Plot the `average`.  \nplot(average,  \"average\",  color.purple,  3)  \n  \nif  barstate.isconfirmed  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on confirmed bar!\\nBar excluded from the average.\"  \nlabel.new(bar_index,  high,  color  =  color.red,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (Confirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on unconfirmed bar!\"  \nlabel.new(bar_index,  high,  color  =  color.red,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (unconfirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  color  =  color.orange,  tooltip  =  debugText,  force_overlay  =  true)  \n``\n\nWhen drawing labels across successive bars, it‚Äôs important to note that the maximum number of labels a script can display is 500. As such, the examples above allow users to inspect information for only the most recent 500 chart bars.\n\nFor successive labels on earlier bars, programmers can create conditional logic that limits the drawings to specific  _time ranges_, e.g.:\n\n```\n\n```\n\nBelow, we added a condition to the script that draws a label only when the bar‚Äôs  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  is between the  [chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time)  and  [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time)  values. This logic restricts the drawings to  _visible_  chart bars, allowing us to scroll through the chart and inspect labels on any bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-drawings-Labels-Drawing-on-successive-bars-3.DxYYTLXs_Z1pHas.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Drawing in visible ranges demo\",  \"Average bar ratio\")  \n  \n//@variable The current bar's change from the `open` to `close`.  \nfloat  numerator  =  close  -  open  \n//@variable The current bar's `low` to `high` range.  \nfloat  denominator  =  high  -  low  \n//@variable The ratio of the bar's open-to-close change to its full range.  \nfloat  ratio  =  numerator  /  denominator  \n//@variable The average `ratio` over 10 *non-na* values.  \nfloat  average  =  ta.sma(ratio,  10)  \n  \n// Plot the `average`.  \nplot(average,  \"average\",  color.purple,  3)  \n  \nif  time  >=  chart.left_visible_bar_time  and  time  <=  chart.right_visible_bar_time  \nif  barstate.isconfirmed  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on confirmed bar!\\nBar excluded from the average.\"  \nlabel.new(bar_index,  high,  color  =  color.red,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (Confirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nif  denominator  ==  0  \nstring  debugText  =  \"Division by 0 on unconfirmed bar!\"  \nlabel.new(bar_index,  high,  color  =  color.red,  tooltip  =  debugText,  force_overlay  =  true)  \nelse  \nstring  debugText  =  str.format(  \n\"Values (unconfirmed):  \n\\nnumerator: {0,number,#.########}  \n\\ndenominator: {1,number,#.########}  \n\\nratio: {2,number,#.########}  \n\\naverage: {3,number,#.########}\",  \nnumerator,  denominator,  ratio,  average  \n)  \nlabel.new(bar_index,  high,  color  =  color.orange,  tooltip  =  debugText,  force_overlay  =  true)  \n``\n\nNote that:\n\n-   The script  _restarts_  each time the  [UNIX timestamps](https://www.tradingview.com/pine-script-docs/concepts/time/#unix-timestamps)  of the  [chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.left_visible_bar_time)  or  [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time)  variables change after the user scrolls or zooms on the chart.\n\n#### [Drawing at the end of the  chart](https://www.tradingview.com/pine-script-docs/writing/debugging/#drawing-at-the-end-of-the-chart)\n\nWhen debugging information does not change frequently across executions, or only the information from a specific execution requires inspection, programmers often display it using  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  anchored to the  _end_  of the chart.\n\nThe following example displays price and chart information in four separate labels at the end of the chart. The script‚Äôs  `printLabel()`  function renders a specified string in a label that always anchors to the last available time in the dataset, regardless of when the function call occurs:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-drawings-Labels-Drawing-at-the-end-of-the-chart-1.5mqpohZu_ub26N.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Drawing labels at the end of the chart demo\",  \"Chart info\",  true)  \n  \n//@function Draws a label to display the `info` text at the latest available time.  \n// Each instance of a call to this function updates its label text across executions.  \n//@param info The string to display.  \n//@param price Optional. The y-coordinate of the label. If `na`, the function draws the label above the last bar.  \n// The default is `na`.  \n//@param textColor Optional. The color of the displayed text. If `na`, the label uses `chart.fg_color`.  \n// The default is `na`.  \n//@param size Optional. The size of the label in typographic points. The default is 18.  \n//@returns A `label` object with dynamic text.  \nprintLabel(string  info,  simple  float  price  =  na,  simple  color  textColor  =  na,  simple  int  size  =  18) =>  \nvar  int  anchorTime  =  math.max(last_bar_time,  chart.right_visible_bar_time)  \nvar  color  col  =  nz(textColor,  chart.fg_color)  \nvar  yloc  =  na(price) ?  yloc.abovebar  :  yloc.price  \nvar  label  result  =  label.new(  \nanchorTime,  price,  na,  xloc.bar_time,  yloc,  na,  label.style_none,  col,  size,  force_overlay  =  true  \n)  \nresult.set_text(info)  \n  \n// Call `printLabel()` on the first bar to display \"Chart info:\" and formatted chart information.  \nif  barstate.isfirst  \nprintLabel(\"Chart info:\"  +  str.repeat(\"\\n\",  6),  textColor  =  color.teal)  \nprintLabel(  \nstr.format(  \n\"Symbol: {0}, Type: {1}, Timeframe: {2}\\nStandard chart: {3}, Replay active: {4}\",  \nticker.standard(),  syminfo.type,  timeframe.period,  chart.is_standard,  \nstr.contains(syminfo.tickerid,  \"replay\")  \n) +  str.repeat(\"\\n\",  3)  \n)  \n  \n// On the last available bar, call `printLabel()` to display the latest OHLCV values and total bar count.  \nif  barstate.islast  \nprintLabel(  \nstr.format(  \n\"O: {0,number,#.#####}, H: {1,number,#.#####}, L: {2,number,#.#####}, C: {3,number,#.#####},  \nV: {4}\",  \nopen,  high,  low,  close,  str.tostring(volume,  format.volume)  \n) +  \"\\n\"  \n)  \nprintLabel(\"Total bars: \"  +  str.tostring(bar_index  +  1))  \n``\n\nNote that:\n\n-   The  `printLabel()`  function draws  _one_  label per function call instance. The label‚Äôs  `x`  property is the maximum of the  [last_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_last_bar_time)  and  [chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v6/#var_chart.right_visible_bar_time)  values, ensuring it appears above the last available bar.\n-   On each execution of a  `printLabel()`  instance, the label‚Äôs  `text`  property updates to reflect the latest  `info`  value.\n-   The  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  call in the  `printLabel()`  function includes  `force_overlay = true`, meaning the drawing always appears in the main chart pane.\n-   This script uses  _four_  distinct  `printLabel()`  calls. The first three append repeated newline characters (`\\n`) in the  `info`  argument to prevent the label text from overlapping.",
    "keywords": [
      "www.tradingview",
      "label.new",
      "fun_label.new",
      "tradingview.com",
      "ta.sma",
      "color.purple",
      "barstate.isconfirmed",
      "color.red",
      "str.format",
      "color.orange",
      "e.g",
      "chart.left_visible_bar_time",
      "var_chart.left_visible_bar_time",
      "chart.right_visible_bar_time",
      "var_chart.right_visible_bar_time",
      "chart.fg_color",
      "math.max",
      "yloc.abovebar",
      "yloc.price",
      "xloc.bar_time",
      "label.style_none",
      "result.set_text",
      "barstate.isfirst",
      "str.repeat",
      "color.teal",
      "ticker.standard",
      "syminfo.type",
      "timeframe.period",
      "chart.is_standard",
      "str.contains",
      "syminfo.tickerid",
      "barstate.islast",
      "str.tostring",
      "format.volume",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "simple",
      "import",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-374",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Plots and chart  colors](https://www.tradingview.com/pine-script-docs/writing/debugging/#plots-and-chart-colors)",
    "content": "### [Tables](https://www.tradingview.com/pine-script-docs/writing/debugging/#tables)\n\n[Tables](https://www.tradingview.com/pine-script-docs/visuals/tables/)  display text within cells arranged in columns and rows at fixed locations in the chart pane‚Äôs visual space. In contrast to other  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), which create visuals on the chart at specified  _coordinates_, tables appear at one of nine unique,  _bar-agnostic_  locations defined by the  `position.*`  constants.\n\nBecause tables appear at consistent relative locations in the pane, unaffected by scroll or zoom actions, programmers occasionally use them for on-chart debugging. The most common technique is to draw a  _single-cell_  table containing information from specific script executions.\n\nThis example contains a  `printTable()`  function that calls  [table.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.new)  and  [table.cell()](https://www.tradingview.com/pine-script-reference/v6/#fun_table.cell)  to create a single-cell table that displays dynamic text in a relative location on the main chart pane. The script uses a single call to this function to display the same chart information shown by the example script from the  [previous section](https://www.tradingview.com/pine-script-docs/writing/debugging/#drawing-at-the-end-of-the-chart):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Pine-drawings-Tables-1.D2zJtwRb_Z1ADabn.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Debugging with single-cell tables demo\",  \"Chart info\",  true)  \n  \n//@function Draws a single-cell table to display the `info` text in the top-right corner of the chart.  \n//@param info The string to display.  \n//@param textColor Optional. The color of the displayed text. If `na`, the table uses `chart.fg_color`.  \n// The default is `na`.  \n//@param size Optional. The size of the table's text in typographic points. The default is 18.  \n//@returns A single-cell table with dynamic text.  \nprintTable(string  info,  simple  color  textColor  =  na,  simple  int  size  =  18) =>  \nvar  color  col  =  nz(textColor,  chart.fg_color)  \nvar  table  result  =  table.new(position.top_right,  1,  1,  na,  force_overlay  =  true)  \ntable.cell(result,  0,  0,  info,  text_color  =  col,  text_size  =  size)  \n  \n// Call `printTable()` on the latest available bar to display chart information in the top-right corner.  \nif  barstate.islast  \nprintTable(  \nstr.format(  \n\"Chart info:  \n\\n\\nSymbol: {0},  Type: {1},  Timeframe: {2}\\nStandard  chart: {3},  Replay  active: {4}  \n\\n\\nO: {5,number,#.#####}, H: {6,number,#.#####}, L: {7,number,#.#####}, C: {8,number,#.#####}, V: {9}  \n\\nTotalBars: {10}\",  \nticker.standard(),  syminfo.type,  timeframe.period,  chart.is_standard,  \nstr.contains(syminfo.tickerid,  \"replay\"),  open,  high,  low,  close,  str.tostring(volume,  format.volume),  \nbar_index  +  1  \n)  \n)  \n``\n\nNote that:\n\n-   Every new table drawing  _replaces_  any existing one that has the same specified position. Therefore, scripts cannot call the  `printTable()`  function multiple times to place multiple drawings in a single location, unlike the  `printLabel()`  function from the previous section.\n-   This script calls  `printTable()`  only on the last historical bar and all realtime bars because updating tables on each historical bar is an unnecessary use of runtime resources. See the  [Reducing drawing updates](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-drawing-updates)  section of the  [Profiling and optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/)  page for more information.",
    "keywords": [
      "www.tradingview",
      "table.new",
      "fun_table.new",
      "table.cell",
      "fun_table.cell",
      "tradingview.com",
      "chart.fg_color",
      "position.top_right",
      "barstate.islast",
      "str.format",
      "ticker.standard",
      "syminfo.type",
      "timeframe.period",
      "chart.is_standard",
      "str.contains",
      "syminfo.tickerid",
      "str.tostring",
      "format.volume",
      "indicator",
      "overlay",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-375",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Plotting  numbers](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-numbers)",
    "content": "## [Plots and chart  colors](https://www.tradingview.com/pine-script-docs/writing/debugging/#plots-and-chart-colors)\n\nThe built-in  `plot*()`  functions display results from a value‚Äôs series in up to four locations: the chart pane, the script‚Äôs status line, the Data Window, and the price scale. Programmers often use these output functions as a quick way to display the history of a script‚Äôs numeric values, conditions, and colors. Two other functions,  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  and  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), color a chart pane‚Äôs background and the main chart‚Äôs bars or candles. Although not as versatile as other output functions, they offer a quick way to display conditions and colors on the chart.\n\nAll these functions, especially  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot),  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar), and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape), can serve as helpful tools for debugging a script‚Äôs calculations and logic. For instance, the outputs of a single  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call can show the complete available history of a script‚Äôs series on the chart and provide information for any bar in other locations.\n\nBefore using plots or chart colors for debugging, it is important to note the following limitations:\n\n-   Unlike  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  or  [drawings](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-drawings), these outputs  _cannot_  display results for values that are accessible from local scopes only. Scripts must  [extract](https://www.tradingview.com/pine-script-docs/writing/debugging/#extracting-data-from-local-scopes)  values from local scopes into the  _global scope_  to debug them with plots or chart colors.\n-   The only  `plot*()`  functions that can display  _text_  on the chart ‚Äî  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  and  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  ‚Äî require ‚Äúconst string‚Äù values. Therefore, they cannot display dynamic strings or calculated  [string conversions](https://www.tradingview.com/pine-script-docs/concepts/strings/#string-conversion-and-formatting)  of other types.\n-   Similar to drawings, plots  _do not_  have built-in navigation features. Users must scroll across the chart to find plotted information for specific bars.\n-   The maximum  _plot count_  for any script is 64. Each call to these functions contributes a different number to the total, depending on its arguments. See the  [Plot limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#plot-limits)  section of the  [Limitations](https://www.tradingview.com/pine-script-docs/writing/limitations/)  page to learn more.",
    "keywords": [
      "www.tradingview",
      "plot",
      "bgcolor",
      "barcolor",
      "series",
      "const",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-376",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Plotting and coloring  conditions](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-and-coloring-conditions)",
    "content": "### [Plotting  numbers](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-numbers)\n\nOne of the simplest methods to inspect global numeric series (‚Äúint‚Äù or ‚Äúfloat‚Äù values) is to plot them using the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot),  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar), or  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  function. The outputs on the chart pane provide a graphical view of the series‚Äô history. The other possible output locations (status line, price scale, and Data Window) show formatted numbers representing the values calculated on a specific bar.\n\nLet‚Äôs look at a simple debugging example. The following script calculates a custom oscillator whose value is the average of three separate oscillators. It displays the  `oscillator`  value in four output locations using a  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-numbers-1._9pJe3gC_Zj4NpU.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting numbers demo\")  \n  \n//@variable The length of each oscillator.  \nint  lengthInput  =  input.int(20,  \"Length\",  2)  \n  \n//@variable The correlation between `close` and `bar_index` over `lengthInput` bars.  \nfloat  osc1  =  ta.correlation(close,  bar_index,  lengthInput)  \n//@variable The RSI of `close` over `lengthInput` bars, scaled to the range [-1, 1].  \nfloat  osc2  = (ta.rsi(close,  lengthInput) -  50) /  50  \n//@variable The percent rank of `close` compared to `lengthInput` past values, scaled to the range [-1, 1].  \nfloat  osc3  = (ta.percentrank(close,  lengthInput) -  50) /  50  \n  \n//@variable The average of `osc1`, `osc2`, and `osc3`.  \nfloat  oscillator  =  math.avg(osc1,  osc2,  osc3)  \n  \n// Plot the `oscillator`.  \nplot(oscillator,  \"Combined oscillator\",  color.purple,  3)  \n``\n\nThe above script‚Äôs outputs allow inspection of the final  `oscillator`, but not the three constituent oscillators that determine its value. Because the script calculates all three series in the global scope, we can inspect them using additional plots. Here, we add three  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  calls to the script to display each oscillator, allowing us to verify the script‚Äôs calculated values and understand how they affect the final result:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-numbers-2.DpbWG2QO_cQIdm.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting numbers demo\")  \n  \n//@variable The length of each oscillator.  \nint  lengthInput  =  input.int(20,  \"Length\",  2)  \n  \n//@variable The correlation between `close` and `bar_index` over `lengthInput` bars.  \nfloat  osc1  =  ta.correlation(close,  bar_index,  lengthInput)  \n//@variable The RSI of `close` over `lengthInput` bars, scaled to the range [-1, 1].  \nfloat  osc2  = (ta.rsi(close,  lengthInput) -  50) /  50  \n//@variable The percent rank of `close` compared to `lengthInput` past values, scaled to the range [-1, 1].  \nfloat  osc3  = (ta.percentrank(close,  lengthInput) -  50) /  50  \n  \n//@variable The average of `osc1`, `osc2`, and `osc3`.  \nfloat  oscillator  =  math.avg(osc1,  osc2,  osc3)  \n  \n// Plot the `oscillator`.  \nplot(oscillator,  \"Combined oscillator\",  color.purple,  3)  \n  \n// Plot the `osc1`, `osc2`, and `osc3` series for inspection.  \nplot(osc1,  \"osc1\",  color.red,  2,  plot.style_circles,  join  =  true)  \nplot(osc2,  \"osc2\",  color.maroon,  2,  plot.style_circles,  join  =  true)  \nplot(osc3,  \"osc3\",  color.blue,  2,  plot.style_circles,  join  =  true)  \n``\n\nNote that:\n\n-   The numbers in the script‚Äôs status line and the Data Window represent the values plotted on the bar at the mouse pointer‚Äôs location. When the pointer is  _not_  on the chart, these numbers represent the  _latest_  bar‚Äôs data.\n-   The labels in the price scale show the latest  _non-na_  values available in the plotted series up to the last visible bar. If a plotted series does not have a non-na value at any point before that bar, the price scale does  _not_  show a label for it.\n\nTipWhen debugging numbers, it is crucial to consider the  _decimal precision_  (i.e., number of  _fractional digits_) required to inspect them effectively. Programmers can set the precision for a script‚Äôs plots using the  `precision`  parameter of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator),  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy), or  `plot*()`  functions. Alternatively, users can change the precision from the ‚ÄúPrecision‚Äù field in the script‚Äôs ‚ÄúSettings‚Äù menu or the chart‚Äôs settings. Note that when a  `plot*()`  function includes a  `precision`  argument, it uses that value to determine the output‚Äôs decimal precision, ignoring the script‚Äôs global precision setting.\n\n#### [Plotting without affecting the  scale](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-without-affecting-the-scale)\n\nDebugging multiple numeric series by plotting them on the chart can make the results hard to read if the plots affect the price scale, especially if each plotted series has a significantly different value range. Programmers can specify a plot‚Äôs  _display locations_  to avoid distorting the scale by passing a  `display.*`  constant or expression to the  `display`  parameter of the  `plot*()`  call.\n\nLet‚Äôs look at a simple example that calculates a few numeric series with different ranges. This script calculates a weighted moving average with custom weights and plots the result on the chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-numbers-Plotting-without-affecting-the-scale-1.DCLyJ8at_8SNnK.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting without affecting the scale demo\",  \"Weighted average\",  true,  precision  =  5)  \n  \n//@variable The number of bars in the average.  \nint  lengthInput  =  input.int(20,  \"Length\",  1)  \n  \n//@variable The weight applied to the price on each bar.  \nfloat  weight  =  math.pow(close  -  open,  2)  \n  \n//@variable The numerator of the average.  \nfloat  numerator  =  math.sum(weight  *  close,  lengthInput)  \n//@variable The denominator of the average.  \nfloat  denominator  =  math.sum(weight,  lengthInput)  \n  \n//@variable The weighted average over `lengthInput` bars.  \nfloat  average  =  numerator  /  denominator  \n  \n// Plot the `average`.  \nplot(average,  \"Weighted average\",  linewidth  =  3)  \n``\n\nNote that:\n\n-   This script includes  `precision = 5`  in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  declaration statement, which specifies that it plots numbers with five fractional digits instead of using the chart‚Äôs default precision setting.\n\nSuppose we want to inspect  _all_  the values in the  `average`  calculation using plots. If we use  `plot*()`  functions with the default  `display`  argument ([display.all](https://www.tradingview.com/pine-script-reference/v6/#const_display.all)), the plotted results appear in all possible locations, including the chart pane. Unlike the example script from the  [Plotting numbers](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-numbers)  section, this script‚Äôs visuals become hard to read in the pane because each plot has a significantly different range:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-numbers-Plotting-without-affecting-the-scale-2.JCRilku2_uWE4Y.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting without affecting the scale demo\",  \"Weighted average\",  true,  precision  =  5)  \n  \n//@variable The number of bars in the average.  \nint  lengthInput  =  input.int(20,  \"Length\",  1)  \n  \n//@variable The weight applied to the price on each bar.  \nfloat  weight  =  math.pow(close  -  open,  2)  \n  \n//@variable The numerator of the average.  \nfloat  numerator  =  math.sum(weight  *  close,  lengthInput)  \n//@variable The denominator of the average.  \nfloat  denominator  =  math.sum(weight,  lengthInput)  \n  \n//@variable The weighted average over `lengthInput` bars.  \nfloat  average  =  numerator  /  denominator  \n  \n// Plot the `average`.  \nplot(average,  \"Weighted average\",  linewidth  =  3)  \n  \n// Create debug plots for the `weight`, `numerator`, and `denominator`.  \nplot(weight,  \"weight\",  color.purple)  \nplot(numerator,  \"numerator\",  color.teal)  \nplot(denominator,  \"denominator\",  color.maroon)  \n``\n\nWe can change the  `display`  argument in each debug  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call to view all the calculated values while preserving the chart‚Äôs scale. Below, we set the argument to  `display.all - display.pane`, meaning all the debug plots show information in all locations  _except_  the chart pane. Now, we can visualize how the calculated values affect each bar‚Äôs  `average`  result without distorting the scale:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-numbers-Plotting-without-affecting-the-scale-3.BdsQvxR3_Z2nxNp8.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting without affecting the scale demo\",  \"Weighted average\",  true,  precision  =  5)  \n  \n//@variable The number of bars in the average.  \nint  lengthInput  =  input.int(20,  \"Length\",  1)  \n  \n//@variable The weight applied to the price on each bar.  \nfloat  weight  =  math.pow(close  -  open,  2)  \n  \n//@variable The numerator of the average.  \nfloat  numerator  =  math.sum(weight  *  close,  lengthInput)  \n//@variable The denominator of the average.  \nfloat  denominator  =  math.sum(weight,  lengthInput)  \n  \n//@variable The weighted average over `lengthInput` bars.  \nfloat  average  =  numerator  /  denominator  \n  \n// Plot the `average`.  \nplot(average,  \"Weighted average\",  linewidth  =  3)  \n  \n//@variable The display locations of all debug plots.  \ndebugLocations  =  display.all  -  display.pane  \n// Create debug plots for the `weight`, `numerator`, and `denominator`.  \nplot(weight,  \"weight\",  color.purple,  display  =  debugLocations)  \nplot(numerator,  \"numerator\",  color.teal,  display  =  debugLocations)  \nplot(denominator,  \"denominator\",  color.maroon,  display  =  debugLocations)  \n``\n\nNote that:\n\n-   The  `display.*`  constants support  _addition_  and  _subtraction_  operations for customized display settings. This script uses subtraction to remove  [display.pane](https://www.tradingview.com/pine-script-reference/v6/#const_display.pane)  from the output locations allowed by  [display.all](https://www.tradingview.com/pine-script-reference/v6/#const_display.all). Operations that remove valid display constants more than once do not cause errors. For instance, this script produces the  _same_  outputs if it subtracts  [display.pane](https://www.tradingview.com/pine-script-reference/v6/#const_display.pane)  once, twice, or more times in the  `debugLocations`  expression.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "ta.correlation",
      "ta.rsi",
      "ta.percentrank",
      "math.avg",
      "color.purple",
      "color.red",
      "plot.style_circles",
      "color.maroon",
      "color.blue",
      "i.e",
      "math.pow",
      "math.sum",
      "display.all",
      "const_display.all",
      "color.teal",
      "display.pane",
      "const_display.pane",
      "indicator",
      "strategy",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "const",
      "method",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-377",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Tips and  techniques](https://www.tradingview.com/pine-script-docs/writing/debugging/#tips-and-techniques)",
    "content": "### [Plotting and coloring  conditions](https://www.tradingview.com/pine-script-docs/writing/debugging/#plotting-and-coloring-conditions)\n\nProgrammers can inspect a script‚Äôs conditions (‚Äúbool‚Äù values) with the  `plot*()`,  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor), and  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor)  functions in several ways, including:\n\n-   Using the ‚Äúbool‚Äù condition as the  `series`  argument in a  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  or  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call. The call creates a shape/character with specified text on the chart when the condition is  `true`, and it shows a  _numeric text_  representation of the condition in the status line and Data Window (`1`  for  `true`  and  `0`  for  `false`).\n-   Creating a logical expression that returns different ‚Äúint‚Äù or ‚Äúfloat‚Äù values for the condition‚Äôs  `true`  and  `false`  states, then using the result as the  `series`  argument in a  `plot*()`  call. When using  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  or  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape), note that these functions show visuals on the chart only when the  `series`  value is not  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  or 0.\n-   Creating a logical expression that returns different ‚Äúcolor‚Äù values based on the condition‚Äôs  `true`  or  `false`  state, then using the result to color the chart with  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  or  [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor), or to color a plot or fill.\n\nThe following example uses the above methods to debug a simple condition. The script calculates an RSI with an input length and defines a  `crossBelow`  condition that is  `true`  when the RSI crosses 30. It uses  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape),  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar), and  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  calls to visualize the  `crossBelow`  condition in different ways:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-and-coloring-conditions-1.BhI2H3mP_1CXbkm.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting and coloring conditions demo\")  \n  \n//@variable The length of the RSI.  \nint  lengthInput  =  input.int(14,  \"Length\",  1)  \n  \n//@variable The calculated RSI value.  \nfloat  rsi  =  ta.rsi(close,  lengthInput)  \n  \n//@variable Is `true` when the `rsi` crosses below 30, `false` otherwise.  \nbool  crossBelow  =  ta.crossunder(rsi,  30.0)  \n  \n// Plot the `rsi`.  \nplot(rsi,  \"RSI\",  color.rgb(136,  76,  146),  linewidth  =  3)  \n  \n// Plot a circle near the top of the pane when `crossBelow` is `true`.  \n// The status line and Data Window show 1 when the condition is `true` and 0 when it is `false`.  \nplotshape(crossBelow,  \"plotshape debug\",  shape.circle,  location.top,  color.red,  size  =  size.small)  \n  \n// Plot the `‚§∞` character at the `rsi` value when `crossBelow` is `true`.  \n// The status line and Data Window show the `rsi` value when the condition is `true` and `na` when it is `false`.  \nplotchar(crossBelow  ?  rsi  :  na,  \"plotchar debug\",  \"‚§∞\",  location.absolute,  color.maroon,  size  =  size.normal)  \n  \n// Highlight the background when `crossBelow` is `true`. Does not add information to the status line or Data Window.  \nbgcolor(crossBelow  ?  color.new(color.red,  60) :  na,  title  =  \"bgcolor debug\")  \n``\n\nNote that:\n\n-   The  `plot*()`  functions that display text or shapes on the chart ‚Äî  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape),  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar), and  [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)  ‚Äî  _do not_  display data in the price scale.\n-   The  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  call uses  `crossUnder`  as its  `series`  argument. The chart pane shows a shape at the top when the condition occurs. The status line and Data Window show 1 when the  `series`  is  `true`  and 0 when it is  `false`.\n-   The  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call plots the result of a ternary expression that returns the  `rsi`  when  `crossUnder`  is  `true`  and  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  otherwise. It shows the character U+2930 at the  `rsi`  location when the expression does not evaluate to  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). Because the  `series`  argument is a ‚Äúfloat‚Äù value, the number in the status line and Data Window represents that value directly.\n-   The  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  call highlights the chart‚Äôs background when  `crossUnder`  is  `true`, but it does not display information in the status line or Data Window.\n\nThe  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  and  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  functions have a  `text`  parameter that adds ‚Äúconst string‚Äù text to the plotted shapes/characters. When debugging multiple global conditions, it is often helpful to call these functions with  `text`  arguments to label each condition for simple on-chart inspection. The arguments can contain the newline character (`\\n`  [escape sequence](https://www.tradingview.com/pine-script-docs/concepts/strings/#escape-sequences)), allowing scripts to plot multiple shapes in identical locations with non-overlapping text.\n\nLet‚Äôs explore a debugging example using this approach. The script below calculates an RSI and its median over  `lengthInput`  bars. Then, it creates five singular conditions and uses them to form a  _compound condition_. The script plots the  `rsi`  and  `median`  values with the  `plot()`  function, and it colors the background with  [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)  when the  `compoundCondition`  is  `true`:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-and-coloring-conditions-2.1wtCT3lE_ZhTEf7.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting and coloring compound conditions demo\")  \n  \n//@variable The length of the RSI and median RSI calculations.  \nint  lengthInput  =  input.int(14,  \"Length\",  2)  \n  \n//@variable The RSI of `close` with a smoothing factor defined by `lengthInput`.  \nfloat  rsi  =  ta.rsi(close,  lengthInput)  \n//@variable The median of the `rsi` over `lengthInput` bars.  \nfloat  median  =  ta.median(rsi,  lengthInput)  \n  \n//@variable Condition #1: Is `true` when the 1-bar `rsi` change switches from 1 to -1.  \nbool  changeNegative  =  ta.change(math.sign(ta.change(rsi))) ==  -2  \n//@variable Condition #2: Is `true` when the previous bar's `rsi` is greater than 70.  \nbool  prevAbove70  =  rsi[1] >  70.0  \n//@variable Condition #3: Is `true` when the current `close` is lower than the previous bar's `open`.  \nbool  closeBelow  =  close  <  open[1]  \n//@variable Condition #4: Is `true` when the `rsi` is between 60 and 70.  \nbool  betweenLevels  =  bool(math.max(70.0  -  rsi,  0.0) *  math.max(rsi  -  60.0,  0.0))  \n//@variable Condition #5: Is `true` when the `rsi` is above the `median`.  \nbool  aboveMedian  =  rsi  >  median  \n  \n//@variable Is `true` when the first condition occurs alongside conditions 2 and 3 or 4 and 5.  \nbool  compundCondition  =  changeNegative  and ((prevAbove70  and  closeBelow) or (betweenLevels  and  aboveMedian))  \n  \n//Plot the `rsi` and the `median`.  \nplot(rsi,  \"RSI\",  color.teal,  3)  \nplot(median,  \"RSI Median\",  color.gray,  2)  \n  \n// Highlight the background red when the `compundCondition` occurs.  \nbgcolor(compundCondition  ?  color.new(color.red,  60) :  na,  title  =  \"compundCondition\")  \n``\n\nTo verify that the script‚Äôs logic works as intended, we can inspect each of the conditions that affect the final  `compoundCondition`  value. Below, we added five  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  calls to display information for these conditions, each with the same  `location`  argument. To label the conditions on the chart, each  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call uses a string containing newline characters (`\\n`) and a digit from 1 to 5 as the  `text`  argument. With these outputs, we can see which sets of conditions trigger each  `compoundCondition`  occurrence:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Plots-and-chart-colors-Plotting-and-coloring-conditions-3.STxZruzR_Z1OOA4S.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Plotting and coloring compound conditions demo\")  \n  \n//@variable The length of the RSI and median RSI calculations.  \nint  lengthInput  =  input.int(14,  \"Length\",  2)  \n  \n//@variable The RSI over `lengthInput` bars.  \nfloat  rsi  =  ta.rsi(close,  lengthInput)  \n//@variable The median of the `rsi` over `lengthInput` bars.  \nfloat  median  =  ta.median(rsi,  lengthInput)  \n  \n//@variable Condition #1: Is `true` when the 1-bar `rsi` change switches from 1 to -1.  \nbool  changeNegative  =  ta.change(math.sign(ta.change(rsi))) ==  -2  \n//@variable Condition #2: Is `true` when the previous bar's `rsi` is greater than 70.  \nbool  prevAbove70  =  rsi[1] >  70.0  \n//@variable Condition #3: Is `true` when the current `close` is lower than the previous bar's `open`.  \nbool  closeBelow  =  close  <  open[1]  \n//@variable Condition #4: Is `true` when the `rsi` is between 60 and 70.  \nbool  betweenLevels  =  bool(math.max(70.0  -  rsi,  0.0) *  math.max(rsi  -  60.0,  0.0))  \n//@variable Condition #5: Is `true` when the `rsi` is above the `median`.  \nbool  aboveMedian  =  rsi  >  median  \n  \n//@variable Is `true` when the first condition occurs alongside conditions 2 and 3 or 4 and 5.  \nbool  compundCondition  =  changeNegative  and ((prevAbove70  and  closeBelow) or (betweenLevels  and  aboveMedian))  \n  \n//Plot the `rsi` and the `median`.  \nplot(rsi,  \"RSI\",  color.teal,  3)  \nplot(median,  \"RSI Median\",  color.gray,  2)  \n  \n// Highlight the background red when the `compundCondition` occurs.  \nbgcolor(compundCondition  ?  color.new(color.red,  60) :  na,  title  =  \"compundCondition\")  \n  \n// Use `plotshape()` to show `compundCondition` values in the status line and Data Window.  \nplotshape(  \ncompundCondition,  \"compundCondition (1 and (2 and 3) or (4 and 5))\",  \ncolor  =  chart.fg_color,  display  =  display.all  -  display.pane  \n)  \n  \n// Plot characters on the chart and numbers in the status line and Data Window when conditions 1-5 occur.  \nplotchar(changeNegative,  \"changeNegative (1)\",  \"\",  location.top,  text  =  \"1\",  textcolor  =  chart.fg_color)  \nplotchar(prevAbove70,  \"prevAbove70 (2)\",  \"\",  location.top,  text  =  \"\\n2\",  textcolor  =  chart.fg_color)  \nplotchar(closeBelow,  \"closeBelow (3)\",  \"\",  location.top,  text  =  \"\\n\\n3\",  textcolor  =  chart.fg_color)  \nplotchar(betweenLevels,  \"betweenLevels (4)\",  \"\",  location.top,  text  =  \"\\n\\n\\n4\",  textcolor  =  chart.fg_color)  \nplotchar(aboveMedian,  \"aboveMedian (5)\",  \"\",  location.top,  text  =  \"\\n\\n\\n\\n5\",  textcolor  =  chart.fg_color)  \n``\n\nNote that:\n\n-   The  `char`  argument of each  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call is an empty string, meaning the function displays its  `text`  value without a character above it.\n-   Because each  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call outputs results at the same relative location (`location.top`), we included different numbers of leading  `\\n`  sequences in the  `text`  arguments to move the displayed numerals down and ensure they do not overlap.\n-   The  `title`  argument of each  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  call contains the condition number to distinguish it in the Data Window.\n-   The  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  call‚Äôs title describes the compound condition‚Äôs structure in the Data Window.\n\nTo learn more about the  [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)  and  [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)  functions and how their outputs differ from  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels), refer to the  [Text and shapes](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/)  page.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "ta.rsi",
      "ta.crossunder",
      "color.rgb",
      "shape.circle",
      "location.top",
      "color.red",
      "size.small",
      "location.absolute",
      "color.maroon",
      "size.normal",
      "color.new",
      "ta.median",
      "ta.change",
      "math.sign",
      "math.max",
      "color.teal",
      "color.gray",
      "chart.fg_color",
      "display.all",
      "display.pane",
      "indicator",
      "input",
      "plot",
      "fill",
      "bgcolor",
      "barcolor",
      "var",
      "series",
      "simple",
      "const",
      "method",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-378",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Decomposing  expressions](https://www.tradingview.com/pine-script-docs/writing/debugging/#decomposing-expressions)",
    "content": "## [Tips and  techniques](https://www.tradingview.com/pine-script-docs/writing/debugging/#tips-and-techniques)\n\nThe following sections explain several additional tips and helpful techniques for effective Pine Script debugging.",
    "keywords": [
      "www.tradingview",
      "for"
    ]
  },
  {
    "id": "doc-379",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Extracting data from local  scopes](https://www.tradingview.com/pine-script-docs/writing/debugging/#extracting-data-from-local-scopes)",
    "content": "### [Decomposing  expressions](https://www.tradingview.com/pine-script-docs/writing/debugging/#decomposing-expressions)\n\nOne of the best practices for efficient debugging is to  _split expressions_, especially those with multiple calculations or logical operations, into  _smaller parts_  assigned to separate variables. Decomposing expressions enables programmers to inspect each critical part individually, making it easier to verify calculations or logic and isolate potential issues in the code. Additionally, complex code broken down into smaller parts is typically simpler to read, maintain, and  [profile](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script).\n\nThe following script calculates a custom oscillator representing the smoothed median change in the differences between the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price and two EMAs over different lengths. The script performs all the calculations in a single expression assigned to the  `osc`  variable. Then, it creates a compound condition in another expression assigned to the  `upSignal`  variable and uses that variable to trigger  [order placement commands](https://www.tradingview.com/pine-script-docs/concepts/strategies/#order-placement-and-cancellation). The script plots the  `osc`  series as columns with different colors based on the  `upSignal`  value:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Decomposing-expressions-1.DPZlbAAY_Z1JS6lp.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nstrategy(\"Decomposing expressions demo\")  \n  \n//@variable The length used for the first part of the oscillator.  \nint  length1Input  =  input.int(20)  \n//@variable The length used for the second part of the oscillator.  \nint  length2Input  =  input.int(40)  \n//@variable Oscillator smoothing length.  \nint  smoothingInput  =  input.int(10)  \n  \n//@variable The maximum of `length1Input` and `length2Input`.  \nint  maxLength  =  math.max(length1Input,  length2Input)  \n  \n//@variable The smoothed median change in the differences between `close` and two EMAs over different lengths.  \nfloat  osc  =  ta.ema(  \nmath.avg(  \nta.change(close  -  ta.ema(close,  length1Input),  length1Input),  \nta.change(close  -  ta.ema(close,  length2Input),  length2Input)  \n),  smoothingInput  \n)  \n  \n//@variable `true` if `osc` is positive, above the last two-bar average, and below twice the stdev for `maxLength` bars.  \nbool  upSignal  =  osc  <  2  *  ta.stdev(osc,  maxLength) and  osc  >  0  and  math.avg(osc[1],  osc[2]) <  osc  \n  \n// Plot the `osc` as columns colored based on the `upSignal`.  \nplot(osc,  \"Custom oscillator\",  upSignal  ?  color.aqua  :  color.gray,  style  =  plot.style_columns)  \n  \n// Place a \"Buy\" market order when `upSignal` is `true`, and a closing market order when it is `false`.  \nif  upSignal  \nstrategy.entry(\"Buy\",  strategy.long)  \nelse  \nstrategy.close(\"Buy\")  \n``\n\nBecause the  `osc`  and  `upSignal`  values depend on multiple calculations and conditions, inspecting only the final values does not provide complete information about the script‚Äôs behaviors. To verify the script‚Äôs workings, we can decompose the expressions assigned to  `osc`  and  `upCondition`  into smaller parts and inspect them individually.\n\nThe script version below declares several extra variables to hold  _different parts_  of the original  `osc`  and  `upCondition`  expressions. With this expanded structure, we can inspect each part of the calculations and logic step-by-step using various outputs. In this script, we included a single  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call at the end that displays  [formatted text](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  containing each variable‚Äôs information in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Decomposing-expressions-2.CWIhg_Os_1r2usz.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nstrategy(\"Decomposing expressions demo\")  \n  \n//@variable The length used for the first part of the oscillator.  \nint  length1Input  =  input.int(20)  \n//@variable The length used for the second part of the oscillator.  \nint  length2Input  =  input.int(40)  \n//@variable Oscillator smoothing length.  \nint  smoothingInput  =  input.int(10)  \n  \n//@variable The maximum of `length1Input` and `length2Input`.  \nint  maxLength  =  math.max(length1Input,  length2Input)  \n  \n//#region Split the `osc` calculations into smaller parts:  \n  \n// 1. Calculate the EMAS over `length1Input` and `length2Input` bars.  \nfloat  ema1  =  ta.ema(close,  length1Input),  float  ema2  =  ta.ema(close,  length2Input)  \n// 2. Calculate the differences between `close` and `ema1` and `ema2`.  \nfloat  diff1  =  close  -  ema1,  float  diff2  =  close  -  ema2  \n// 3. Calculate the changes in `diff1` and `diff2` over `length1Input` and `length2Input` bars.  \nfloat  change1  =  ta.change(diff1,  length1Input),  float  change2  =  ta.change(diff2,  length2Input)  \n// 4. Calculate the median of `change1` and `change2`.  \nfloat  medChange  =  math.avg(change1,  change2)  \n//#endregion  \n  \n//@variable The smoothed median change in the differences between `close` and two EMAs over different lengths.  \nfloat  osc  =  ta.ema(medChange,  smoothingInput)  \n  \n//#region Split the `upSignal` calculations and logic into smaller parts:  \n  \n// 1. Assign the calculations in the expression to separate variables.  \nfloat  oscDev  =  2  *  ta.stdev(osc,  maxLength),  float  pastAvg  =  math.avg(osc[1],  osc[2])  \n// 2. Assign each singular condition to a separate variable.  \nbool  cond1  =  osc  <  oscDev,  bool  cond2  =  osc  >  0,  bool  cond3  =  pastAvg  <  osc  \n//#endregion  \n  \n//@variable Is `true` if `osc` is positive, above the past two-bar average, and below twice its stdev over `maxLength` bars.  \nbool  upSignal  =  cond1  and  cond2  and  cond3  \n  \n// Plot the `osc` as columns colored based on the `upSignal`.  \nplot(osc,  \"Custom oscillator\",  upSignal  ?  color.aqua  :  color.gray,  style  =  plot.style_columns)  \n  \n// Place a \"Buy\" market order when `upSignal` is `true`, and a closing market order when it is `false`.  \nif  upSignal  \nstrategy.entry(\"Buy\",  strategy.long)  \nelse  \nstrategy.close(\"Buy\")  \n  \n// Call `log.info()` to display a formatted message containing debug information in the Pine Logs pane.  \nif  barstate.isconfirmed  \nlog.info(  \n\"\\nema1: {0,number,0.00000}, diff1: {1,number,0.00000}, change1: {2,number,0.00000}  \n\\nema2: {3,number,0.00000},  diff2: {4,number,0.00000},  change2: {5,number,0.00000}  \n\\nmedChange: {6,number,0.00000}\\n\\nosc: {7,number,0.00000}\\n----  \n\\noscDev: {8,number,0.00000}\\npastAvg: {9,number,0.00000}  \n\\ncond1: {10},  cond2: {11},  cond3: {12}\\n\\nupSignal: {13}\",  \nema1,  diff1,  change1,  ema2,  diff2,  change2,  medChange,  osc,  oscDev,  pastAvg,  cond1,  cond2,  cond3,  upSignal  \n)  \n``\n\nNote that:\n\n-   This script declares some extra variables on the  _same line_, separated by commas, to reduce the number of lines added to the code.\n-   The script calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  only when  [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.isconfirmed)  is  `true`, preventing unnecessary logs on the ticks of unconfirmed bars.\n-   All the placeholders with the  `number`  modifier in the  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call‚Äôs formatting string include the  `0.00000`  pattern, which forces the formatted numbers to always show five fractional digits. Refer to the  [Formatting strings](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  section of the  [Strings](https://www.tradingview.com/pine-script-docs/concepts/strings/)  page for more information.\n-   The Pine Logs pane displays up to 10,000 historical logs. To view earlier logs, add another condition to the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure that limits the  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call to specific bars. See the  [Custom code filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)  section above for an example that restricts  `log.*()`  calls using  [time inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/#time-input).",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "math.max",
      "ta.ema",
      "math.avg",
      "ta.change",
      "ta.stdev",
      "color.aqua",
      "color.gray",
      "plot.style_columns",
      "strategy.entry",
      "strategy.long",
      "strategy.close",
      "log.info",
      "fun_log.info",
      "barstate.isconfirmed",
      "var_barstate.isconfirmed",
      "strategy",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-380",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Inspecting  loops](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-loops)",
    "content": "### [Extracting data from local  scopes](https://www.tradingview.com/pine-script-docs/writing/debugging/#extracting-data-from-local-scopes)\n\nThe  _scope_  of an identifier (e.g., a variable) refers to the part of a script where it is defined and  _accessible_  during the script‚Äôs execution.\n\nAll identifiers declared outside  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/),  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods),  [loops](https://www.tradingview.com/pine-script-docs/language/loops/),  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/), or  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  and  [enum type](https://www.tradingview.com/pine-script-docs/language/type-system/#enum-types)  declarations belong to the  _global scope_. Identifiers in the global scope are accessible to most  _inner_  (local) scopes after declaration. Every Pine script has exactly  **one**  global scope.\n\nAll user-defined functions, methods, loops, and conditional structures in a script create unique, separate  _local scopes_. All identifiers within a local scope belong exclusively to that scope, meaning their values or references are  _inaccessible_  to any  _outer_  or  _containing_  scope.\n\nA common practice when debugging variables declared in a local scope is to extract their data to an outer scope or the global scope, making it usable in debugging outputs with different scope requirements.\n\nThe following sections explain techniques for extracting data from local scopes using  [return expressions](https://www.tradingview.com/pine-script-docs/writing/debugging/#extraction-using-return-expressions)  and  [reference types](https://www.tradingview.com/pine-script-docs/writing/debugging/#extraction-using-reference-types). We demonstrate these techniques on the following script, which contains a  `customMA()`  function that calculates a custom adaptive moving average of a  `source`  series based on the distance from its current value to its 25th and 75th percentiles over  `length`  bars. The script contains a local function scope, and a nested block scope from the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure that sets the  `outerRange`  value:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Extracting-data-from-local-scopes-1.7noUNshc_fuFiN.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Extracting from local scopes initial demo\",  overlay  =  true)  \n  \n//@variable The number of bars in the `customMA()` calculation.  \nint  lengthInput  =  input.int(50,  \"Length\",  2)  \n  \n//@function Calculates a moving average that changes only when `source` is outside the first and third quartiles.  \n//@param source The series of values to process.  \n//@param length The number of bars in the quartile calculation.  \n//@returns The adaptive moving average value.  \ncustomMA(float  source,  int  length) =>  \n//@variable The custom moving average.  \nvar  float  result  =  na  \n// Calculate the 25th and 75th `source` percentiles (first and third quartiles) over `length` bars.  \nfloat  q1  =  ta.percentile_linear_interpolation(source,  length,  25)  \nfloat  q3  =  ta.percentile_linear_interpolation(source,  length,  75)  \n//@variable The distance from `source` to its interquartile range.  \nfloat  outerRange  =  0.0  \n// Calculate the `outerRange` value when `source` is not `na`.  \nif  not  na(source)  \nfloat  upperRange  =  source  -  q3  \nfloat  lowerRange  =  q1  -  source  \nouterRange  :=  math.max(upperRange,  lowerRange,  0.0)  \n//@variable The total range of `source` values over `length` bars.  \nfloat  totalRange  =  ta.range(source,  length)  \n//@variable Half the ratio of the `outerRange` to the `totalRange`.  \nfloat  alpha  =  0.5  *  outerRange  /  totalRange  \n// Mix the `source` with the `result` based on the `alpha` value.  \nresult  := (1.0  -  alpha) *  nz(result,  source) +  alpha  *  source  \n// Return the `result`.  \nresult  \n  \n//@variable The `customMA()` of `close` over `lengthInput` bars.  \nfloat  maValue  =  customMA(close,  lengthInput)  \n  \n// Plot the `maValue`.  \nplot(maValue,  \"Custom MA\",  color.blue,  3)  \n``\n\n#### [Extraction using return  expressions](https://www.tradingview.com/pine-script-docs/writing/debugging/#extraction-using-return-expressions)\n\nIn Pine Script, any  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  call,  [loop](https://www.tradingview.com/pine-script-docs/language/loops/), or  [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  _returns_  the result of the  _final_  expression or nested structure within its local scope. Scripts can use these structures‚Äô returned results, excluding  [void](https://www.tradingview.com/pine-script-docs/language/type-system/#void), by assigning them to variables declared in the  _outer_  scope.\n\nWhen debugging functions and conditional structures that contain multiple local variables, a common technique to extract data from their scopes is to return  [tuples](https://www.tradingview.com/pine-script-docs/language/type-system/#tuples)  containing the data that requires inspection.\n\nHere, we‚Äôve modified the  [previous](https://www.tradingview.com/pine-script-docs/writing/debugging/#extracting-data-from-local-scopes)  example script‚Äôs  `customMA()`  function to return a tuple containing values calculated from the local scopes. With this change, the script can call the function with a  _tuple declaration_  to make all the data available to the global scope. The script plots the  `q1Dbg`  and  `q3Dbg`  values, highlights the background when  `alphaDbg`  is 0, and uses  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  to display a formatted string containing all the extracted data in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Extracting-data-from-local-scopes-Extraction-using-return-expressions-1.gNLzCXLM_ZdahrJ.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Extraction using return expressions demo\",  overlay  =  true)  \n  \n//@variable The number of bars in the `customMA()` calculation.  \nint  lengthInput  =  input.int(50,  \"Length\",  2)  \n  \n//@function Calculates a moving average that changes only when `source` is outside the first and third quartiles.  \n//@param source The series of values to process.  \n//@param length The number of bars in the quartile calculation.  \n//@returns The adaptive moving average value.  \ncustomMA(float  source,  int  length) =>  \n//@variable The custom moving average.  \nvar  float  result  =  na  \n// Calculate the 25th and 75th `source` percentiles (first and third quartiles) over `length` bars.  \nfloat  q1  =  ta.percentile_linear_interpolation(source,  length,  25)  \nfloat  q3  =  ta.percentile_linear_interpolation(source,  length,  75)  \n//@variable The distance from `source` to its interquartile range.  \nfloat  outerRange  =  0.0  \n// To extract `upperRange` and `lowerRange` values, we need to make them accessible to the function's main scope.  \n// Here, we added a tuple at the end of the `if` statement's local block, then declared a tuple in the function's  \n// scope to hold the returned values.  \n[upper,  lower] =  if  not  na(source)  \nfloat  upperRange  =  source  -  q3  \nfloat  lowerRange  =  q1  -  source  \nouterRange  :=  math.max(upperRange,  lowerRange,  0.0)  \n[upperRange,  lowerRange]  \n//@variable The total range of `source` values over `length` bars.  \nfloat  totalRange  =  ta.range(source,  length)  \n//@variable Half the ratio of the `outerRange` to the `totalRange`.  \nfloat  alpha  =  0.5  *  outerRange  /  totalRange  \n// Mix the `source` with the `result` based on the `alpha` value.  \nresult  := (1.0  -  alpha) *  nz(result,  source) +  alpha  *  source  \n// Return a tuple containing the `result` and other local variables.  \n[result,  q1,  q3,  upper,  lower,  outerRange,  totalRange,  alpha]  \n  \n//@variable The `customMA()` of `close` over `lengthInput` bars.  \n[maValue,  q1Dbg,  q3Dbg,  upperDbg,  lowerDbg,  outerRangeDbg,  totalRangeDbg,  alphaDbg] =  customMA(close,  lengthInput)  \n  \n// Plot the `maValue`.  \nplot(maValue,  \"Custom MA\",  color.blue,  3)  \n  \n// When the bar is confirmed, log an \"info\" message containing formatted debug information for each variable.  \nif  barstate.isconfirmed  \nlog.info(  \n\"maValue: {0,number,#.#####}\\nq1Dbg: {1,number,#.#####}, q3Dbg: {2,number,#.#####}  \n\\nupperDbg: {3,number,#.#####}, lowerDbg: {4,number,#.#####}  \n\\nouterRangeDbg: {5,number,#.#####}, totalRangeDbg: {6,number,#.#####}  \n\\nalphaDbg: {7,number,#.#####}\",  \nmaValue,  q1Dbg,  q3Dbg,  upperDbg,  lowerDbg,  outerRangeDbg,  totalRangeDbg,  alphaDbg  \n)  \n  \n// Display the extracted `q1` and `q3` data in all plot locations.  \nplot(q1Dbg,  \"q1Dbg\",  color.new(color.maroon,  50))  \nplot(q3Dbg,  \"q3Dbg\",  color.new(color.teal,  50))  \n// Highlight the chart's background when the extracted `alpha` value is 0.  \nbgcolor(alphaDbg  ==  0.0  ?  color.new(color.orange,  90) :  na,  title  =  \"`alpha == 0.0` highlight\")  \n``\n\nNote that:\n\n-   We added a tuple at the  _end_  of the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure‚Äôs block to  _return_  the  `upperRange`  and  `lowerRange`  values from its local scope. The function assigns the result to a two-variable tuple in its main scope, enabling it to include the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure‚Äôs local values in the return expression.\n\n#### [Extraction using reference  types](https://www.tradingview.com/pine-script-docs/writing/debugging/#extraction-using-reference-types)\n\n_Reference types_, including all  [special types](https://www.tradingview.com/pine-script-docs/language/type-system/#types)  and  [user-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types), serve as structures for creating  _objects_. Each object has an associated  _reference_  that distinguishes it and provides access to its data. Unlike fundamental types, variables of reference types  **do not**  store values directly. Instead, they hold the references for specific objects in memory.\n\nAn advanced, flexible way to extract data from local scopes is to initialize reference-type objects ‚Äî such as instances of  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  or UDTs ‚Äî in the global scope and store local variable data in their elements or fields.\n\nThis technique is especially useful for extracting data from  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  and  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods). Although functions can access global variables, they cannot  _reassign_  them like global  [conditional structures](https://www.tradingview.com/pine-script-docs/language/conditional-structures/)  and  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  can. Consequently, they  _cannot update_  the data held by global variables of fundamental types. However, scripts do not modify reference types by reassigning their variables; they access objects via their references and use  _methods_  or  _field reassignments_  to update their data. As such, scripts  _can_  update global collections or UDT instances from inside function scopes.\n\nFor example, this modified version of our  [initial script](https://www.tradingview.com/pine-script-docs/writing/debugging/#extracting-data-from-local-scopes)  declares a global  `debugData`  variable that holds the reference of a  [map](https://www.tradingview.com/pine-script-reference/v6/#type_map)  with ‚Äústring‚Äù keys and ‚Äúfloat‚Äù values. Each  [map.put()](https://www.tradingview.com/pine-script-reference/v6/#fun_map.put)  call inside the  `customMA()`  scope modifies the map by adding a  _key-value pair_  containing a local variable‚Äôs  _name_  and  _value_. After calling  `customMA()`, the script uses  [map.get()](https://www.tradingview.com/pine-script-reference/v6/#fun_map.get)  calls on  `debugData`  to retrieve the stored information for its debugging outputs:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Extracting-data-from-local-scopes-Extraction-using-reference-types-1.BdAF7qQM_Z1mwS83.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Extraction using reference types demo\",  overlay  =  true)  \n  \n//@variable The number of bars in the `customMA()` calculation.  \nint  lengthInput  =  input.int(50,  \"Length\",  2)  \n  \n//@variable A global map of \"string\" keys and \"float\" values to store debug information from local scopes.  \nvar  map<string,  float> debugData  =  map.new<string,  float>()  \n  \n//@function Calculates a moving average that changes only when `source` is outside the first and third quartiles.  \n//@param source The series of values to process.  \n//@param length The number of bars in the quartile calculation.  \n//@returns The adaptive moving average value.  \ncustomMA(float  source,  int  length) =>  \n//@variable The custom moving average.  \nvar  float  result  =  na  \n// Calculate the 25th and 75th percentiles (first and third quartiles).  \nfloat  q1  =  ta.percentile_linear_interpolation(source,  length,  25),  debugData.put(\"q1\",  q1)  \nfloat  q3  =  ta.percentile_linear_interpolation(source,  length,  75),  debugData.put(\"q3\",  q3)  \n//@variable The distance from `source` to its interquartile range.  \nfloat  outerRange  =  0.0  \n// Calculate the `outerRange` value when `source` is not `na`.  \nif  not  na(source)  \nfloat  upperRange  =  source  -  q3,  debugData.put(\"upperRange\",  upperRange)  \nfloat  lowerRange  =  q1  -  source,  debugData.put(\"lowerRange\",  lowerRange)  \nouterRange  :=  math.max(upperRange,  lowerRange,  0.0),  debugData.put(\"outerRange\",  outerRange)  \n//@variable The total range of `source` values over `length` bars.  \nfloat  totalRange  =  ta.range(source,  length),  debugData.put(\"totalRange\",  totalRange)  \n//@variable Half the ratio of the `outerRange` to the `totalRange`.  \nfloat  alpha  =  0.5  *  outerRange  /  totalRange,  debugData.put(\"alpha\",  alpha)  \n// Mix the `source` with the `result` based on the `alpha` value.  \nresult  := (1.0  -  alpha) *  nz(result,  source) +  alpha  *  source  \n// Return the `result`.  \nresult  \n  \n//@variable The `customMA()` of `close` over `lengthInput` bars.  \nfloat  maValue  =  customMA(close,  lengthInput)  \n  \n// Plot the `maValue`.  \nplot(maValue,  \"Custom MA\",  color.blue,  3)  \n  \n// When the bar is confirmed, log an \"info\" message containing formatted debug information for each value.  \nif  barstate.isconfirmed  \nlog.info(  \n\"maValue: {0,number,#.#####}\\nq1: {1,number,#.#####}, q3: {2,number,#.#####}  \n\\nupperRange: {3,number,#.#####}, lowerRange: {4,number,#.#####}  \n\\nouterRange: {5,number,#.#####}, totalRange: {6,number,#.#####}  \n\\nalpha: {7,number,#.#####}\",  \nmaValue,  debugData.get(\"q1\"),  debugData.get(\"q3\"),  debugData.get(\"upperRange\"),  debugData.get(\"lowerRange\"),  \ndebugData.get(\"outerRange\"),  debugData.get(\"totalRange\"),  debugData.get(\"alpha\")  \n)  \n  \n// Display the extracted `q1` and `q3` data in all plot locations.  \nplot(debugData.get(\"q1\"),  \"q1\",  color.new(color.maroon,  50))  \nplot(debugData.get(\"q3\"),  \"q3\",  color.new(color.teal,  50))  \n// Highlight the chart's background when the extracted `alpha` value is 0.  \nbgcolor(debugData.get(\"alpha\") ==  0.0  ?  color.new(color.orange,  90) :  na,  title  =  \"`alpha == 0.0` highlight\")  \n``\n\nNote that:\n\n-   The script declares  `debugData`  with the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword, meaning the assigned map reference  _persists_  across script executions.\n-   A function executes its local code only when the script calls it. Therefore, the  `debugData`  map contains new information only after the  `customMA()`  call.\n-   Because the  [map.put()](https://www.tradingview.com/pine-script-reference/v6/#fun_map.put)  calls in  `customMA()`  assign keys to the map that do not change across executions, each  `customMA()`  call  _replaces_  the  `debugData`  map‚Äôs existing data. Programmers can  _preserve_  data from specific executions with this technique by making a  _copy_  of the global collection after the function call.",
    "keywords": [
      "www.tradingview",
      "e.g",
      "tradingview.com",
      "input.int",
      "ta.percentile_linear_interpolation",
      "math.max",
      "ta.range",
      "color.blue",
      "log.info",
      "fun_log.info",
      "barstate.isconfirmed",
      "color.new",
      "color.maroon",
      "color.teal",
      "color.orange",
      "map.put",
      "fun_map.put",
      "map.get",
      "fun_map.get",
      "map.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-381",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Debugging  collections](https://www.tradingview.com/pine-script-docs/writing/debugging/#debugging-collections)",
    "content": "### [Inspecting  loops](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-loops)\n\n[Loops](https://www.tradingview.com/pine-script-docs/language/loops/)  are structures that execute a local code block repeatedly based on a  _counter_  ([for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)), the  _contents_  of a  [collection](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  ([for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)), or a  _condition_  ([while](https://www.tradingview.com/pine-script-reference/v6/#kw_while)). These structures allow scripts to perform repetitive tasks without redundant lines of code.\n\nBecause loops can execute their local code multiple times, programmers must use techniques to track local variables  _across iterations_  to debug them effectively. As with other structures, there are many ways to inspect loops. These sections cover two helpful techniques:  [collecting loop information](https://www.tradingview.com/pine-script-docs/writing/debugging/#collecting-loop-information)  and  [tracing loop executions](https://www.tradingview.com/pine-script-docs/writing/debugging/#tracing-loop-executions).\n\n#### [Collecting loop  information](https://www.tradingview.com/pine-script-docs/writing/debugging/#collecting-loop-information)\n\nOne of the most effective loop inspection techniques is to use  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  or  [strings](https://www.tradingview.com/pine-script-docs/concepts/strings)  to gather information from the local scope on each iteration requiring inspection, then use the information in output functions  _after_  the loop terminates.\n\nLet‚Äôs look at a simple loop debugging example using this technique. The following script calculates the average rate of change in the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price over lengths from 1 to  `lookbackInput`  bars inside a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop. It declares an  `aroc`  variable in the global scope, sums the rates of change inside the loop, and then divides the sum by the  `lookbackInput`  to calculate the average:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Inspecting-loops-Collecting-loop-information-1.CbIJsIuS_1XDLYo.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Collecting loop information demo\",  \"Average ROC\")  \n  \n//@variable The number of past bars in the calculation.  \nint  lookbackInput  =  input.int(20,  \"Lookback\",  1)  \n  \n//@variable The average ROC of `close` prices over each length from 1 to `lookbackInput` bars.  \nfloat  aroc  =  0.0  \n  \n// Calculation loop.  \nfor  length  =  1  to  lookbackInput  \n//@variable The `close` value `length` bars ago.  \nfloat  pastClose  =  close[length]  \n//@variable The `close` rate of change over `length` bars.  \nfloat  roc  = (close  -  pastClose) /  pastClose  \n// Add the `roc` to the `aroc` value.  \naroc  +=  roc  \n  \n// Divide `aroc` by the `lookbackInput` to get the average.  \naroc  /=  lookbackInput  \n  \n// Plot the `aroc` series.  \nplot(aroc,  \"aroc\",  color.blue,  3)  \n``\n\nTo debug the script‚Äôs loop and ensure it works as intended, we can collect data from the local scope on each iteration and pass the result to the available output functions after the loop ends. In the script version below, we demonstrate two extraction methods. The first declares a global  `logText`  variable and concatenates  [formatted strings](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  containing each loop iteration‚Äôs  `length`  and  `roc`  values. The second declares a global  `rocArray`  variable and pushes each iteration‚Äôs  `roc`  value into the referenced  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array).\n\nAfter terminating the loop, the script calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  to display the  `logText`  in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane if the bar is confirmed. It then displays a ‚Äústring‚Äù representation of the  `rocArray`  inside  [label](https://www.tradingview.com/pine-script-reference/v6/#fun_label)  tooltips. Lastly, it shows the array‚Äôs  _first_  and  _last_  element values in all possible plot locations with the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  function:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Inspecting-loops-Collecting-loop-information-2.CS9aDiYb_2aGugI.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Collecting loop information demo\",  \"Average ROC\",  max_labels_count  =  500)  \n  \n//@variable The number of bars in the calculation.  \nint  lookbackInput  =  input.int(20,  \"Lookback\",  1)  \n  \n//@variable An array containing the `roc` value from each loop iteration.  \narray<float> debugValues  =  array.new<float>()  \n//@variable A string containing information about the `roc` value on each iteration.  \nstring  logText  =  \"\"  \n  \n//@variable The average ROC of `close` over lags from 1 to `lookbackInput` bars.  \nfloat  aroc  =  0.0  \n  \n// Calculation loop.  \nfor  length  =  1  to  lookbackInput  \n//@variable The `close` value `length` bars ago.  \nfloat  pastClose  =  close[length]  \n//@variable The `close` rate of change over `length` bars.  \nfloat  roc  = (close  -  pastClose) /  pastClose  \n// Add the `roc` to `aroc`.  \naroc  +=  roc  \n  \n// Concatenate a new \"string\" representation with the `debugText`.  \nlogText  +=  \"\\nlength: \"  +  str.tostring(length) +  \", roc: \"  +  str.tostring(roc)  \n// Push the `roc` value into the `debugValues` array.  \narray.push(debugValues,  roc)  \n  \n// Divide `aroc` by the `lookbackInput`.  \naroc  /=  lookbackInput  \n  \n// Plot the `aroc`.  \nplot(aroc,  \"aroc\",  color.blue,  3)  \n  \n// Log the `logText` in the Pine Logs pane when the bar is confirmed.  \nif  barstate.isconfirmed  \nlog.info(logText)  \n  \n// Draw a label with a tooltip containing a \"string\" representation of the `debugValues` array.  \nlabel.new(bar_index,  aroc,  color  =  color.new(color.blue,  70),  tooltip  =  str.tostring(debugValues))  \n  \n// Plot the `roc` values from the first and last iteration.  \nplot(array.first(debugValues),  \"First iteration roc\",  color.new(color.teal,  50),  2)  \nplot(array.last(debugValues),  \"Last iteration roc\",  color.new(color.maroon,  50),  2)  \n``\n\nNote that:\n\n-   Scripts can generate  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  and  [drawings](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-drawings)  directly from within a loop‚Äôs local scope. However, because loops usually execute their local code  _more than once_, calling  `log.*()`  or  [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label.new)  functions inside the scope can result in numerous logs or  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  per bar. Logging on each iteration helps trace execution patterns, but it also limits the number of  _historical_  bars with available debug data. See the next section,  [Tracing loop executions](https://www.tradingview.com/pine-script-docs/writing/debugging/#tracing-loop-executions), for an example.\n-   [Strings](https://www.tradingview.com/pine-script-docs/concepts/strings/)  can contain up to  _40,960_  characters, and large strings or repeated  [concatenation](https://www.tradingview.com/pine-script-docs/concepts/strings/#concatenation)  can impact a script‚Äôs performance. Therefore, extracting loop information with string concatenation is suitable for relatively  _small_  loops or inspecting specific variables. To extract large amounts of data from loops, use  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  instead.\n\n#### [Tracing loop  executions](https://www.tradingview.com/pine-script-docs/writing/debugging/#tracing-loop-executions)\n\nAn alternative way to inspect a loop, without collecting information for use in the  _outer scope_, is to add  `log.*()`  calls directly to the loop‚Äôs  _local block_. Each iteration that activates the call results in a new message in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane, allowing programmers to trace the loop‚Äôs execution pattern in detail.\n\nThis simple script calculates a pseudorandom sample from a  [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution)  using a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop. The plotted  `sample`  series represents the number of  [math.random()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.random)  calls across  `trialsInput`  iterations that return a value not exceeding the  `probabilityInput`  value. On each iteration where  `success`  is  `false`, the loop  _skips_  the rest of its block and moves to the next iteration. On other iterations, it increments the  `sample`  value by one:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Inspecting-loops-Tracing-loop-executions-1.KSzq3fPt_Z1u18SW.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Tracing loop executions demo\",  \"Binomial sample\")  \n  \n//@variable The probability that each random trial succeeds.  \nfloat  probabilityInput  =  input.float(0.5,  \"Success probability\",  0.0,  1.0)  \n//@variable The number of random trials to test.  \nfloat  trialsInput  =  input.int(10,  \"Trials\",  1)  \n  \n//@variable Random sample from a binomial distribution, i.e., the number of successes from `trialsInput` random trials.  \nint  sample  =  0  \n  \n// Execute `trialsInput` loop iterations to calculate the `sample`.  \nfor  trial  =  1  to  trialsInput  \n//@variable A pseudorandom value between 0 and 1.  \nfloat  randValue  =  math.random()  \n//@variable `true` if the `randValue` is less than or equal to the `probabilityInput`, `false` otherwise.  \nbool  success  =  randValue  <=  probabilityInput  \n// Skip the rest of the iteration if `success` is `false`.  \nif  not  success  \ncontinue  \n// Otherwise, add 1 to the `sample`.  \nsample  +=  1  \n  \n// Plot the `sample` as teal columns.  \nplot(sample,  \"Binomial sample\",  color.teal,  1,  plot.style_columns)  \n``\n\nBelow, we added  `log.*()`  function calls to generate  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  at specific points in the loop‚Äôs local block across iterations. Each loop iteration creates two new logs. The first log shows formatted text containing the local  `trial`,  `randValue`, and  `success`  variables‚Äô values. The second log depends on the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  statement. When the statement‚Äôs local code executes, the log is a  `\"CONTINUE\"`  message with the ‚Äúwarning‚Äù level. Otherwise, the second log is an ‚Äúinfo‚Äù message containing the current iteration‚Äôs  `sample`  value:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Inspecting-loops-Tracing-loop-executions-2.f9od3pWY_Z2l30GG.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Tracing loop executions demo\")  \n  \n//@variable The probability that each random trial succeeds.  \nfloat  probabilityInput  =  input.float(0.5,  \"Success probability\",  0.0,  1.0)  \n//@variable The number of random trials to test.  \nfloat  trialsInput  =  input.int(10,  \"Trials\",  1)  \n  \n//@variable Random sample from a binomial distribution, i.e., the number of successes from `trialsInput` random trials.  \nint  sample  =  0  \n  \n// Log a message to mark the point before the start of the loop.  \nlog.warning(\"---------------- LOOP START (bar {0,number,#})\",  bar_index)  \n  \n// Execute `trialsInput` loop iterations to calculate the `sample`.  \nfor  trial  =  1  to  trialsInput  \n//@variable A pseudorandom value between 0 and 1.  \nfloat  randValue  =  math.random()  \n//@variable `true` if the `randValue` is less than or equal to the `probabilityInput`, `false` otherwise.  \nbool  success  =  randValue  <=  probabilityInput  \n// Log a message containing the `trial`, `randValue`, and `success` information.  \nlog.info(\"trial: {0}, randValue: {1,number,#.########}, success: {2}\",  trial,  randValue,  success)  \n// Skip the rest of the iteration if `success` is `false`.  \nif  not  success  \n// Log a message before the `continue` statement.  \nlog.warning(\"CONTINUE\")  \ncontinue  \n// Otherwise, add 1 to the `sample`.  \nsample  +=  1  \n// Log a message showing the iteration's `sample` value.  \nlog.info(\"sample: {0}\",  sample)  \n  \n// Log a message to mark the point after the loop ends.  \nlog.warning(\"---------------- LOOP END\\n\\n\")  \n  \n// Plot the `sample` as teal columns.  \nplot(sample,  \"Binomial sample\",  color.teal,  1,  plot.style_columns)  \n``\n\nNote that:\n\n-   The script includes  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning)  calls before and after the loop to mark its start and end in the Pine Logs pane. The message marking the start of the loop also displays the current  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  value.\n-   The Pine Logs pane shows only the most recent 10,000 logs created on historical bars. Because this script creates multiple logs per bar, the earliest message in the pane is from less than 10,000 bars back. Programmers can use conditional logic that limits  `log.*()`  calls in order to inspect a loop‚Äôs execution flow on earlier bars with this technique. See the  [Custom code filters](https://www.tradingview.com/pine-script-docs/writing/debugging/#custom-code-filters)  section to learn more.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "color.blue",
      "log.info",
      "fun_log.info",
      "array.new",
      "str.tostring",
      "array.push",
      "barstate.isconfirmed",
      "label.new",
      "color.new",
      "array.first",
      "color.teal",
      "array.last",
      "color.maroon",
      "fun_label.new",
      "en.wikipedia",
      "math.random",
      "fun_math.random",
      "input.float",
      "i.e",
      "plot.style_columns",
      "log.warning",
      "fun_log.warning",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "method",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-382",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Debugging objects of  UDTs](https://www.tradingview.com/pine-script-docs/writing/debugging/#debugging-objects-of-udts)",
    "content": "### [Debugging  collections](https://www.tradingview.com/pine-script-docs/writing/debugging/#debugging-collections)\n\n[Collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  are data structures that store values or references as  _elements_, which scripts access using indices or keys, depending on the type. These structures can contain a lot of information, as the maximum number of elements across all instances of each collection type is 100,000.\n\nProgrammers can inspect a collection‚Äôs data using various techniques, depending on the types they contain and their sizes. The most common approaches include:\n\n-   Creating a ‚Äústring‚Äù representation of the collection with  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring)  and displaying the result using  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  or other text outputs.\n-   Retrieving specific elements from the collection, then creating  [formatted strings](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  for logging, or using the element values or references in other output processes.\n\n#### [Displaying collection  strings](https://www.tradingview.com/pine-script-docs/writing/debugging/#displaying-collection-strings)\n\nThe simplest way to inspect the data of  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  and  [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/)  of ‚Äúint‚Äù, ‚Äúfloat‚Äù, ‚Äúbool‚Äù, and ‚Äústring‚Äù types is to generate ‚Äústring‚Äù representations with the  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring)  function, then display the results using  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  or other ‚Äústring‚Äù outputs.\n\nThe following script calls  [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf)  to retrieve a ‚Äúfloat‚Äù  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  containing  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  prices for each lower-timeframe bar within the current chart bar, which it uses to calculate an average intrabar price. Then, it calculates the ratio of the difference between the bar‚Äôs price and the intrabar average to the bar‚Äôs total range. The script plots the resulting ratio and its EMA in a separate pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-collections-Displaying-collection-strings-1.C-bZsQtI_p3U9Y.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Displaying collection strings demo\")  \n  \n//@variable The length of the EMA.  \nint  lengthInput  =  input.int(20,  \"EMA length\",  1)  \n  \n//@variable An array of `close` prices requested for the chart's symbol at the 1-minute timeframe.  \narray<float> intrabarPrices  =  request.security_lower_tf(\"\",  \"1\",  close)  \n  \n//@variable The average `close` price of the intrabars within the current chart bar.  \nfloat  avgPrice  =  intrabarPrices.avg()  \n//@variable The bar's total range.  \nfloat  barRange  =  high  -  low  \n  \n//@variable The difference between `close` and `avgPrice`, normalized by the `barRange`.  \nfloat  ratio  = (close  -  avgPrice) /  barRange  \n//@variable The EMA of the `ratio`.  \nfloat  smoothed  =  ta.ema(ratio,  lengthInput)  \n  \n// Plot the `ratio` series as conditionally-colored columns.  \nplot(ratio,  \"\",  ratio  >  0  ?  color.teal  :  color.maroon,  1,  plot.style_columns)  \n// Display the `smoothed` series as a translucent orange area plot.  \nplot(smoothed,  \"\",  color.new(color.orange,  40),  1,  plot.style_area)  \n``\n\nTo verify the ratio‚Äôs calculations, we can inspect the data stored in the  `intrabarPrices`  array by converting it to a ‚Äústring‚Äù value and displaying the result for each bar.\n\nThe script version below declares a  `debugText`  variable that holds a  [formatted string](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  representing the  `intrabarPrices`  array, the array‚Äôs size, and the  `avgPrice`  value. The script calls the  `log.*()`  functions to display the  `debugText`  value for each bar in the  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  pane:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-collections-Displaying-collection-strings-2.DKihV-eb_Z159pA0.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Displaying collection strings demo\")  \n  \n//@variable The length of the EMA.  \nint  lengthInput  =  input.int(20,  \"EMA length\",  1)  \n  \n//@variable An array of `close` prices requested for the chart's symbol at the 1-minute timeframe.  \narray<float> intrabarPrices  =  request.security_lower_tf(\"\",  \"1\",  close)  \n  \n//@variable The average `close` price of the intrabars within the current chart bar.  \nfloat  avgPrice  =  intrabarPrices.avg()  \n//@variable The bar's total range.  \nfloat  barRange  =  high  -  low  \n  \n//@variable The difference between `close` and `avgPrice`, normalized by the `barRange`.  \nfloat  ratio  = (close  -  avgPrice) /  barRange  \n//@variable The EMA of the `ratio`.  \nfloat  smoothed  =  ta.ema(ratio,  lengthInput)  \n  \n// Plot the `ratio` series as conditionally-colored columns.  \nplot(ratio,  \"\",  ratio  >  0  ?  color.teal  :  color.maroon,  1,  plot.style_columns)  \n// Display the `smoothed` series as a translucent orange area plot.  \nplot(smoothed,  \"\",  color.new(color.orange,  40),  1,  plot.style_area)  \n  \n//@variable A \"string\" representation of `intrabarPrices`, `intrabarPrices.size()`, and the `avgPrice`.  \nstring  debugText  =  str.format(  \n\"\\nintrabarPrices: {0}\\nsize: {1}\\navgPrice: {2,number,#.#####}\",  \nstr.tostring(intrabarPrices),  intrabarPrices.size(),  avgPrice  \n)  \n  \n// Log the `debugText` with the \"info\" or \"warning\" level, depending on whether the bar is confirmed.  \nswitch  \nbarstate.isconfirmed  =>  log.info(debugText)  \n=>  log.warning(debugText)  \n``\n\nNote that:\n\n-   The script calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  on confirmed bars and  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning)  on the open bar. Users can  [filter](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)  the logs by  [logging level](https://www.tradingview.com/pine-script-docs/writing/debugging/#logging-level)  to inspect confirmed and unconfirmed bars‚Äô logs separately.\n-   For larger collections whose ‚Äústring‚Äù representations  _exceed_  40,960 characters or cause excessive memory use, programmers can split them into  _smaller parts_  and convert them to strings separately. Alternatively, they can inspect  [individual elements](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-individual-elements)  via the  `*.get()`  method or  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loops.\n\nTipIn contrast to  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  and  [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/)  of numeric values, Boolean values, or strings,  [maps](https://www.tradingview.com/pine-script-docs/language/maps/)  of such types  _do not_  have built-in ‚Äústring‚Äù representations. However, programmers can inspect a map‚Äôs contents with this technique by using  [map.keys()](https://www.tradingview.com/pine-script-reference/v6/#fun_map.keys)  and  [map.values()](https://www.tradingview.com/pine-script-reference/v6/#fun_map.values)  to retrieve  _key_  and  _value_  arrays, then calling  [str.tostring()](https://www.tradingview.com/pine-script-reference/v6/#fun_str.tostring)  to convert those arrays to ‚Äústring‚Äù values.\n\n#### [Inspecting individual  elements](https://www.tradingview.com/pine-script-docs/writing/debugging/#inspecting-individual-elements)\n\nCollections of ‚Äúcolor‚Äù or non-fundamental types (e.g.,  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels))  _do not_  have built-in ‚Äústring‚Äù representations. Consequently, the technique described in the  [Displaying collection strings](https://www.tradingview.com/pine-script-docs/writing/debugging/#displaying-collection-strings)  section does not work for them.\n\nTo inspect a collection that does not have a built-in ‚Äústring‚Äù format, programmers can retrieve elements individually within  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loops or using methods such as  `*.get()`, then use those elements in custom ‚Äústring‚Äù constructions or other output routines.\n\nConsider the following example, which calculates the ratio of  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  changes to the overall  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  range over  `lengthInput`  bars. It plots the resulting  `osc`  in a separate pane, and it draws a  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  on the main chart pane each time the variable‚Äôs absolute value is 1:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-collections-Inspecting-individual-elements-1.DejiM-hQ_X72Tr.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Inspecting individual elements demo\")  \n  \n//@variable The number of bars in the calculation.  \nint  lengthInput  =  input.int(20,  \"Length\",  2)  \n  \n//@variable The change in price across `lengthInput` - 1 bars.  \nfloat  priceChange  =  ta.change(close,  lengthInput  -  1)  \n//@variable The total `close` range over `lengthInput` bars.  \nfloat  priceRange  =  ta.range(close,  lengthInput)  \n  \n//@variable The ratio of the `priceChange` to the `priceRange`.  \nfloat  osc  =  priceChange  /  priceRange  \n  \n//@variable Teal if `osc` is positive, maroon otherwise.  \ncolor  oscColor  =  osc  >  0  ?  color.teal  :  color.maroon  \n  \n// Draw a label at the current bar's `bar_index` and `close` displaying `priceChange` when `osc` is 1 or -1.  \nif  math.abs(osc) ==  1  \nstring  labelText  =  str.format(\"priceChange: {0,number,#.####}\",  priceChange)  \nlabel.new(bar_index,  close,  labelText,  color  =  oscColor,  textcolor  =  color.white,  force_overlay  =  true)  \n  \n// Plot the `osc` using the `oscColor`.  \nplot(osc,  \"Oscillator\",  oscColor,  1,  plot.style_area)  \n``\n\nWhen a script creates  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels), it  _automatically_  maintains an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  containing each active label‚Äôs reference. Programmers can access this array using the  [label.all](https://www.tradingview.com/pine-script-reference/v6/#var_label.all)  variable, and thus inspect each individual label‚Äôs properties on any bar.\n\nIn the version below, the script executes a  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call to display the current  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  and the size of the  [label.all](https://www.tradingview.com/pine-script-reference/v6/#var_label.all)  array for the latest bar. Then, it iterates through the array with a  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop. On each iteration, the script calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  to log formatted text containing the array index and the corresponding label‚Äôs  `x`,  `y`, and  `text`  properties. Additionally, the script plots the oldest and newest active labels‚Äô y-coordinates on each bar:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-collections-Inspecting-individual-elements-2.CxLrVvEC_SozMo.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Inspecting individual elements demo\")  \n  \n//@variable The number of bars in the calculation.  \nint  lengthInput  =  input.int(20,  \"Length\",  2)  \n  \n//@variable The change in price across `lengthInput` - 1 bars.  \nfloat  priceChange  =  ta.change(close,  lengthInput  -  1)  \n//@variable The total `close` range over `lengthInput` bars.  \nfloat  priceRange  =  ta.range(close,  lengthInput)  \n  \n//@variable The ratio of the `priceChange` to the `priceRange`.  \nfloat  osc  =  priceChange  /  priceRange  \n  \n//@variable Teal if `osc` is positive, maroon otherwise.  \ncolor  oscColor  =  osc  >  0  ?  color.teal  :  color.maroon  \n  \n// Draw a label at the current bar's `bar_index` and `close` displaying `priceChange` when `osc` is 1 or -1.  \nif  math.abs(osc) ==  1  \nstring  labelText  =  str.format(\"priceChange: {0,number,#.####}\",  priceChange)  \nlabel.new(bar_index,  close,  labelText,  color  =  oscColor,  textcolor  =  color.white,  force_overlay  =  true)  \n  \n// Plot the `osc` using the `oscColor`.  \nplot(osc,  \"Oscillator\",  oscColor,  1,  plot.style_area)  \n  \n// On the first or last tick of the latest bar, inspect all labels on the chart.  \nif  barstate.islast  and (barstate.isnew  or  barstate.isconfirmed)  \n// Log a message containing the current `bar_index` and `label.all.size()`.  \nlog.info(\"Current bar: {0,number,#}, Active labels: {1}\",  bar_index,  label.all.size())  \n// Loop through the `label.all` array.  \nfor [i,  lbl] in  label.all  \n// Log a message containing the array index (`i`) and the label's `x`, `y`, and `text` properties.  \nlog.info(  \n\"{0}, x: {1,number,#}, y: {2,number,#.#####}, text: {3}\",  i,  lbl.get_x(),  lbl.get_y(),  lbl.get_text()  \n)  \n  \n// Initialize variables for the oldest and newest active labels.  \nlabel  oldestLabel  =  na  \nlabel  newestLabel  =  na  \n// Reassign the variables to the first and last labels in `label.all` when the array is not empty.  \nif  label.all.size() >  0  \noldestLabel  :=  label.all.first()  \nnewestLabel  :=  label.all.last()  \n  \n// Plot the y-coordinate history of the `oldestLabel` and `newestLabel`.  \nplot(label.get_y(oldestLabel),  \"oldestLabel y-coordinate\",  color.fuchsia,  force_overlay  =  true)  \nplot(label.get_y(newestLabel),  \"newestLabel y-coordinate\",  color.aqua,  force_overlay  =  true)  \n``\n\nNote that:\n\n-   It is not possible to obtain  _all_  properties from drawing objects. For example, there is no built-in method to retrieve a label‚Äôs color. Some other types, such as  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table), do not have  `*.get_*()`  methods. If an object‚Äôs properties are not directly accessible, programmers can create separate variables for the arguments of the drawing‚Äôs  `*.new()`  or  `*.set_*()`  function, and then use those variables for debugging.\n-   In the above image, the logs show that the  [label.all](https://www.tradingview.com/pine-script-reference/v6/#var_label.all)  array contains 55 elements. By default, Pine limits the number of labels to approximately 50, but the  _precise_  number of active labels varies. Programmers can increase the label drawing limit using the  `max_labels_count`  parameter of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement.",
    "keywords": [
      "www.tradingview",
      "str.tostring",
      "fun_str.tostring",
      "request.security_lower_tf",
      "fun_request.security_lower_tf",
      "tradingview.com",
      "input.int",
      "ta.ema",
      "color.teal",
      "color.maroon",
      "plot.style_columns",
      "color.new",
      "color.orange",
      "plot.style_area",
      "str.format",
      "barstate.isconfirmed",
      "log.info",
      "log.warning",
      "fun_log.info",
      "fun_log.warning",
      "map.keys",
      "fun_map.keys",
      "map.values",
      "fun_map.values",
      "e.g",
      "ta.change",
      "ta.range",
      "math.abs",
      "label.new",
      "color.white",
      "label.all",
      "var_label.all",
      "barstate.islast",
      "barstate.isnew",
      "lbl.get_x",
      "lbl.get_y",
      "lbl.get_text",
      "label.get_y",
      "color.fuchsia",
      "color.aqua",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "const",
      "method",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-383",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Organization and  readability](https://www.tradingview.com/pine-script-docs/writing/debugging/#organization-and-readability)",
    "content": "### [Debugging objects of  UDTs](https://www.tradingview.com/pine-script-docs/writing/debugging/#debugging-objects-of-udts)\n\n[User-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  define the structures of  [objects](https://www.tradingview.com/pine-script-docs/language/objects/). Objects contain a fixed set of  _fields_, where each field can hold a separate value or reference to another specified type, even to another instance of the  _same_  user-defined type.\n\nBecause UDT objects can organize values and references to an arbitrary number of various  _different_  types, Pine does not have a built-in method to convert UDT objects to strings. Instead, to debug these structures, programmers must retrieve data from each  _field_  that requires inspection.\n\nThe following example defines a custom  `Data`  type with three fields. The first two fields reference  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  that hold successive price and time values. The third field specifies the number of bars between each new data sample. The script creates a new object of this type with a randomized  `length`  field on the first bar, then updates its arrays on bars whose  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  values are divisible by that field.\n\nThe script uses  [array.covariance()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.covariance)  and  [array.variance()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.variance)  on the object‚Äôs  `prices`  and  `times`  arrays to calculate a time-based slope of the collected data, and then plots the result on the chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-objects-of-udts-1.BNdDHvUW_vOGtv.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Debugging objects of UDTs demo\")  \n  \n//@type A structure for storing time and price information once every `sampleMult` bars.  \n//@field prices References an array of \"float\" price values.  \n//@field times References an array of \"int\" UNIX timestamps.  \n//@field sampleMult Number of bars per sample.  \ntype  Data  \narray<float> prices  \narray<int> times  \nint  sampleMult  \n  \n//@variable The initial seed for the `math.random()` function.  \nint  seedInput  =  input.int(1234,  \"Seed\",  1)  \n  \n//@variable References a `Data` object with arrays of 10 elements and a pseudorandom `sampleMult` value.  \nvar  Data  data  =  Data.new(array.new<float>(10),  array.new<int>(10),  int(math.random(1,  11,  seedInput)))  \n  \n// Queue new data through the `prices` and `times` arrays of the `Data` object once every `data.sampleMult` bars.  \nif  bar_index  %  data.sampleMult  ==  0  \ndata.prices.push(close)  \ndata.times.push(time)  \ndata.prices.shift()  \ndata.times.shift()  \n  \n//@variable The time-based slope calculated from the `data` array fields.  \nfloat  slope  =  array.covariance(data.prices,  data.times) /  data.times.variance()  \n  \n// Plot the `slope` value.  \nplot(slope,  \"Slope\",  slope  >  0  ?  color.teal  :  color.maroon,  3)  \n``\n\nTo verify and understand the script‚Äôs calculations, we can  _extract_  information from the  `Data`  object‚Äôs  _fields_  and inspect the data with  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  or other outputs.\n\nThe script version below includes a  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  call inside the  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure. The call displays  [formatted text](https://www.tradingview.com/pine-script-docs/concepts/strings/#formatting-strings)  representing information from the  `Data`  object‚Äôs  `prices`,  `times`, and  `length`  fields in the Pine Logs pane. Now, we can view each change to the object‚Äôs data to confirm the script‚Äôs behavior:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Debugging-Tips-and-techniques-Debugging-objects-of-udts-2.DboJuwuM_Z1kAouY.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Debugging objects of UDTs demo\")  \n  \n//@type A structure for storing time and price information once every `sampleMult` bars.  \n//@field prices References an array of \"float\" price values.  \n//@field times References an array of \"int\" UNIX timestamps.  \n//@field sampleMult Number of bars per sample.  \ntype  Data  \narray<float> prices  \narray<int> times  \nint  sampleMult  \n  \n//@variable The initial seed for the `math.random()` function.  \nint  seedInput  =  input.int(1234,  \"Seed\",  1)  \n  \n//@variable References a `Data` object with arrays of 10 elements and a pseudorandom `sampleMult` value.  \nvar  Data  data  =  Data.new(array.new<float>(10),  array.new<int>(10),  int(math.random(1,  11,  seedInput)))  \n  \n// Queue new data through the `prices` and `times` arrays of the `Data` object once every `data.sampleMult` bars.  \nif  bar_index  %  data.sampleMult  ==  0  \ndata.prices.push(close)  \ndata.times.push(time)  \ndata.prices.shift()  \ndata.times.shift()  \n  \n// Log formatted text containing information from the `Data` object's `prices`, `times`, and `sampleMult`  \n// fields with the \"info\" or \"warning\" level.  \nstring  fString  =  \"Data object fields:\\n\\nprices: {0}\\n\\ntimes: {1}\\n\\nsampleMult: {2}\\n-------\"  \nswitch  \nbarstate.isconfirmed  =>  log.info(fString,  str.tostring(data.prices),  str.tostring(data.times),  data.sampleMult)  \n=>  log.warning(fString,  str.tostring(data.prices),  str.tostring(data.times),  data.sampleMult)  \n  \n//@variable The time-based slope calculated from the `data` array fields.  \nfloat  slope  =  array.covariance(data.prices,  data.times) /  data.times.variance()  \n  \n// Plot the `slope` value.  \nplot(slope,  \"Slope\",  slope  >  0  ?  color.teal  :  color.maroon,  3)  \n``\n\nNote that:\n\n-   The script calls  [log.info()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.info)  on confirmed bars and  [log.warning()](https://www.tradingview.com/pine-script-reference/v6/#fun_log.warning)  on open bars, allowing users to  [filter](https://www.tradingview.com/pine-script-docs/writing/debugging/#filtering-logs)  the results by  [logging level](https://www.tradingview.com/pine-script-docs/writing/debugging/#logging-level)  in the Pine Logs pane.",
    "keywords": [
      "www.tradingview",
      "array.covariance",
      "fun_array.covariance",
      "array.variance",
      "fun_array.variance",
      "tradingview.com",
      "math.random",
      "input.int",
      "array.new",
      "data.sample",
      "data.prices",
      "data.times",
      "color.teal",
      "color.maroon",
      "log.info",
      "fun_log.info",
      "barstate.isconfirmed",
      "str.tostring",
      "log.warning",
      "fun_log.warning",
      "indicator",
      "input",
      "plot",
      "var",
      "method",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-384",
    "type": "documentation",
    "source": "writing_scripts/debugging.md",
    "section": "writing_scripts",
    "title": "[Organization and  readability](https://www.tradingview.com/pine-script-docs/writing/debugging/#organization-and-readability)",
    "content": "### [Organization and  readability](https://www.tradingview.com/pine-script-docs/writing/debugging/#organization-and-readability)\n\nSource code that is organized and easy to read is typically simpler to debug. Furthermore, well-written code is more straightforward for programmers to maintain and improve over time. Therefore, we recommend prioritizing organization and readability throughout the script-writing process, especially while debugging.\n\nBelow are a few helpful coding recommendations based on our  [Style guide](https://www.tradingview.com/pine-script-docs/writing/style-guide/)  and best practices:\n\n-   Follow the  [script organization](https://www.tradingview.com/pine-script-docs/writing/style-guide/#script-organization)  guidelines. Organizing scripts based on this structure makes different parts of the code simple to locate and inspect.\n-   Use  _identifiers_  that you can read, distinguish, and understand. When a code contains unclear identifiers, it is often harder to debug efficiently. See our  [Naming conventions](https://www.tradingview.com/pine-script-docs/writing/style-guide/#naming-conventions)  to learn our recommended identifier format.\n-   Use  _type keywords_  to signify the qualified types that variables and parameters can accept. Although Pine can usually  _infer_  variable and parameter types, declaring them explicitly improves readability and helps programmers distinguish between assignment and reassignment operations. Plus, it enables Pine‚Äôs autosuggest feature to display more relevant type-based suggestions.\n-   Document the code using comments and  [compiler annotations](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations)  (`//@function`,  `//@variable`, etc.). The Pine Editor‚Äôs autosuggest displays the text from annotations when the mouse pointer hovers over identifiers, making it simple to recall what different parts of the code represent.",
    "keywords": [
      "www.tradingview",
      "var",
      "simple",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-385",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Loop  execution](https://www.tradingview.com/pine-script-docs/writing/limitations/#loop-execution)",
    "content": "# [Limitations](https://www.tradingview.com/pine-script-docs/writing/limitations/#limitations)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/writing/limitations/#introduction)\n\nAs is mentioned in our  [Welcome](https://www.tradingview.com/pine-script-docs/welcome/)  page:\n\n> _Because each script uses computational resources in the cloud, we must impose limits in order to share these resources fairly among our users. We strive to set as few limits as possible, but will of course have to implement as many as needed for the platform to run smoothly. Limitations apply to the amount of data requested from additional symbols, execution time, memory usage and script size._\n\nIf you develop complex scripts using Pine Script¬Æ, sooner or later you will run into some of the limitations we impose. This section provides you with an overview of the limitations that you may encounter. There are currently no means for Pine Script programmers to get data on the resources consumed by their scripts. We hope this will change in the future.\n\nIn the meantime, when you are considering large projects, it is safest to make a proof of concept in order to assess the probability of your script running into limitations later in your project.\n\nBelow, we describe the limits imposed in the Pine Script environment.\n\n## [Time](https://www.tradingview.com/pine-script-docs/writing/limitations/#time)\n\n### [Script  compilation](https://www.tradingview.com/pine-script-docs/writing/limitations/#script-compilation)\n\nScripts must compile before they are executed on charts. Compilation occurs when you save a script from the Pine Editor or when you add a script to the chart. A two-minute limit is imposed on compilation time, which will depend on the size and complexity of your script, and whether or not a cached version of a previous compilation is available. When a compile exceeds the two-minute limit, a warning is issued. Heed that warning by shortening your script because after three consecutive warnings a one-hour ban on compilation attempts is enforced. The first thing to consider when optimizing code is to avoid repetitions by using functions to encapsulate oft-used segments, and call functions instead of repeating code.\n\n### [Script  execution](https://www.tradingview.com/pine-script-docs/writing/limitations/#script-execution)\n\nOnce a script is compiled it can be executed. See the  [Events that trigger script executions](https://www.tradingview.com/pine-script-docs/language/execution-model/#events-that-trigger-script-executions)  section of the  [Execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/)  page for a list of the events triggering the execution of a script. The time allotted for the script to execute on all bars of a dataset varies with account types. The limit is 20 seconds for basic accounts, 40 for others.",
    "keywords": [
      "www.tradingview",
      "size._",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-386",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Plot  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#plot-limits)",
    "content": "### [Loop  execution](https://www.tradingview.com/pine-script-docs/writing/limitations/#loop-execution)\n\nThe execution time for any loop on any single bar is limited to 500 milliseconds. The outer loop of embedded loops counts as one loop, so it will time out first. Keep in mind that even though a loop may execute under the 500 ms time limit on a given bar, the time it takes to execute on all the dataset‚Äôs bars may nonetheless cause your script to exceed the total execution time limit. For example, the limit on total execution time will make it impossible for you script to execute a 400 ms loop on each bar of a 20,000-bar dataset because your script would then need 8000 seconds to execute.\n\n## [Chart  visuals](https://www.tradingview.com/pine-script-docs/writing/limitations/#chart-visuals)",
    "keywords": [
      "www.tradingview",
      "for"
    ]
  },
  {
    "id": "doc-387",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Line, box, polyline, and label  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#line-box-polyline-and-label-limits)",
    "content": "### [Plot  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#plot-limits)\n\nA maximum of 64 plot counts are allowed per script. The functions that generate plot counts are:\n\n-   [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)\n-   [plotarrow()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotarrow)\n-   [plotbar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotbar)\n-   [plotcandle()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotcandle)\n-   [plotchar()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotchar)\n-   [plotshape()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotshape)\n-   [alertcondition()](https://www.tradingview.com/pine-script-reference/v6/#fun_alertcondition)\n-   [bgcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_bgcolor)\n-   [barcolor()](https://www.tradingview.com/pine-script-reference/v6/#fun_barcolor)\n-   [fill()](https://www.tradingview.com/pine-script-reference/v6/#fun_fill), but only if its  `color`  is of the  [series](https://www.tradingview.com/pine-script-reference/v6/#type_series)  form.\n\nThe following functions do not generate plot counts:\n\n-   [hline()](https://www.tradingview.com/pine-script-reference/v6/#fun_hline)\n-   [line.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_line%7Bdot%7Dnew)\n-   [label.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_label%7Bdot%7Dnew)\n-   [table.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_table%7Bdot%7Dnew)\n-   [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box%7Bdot%7Dnew)\n\nOne function call can generate up to seven plot counts, depending on the function and how it is called. When your script exceeds the maximum of 64 plot counts, the runtime error message will display the plot count generated by your script. Once you reach that point, you can determine how many plot counts a function call generates by commenting it out in a script. As long as your script still throws an error, you will be able to see how the actual plot count decreases after you have commented out a line.\n\nThe following example shows different function calls and the number of plot counts each one will generate:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n```//@version=6  \nindicator(\"Plot count example\")  \n  \nbool  isUp  =  close  >  open  \ncolor  isUpColor  =  isUp  ?  color.green  :  color.red  \nbool  isDn  =  not  isUp  \ncolor  isDnColor  =  isDn  ?  color.red  :  color.green  \n  \n// Uses one plot count each.  \np1  =  plot(close,  color  =  color.white)  \np2  =  plot(open,  color  =  na)  \n  \n// Uses two plot counts for the `close` and `color` series.  \nplot(close,  color  =  isUpColor)  \n  \n// Uses one plot count for the `close` series.  \nplotarrow(close,  colorup  =  color.green,  colordown  =  color.red)  \n  \n// Uses two plot counts for the `close` and `colorup` series.  \nplotarrow(close,  colorup  =  isUpColor)  \n  \n// Uses three plot counts for the `close`, `colorup`, and the `colordown` series.  \nplotarrow(close  -  open,  colorup  =  isUpColor,  colordown  =  isDnColor)  \n  \n// Uses four plot counts for the `open`, `high`, `low`, and `close` series.  \nplotbar(open,  high,  low,  close,  color  =  color.white)  \n  \n// Uses five plot counts for the `open`, `high`, `low`, `close`, and `color` series.  \nplotbar(open,  high,  low,  close,  color  =  isUpColor)  \n  \n// Uses four plot counts for the `open`, `high`, `low`, and `close` series.  \nplotcandle(open,  high,  low,  close,  color  =  color.white,  wickcolor  =  color.white,  bordercolor  =  color.purple)  \n  \n// Uses five plot counts for the `open`, `high`, `low`, `close`, and `color` series.  \nplotcandle(open,  high,  low,  close,  color  =  isUpColor,  wickcolor  =  color.white,  bordercolor  =  color.purple)  \n  \n// Uses six plot counts for the `open`, `high`, `low`, `close`, `color`, and `wickcolor` series.  \nplotcandle(open,  high,  low,  close,  color  =  isUpColor,  wickcolor  =  isUpColor  ,  bordercolor  =  color.purple)  \n  \n// Uses seven plot counts for the `open`, `high`, `low`, `close`, `color`, `wickcolor`, and `bordercolor` series.  \nplotcandle(open,  high,  low,  close,  color  =  isUpColor,  wickcolor  =  isUpColor  ,  bordercolor  =  isUp  ?  color.lime  :  color.maroon)  \n  \n// Uses one plot count for the `close` series.  \nplotchar(close,  color  =  color.white,  text  =  \"|\",  textcolor  =  color.white)  \n  \n// Uses two plot counts for the `close`` and `color` series.  \nplotchar(close,  color  =  isUpColor,  text  =  \"‚Äî\",  textcolor  =  color.white)  \n  \n// Uses three plot counts for the `close`, `color`, and `textcolor` series.  \nplotchar(close,  color  =  isUpColor,  text  =  \"O\",  textcolor  =  isUp  ?  color.yellow  :  color.white)  \n  \n// Uses one plot count for the `close` series.  \nplotshape(close,  color  =  color.white,  textcolor  =  color.white)  \n  \n// Uses two plot counts for the `close` and `color` series.  \nplotshape(close,  color  =  isUpColor,  textcolor  =  color.white)  \n  \n// Uses three plot counts for the `close`, `color`, and `textcolor` series.  \nplotshape(close,  color  =  isUpColor,  textcolor  =  isUp  ?  color.yellow  :  color.white)  \n  \n// Uses one plot count.  \nalertcondition(close  >  open,  \"close > open\",  \"Up bar alert\")  \n  \n// Uses one plot count.  \nbgcolor(isUp  ?  color.yellow  :  color.white)  \n  \n// Uses one plot count for the `color` series.  \nfill(p1,  p2,  color  =  isUpColor)  \n```\n\nThis example generates a plot count of 56. If we were to add two more instances of the last call to  [plotcandle()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotcandle), the script would throw an error stating that the script now uses 70 plot counts, as each additional call to  [plotcandle()](https://www.tradingview.com/pine-script-reference/v6/#fun_plotcandle)  generates seven plot counts, and 56 + (7 * 2) is 70.",
    "keywords": [
      "www.tradingview",
      "line.new",
      "label.new",
      "table.new",
      "box.new",
      "tradingview.com",
      "color.green",
      "color.red",
      "color.white",
      "color.purple",
      "color.lime",
      "color.maroon",
      "color.yellow",
      "indicator",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "barcolor",
      "alert",
      "alertcondition",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-388",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Table  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#table-limits)",
    "content": "### [Line, box, polyline, and label  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#line-box-polyline-and-label-limits)\n\nContrary to  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/), which can cover the chart‚Äôs entire dataset, scripts will only show the last 50  [lines](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#lines),  [boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#boxes),  [polylines](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#polylines), and  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  on the chart by default. One can increase the maximum number for each of these  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  via the  `max_lines_count`,  `max_boxes_count`,  `max_polylines_count`, and  `max_labels_count`  parameters of the script‚Äôs  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement. The maximum number of  [line](https://www.tradingview.com/pine-script-reference/v6/#type_line),  [box](https://www.tradingview.com/pine-script-reference/v6/#type_box), and  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  IDs is 500, and the maximum number of  [polyline](https://www.tradingview.com/pine-script-reference/v6/#type_polyline)  IDs is 100.\n\nIn this example, we set the maximum number of recent labels shown on the chart to 100:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Label limits example\",  max_labels_count  =  100,  overlay  =  true)  \nlabel.new(bar_index,  high,  str.tostring(high,  format.mintick))  \n`\n\nIt‚Äôs important to note when setting any of a drawing object‚Äôs properties to  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  that its ID still exists and thus contributes to a script‚Äôs drawing totals. To demonstrate this behavior, the following script draws a ‚ÄúBuy‚Äù and ‚ÄúSell‚Äù  [label](https://www.tradingview.com/pine-script-reference/v6/#type_label)  on each bar, with  `x`  values determined by the  `longCondition`  and  `shortCondition`  variables.\n\nThe ‚ÄúBuy‚Äù label‚Äôs  `x`  value is  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  when the bar index is even, and the ‚ÄúSell‚Äù label‚Äôs  `x`  value is  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  when the bar index is odd. Although the  `max_labels_count`  is 10 in this example, we can see that the script displays fewer than 10  [labels](https://www.tradingview.com/pine-script-docs/visuals/text-and-shapes/#labels)  on the chart since the ones with  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  values also count toward the total:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Limitations-LabelsWithNa-1.BrXz3MoQ_2600rs.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \n  \n// Approximate maximum number of label drawings  \nMAX_LABELS  =  10  \n  \nindicator(\"labels with na\",  overlay  =  false,  max_labels_count  =  MAX_LABELS)  \n  \n// Add background color for the last MAX_LABELS bars.  \nbgcolor(bar_index  >  last_bar_index  -  MAX_LABELS  ?  color.new(color.green,  80) :  na)  \n  \nlongCondition  =  bar_index  %  2  !=  0  \nshortCondition  =  bar_index  %  2  ==  0  \n  \n// Add \"Buy\" and \"Sell\" labels on each new bar.  \nlabel.new(longCondition  ?  bar_index  :  na,  0,  text  =  \"Buy\",  color  =  color.new(color.green,  0),  style  =  label.style_label_up)  \nlabel.new(shortCondition  ?  bar_index  :  na,  0,  text  =  \"Sell\",  color  =  color.new(color.red,  0),  style  =  label.style_label_down)  \n  \nplot(longCondition  ?  1  :  0)  \nplot(shortCondition  ?  1  :  0)  \n`\n\nTo display the desired number of labels, we must eliminate label drawings we don‚Äôt want to show rather than setting their properties to  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na). The example below uses an  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure to conditionally draw the ‚ÄúBuy‚Äù and ‚ÄúSell‚Äù labels, preventing the script from creating new label IDs when it isn‚Äôt necessary:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Limitations-LabelsWithNa-2.CiofVUZK_2oXzgA.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \n  \n// Approximate maximum number of label drawings  \nMAX_LABELS  =  10  \n  \nindicator(\"conditional labels\",  overlay  =  false,  max_labels_count  =  MAX_LABELS)  \n  \n// Add background color for the last MAX_LABELS bars.  \nbgcolor(bar_index  >  last_bar_index  -  MAX_LABELS  ?  color.new(color.green,  80) :  na)  \n  \nlongCondition  =  bar_index  %  2  !=  0  \nshortCondition  =  bar_index  %  2  ==  0  \n  \n// Add a \"Buy\" label when `longCondition` is true.  \nif  longCondition  \nlabel.new(bar_index,  0,  text  =  \"Buy\",  color  =  color.new(color.green,  0),  style  =  label.style_label_up)  \n// Add a \"Sell\" label when `shortCondition` is true.  \nif  shortCondition  \nlabel.new(bar_index,  0,  text  =  \"Sell\",  color  =  color.new(color.red,  0),  style  =  label.style_label_down)  \n  \nplot(longCondition  ?  1  :  0)  \nplot(shortCondition  ?  1  :  0)  \n``",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "label.new",
      "str.tostring",
      "format.mintick",
      "color.new",
      "color.green",
      "label.style_label_up",
      "color.red",
      "label.style_label_down",
      "indicator",
      "strategy",
      "overlay",
      "plot",
      "bgcolor",
      "var",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-389",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Number of  calls](https://www.tradingview.com/pine-script-docs/writing/limitations/#number-of-calls)",
    "content": "### [Table  limits](https://www.tradingview.com/pine-script-docs/writing/limitations/#table-limits)\n\nScripts can display a maximum of nine  [tables](https://www.tradingview.com/pine-script-docs/visuals/tables/)  on the chart, one for each of the possible locations:  [position.bottom_center](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dbottom_center),  [position.bottom_left](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dbottom_left),  [position.bottom_right](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dbottom_right),  [position.middle_center](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dmiddle_center),  [position.middle_left](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dmiddle_left),  [position.middle_right](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dmiddle_right),  [position.top_center](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dtop_center),  [position.top_left](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dtop_left), and  [position.top_right](https://www.tradingview.com/pine-script-reference/v6/#const_position%7Bdot%7Dtop_right). When attempting to place two tables in the same location, only the newest instance will show on the chart.\n\n## [‚Äã`request.*()`‚Äã calls](https://www.tradingview.com/pine-script-docs/writing/limitations/#request-calls)",
    "keywords": [
      "www.tradingview",
      "position.bottom_center",
      "position.bottom_left",
      "position.bottom_right",
      "position.middle_center",
      "position.middle_left",
      "position.middle_right",
      "position.top_center",
      "position.top_left",
      "position.top_right",
      "const",
      "for"
    ]
  },
  {
    "id": "doc-390",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Intrabars](https://www.tradingview.com/pine-script-docs/writing/limitations/#intrabars)",
    "content": "### [Number of  calls](https://www.tradingview.com/pine-script-docs/writing/limitations/#number-of-calls)\n\nA script can use up to 40  _unique_  calls to the functions in the  `request.*()`  namespace, or up to 64 unique calls if the user has the  [Ultimate plan](https://www.tradingview.com/pricing/). A subsequent call to the same  `request.*()`  function with the same arguments is not typically unique. This limitation applies when using any  `request.*()`  functions, including:\n\n-   [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)\n-   [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf)\n-   [request.currency_rate()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.currency_rate)\n-   [request.dividends()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.dividends)\n-   [request.splits()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.splits)\n-   [request.earnings()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.earnings)\n-   [request.quandl()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.quandl)\n-   [request.financial()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.financial)\n-   [request.economic()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.economic)\n-   [request.seed()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.seed)\n\nWhen a script executes two or more identical  `request.*()`  function calls, only the  _first_  call usually counts toward this limit. The repeated calls do not count because they  _reuse_  the data from the first call rather than executing a redundant request. Note that when a script imports  [library](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  functions containing  `request.*()`  calls within their scopes, those calls  **do**  count toward this limit, even if the script already calls the same  `request.*()`  function with the same arguments in its main scope.\n\nThe script below calls  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  with the same arguments 50 times within a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop. Although the script contains more than 40  `request.*()`  calls, it  _does not_  raise an error because each call is  **identical**. In this case, it reuses the data from the first iteration‚Äôs  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call for the repeated calls on all subsequent iterations:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"`request.*()` call limit demo\")  \n  \n//@variable The sum of values requested from all `request.security()` calls.  \nfloat  reqSum  =  0.0  \n  \n// Call `request.security()` 50 times within a loop.  \n// More than 40 `request.*()` calls occur, but each call is identical. Redundant calls do not count toward the limit.  \nfor  i  =  1  to  50  \nreqSum  +=  request.security(syminfo.tickerid,  \"1D\",  close)  \n  \nplot(reqSum)  \n``\n\nHere, we modified the above script to call  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  with a different  `timeframe`  argument on each iteration, meaning all 50 calls are now  **unique**. This time, the script will reach the  `request.*()`  call limit while executing the loop and raise a runtime error because it requests a  _distinct_  dataset on each iteration:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"`request.*()` call limit demo\")  \n  \n//@variable The sum of values requested from all `request.security()` calls.  \nfloat  reqSum  =  0.0  \n  \n// Call `request.security()` 50 times within a loop with different `timeframe` arguments.  \n// This loop causes a runtime error when `i == 41` because each iteration executes a unique request.  \nfor  i  =  1  to  50  \nreqSum  +=  request.security(syminfo.tickerid,  str.tostring(i),  close)  \n  \nplot(reqSum)  \n``\n\nNote that:\n\n-   These example scripts can call  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  within a loop and allow ‚Äúseries string‚Äù  `timeframe`  arguments because Pine v6 scripts enable dynamic requests by default. See  [this section](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#dynamic-requests)  of the  [Other timeframes and data](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data)  page for more information.",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "request.security_lower_tf",
      "fun_request.security_lower_tf",
      "request.currency_rate",
      "fun_request.currency_rate",
      "request.dividends",
      "fun_request.dividends",
      "request.splits",
      "fun_request.splits",
      "request.earnings",
      "fun_request.earnings",
      "request.quandl",
      "fun_request.quandl",
      "request.financial",
      "fun_request.financial",
      "request.economic",
      "fun_request.economic",
      "request.seed",
      "fun_request.seed",
      "tradingview.com",
      "syminfo.tickerid",
      "str.tostring",
      "indicator",
      "plot",
      "var",
      "series",
      "import",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-391",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Tuple element  limit](https://www.tradingview.com/pine-script-docs/writing/limitations/#tuple-element-limit)",
    "content": "### [Intrabars](https://www.tradingview.com/pine-script-docs/writing/limitations/#intrabars)\n\nScripts can retrieve up to the most recent 200,000  _intrabars_  (lower-timeframe bars) via the  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  or  [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf)  functions, depending on the user‚Äôs plan:\n\n-   All non-professional plans ‚Äî Basic, Essential, Plus, and Premium ‚Äî can request up to 100K bars of data.\n-   Expert plans have access to 125K bars of data.\n-   Ultimate plans can request 200K lower-timeframe bars.\n\nThe  `calc_bars_count`  parameter of the  `request.*()`  functions limits the intrabar data retrieved by a request. If a  `request.*()`  call does not include a  `calc_bars_count`  argument, the number of requested bars is the same as the number of  [chart bars](https://www.tradingview.com/pine-script-docs/writing/limitations/#chart-bars)  available for the symbol and timeframe. Otherwise, the function retrieves up to the specified number of bars, depending on the span of the dataset. The largest possible number of bars in the request depends on the limits listed above.\n\nThe number of bars on the chart‚Äôs timeframe covered by a lower-timeframe request varies with the number of intrabars available for each chart bar. For example, if a script running on a 60-minute chart uses a  `request.*()`  call that requests data from the 1-minute timeframe, that call can retrieve data for up to 60 intrabars per chart bar. If the call uses the argument  `calc_bars_count = 100000`, the minimum number of chart bars covered by the request is 1666, because 100000 / 60 = 1666.67. However, it‚Äôs important to note that a that a provider might not report data for  _every_  minute within an hour. Therefore, such a request might cover more chart bars, depending on the available data.",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "request.security_lower_tf",
      "fun_request.security_lower_tf",
      "var",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-392",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Compiled  tokens](https://www.tradingview.com/pine-script-docs/writing/limitations/#compiled-tokens)",
    "content": "### [Tuple element  limit](https://www.tradingview.com/pine-script-docs/writing/limitations/#tuple-element-limit)\n\nAll the  `request.*()`  function calls in a script taken together cannot return more than 127 tuple elements. When the combined tuple size of all  `request.*()`  calls will exceed 127 elements, one can instead utilize  [user-defined types (UDTs)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  to request a greater number of values.\n\nThe example below outlines this limitation and the way to work around it. The first  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call represents using a tuple with 128 elements as the  `expression`  argument. Since the number of elements is greater than 127, it would result in an error.\n\nTo avoid the error, we can use those same values as  _fields_  within an  [object](https://www.tradingview.com/pine-script-docs/language/objects/)  of a  [UDT](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  and pass its ID to the  `expression`  instead:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Tuple element limit\")  \n  \ns1  =  close  \ns2  =  close  *  2  \n...  \ns128  =  close  *  128  \n  \n// Causes an error.  \n[v1,  v2,  v3, ..., v128] =  request.security(syminfo.tickerid,  \"1D\", [s1,  s2,  s3, ..., s128])  \n  \n// Works fine:  \ntype  myType  \nfloat  v1  \nfloat  v2  \nfloat  v3  \n...  \nfloat  v128  \n  \nmyObj  =  request.security(syminfo.tickerid,  \"1D\",  myType.new(s1,  s2,  s3, ..., s128))  \n`\n\nNote that:\n\n-   This example outlines a scenario where the script tries to evaluate 128 tuple elements in a single  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call. The same limitation applies if we were to split the tuple request across  _multiple_  calls. For example, two  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  calls that each retrieve a tuple with 64 elements will also cause an error.\n\n## [Script size and  memory](https://www.tradingview.com/pine-script-docs/writing/limitations/#script-size-and-memory)",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "tradingview.com",
      "syminfo.tickerid",
      "indicator",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-393",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Variables per  scope](https://www.tradingview.com/pine-script-docs/writing/limitations/#variables-per-scope)",
    "content": "### [Compiled  tokens](https://www.tradingview.com/pine-script-docs/writing/limitations/#compiled-tokens)\n\nBefore the execution of a script, the compiler translates it into a tokenized  _Intermediate Language_  (IL). Using an IL allows Pine Script to accommodate larger scripts by applying various memory and performance optimizations. The compiler determines the size of a script based on the  _number of tokens_  in its IL form,  **not**  the number of characters or lines in the code viewable in the Pine Editor.\n\nThe compiled form of each indicator, strategy, and library script is limited to 100,000 tokens. If a script imports libraries, the total number of tokens from all imported libraries cannot exceed 1 million. There is no way to inspect a script‚Äôs compiled form, nor its IL token count. As such, you will only know your script exceeds the size limit when the compiler reaches it.\n\nIn most cases, a script‚Äôs compiled size will likely not reach the limit. However, if a compiled script does reach the token limit, the most effective ways to decrease compiled tokens are to reduce repetitive code, encapsulate redundant calls within functions, and utilize  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  when possible.\n\nIt‚Äôs important to note that the compilation process omits any  _unused_  variables, functions, types, etc. from the final IL form, where ‚Äúunused‚Äù refers to anything that  _does not_  affect the script‚Äôs outputs. This optimization prevents superfluous elements in the code from contributing to the script‚Äôs IL token count.\n\nFor example, the script below declares a  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  and a  [user-defined method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  and defines a sequence of calls using them:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"My Script\")  \nplot(close)  \n  \ntype  myType  \nfloat  field  =  10.0  \n  \nmethod  m(array<myType> a,  myType  v) =>  \na.push(v)  \n  \nvar  arr  =  array.new<myType>()  \narr.push(myType.new(25))  \narr.m(myType.new())  \n`\n\nDespite the inclusion of  `array.new<myType>()`,  `myType.new()`, and  `arr.m()`  calls in the script, the only thing actually  **output**  by the script is  `plot(close)`. The rest of the code does not affect the output. Therefore, the compiled form of this script will have the  _same_  number of tokens as:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"My Script\")  \nplot(close)  \n`",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "a.push",
      "array.new",
      "arr.push",
      "arr.m",
      "indicator",
      "strategy",
      "plot",
      "var",
      "import",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-394",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Maximum bars  back](https://www.tradingview.com/pine-script-docs/writing/limitations/#maximum-bars-back)",
    "content": "### [Variables per  scope](https://www.tradingview.com/pine-script-docs/writing/limitations/#variables-per-scope)\n\nScripts can contain up to 1,000 variables in each of its scopes. Pine scripts always contain one global scope, represented by non-indented code, and they may contain zero or more local scopes. Local scopes are sections of indented code representing procedures executed within  [functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  and  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods), as well as  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if),  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch),  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for),  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in), and  [while](https://www.tradingview.com/pine-script-reference/v6/#kw_while)  structures, which allow for one or more local blocks. Each local block counts as one local scope.\n\nThe branches of a conditional expression using the  [?:](https://www.tradingview.com/pine-script-reference/v6/#op_%7Bquestion%7D%7Bcolon%7D)  ternary operator do not count as local blocks.\n\n### [Compilation request  size](https://www.tradingview.com/pine-script-docs/writing/limitations/#compilation-request-size)\n\nThe size of the compilation request for a script cannot exceed 5MB. The compilation request is all of the information that is sent to the compiler. This information comprises the script itself and any libraries the script imports.\n\nUnlike the limit for compiled tokens, the request size limit includes unused parts of code. This is because the script is not compiled yet, so any unused code has not yet been optimized out.\n\nTo reduce the compilation request size, you can:\n\n-   Reduce the size of the script by optimizing the code.\n-   Reduce the number of script inputs (script inputs are counted separately).\n-   Remove any imported libraries that are not needed.\n-   Use smaller libraries. The entire library is sent for compilation, regardless of which functions are called.\n\n### [Collections](https://www.tradingview.com/pine-script-docs/writing/limitations/#collections)\n\nPine Script collections ([arrays](https://www.tradingview.com/pine-script-docs/language/arrays/),  [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/), and  [maps](https://www.tradingview.com/pine-script-docs/language/maps/)) can have a maximum of 100,000 elements. Each key-value pair in a map contains two elements, meaning  [maps](https://www.tradingview.com/pine-script-docs/language/maps/)  can contain a maximum of 50,000 key-value pairs.\n\n## [Other  limitations](https://www.tradingview.com/pine-script-docs/writing/limitations/#other-limitations)",
    "keywords": [
      "www.tradingview",
      "input",
      "var",
      "import",
      "method",
      "switch",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-395",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Maximum bars  forward](https://www.tradingview.com/pine-script-docs/writing/limitations/#maximum-bars-forward)",
    "content": "### [Maximum bars  back](https://www.tradingview.com/pine-script-docs/writing/limitations/#maximum-bars-back)\n\nReferences to past values using the  [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D)  [history-referencing operator](https://www.tradingview.com/pine-script-docs/language/operators/#-history-referencing-operator)  are dependent on the size of the  [historical buffer](https://www.tradingview.com/pine-script-docs/language/execution-model/#historical-buffers)  maintained by the Pine Script runtime, which is limited to a maximum of 5000 bars for most series. Some built-in series like  [open](https://www.tradingview.com/pine-script-reference/v6/#var_open),  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high),  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low),  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close), and  [time](https://www.tradingview.com/pine-script-reference/v6/#var_time)  have larger historical buffers that can reference up to 10,000 bars.\n\nIf a script references values beyond the historical buffer‚Äôs limit, it causes a runtime error. For more information about this error, refer to  [this section](https://www.tradingview.com/pine-script-docs/error-messages/#the-requested-historical-offset-x-is-beyond-the-historical-buffers-limit-y)  of the  [Error messages](https://www.tradingview.com/pine-script-docs/error-messages/)  page, which discusses the historical buffer and how to change its size using either the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function or the  `max_bars_back`  parameter of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  or  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement.\n\nDrawings using  [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_index)  can be positioned a maximum of 10,000 bars in the past.",
    "keywords": [
      "www.tradingview",
      "xloc.bar_index",
      "const_xloc.bar_index",
      "indicator",
      "strategy",
      "var",
      "series",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-396",
    "type": "documentation",
    "source": "writing_scripts/limitations.md",
    "section": "writing_scripts",
    "title": "[Trade orders in  backtesting](https://www.tradingview.com/pine-script-docs/writing/limitations/#trade-orders-in-backtesting)",
    "content": "### [Maximum bars  forward](https://www.tradingview.com/pine-script-docs/writing/limitations/#maximum-bars-forward)\n\nWhen positioning drawings using  [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v6/#const_xloc.bar_index), it is possible to use bar index values greater than that of the current bar as  _x_  coordinates. A maximum of 500 bars in the future can be referenced.\n\nThis example shows how we use the  `maxval`  parameter in our  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input%7Bdot%7Dint)  function call to cap the user-defined number of bars forward we draw a projection line so that it never exceeds the limit:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Max bars forward example\",  overlay  =  true)  \n  \n// This function draws a `line` using bar index x-coordinates.  \ndrawLine(bar1,  y1,  bar2,  y2) =>  \n// Only execute this code on the last bar.  \nif  barstate.islast  \n// Create the line only the first time this function is executed on the last bar.  \nvar  line  lin  =  line.new(bar1,  y1,  bar2,  y2,  xloc.bar_index)  \n// Change the line's properties on all script executions on the last bar.  \nline.set_xy1(lin,  bar1,  y1)  \nline.set_xy2(lin,  bar2,  y2)  \n  \n// Input determining how many bars forward we draw the `line`.  \nint  forwardBarsInput  =  input.int(10,  \"Forward Bars to Display\",  minval  =  1,  maxval  =  500)  \n  \n// Calculate the line's left and right points.  \nint  leftBar  =  bar_index[2]  \nfloat  leftY  =  high[2]  \nint  rightBar  =  leftBar  +  forwardBarsInput  \nfloat  rightY  =  leftY  + (ta.change(high)[1] *  forwardBarsInput)  \n  \n// This function call is executed on all bars, but it only draws the `line` on the last bar.  \ndrawLine(leftBar,  leftY,  rightBar,  rightY)  \n``\n\n### [Chart  bars](https://www.tradingview.com/pine-script-docs/writing/limitations/#chart-bars)\n\nThe number of bars appearing on charts is dependent on the amount of historical data available for the chart‚Äôs symbol and timeframe, and on the type of account you hold. When the required historical date is available, the minimum number of chart bars is:\n\n-   40000 historical bars for the Ultimate plan.\n-   25000 historical bars for the Expert plan.\n-   20000 historical bars for the Premium plan.\n-   10000 historical bars for Essential and Plus plans.\n-   5000 historical bars for other plans.\n\n### [Trade orders in  backtesting](https://www.tradingview.com/pine-script-docs/writing/limitations/#trade-orders-in-backtesting)\n\nA script can place a maximum of 9000 orders when backtesting strategies. Once it reaches that limit, the earlier orders are  _trimmed_  to store the information of new orders. Programmers can use the  [strategy.closedtrades.first_index](https://www.tradingview.com/pine-script-reference/v6/#var_strategy.closedtrades.first_index)  variable to reference the index of the earliest untrimmed trade.\n\nWhen using Deep Backtesting, the order limit is 1,000,000",
    "keywords": [
      "www.tradingview",
      "xloc.bar_index",
      "const_xloc.bar_index",
      "input.int",
      "tradingview.com",
      "barstate.islast",
      "line.new",
      "line.set_xy",
      "ta.change",
      "strategy.closedtrades",
      "var_strategy.closedtrades",
      "line.set_xy1",
      "line.set_xy2",
      "indicator",
      "strategy",
      "overlay",
      "input",
      "var",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-397",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Profiling a  script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)",
    "content": "# [Profiling and  optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-and-optimization)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#introduction)\n\nPine Script¬Æ is a cloud-based compiled language geared toward efficient repeated script execution. When a user adds a Pine script to a chart, it executes  _numerous_  times, once for each available bar or tick in the data feeds it accesses, as explained in this manual‚Äôs  [Execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/)  page.\n\nThe Pine Script compiler automatically performs several internal optimizations to accommodate scripts of various sizes and help them run smoothly. However, such optimizations  _do not_  prevent performance bottlenecks in script executions. As such, it‚Äôs up to programmers to  [profile](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  a script‚Äôs runtime performance and identify ways to modify critical code blocks and lines when they need to improve execution times.\n\nThis page covers how to profile and monitor a script‚Äôs runtime and executions with the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  and explains some ways programmers can modify their code to  [optimize](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimization)  runtime performance.\n\nFor a quick introduction, see the following video, where we profile an example script and optimize it step-by-step, examining several common script inefficiencies and explaining how to avoid them along the way:\n\n## [Pine  Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)\n\nBefore diving into  [optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimization), it‚Äôs prudent to evaluate a script‚Äôs runtime and pinpoint  _bottlenecks_, i.e., areas in the code that substantially impact overall performance. With these insights, programmers can ensure they focus on optimizing where it truly matters instead of spending time and effort on low-impact code.\n\nEnter the  _Pine Profiler_, a powerful utility that analyzes the executions of all significant code lines and blocks in a script and displays helpful performance information next to the lines inside the Pine Editor. By inspecting the Profiler‚Äôs results, programmers can gain a clearer perspective on a script‚Äôs overall runtime, the distribution of runtime across its significant code regions, and the critical portions that may need extra attention and optimization.",
    "keywords": [
      "www.tradingview",
      "i.e",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-398",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Interpreting profiled  results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)",
    "content": "### [Profiling a  script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)\n\nThe Pine Profiler can analyze the runtime performance of any  _editable_  script coded in Pine Script v6. To profile a script, add it to the chart, open the source code in the Pine Editor, and turn on the ‚ÄúProfiler mode‚Äù switch in the dropdown accessible via the ‚ÄúMore‚Äù option in the top-right corner:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-a-script-1.BMT4r11Q_18aofc.webp)\n\nWe will use the script below for our initial profiling example, which calculates a custom  `oscillator`  based on average distances from the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price to upper and lower percentiles over  `lengthInput`  bars. It includes a few different types of  _significant_  code regions, which come with some differences in  [interpretation](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  while profiling:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Pine Profiler demo\")  \n  \n//@variable The number of bars in the calculations.  \nint  lengthInput  =  input.int(100,  \"Length\",  2)  \n//@variable The percentage for upper percentile calculation.  \nfloat  upperPercentInput  =  input.float(75.0,  \"Upper percentile\",  50.0,  100.0)  \n//@variable The percentage for lower percentile calculation.  \nfloat  lowerPercentInput  =  input.float(25.0,  \"Lower percentile\",  0.0,  50.0)  \n  \n// Calculate percentiles using the linear interpolation method.  \nfloat  upperPercentile  =  ta.percentile_linear_interpolation(close,  lengthInput,  upperPercentInput)  \nfloat  lowerPercentile  =  ta.percentile_linear_interpolation(close,  lengthInput,  lowerPercentInput)  \n  \n// Declare arrays for upper and lower deviations from the percentiles on the same line.  \nvar  upperDistances  =  array.new<float>(lengthInput),  var  lowerDistances  =  array.new<float>(lengthInput)  \n  \n// Queue distance values through the `upperDistances` and `lowerDistances` arrays based on excessive price deviations.  \nif  math.abs(close  -  0.5  * (upperPercentile  +  lowerPercentile)) >  0.5  * (upperPercentile  -  lowerPercentile)  \narray.push(upperDistances,  math.max(close  -  upperPercentile,  0.0))  \narray.shift(upperDistances)  \narray.push(lowerDistances,  math.max(lowerPercentile  -  close,  0.0))  \narray.shift(lowerDistances)  \n  \n//@variable The average distance from the `upperDistances` array.  \nfloat  upperAvg  =  upperDistances.avg()  \n//@variable The average distance from the `lowerDistances` array.  \nfloat  lowerAvg  =  lowerDistances.avg()  \n//@variable The ratio of the difference between the `upperAvg` and `lowerAvg` to their sum.  \nfloat  oscillator  = (upperAvg  -  lowerAvg) / (upperAvg  +  lowerAvg)  \n//@variable The color of the plot. A green-based gradient if `oscillator` is positive, a red-based gradient otherwise.  \ncolor  oscColor  =  oscillator  >  0  ?  \ncolor.from_gradient(oscillator,  0.0,  1.0,  color.gray,  color.green) :  \ncolor.from_gradient(oscillator,  -1.0,  0.0,  color.red,  color.gray)  \n  \n// Plot the `oscillator` with the `oscColor`.  \nplot(oscillator,  \"Oscillator\",  oscColor,  style  =  plot.style_area)  \n``\n\nOnce enabled, the Profiler collects information from all executions of the script‚Äôs significant code lines and blocks, then displays bars and approximate runtime percentages to the left of the code lines inside the Pine Editor:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-a-script-2.Ud_wxirg_1toi2O.webp)\n\nNote that:\n\n-   The Profiler tracks every execution of a significant code region, including the executions on  _realtime ticks_. Its information updates over time as new executions occur.\n-   Profiler results  **do not**  appear for script declaration statements, type declarations, other  _insignificant_  code lines such as variable declarations with no tangible impact,  _unused code_  that the script‚Äôs outputs do not depend on, or  _repetitive code_  that the compiler optimizes during translation. See  [this section](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#insignificant-unused-and-redundant-code)  for more information.\n\nWhen a script contains at least  _four_  significant lines of code, the Profiler will include ‚Äúflame‚Äù icons next to the  _top three_  code regions with the highest performance impact. If one or more of the highest-impact code regions are  _outside_  the lines visible inside the Pine Editor, a ‚Äúflame‚Äù icon and a number indicating how many critical lines are outside the view will appear at the top or bottom of the left margin. Clicking the icon will vertically scroll the Editor‚Äôs window to show the nearest critical line:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-a-script-3.CRdP8jVv_Z2lC0Am.webp)\n\nHovering the mouse pointer over the space next to a line highlights the analyzed code and exposes a tooltip with additional information, including the time spent and the number of executions. The information shown next to each line and in the corresponding tooltip depends on the profiled code region. The  [section below](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  explains different types of code the Profiler analyzes and how to interpret their performance results.\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-a-script-4.B8hBGa6N_2sbc0.webp)\n\nNote\n\nSimilar to profiling tools for other languages, the Pine Profiler  _wraps_  a script and its significant code with  [extra calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#a-look-into-the-profilers-inner-workings)  to collect performance data. Therefore, a script‚Äôs resource usage  **increases**  while profiling, and the results are thus  **estimates**  rather than precise performance measurements.\n\n  \n\nFurthermore, the Profiler cannot collect and display individual performance data for the  _internal calculations_  that also affect runtime, including the calculations required to track performance, meaning the time values shown for all a script‚Äôs code regions  **do not**  add up to exactly 100% of its overall runtime.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "input.float",
      "ta.percentile_linear_interpolation",
      "array.new",
      "math.abs",
      "array.push",
      "math.max",
      "array.shift",
      "color.from_gradient",
      "color.gray",
      "color.green",
      "color.red",
      "plot.style_area",
      "indicator",
      "input",
      "plot",
      "var",
      "method",
      "type",
      "switch",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-399",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[A look into the Profiler‚Äôs inner  workings](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#a-look-into-the-profilers-inner-workings)",
    "content": "### [Interpreting profiled  results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)\n\n#### [Single-line  results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#single-line-results)\n\nFor a code line containing single-line expressions, the Profiler bar and displayed percentage represent the relative portion of the script‚Äôs total runtime spent on that line. The corresponding tooltip displays three fields:\n\n-   The ‚ÄúLine number‚Äù field indicates the analyzed code line.\n-   The ‚ÄúTime‚Äù field shows the runtime percentage for the line of code, the runtime spent on that line, and the script‚Äôs total runtime.\n-   The ‚ÄúExecutions‚Äù field shows the number of times that specific line executed while running the script.\n\nHere, we hovered the pointer over the space next to line 12 of our profiled code to view its tooltip:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Single-line-results-1.DxmafMJF_Z1xuVkr.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`float  upperPercentile  =  ta.percentile_linear_interpolation(close,  lengthInput,  upperPercentInput)  \n`\n\nNote that:\n\n-   The time information for the line represents the time spent completing  _all_  executions,  **not**  the time spent on a single execution.\n-   To estimate the  _average_  time spent per execution, divide the line‚Äôs time by the number of executions. In this case, the tooltip shows that line 12 took about 14.1 milliseconds to execute 20,685 times, meaning the average time per execution was approximately 14.1 ms / 20685 = 0.0006816534 milliseconds (0.6816534 microseconds).\n\nWhen a line of code consists of more than one expression separated by commas, the number of executions shown in the tooltip represents the  _sum_  of each expression‚Äôs total executions, and the time value displayed represents the total time spent evaluating all the line‚Äôs expressions.\n\nFor instance, this global line from our initial example includes two  [variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  separated by commas. Each uses the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword, meaning the script only executes them once on the first available bar. As we see in the Profiler tooltip for the line, it counted  _two_  executions (one for each expression), and the time value shown is the  _combined_  result from both expressions on the line:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Single-line-results-2.CGsjIphG_1lBWSK.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`var  upperDistances  =  array.new<float>(lengthInput),  var  lowerDistances  =  array.new<float>(lengthInput)  \n`\n\nNote that:\n\n-   When analyzing scripts with more than one expression on the same line, we recommend moving each expression to a  _separate line_  for more detailed insights while profiling, namely if they may contain  _higher-impact_  calculations.\n\nWhen using  [line wrapping](https://www.tradingview.com/pine-script-docs/writing/style-guide/#line-wrapping)  for readability or stylistic purposes, the Profiler considers all portions of a wrapped line as part of the  _first line_  where it starts in the Pine Editor.\n\nFor example, although this code from our initial script occupies more than one line in the Pine Editor, it‚Äôs still treated as a  _single_  line of code, and the Profiler tooltip displays single-line results, with the ‚ÄúLine number‚Äù field showing the  _first_  line in the Editor that the wrapped line occupies:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Single-line-results-3.8u0gLHs0_yR0hQ.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`color  oscColor  =  oscillator  >  0  ?  \ncolor.from_gradient(oscillator,  0.0,  1.0,  color.gray,  color.green) :  \ncolor.from_gradient(oscillator,  -1.0,  0.0,  color.red,  color.gray)  \n`\n\n#### [Code block  results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)\n\nFor a line at the start of a  [loop](https://www.tradingview.com/pine-script-docs/language/loops/)  or  [conditional structure](https://www.tradingview.com/pine-script-docs/language/conditional-structures/), the Profiler bar and percentage represent the relative portion of the script‚Äôs runtime spent on the  **entire code block**, not just the single line. The corresponding tooltip displays four fields:\n\n-   The ‚ÄúCode block range‚Äù field indicates the range of lines included in the structure.\n-   The ‚ÄúTime‚Äù field shows the code block‚Äôs runtime percentage, the time spent on all block executions, and the script‚Äôs total runtime.\n-   The ‚ÄúLine time‚Äù field shows the runtime percentage for the block‚Äôs initial line, the time spent on that line, and the script‚Äôs total runtime. The interpretation differs for  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  blocks or  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  blocks  _with_  `else if`  statements, as the values represent the total time spent on  **all**  the structure‚Äôs conditional statements. See below for more information.\n-   The ‚ÄúExecutions‚Äù field shows the number of times the code block executed while running the script.\n\nHere, we hovered over the space next to line 19 in our initial script, the beginning of a simple  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure  _without_  `else if`  statements. As we see below, the tooltip shows performance information for the entire code block and the current line:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Code-block-results-1.Cp7Cs5Lf_Z1aX7Bw.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`if  math.abs(close  -  0.5  * (upperPercentile  +  lowerPercentile)) >  0.5  * (upperPercentile  -  lowerPercentile)  \narray.push(upperDistances,  math.max(close  -  upperPercentile,  0.0))  \narray.shift(upperDistances)  \narray.push(lowerDistances,  math.max(lowerPercentile  -  close,  0.0))  \narray.shift(lowerDistances)  \n`\n\nNote that:\n\n-   The ‚ÄúTime‚Äù field shows that the total time spent evaluating the structure 20,685 times was 7.2 milliseconds.\n-   The ‚ÄúLine time‚Äù field indicates that the runtime spent on the  _first line_  of this  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure was about three milliseconds.\n\nUsers can also inspect the results from lines and nested blocks within a code block‚Äôs range to gain more granular performance insights. Here, we hovered over the space next to line 20 within the code block to view its  [single-line result](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#single-line-results):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Code-block-results-2.Cy1_m4AY_ZsCh1h.webp)\n\nNote that:\n\n-   The number of executions shown is  _less than_  the result for the entire code block, as the condition that controls the execution of this line does not return  `true`  all the time. The opposite applies to the code inside  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  since each execution of a loop statement can trigger  **several**  executions of the loop‚Äôs local block.\n\nWhen profiling a  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  structure or an  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure that includes  `else if`  statements, the ‚ÄúLine time‚Äù field will show the time spent executing  **all**  the structure‚Äôs conditional expressions,  **not**  just the block‚Äôs first line. The results for the lines inside the code block range will show runtime and executions for each  **local block**. This format is necessary for these structures due to the Profiler‚Äôs calculation and display constraints. See  [this section](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#a-look-into-the-profilers-inner-workings)  for more information.\n\nFor example, the ‚ÄúLine time‚Äù for the  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  structure in this script represents the time spent evaluating  _all four_  conditional statements within its body, as the Profiler  _cannot_  track them separately. The results for each line in the code block‚Äôs range represent the performance information for each  _local block_:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Code-block-results-3.D12wyQyn_ZXHSFp.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"`switch` and `if...else if` results demo\")  \n  \n//@variable The upper band for oscillator calculation.  \nvar  float  upperBand  =  close  \n//@variable The lower band for oscillator calculation.  \nvar  float  lowerBand  =  close  \n  \n// Update the `upperBand` and `lowerBand` based on the proximity of the `close` to the current band values.  \n// The \"Line time\" field on line 11 represents the time spent on all 4 conditional expressions in the structure.  \nswitch  \nclose  >  upperBand  =>  upperBand  :=  close  \nclose  <  lowerBand  =>  lowerBand  :=  close  \nupperBand  -  close  >  close  -  lowerBand  =>  upperBand  :=  0.9  *  upperBand  +  0.1  *  close  \nclose  -  lowerBand  >  upperBand  -  close  =>  lowerBand  :=  0.9  *  lowerBand  +  0.1  *  close  \n  \n//@variable The ratio of the difference between `close` and `lowerBand` to the band range.  \nfloat  oscillator  =  100.0  * (close  -  lowerBand) / (upperBand  -  lowerBand)  \n  \n// Plot the `oscillator` as columns with a dynamic color.  \nplot(  \noscillator,  \"Oscillator\",  oscillator  >  50.0  ?  color.teal  :  color.maroon,  \nstyle  =  plot.style_columns,  histbase  =  50.0  \n)  \n``\n\nWhen the conditional logic in such structures involves significant calculations, programmers may require more granular performance information for each calculated condition. An effective way to achieve this analysis is to use  _nested_  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  blocks instead of the more compact  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  or  `if...else if`  structures. For example, instead of:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`switch  \n<expression1>  =>  <localBlock1>  \n<expression2>  =>  <localBlock2>  \n=>  <localBlock3>  \n`\n\nor:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`if  <expression1>  \n<localBlock1>  \nelse  if  <expression2>  \n<localBlock2>  \nelse  \n<localBlock3>  \n`\n\none can use nested  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  blocks for more in-depth profiling while maintaining the same logical flow:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`if  <expression1>  \n<localBlock1>  \nelse  \nif  <expression2>  \n<localBlock2>  \nelse  \n<localBlock3>  \n`\n\nBelow, we changed the previous  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  example to an equivalent nested  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure. Now, we can view the runtime and executions for each significant part of the conditional pattern individually:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Code-block-results-4.OxkZ6XRw_Zs1azS.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"`switch` and `if...else if` results demo\")  \n  \n//@variable The upper band for oscillator calculation.  \nvar  float  upperBand  =  close  \n//@variable The lower band for oscillator calculation.  \nvar  float  lowerBand  =  close  \n  \n// Update the `upperBand` and `lowerBand` based on the proximity of the `close` to the current band values.  \nif  close  >  upperBand  \nupperBand  :=  close  \nelse  \nif  close  <  lowerBand  \nlowerBand  :=  close  \nelse  \nif  upperBand  -  close  >  close  -  lowerBand  \nupperBand  :=  0.9  *  upperBand  +  0.1  *  close  \nelse  \nif  close  -  lowerBand  >  upperBand  -  close  \nlowerBand  :=  0.9  *  lowerBand  +  0.1  *  close  \n  \n//@variable The ratio of the difference between `close` and `lowerBand` to the band range.  \nfloat  oscillator  =  100.0  * (close  -  lowerBand) / (upperBand  -  lowerBand)  \n  \n// Plot the `oscillator` as columns with a dynamic color.  \nplot(  \noscillator,  \"Oscillator\",  oscillator  >  50.0  ?  color.teal  :  color.maroon,  \nstyle  =  plot.style_columns,  histbase  =  50.0  \n)  \n``\n\nNote that:\n\n-   This same process can also apply to  [ternary operations](https://www.tradingview.com/pine-script-docs/language/operators/#-ternary-operator). When a complex ternary expression‚Äôs operands contain significant calculations, reorganizing the logic into a nested  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure allows more detailed Profiler results, making it easier to spot critical parts.\n\n#### [User-defined function  calls](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#user-defined-function-calls)\n\n[User-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  and  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  are functions written by users. They encapsulate code sequences that a script may execute several times. Users often write functions and methods for improved code modularity, reusability, and maintainability.\n\nThe indented lines of code within a function represent its  _local scope_, i.e., the sequence that executes  _each time_  the script calls it. Unlike code in a script‚Äôs global scope, which a script evaluates once on each execution, the code inside a function may activate zero, one, or  _multiple times_  on each script execution, depending on the conditions that trigger the calls, the number of calls that occur, and the function‚Äôs logic.\n\nThis distinction is crucial to consider while interpreting Profiler results. When a profiled code contains  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  calls:\n\n-   The results for each  _function call_  reflect the runtime allocated toward it and the total number of times the script activated that specific call.\n-   The time and execution information for all local code  _inside_  a function‚Äôs scope reflects the combined results from  **all**  calls to the function.\n\nThis example contains a user-defined  `similarity()`  function that estimates the similarity of two series, which the script calls only  _once_  from the global scope on each execution. In this case, the Profiler‚Äôs results for the code inside the function‚Äôs body correspond to that specific call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-User-defined-function-calls-1.DUf4uWCa_1zRHzX.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"User-defined function calls demo\")  \n  \n//@function Estimates the similarity between two standardized series over `length` bars.  \n// Each individual call to this function activates its local scope.  \nsimilarity(float  sourceA,  float  sourceB,  int  length) =>  \n// Standardize `sourceA` and `sourceB` for comparison.  \nfloat  normA  = (sourceA  -  ta.sma(sourceA,  length)) /  ta.stdev(sourceA,  length)  \nfloat  normB  = (sourceB  -  ta.sma(sourceB,  length)) /  ta.stdev(sourceB,  length)  \n// Calculate and return the estimated similarity of `normA` and `normB`.  \nfloat  abSum  =  math.sum(normA  *  normB,  length)  \nfloat  a2Sum  =  math.sum(normA  *  normA,  length)  \nfloat  b2Sum  =  math.sum(normB  *  normB,  length)  \nabSum  /  math.sqrt(a2Sum  *  b2Sum)  \n  \n// Plot the similarity between the `close` and an offset `close` series.  \nplot(similarity(close,  close[1],  100),  \"Similarity 1\",  color.red)  \n``\n\nLet‚Äôs increase the number of times the script calls the function each time it executes. Here, we changed the script to call our  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  _five times_:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"User-defined function calls demo\")  \n  \n//@function Estimates the similarity between two standardized series over `length` bars.  \n// Each individual call to this function activates its local scope.  \nsimilarity(float  sourceA,  float  sourceB,  int  length) =>  \n// Standardize `sourceA` and `sourceB` for comparison.  \nfloat  normA  = (sourceA  -  ta.sma(sourceA,  length)) /  ta.stdev(sourceA,  length)  \nfloat  normB  = (sourceB  -  ta.sma(sourceB,  length)) /  ta.stdev(sourceB,  length)  \n// Calculate and return the estimated similarity of `normA` and `normB`.  \nfloat  abSum  =  math.sum(normA  *  normB,  length)  \nfloat  a2Sum  =  math.sum(normA  *  normA,  length)  \nfloat  b2Sum  =  math.sum(normB  *  normB,  length)  \nabSum  /  math.sqrt(a2Sum  *  b2Sum)  \n  \n// Plot the similarity between the `close` and several offset `close` series.  \nplot(similarity(close,  close[1],  100),  \"Similarity 1\",  color.red)  \nplot(similarity(close,  close[2],  100),  \"Similarity 2\",  color.orange)  \nplot(similarity(close,  close[4],  100),  \"Similarity 3\",  color.green)  \nplot(similarity(close,  close[8],  100),  \"Similarity 4\",  color.blue)  \nplot(similarity(close,  close[16],  100),  \"Similarity 5\",  color.purple)  \n``\n\nIn this case, the local code results no longer correspond to a  _single_  evaluation per script execution. Instead, they represent the  _combined_  runtime and executions of the local code from  **all five**  calls. As we see below, the results after running this version of the script across the same data show 137,905 executions of the local code,  _five times_  the number from when the script only contained one  `similarity()`  function call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-User-defined-function-calls-2.BJPTeot1_Z1mNfz1.webp)\n\nNoteIf the local scopes of a script‚Äôs  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  contain calls to  `request.*()`  functions, the  _translated form_  of the script extracts such calls  **outside**  the functions‚Äô scopes to evaluate them  **separately**. Consequently, the Profiler‚Äôs results for lines with calls to those user-defined functions  **do not**  include the time spent on the  `request.*()`  calls. See the  [section below](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#when-requesting-other-contexts)  to learn more.\n\n#### [When requesting other  contexts](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#when-requesting-other-contexts)\n\nPine scripts can request data from other  _contexts_, i.e., different symbols, timeframes, or data modifications than what the chart‚Äôs data uses by calling the  `request.*()`  family of functions or specifying an alternate  `timeframe`  in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  declaration statement.\n\nWhen a script requests data from another context, it evaluates all required scopes and calculations within that context, as explained in the  [Other timeframes and data](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/)  page. This behavior can affect the runtime of a script‚Äôs code regions and the number of times they execute.\n\nThe Profiler information for any code  [line](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#single-line-results)  or  [block](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)  represents the results from executing the code in  _all necessary contexts_, which may or may not include the chart‚Äôs data. Pine Script determines which contexts to execute code within based on the calculations required by a script‚Äôs data requests and outputs.\n\nLet‚Äôs look at a simple example. This initial script only uses the chart‚Äôs data for its calculations. It declares a  `pricesArray`  variable with the  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keyword, meaning the  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  assigned to it persists across the data‚Äôs history and all available realtime ticks. On each execution, the script calls  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  to push a new  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  value into the  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array), and it  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  the array‚Äôs size.\n\nAfter profiling the script across all the bars on an intraday chart, we see that the number of elements in the  `pricesArray`  corresponds to the number of executions the Profiler shows for the  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  call on line 8:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-When-requesting-other-contexts-1.4ixtln-7_gTemj.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"When requesting other contexts demo\")  \n  \n//@variable An array containing the `close` value from every available price update.  \nvarip  array<float> pricesArray  =  array.new<float>()  \n  \n// Push a new `close` value into the `pricesArray` on each update.  \narray.push(pricesArray,  close)  \n  \n// Plot the size of the `pricesArray`.  \nplot(array.size(pricesArray),  \"Total number of chart price updates\")  \n``\n\nNow, let‚Äôs try evaluating the size of the  `pricesArray`  from  _another context_  instead of using the chart‚Äôs data. Below, we‚Äôve added a  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call with  [array.size(pricesArray)](https://www.tradingview.com/pine-script-reference/v6/#fun_array.size)  as its  `expression`  argument to retrieve the value calculated on the ‚Äú1D‚Äù timeframe and plotted that result instead.\n\nIn this case, the number of executions the Profiler shows on line 8 still corresponds to the number of elements in the  `pricesArray`. However, it did not execute the same number of times since the script did not require the  _chart‚Äôs data_  in the calculations. It only needed to initialize the  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  and evaluate  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  across all the requested  _daily data_, which has a different number of price updates than our current intraday chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-When-requesting-other-contexts-2.COS2z1lh_s4Tg3.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"When requesting other contexts demo\")  \n  \n//@variable An array containing the `close` value from every available price update.  \nvarip  array<float> pricesArray  =  array.new<float>()  \n  \n// Push a new `close` value into the `pricesArray` on each update.  \narray.push(pricesArray,  close)  \n  \n// Plot the size of the `pricesArray` requested from the daily timeframe.  \nplot(request.security(syminfo.tickerid,  \"1D\",  array.size(pricesArray)),  \"Total number of daily price updates\")  \n``\n\nNote that:\n\n-   The requested EOD data in this example had fewer data points than our intraday chart, so the  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  call required fewer executions in this case. However, EOD feeds  _do not_  have history limitations, meaning it‚Äôs also possible for requested HTF data to span  **more**  bars than a user‚Äôs chart, depending on the timeframe, the data provider, and the user‚Äôs  [plan](https://www.tradingview.com/pricing/).\n\nIf this script were to plot the  [array.size()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.size)  value directly in addition to the requested daily value, it would then require the creation of  _two_  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  (one for each context) and the execution of  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  across both the chart‚Äôs data  _and_  the data from the daily timeframe. As such, the declaration on line 5 will execute  _twice_, and the results on line 8 will reflect the time and executions accumulated from evaluating the  [array.push()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.push)  call across  **both separate datasets**:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-When-requesting-other-contexts-3.CPXHEchh_1SVGGO.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"When requesting other contexts demo\")  \n  \n//@variable An array containing the `close` value from every available price update.  \nvarip  array<float> pricesArray  =  array.new<float>()  \n  \n// Push a new `close` value into the `pricesArray` on each update.  \narray.push(pricesArray,  close)  \n  \n// Plot the size of the `pricesArray` from the daily timeframe and the chart's context.  \n// Including both in the outputs requires executing line 5 and line 8 across BOTH datasets.  \nplot(request.security(syminfo.tickerid,  \"1D\",  array.size(pricesArray)),  \"Total number of daily price updates\")  \nplot(array.size(pricesArray),  \"Total number of chart price updates\")  \n``\n\nIt‚Äôs important to note that when a script calls a  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  that contains  `request.*()`  calls in its local scope, the script‚Äôs  _translated form_  extracts the  `request.*()`  calls  **outside**  the scope and encapsulates the expressions they depend on within  **separate functions**. When the script executes, it evaluates the required  `request.*()`  calls first, then  _passes_  the requested data to a  _modified form_  of the  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/).\n\nSince the translated script executes a  [user-defined function‚Äôs](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  data requests separately  **before**  evaluating non-requested calculations in its local scope, the Profiler‚Äôs results for lines containing calls to the function  **will not**  include the time spent on its  `request.*()`  calls or their required expressions.\n\nAs an example, the following script contains a user-defined  `getCompositeAvg()`  function with a  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call that requests the  [math.avg()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.avg)  of 10  [ta.wma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.wma)  calls with different  `length`  arguments from a specified  `symbol`. The script uses the function to request the average result using a  [Heikin Ashi](https://www.tradingview.com/pine-script-docs/concepts/non-standard-charts-data/#tickerheikinashi)  ticker ID:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"User-defined functions with `request.*()` calls demo\",  overlay  =  true)  \n  \nint  multInput  =  input.int(10,  \"Length multiplier\",  1)  \n  \nstring  tickerID  =  ticker.heikinashi(syminfo.tickerid)  \n  \ngetCompositeAvg(string  symbol,  int  lengthMult) =>  \nrequest.security(  \nsymbol,  timeframe.period,  math.avg(  \nta.wma(close,  lengthMult),  ta.wma(close,  2  *  lengthMult),  ta.wma(close,  3  *  lengthMult),  \nta.wma(close,  4  *  lengthMult),  ta.wma(close,  5  *  lengthMult),  ta.wma(close,  6  *  lengthMult),  \nta.wma(close,  7  *  lengthMult),  ta.wma(close,  8  *  lengthMult),  ta.wma(close,  9  *  lengthMult),  \nta.wma(close,  10  *  lengthMult)  \n)  \n)  \n  \nplot(getCompositeAvg(tickerID,  multInput),  \"Composite average\",  linewidth  =  3)  \n``\n\nAfter profiling the script, users might be surprised to see that the runtime results shown inside the function‚Äôs body heavily  **exceed**  the results shown for the  _single_  `getCompositeAvg()`  call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-When-requesting-other-contexts-4.CkN5cmYP_xCyjm.webp)\n\nThe results appear this way since the translated script includes internal modifications that  _moved_  the  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call and its expression  **outside**  the function‚Äôs scope, and the Profiler has no way to represent the results from those calculations other than displaying them next to the  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  line in this scenario. The code below roughly illustrates how the translated script looks:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"User-defined functions with `request.*()` calls demo\",  overlay  =  true)  \n  \nint  multInput  =  input.int(10,  \"Length multiplier\")  \n  \nstring  tickerID  =  ticker.heikinashi(syminfo.tickerid)  \n  \nsecExpr(int  lengthMult)=>  \nmath.avg(  \nta.wma(close,  lengthMult),  ta.wma(close,  2  *  lengthMult),  ta.wma(close,  3  *  lengthMult),  \nta.wma(close,  4  *  lengthMult),  ta.wma(close,  5  *  lengthMult),  ta.wma(close,  6  *  lengthMult),  \nta.wma(close,  7  *  lengthMult),  ta.wma(close,  8  *  lengthMult),  ta.wma(close,  9  *  lengthMult),  \nta.wma(close,  10  *  lengthMult)  \n)  \n  \nfloat  sec  =  request.security(tickerID,  timeframe.period,  secExpr(multInput))  \n  \ngetCompositeAvg(float  s) =>  \ns  \n  \nplot(getCompositeAvg(sec),  \"Composite average\",  linewidth  =  3)  \n``\n\nNote that:\n\n-   The  `secExpr()`  code represents the  _separate function_  used by  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  to calculate the required expression in the requested context.\n-   The  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call takes place in the  **outer scope**, outside the  `getCompositeAvg()`  function.\n-   The translation substantially reduced the local code of  `getCompositeAvg()`. It now solely returns a value passed into it, as all the function‚Äôs required calculations take place  **outside**  its scope. Due to this reduction, the function call‚Äôs performance results  **will not**  reflect any of the time spent on the data request‚Äôs required calculations.\n\n#### [Insignificant, unused, and redundant  code](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#insignificant-unused-and-redundant-code)\n\nWhen inspecting a profiled script‚Äôs results, it‚Äôs crucial to understand that  _not all_  code in a script necessarily impacts runtime performance. Some code has no direct performance impact, such as a script‚Äôs declaration statement and  [type](https://www.tradingview.com/pine-script-reference/v6/#kw_type)  declarations. Other code regions with insignificant expressions, such as most  `input.*()`  calls, variable references, or  [variable declarations](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  without significant calculations, have little to  _no effect_  on a script‚Äôs runtime. Therefore, the Profiler will  **not**  display performance results for these types of code.\n\nAdditionally, Pine scripts do not execute code regions that their  _outputs_  ([plots](https://www.tradingview.com/pine-script-docs/visuals/plots/),  [drawings](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types),  [logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs), etc.) do not depend on, as the compiler automatically  **removes**  them during translation. Since unused code regions have  _zero_  impact on a script‚Äôs performance, the Profiler will  **not**  display any results for them.\n\nThe following example contains a  `barsInRange`  variable and a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop that adds 1 to the variable‚Äôs value for each historical  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price between the current  [high](https://www.tradingview.com/pine-script-reference/v6/#var_high)  and  [low](https://www.tradingview.com/pine-script-reference/v6/#var_low)  over  `lengthInput`  bars. However, the script  **does not use**  these calculations in its outputs, as it only  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  the  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price. Consequently, the script‚Äôs compiled form  **discards**  that unused code and only considers the  [plot(close)](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call.\n\nThe Profiler does not display  **any**  results for this script since it does not execute any  **significant**  calculations:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Insignificant-unused-and-redundant-code-1.CVzX40Kz_HGwJR.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Unused code demo\")  \n  \n//@variable The number of historical bars in the calculation.  \nint  lengthInput  =  input.int(100,  \"Length\",  1)  \n  \n//@variable The number of closes over `lengthInput` bars between the current bar's `high` and `low`.  \nint  barsInRange  =  0  \n  \nfor  i  =  1  to  lengthInput  \n//@variable The `close` price from `i` bars ago.  \nfloat  pastClose  =  close[i]  \n// Add 1 to `barsInRange` if the `pastClose` is between the current bar's `high` and `low`.  \nif  pastClose  >  low  and  pastClose  <  high  \nbarsInRange  +=  1  \n  \n// Plot the `close` price. This is the only output.  \n// Since the outputs do not require any of the above calculations, the compiled script will not execute them.  \nplot(close)  \n``\n\nNote that:\n\n-   Although this script does not use the  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int)  from line 5 and discards all its associated calculations, the ‚ÄúLength‚Äù input  _will_  still appear in the script‚Äôs settings, as the compiler  **does not**  completely remove unused  [inputs](https://www.tradingview.com/pine-script-docs/concepts/inputs/).\n\nIf we change the script to plot the  `barsInRange`  value instead, the declared variables and the  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop are no longer unused since the output depends on them, and the Profiler will now display performance information for that code:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Insignificant-unused-and-redundant-code-2.TBOBJdXS_Z1yftUf.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Unused code demo\")  \n  \n//@variable The number of historical bars in the calculation.  \nint  lengthInput  =  input.int(100,  \"Length\",  1)  \n  \n//@variable The number of closes over `lengthInput` bars between the current bar's `high` and `low`.  \nint  barsInRange  =  0  \n  \nfor  i  =  1  to  lengthInput  \n//@variable The `close` price from `i` bars ago.  \nfloat  pastClose  =  close[i]  \n// Add 1 to `barsInRange` if the `pastClose` is between the current bar's `high` and `low`.  \nif  pastClose  >  low  and  pastClose  <  high  \nbarsInRange  +=  1  \n  \n// Plot the `barsInRange` value. The above calculations will execute since the output requires them.  \nplot(barsInRange,  \"Bars in range\")  \n``\n\nNote that:\n\n-   The Profiler does not show performance information for the  `lengthInput`  declaration on line 5 or the  `barsInRange`  declaration on line 8 since the expressions on these lines do not impact the script‚Äôs performance.\n\nWhen possible, the compiler also simplifies certain instances of  _redundant code_  in a script, such as some forms of identical expressions with the same  [fundamental type](https://www.tradingview.com/pine-script-docs/language/type-system/#types)  values. This optimization allows the compiled script to only execute such calculations  _once_, on the first occurrence, and  _reuse_  the calculated result for each repeated instance that the outputs depend on.\n\nIf a script contains repetitive code and the compiler simplifies it, the Profiler will only show results for the  **first occurrence**  of the code since that‚Äôs the only time the script requires the calculation.\n\nFor example, this script contains a code line that plots the value of  [ta.sma(close, 100)](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  and 12 code lines that plot the value of  [ta.sma(close, 500)](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Redundant calculations demo\",  overlay  =  true)  \n  \n// Plot the 100-bar SMA of `close` values one time.  \nplot(ta.sma(close,  100),  \"100-bar SMA\",  color.teal,  3)  \n  \n// Plot the 500-bar SMA of `close` values 12 times. After compiler optimizations, only the first `ta.sma(close, 500)`  \n// call on line 9 requires calculation in this case.  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #001aff,  12)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #4d0bff,  11)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #7306f7,  10)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #920be9,  9)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #ae11d5,  8)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #c618be,  7)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #db20a4,  6)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #eb2c8a,  5)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #f73d6f,  4)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #fe5053,  3)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #ff6534,  2)  \nplot(ta.sma(close,  500),  \"500-bar SMA\",  #ff7a00,  1)  \n``\n\nSince the last 12 lines all contain identical  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  calls, the compiler can automatically simplify the script so that it only needs to evaluate  [ta.sma(close, 500)](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  _once_  per execution rather than repeating the calculation 11 more times.\n\nAs we see below, the Profiler only shows results for lines 5 and 9. These are the only parts of the code requiring significant calculations since the  [ta.sma()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.sma)  calls on lines 10-20 are redundant in this case:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Insignificant-unused-and-redundant-code-3.B3yrx82E_2jeci8.webp)\n\nAnother type of repetitive code optimization occurs when a script contains two or more  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  or  [methods](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  with identical compiled forms. In such a case, the compiler simplifies the script by  **removing**  the redundant functions, and the script will treat all calls to the redundant functions as calls to the  **first**  defined version. Therefore, the Profiler will only show local code performance results for the  _first_  function since the discarded ‚Äúclones‚Äù will never execute.\n\nFor instance, the script below contains two  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/),  `metallicRatio()`  and  `calcMetallic()`, that calculate a  [metallic ratio](https://en.wikipedia.org/wiki/Metallic_mean)  of a given order raised to a specified exponent:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Redundant functions demo\")  \n  \n//@variable Controls the base ratio for the `calcMetallic()` call.  \nint  order1Input  =  input.int(1,  \"Order 1\",  1)  \n//@variable Controls the base ratio for the `metallicRatio()` call.  \nint  order2Input  =  input.int(2,  \"Order 2\",  1)  \n  \n//@function Calculates the value of a metallic ratio with a given `order`, raised to a specified `exponent`.  \n//@param order Determines the base ratio used. 1 = Golden Ratio, 2 = Silver Ratio, 3 = Bronze Ratio, and so on.  \n//@param exponent The exponent applied to the ratio.  \nmetallicRatio(int  order,  float  exponent) =>  \nmath.pow((order  +  math.sqrt(4.0  +  order  *  order)) *  0.5,  exponent)  \n  \n//@function A function with the same signature and body as `metallicRatio()`.  \n// The script discards this function and treats `calcMetallic()` as an alias for `metallicRatio()`.  \ncalcMetallic(int  ord,  float  exp) =>  \nmath.pow((ord  +  math.sqrt(4.0  +  ord  *  ord)) *  0.5,  exp)  \n  \n// Plot the results from a `calcMetallic()` and `metallicRatio()` call.  \nplot(calcMetallic(order1Input,  bar_index  %  5),  \"Ratio 1\",  color.orange,  3)  \nplot(metallicRatio(order2Input,  bar_index  %  5),  \"Ratio 2\",  color.maroon)  \n``\n\nDespite the differences in the function and parameter names, the two functions are otherwise identical, which the compiler detects while translating the script. In this case, it  **discards**  the redundant  `calcMetallic()`  function, and the compiled script treats the  `calcMetallic()`  call as a  `metallicRatio()`  call.\n\nAs we see here, the Profiler shows performance information for the  `calcMetallic()`  and  `metallicRatio()`  calls on lines 21 and 22, but it does  **not**  show any results for the local code of the  `calcMetallic()`  function on line 18. Instead, the Profiler‚Äôs information on line 13 within the  `metallicRatio()`  function reflects the local code results from  **both**  [function calls](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#user-defined-function-calls):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Interpreting-profiled-results-Insignificant-unused-and-redundant-code-4.DrYo57fh_Z1tHCEy.webp)",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "ta.percentile_linear_interpolation",
      "array.new",
      "color.from_gradient",
      "color.gray",
      "color.green",
      "color.red",
      "math.abs",
      "array.push",
      "math.max",
      "array.shift",
      "color.teal",
      "color.maroon",
      "plot.style_columns",
      "i.e",
      "ta.sma",
      "ta.stdev",
      "math.sum",
      "math.sqrt",
      "color.orange",
      "color.blue",
      "color.purple",
      "fun_array.push",
      "array.size",
      "request.security",
      "fun_request.security",
      "fun_array.size",
      "syminfo.tickerid",
      "math.avg",
      "fun_math.avg",
      "ta.wma",
      "fun_ta.wma",
      "input.int",
      "ticker.heikinashi",
      "timeframe.period",
      "fun_input.int",
      "fun_ta.sma",
      "en.wikipedia",
      "math.pow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "varip",
      "series",
      "simple",
      "const",
      "import",
      "method",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-400",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Profiling across  configurations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations)",
    "content": "### [A look into the Profiler‚Äôs inner  workings](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#a-look-into-the-profilers-inner-workings)\n\nThe Pine Profiler wraps all necessary code regions with specialized  _internal functions_  to track and collect required information across script executions. It then passes the information to additional calculations that organize and display the performance results inside the Pine Editor. This section gives users a peek into how the Profiler applies internal functions to wrap Pine code and collect performance data.\n\nThere are two main internal  **(non-Pine)**  functions the Profiler wraps significant code with to facilitate runtime analysis. The first function retrieves the current system time at specific points in the script‚Äôs execution, and the second maps cumulative elapsed time and execution data to specific code regions. We represent these functions in this explanation as  `System.timeNow()`  and  `registerPerf()`  respectively.\n\nWhen the Profiler detects code that requires analysis, it adds  `System.timeNow()`  above the code to get the initial time before execution. Then, it adds  `registerPerf()`  below the code to map and accumulate the elapsed time and number of executions. The elapsed time added on each  `registerPerf()`  call is the  `System.timeNow()`  value  _after_  the execution minus the value  _before_  the execution.\n\nThe following  _pseudocode_  outlines this process for a  [single line](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#single-line-results)  of code, where  `_startX`  represents the starting time for the  `lineX`  line:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`long  _startX  =  System.timeNow()  \n<code_line_to_analyze>  \nregisterPerf(System.timeNow() -  _startX,  lineX)  \n`\n\nThe process is similar for  [code blocks](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results). The difference is that the  `registerPerf()`  call maps the data to a  _range of lines_  rather than a single line. Here,  `lineX`  represents the  _first_  line in the code block, and  `lineY`  represents the block‚Äôs  _last_  line:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`long  _startX  =  System.timeNow()  \n<code_block_to_analyze>  \nregisterPerf(System.timeNow() -  _startX,  lineX,  lineY)  \n`\n\nNote that:\n\n-   In the above snippets,  `long`,  `System.timeNow()`, and  `registerPerf()`  represent  _internal code_,  **not**  Pine Script code.\n\nLet‚Äôs now look at how the Profiler wraps a full script and all its significant code. We will start with this script, which calculates three pseudorandom series and displays their average result. The script utilizes an  [object](https://www.tradingview.com/pine-script-docs/language/objects/)  of a  [user-defined type](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  to store a pseudorandom state, a  [method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  to calculate new values and update the state, and an  [if‚Ä¶else if](https://www.tradingview.com/pine-script-docs/language/conditional-structures/#if-structure)  structure to update each series based on generated values:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \nindicator(\"Profiler's inner workings demo\")  \n  \nint  seedInput  =  input.int(12345,  \"Seed\")  \n  \ntype  LCG  \nfloat  state  \n  \nmethod  generate(LCG  this,  int  generations  =  1) =>  \nfloat  result  =  0.0  \nfor  i  =  1  to  generations  \nthis.state  :=  16807  *  this.state  %  2147483647  \nresult  +=  this.state  /  2147483647  \nresult  /  generations  \n  \nvar  lcg  =  LCG.new(seedInput)  \n  \nvar  float  val0  =  1.0  \nvar  float  val1  =  1.0  \nvar  float  val2  =  1.0  \n  \nif  lcg.generate(10) <  0.5  \nval0  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \nelse  if  lcg.generate(10) <  0.5  \nval1  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \nelse  if  lcg.generate(10) <  0.5  \nval2  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \n  \nplot(math.avg(val0,  val1,  val2),  \"Average pseudorandom result\",  color.purple)  \n`\n\nThe Profiler will wrap the entire script and all necessary code regions, excluding any  [insignificant, unused, or redundant code](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#insignificant-unused-and-redundant-code), with the aforementioned  **internal**  functions to collect performance data. The  _pseudocode_  below demonstrates how this process applies to the above script:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``long  _startMain  =  System.timeNow() // Start time for the script's overall execution.  \n  \n// <Additional internal code executes here>  \n  \n//@version=6  \nindicator(\"Profiler's inner workings demo\") // Declaration statements do not require profiling.  \n  \nint  seedInput  =  input.int(12345,  \"Seed\") // Variable declaration without significant calculation.  \n  \ntype  LCG  // Type declarations do not require profiling.  \nfloat  state  \n  \nmethod  generate(LCG  this,  int  generations  =  1) =>  // Function signature does not affect runtime.  \nfloat  result  =  0.0  // Variable declaration without significant calculation.  \n  \nlong  _start11  =  System.timeNow() // Start time for the loop block that begins on line 11.  \nfor  i  =  1  to  generations  // Loop header calculations are not independently wrapped.  \n  \nlong  _start12  =  System.timeNow() // Start time for line 12.  \nthis.state  :=  16807  *  this.state  %  2147483647  \nregisterPerf(System.timeNow() -  _start12,  line12) // Register performance info for line 12.  \n  \nlong  _start13  =  System.timeNow() // Start time for line 13.  \nresult  +=  this.state  /  2147483647  \nregisterPerf(System.timeNow() -  _start13,  line13) // Register performance info for line 13.  \n  \nregisterPerf(System.timeNow() -  _start11,  line11,  line13) // Register performance info for the block (line 11 - 13).  \n  \nlong  _start14  =  System.timeNow() // Start time for line 14.  \nresult  /  generations  \nregisterPerf(System.timeNow() -  _start14,  line14) // Register performance info for line 14.  \n  \nlong  _start16  =  System.timeNow() // Start time for line 16.  \nvar  lcg  =  LCG.new(seedInput)  \nregisterPerf(System.timeNow() -  _start16,  line16) // Register performance info for line 16.  \n  \nvar  float  val0  =  1.0  // Variable declarations without significant calculations.  \nvar  float  val1  =  1.0  \nvar  float  val2  =  1.0  \n  \nlong  _start22  =  System.timeNow() // Start time for the `if` block that begins on line 22.  \nif  lcg.generate(10) <  0.5  // `if` statement is not independently wrapped.  \n  \nlong  _start23  =  System.timeNow() // Start time for line 23.  \nval0  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \nregisterPerf(System.timeNow() -  _start23,  line23) // Register performance info for line 23.  \n  \nelse  if  lcg.generate(10) <  0.5  // `else if` statement is not independently wrapped.  \n  \nlong  _start25  =  System.timeNow() // Start time for line 25.  \nval1  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \nregisterPerf(System.timeNow() -  _start25,  line25) // Register performance info for line 25.  \n  \nelse  if  lcg.generate(10) <  0.5  // `else if` statement is not independently wrapped.  \n  \nlong  _start27  =  System.timeNow() // Start time for line 27.  \nval2  *=  1.0  + (2.0  *  lcg.generate(50) -  1.0) *  0.1  \nregisterPerf(System.timeNow() -  _start27,  line27) // Register performance info for line 27.  \n  \nregisterPerf(System.timeNow() -  _start22,  line22,  line28) // Register performance info for the block (line 22 - 28).  \n  \nlong  _start29  =  System.timeNow() // Start time for line 29.  \nplot(math.avg(val0,  val1,  val2),  \"Average pseudorandom result\",  color.purple)  \nregisterPerf(System.timeNow() -  _start29,  line29) // Register performance info for line 29.  \n  \n// <Additional internal code executes here>  \n  \nregisterPerf(System.timeNow() -  _startMain,  total) // Register the script's overall performance info.  \n``\n\nNote that:\n\n-   This example is  **pseudocode**  that provides a basic outline of the  **internal calculations**  the Profiler applies to collect performance data. Saving this example in the Pine Editor will result in a compilation error since  `long`,  `System.timeNow()`, and  `registerPerf()`  **do not**  represent Pine Script code.\n-   These internal calculations that the Profiler wraps a script with require  **additional**  computational resources, which is why a script‚Äôs runtime  **increases**  while profiling. Programmers should always interpret the results as  **estimates**  since they reflect a script‚Äôs performance with the extra calculations included.\n\nAfter running the wrapped script to collect performance data,  _additional_  internal calculations organize the results and display relevant information inside the Pine Editor:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-A-look-into-the-profilers-inner-workings-1.wt5GoYky_Z1cXiWC.webp)\n\nThe  _‚ÄúLine time‚Äù_  calculation for  [code blocks](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)  also occurs at this stage, as the Profiler cannot individually wrap  [loop](https://www.tradingview.com/pine-script-docs/language/loops/)  headers or the conditional statements in  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  or  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  structures. This field‚Äôs value represents the  _difference_  between a block‚Äôs total time and the sum of its local code times, which is why the ‚ÄúLine time‚Äù value for a  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  block or an  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  block with  `else if`  expressions represents the time spent on  **all**  the structure‚Äôs conditional statements, not just the block‚Äôs  _initial line_  of code. If a programmer requires more granular information for each conditional expression in such a block, they can reorganize the logic into a  _nested_  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure, as explained  [here](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results).\n\nNoteThe Profiler  **cannot**  collect individual performance data for any required  _internal_  calculations and display their results inside the Pine Editor. Consequently, the time values the Profiler displays for all code regions in a script  **do not**  add up to 100% of its total runtime.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "this.state",
      "lcg.generate",
      "math.avg",
      "color.purple",
      "indicator",
      "input",
      "plot",
      "var",
      "series",
      "method",
      "type",
      "switch",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-401",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Repetitive  profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#repetitive-profiling)",
    "content": "### [Profiling across  configurations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations)\n\nWhen a code‚Äôs  [time complexity](https://en.wikipedia.org/wiki/Time_complexity)  is not constant or its execution pattern varies with its inputs, function arguments, or available data, it‚Äôs often wise to profile the code across  _different configurations_  and data feeds for a more well-rounded perspective on its general performance.\n\nFor example, this simple script uses a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop to calculate the sum of squared distances between the current  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price and  `lengthInput`  previous prices, then plots the square root of that sum on each bar. In this case, the  `lengthInput`  directly impacts the calculation‚Äôs runtime since it determines the number of times the loop executes its local code:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Profiling across configurations demo\")  \n  \n//@variable The number of previous bars in the calculation. Directly affects the number of loop iterations.  \nint  lengthInput  =  input.int(25,  \"Length\",  1)  \n  \n//@variable The sum of squared distances from the current `close` to `lengthInput` past `close` values.  \nfloat  total  =  0.0  \n  \n// Look back across `lengthInput` bars and accumulate squared distances.  \nfor  i  =  1  to  lengthInput  \nfloat  distance  =  close  -  close[i]  \ntotal  +=  distance  *  distance  \n  \n// Plot the square root of the `total`.  \nplot(math.sqrt(total))  \n``\n\nLet‚Äôs try profiling this script with different  `lengthInput`  values. First, we‚Äôll use the default value of 25. The Profiler‚Äôs results for this specific run show that the script completed 20,685 executions in about 96.7 milliseconds:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-across-configurations-1.DH6uvleV_15wBst.webp)\n\nHere, we‚Äôve increased the input‚Äôs value to 50 in the script‚Äôs settings. The results for this run show that the script‚Äôs total runtime was 194.3 milliseconds, close to  _twice_  the time from the previous run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-across-configurations-2.ggfGlT9L_ZW6q7G.webp)\n\nIn the next run, we changed the input‚Äôs value to 200. This time, the Profiler‚Äôs results show that the script finished all executions in approximately 0.8 seconds, around  _four times_  the previous run‚Äôs time:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Profiling-across-configurations-3.CZLkQfeW_Z1lXDjU.webp)\n\nWe can see from these observations that the script‚Äôs runtime appears to scale  _linearly_  with the  `lengthInput`  value, excluding other factors that may affect performance, as one might expect since the bulk of the script‚Äôs calculations occur within the loop and the input‚Äôs value controls how many times the loop must execute.\n\nTipProfiling each configuration  _more than once_  helps reduce the impact of outliers while assessing how a script‚Äôs performance varies with its inputs or data. See the  [Repetitive profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#repetitive-profiling)  section below for more information.",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "tradingview.com",
      "input.int",
      "math.sqrt",
      "indicator",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-402",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimization)",
    "content": "### [Repetitive  profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#repetitive-profiling)\n\nThe runtime resources available to a script  _vary_  over time. Consequently, the time it takes to evaluate a code region, even one with constant  [complexity](https://en.wikipedia.org/wiki/Time_complexity),  _fluctuates_  across executions, and the cumulative performance results shown by the Profiler  **will vary**  with each independent script run.\n\nUsers can enhance their analysis by  _restarting_  a script several times and profiling each independent run. Averaging the results from each profiled run and evaluating the dispersion of runtime results can help users establish more robust performance benchmarks and reduce the impact of  _outliers_  (abnormally long or short runtimes) in their conclusions.\n\nIncorporating a  _dummy input_  (i.e., an input that does nothing) into a script‚Äôs code is a simple technique that enables users to  _restart_  it while profiling. The input will not directly affect any calculations or outputs. However, as the user changes its value in the script‚Äôs settings, the script restarts and the Profiler re-analyzes the executed code.\n\nFor example, this script  [queues](https://www.tradingview.com/pine-script-docs/language/arrays/#using-an-array-as-a-queue)  pseudorandom values with a constant seed through an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  with a fixed size, and it calculates and plots the  [array.avg()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.avg)  value on each bar. For profiling purposes, the script includes a  `dummyInput`  variable with an  [input.int()](https://www.tradingview.com/pine-script-reference/v6/#fun_input.int)  value assigned to it. The input does nothing in the code aside from allowing us to  _restart_  the script each time we change its value:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Repetitive profiling demo\")  \n  \n//@variable An input not connected to script calculations. Changing its value in the \"Inputs\" tab restarts the script.  \nint  dummyInput  =  input.int(0,  \"Dummy input\")  \n  \n//@variable An array of pseudorandom values.  \nvar  array<float> randValues  =  array.new<float>(2500,  0.0)  \n  \n// Push a new `math.random()` value with a fixed `seed` into the `randValues` array and remove the oldest value.  \narray.push(randValues,  math.random(seed  =  12345))  \narray.shift(randValues)  \n  \n// Plot the average of all elements in the `randValues` array.  \nplot(array.avg(randValues),  \"Pseudorandom average\")  \n``\n\nAfter the first script run, the Profiler shows that it took 308.6 milliseconds to execute across all of the chart‚Äôs data:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Repetitive-profiling-1.CfionGK2_pmOYe.webp)\n\nNow, let‚Äôs change the dummy input‚Äôs value in the script‚Äôs settings to restart it without changing the calculations. This time, it completed the same code executions in 424.6 milliseconds, 116 milliseconds longer than the previous run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Repetitive-profiling-2.LouNiZpq_o9WWS.webp)\n\nRestarting the script again yields another new result. On the third run, the script finished all code executions in 227.4 milliseconds, the shortest time so far:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Pine-profiler-Repetitive-profiling-3.UGJOj4nF_Z1p4czi.webp)\n\nAfter repeating this process several times and documenting the results from each run, one can manually calculate their  _average_  to estimate the script‚Äôs expected total runtime:\n\n`AverageTime = (time1 + time2 + ... + timeN) / N`\n\nNoticeWhether profiling a single script run or multiple, it‚Äôs crucial to understand that  **results will vary**. Averaging results across several profiled script runs can help programmers derive more stable performance estimates. However, those estimates do not necessarily indicate how the script will perform in the future.",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "i.e",
      "array.avg",
      "fun_array.avg",
      "input.int",
      "fun_input.int",
      "tradingview.com",
      "array.new",
      "math.random",
      "array.push",
      "array.shift",
      "indicator",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-403",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Using  built-ins](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#using-built-ins)",
    "content": "## [Optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimization)\n\n_Code optimization_, not to be confused with indicator or strategy optimization, involves modifying a script‚Äôs source code for improved execution time, resource efficiency, and scalability. Programmers may use various approaches to optimize a script when they need enhanced runtime performance, depending on what a script‚Äôs calculations entail.\n\nFundamentally, most techniques one will use to optimize Pine code involve  _reducing_  the number of times critical calculations occur or  _replacing_  significant calculations with simplified formulas or built-ins. Both of these paradigms often overlap.\n\nThe following sections explain several straightforward concepts programmers can apply to optimize their Pine Script code.\n\nTipBefore looking for ways to optimize a script,  [profile it](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  to gauge its performance and identify the  **critical code regions**  that can benefit the most from optimization.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "strategy",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-404",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Reducing  repetition](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-repetition)",
    "content": "### [Using  built-ins](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#using-built-ins)\n\nPine Script features a variety of  _built-in_  functions and variables that help streamline script creation. Many of Pine‚Äôs built-ins feature internal optimizations to help maximize efficiency and minimize execution time. As such, one of the simplest ways to optimize Pine code is to utilize these efficient built-ins in a script‚Äôs calculations when possible.\n\nLet‚Äôs look at an example where one can replace user-defined calculations with a concise built-in call to substantially improve performance. Suppose a programmer wants to calculate the highest value of a series over a specified number of bars. Someone not familiar with all of Pine‚Äôs built-ins might approach the task using a code like the following, which uses a  [loop](https://www.tradingview.com/pine-script-docs/language/loops/)  on each bar to compare  `length`  historical values of a  `source`  series:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@variable A user-defined function to calculate the highest `source` value over `length` bars.  \npineHighest(float  source,  int  length) =>  \nfloat  result  =  na  \nif  bar_index  +  1  >=  length  \nresult  :=  source  \nif  length  >  1  \nfor  i  =  1  to  length  -  1  \nresult  :=  math.max(result,  source[i])  \nresult  \n``\n\nAlternatively, one might devise a more optimized Pine function by reducing the number of times the loop executes, as iterating over the history of the  `source`  to achieve the result is only necessary when specific conditions occur:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@variable A faster user-defined function to calculate the highest `source` value over `length` bars.  \n// This version only requires a loop when the highest value is removed from the window, the `length`  \n// changes, or when the number of bars first becomes sufficient to calculate the result.  \nfasterPineHighest(float  source,  int  length) =>  \nvar  float  result  =  na  \nif  source[length] ==  result  or  length  !=  length[1] or  bar_index  +  1  ==  length  \nresult  :=  source  \nif  length  >  1  \nfor  i  =  1  to  length  -  1  \nresult  :=  math.max(result,  source[i])  \nelse  \nresult  :=  math.max(result,  source)  \nresult  \n``\n\nThe built-in  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  function will outperform  **both**  of these implementations, as its internal calculations are highly optimized for efficient execution. Below, we created a script that plots the results of calling  `pineHighest()`,  `fasterPineHighest()`, and  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  to compare their performance using the  [Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Using built-ins demo\")  \n  \n//@variable A user-defined function to calculate the highest `source` value over `length` bars.  \npineHighest(float  source,  int  length) =>  \nfloat  result  =  na  \nif  bar_index  +  1  >=  length  \nresult  :=  source  \nif  length  >  1  \nfor  i  =  1  to  length  -  1  \nresult  :=  math.max(result,  source[i])  \nresult  \n  \n//@variable A faster user-defined function to calculate the highest `source` value over `length` bars.  \n// This version only requires a loop when the highest value is removed from the window, the `length`  \n// changes, or when the number of bars first becomes sufficient to calculate the result.  \nfasterPineHighest(float  source,  int  length) =>  \nvar  float  result  =  na  \nif  source[length] ==  result  or  length  !=  length[1] or  bar_index  +  1  ==  length  \nresult  :=  source  \nif  length  >  1  \nfor  i  =  1  to  length  -  1  \nresult  :=  math.max(result,  source[i])  \nelse  \nresult  :=  math.max(result,  source)  \nresult  \n  \nplot(pineHighest(close,  20))  \nplot(fasterPineHighest(close,  20))  \nplot(ta.highest(close,  20))  \n``\n\nThe  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  over 20,735 script executions show the call to  `pineHighest()`  took the most time to execute, with a runtime of 57.9 milliseconds, about 69.3% of the script‚Äôs total runtime. The  `fasterPineHighest()`  call performed much more efficiently, as it only took about 16.9 milliseconds, approximately 20.2% of the total runtime, to calculate the same values.\n\nThe most efficient  _by far_, however, was the  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  call, which only required 3.2 milliseconds (~3.8% of the total runtime) to execute across all the chart‚Äôs data and compute the same values in this run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Using-built-ins-1.CXnfIZo4_ZWjpAS.webp)\n\nWhile these results effectively demonstrate that the built-in function outperforms our  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  with a small  `length`  argument of 20, it‚Äôs crucial to consider that the calculations required by the functions  _will vary_  with the argument‚Äôs value. Therefore, we can profile the code while using  [different arguments](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations)  to gauge how its runtime scales.\n\nHere, we changed the  `length`  argument in each function call from 20 to 200 and  [profiled the script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  again to observe the changes in performance. The time spent on the  `pineHighest()`  function in this run increased to about 0.6 seconds (~86% of the total runtime), and the time spent on the  `fasterPineHighest()`  function increased to about 75 milliseconds. The  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  function, on the other hand,  _did not_  experience a substantial runtime change. It took about 5.8 milliseconds this time, only a couple of milliseconds more than the previous run.\n\nIn other words, while our  [user-defined functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  experienced significant runtime growth with a higher  `length`  argument in this run, the change in the built-in  [ta.highest()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.highest)  function‚Äôs runtime was relatively marginal in this case, thus further emphasizing its performance benefits:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Using-built-ins-2.wlIsvoLn_Z1yQ1xR.webp)\n\nNote that:\n\n-   In many scenarios, a script‚Äôs runtime can benefit from using built-ins where applicable. However, the relative performance edge achieved from using built-ins depends on a script‚Äôs  _high-impact code_  and the specific built-ins used. In any case, one should always  [profile their scripts](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script), preferably  [several times](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#repetitive-profiling), when exploring optimized solutions.\n-   The calculations performed by the functions in this example also depend on the sequence of the chart‚Äôs data. Therefore, programmers can gain further insight into their general performance by profiling the script across  [different datasets](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations)  as well.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "math.max",
      "ta.highest",
      "fun_ta.highest",
      "indicator",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "doc-405",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Minimizing ‚Äã`request.*()`‚Äã calls](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-request-calls)",
    "content": "### [Reducing  repetition](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-repetition)\n\nThe Pine Script compiler can automatically simplify some types of  [repetitive code](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#insignificant-unused-and-redundant-code)  without a programmer‚Äôs intervention. However, this automatic process has its limitations. If a script contains repetitive calculations that the compiler  _cannot_  reduce, programmers can reduce the repetition  _manually_  to improve their script‚Äôs performance.\n\nFor example, this script contains a  `valuesAbove()`  [method](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  that counts the number of elements in an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  above the element at a specified index. The script plots the number of values above the element at the last index of a  `data`  array with a calculated  `plotColor`. It calculates the  `plotColor`  within a  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  structure that calls  `valuesAbove()`  in all 10 of its conditional expressions:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing repetition demo\")  \n  \n//@function Counts the number of elements in `this` array above the element at a specified `index`.  \nmethod  valuesAbove(array<float> this,  int  index) =>  \nint  result  =  0  \nfloat  reference  =  this.get(index)  \nfor [i,  value] in  this  \nif  i  ==  index  \ncontinue  \nif  value  >  reference  \nresult  +=  1  \nresult  \n  \n//@variable An array containing the most recent 100 `close` prices.  \nvar  array<float> data  =  array.new<float>(100)  \ndata.push(close)  \ndata.shift()  \n  \n//@variable Returns `color.purple` with a varying transparency based on the `valuesAbove()`.  \ncolor  plotColor  =  switch  \ndata.valuesAbove(99) <=  10  =>  color.new(color.purple,  90)  \ndata.valuesAbove(99) <=  20  =>  color.new(color.purple,  80)  \ndata.valuesAbove(99) <=  30  =>  color.new(color.purple,  70)  \ndata.valuesAbove(99) <=  40  =>  color.new(color.purple,  60)  \ndata.valuesAbove(99) <=  50  =>  color.new(color.purple,  50)  \ndata.valuesAbove(99) <=  60  =>  color.new(color.purple,  40)  \ndata.valuesAbove(99) <=  70  =>  color.new(color.purple,  30)  \ndata.valuesAbove(99) <=  80  =>  color.new(color.purple,  20)  \ndata.valuesAbove(99) <=  90  =>  color.new(color.purple,  10)  \ndata.valuesAbove(99) <=  100  =>  color.new(color.purple,  0)  \n  \n// Plot the number values in the `data` array above the value at its last index.  \nplot(data.valuesAbove(99),  color  =  plotColor,  style  =  plot.style_area)  \n``\n\nThe  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  for this script show that it spent about 2.5 seconds executing 21,201 times. The code regions with the highest impact on the script‚Äôs runtime are the  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop within the  `valuesAbove()`  local scope starting on line 8 and the  [switch](https://www.tradingview.com/pine-script-reference/v6/#kw_switch)  block that starts on line 21:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Reducing-repetition-1.DzXiqnj9_Z1IB5Dn.webp)\n\nNotice that the number of executions shown for the local code within  `valuesAbove()`  is substantially  _greater_  than the number shown for the code in the script‚Äôs global scope, as the script calls the method up to 11 times per execution, and the results for a  [function‚Äôs local code](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#user-defined-function-calls)  reflect the  _combined_  time and executions from each separate call:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Reducing-repetition-2.QnMs1Dg3_ZE1OU8.webp)\n\nAlthough each  `valuesAbove()`  call uses the  _same_  arguments and returns the  _same_  result, the compiler cannot automatically reduce this code for us during translation. We will need to do the job ourselves. We can optimize this script by assigning the value of  `data.valuesAbove(99)`  to a  _variable_  and  _reusing_  the value in all other areas requiring the result.\n\nIn the version below, we modified the script by adding a  `count`  variable to reference the  `data.valuesAbove(99)`  value. The script uses this variable in the  `plotColor`  calculation and the  [plot()](https://www.tradingview.com/pine-script-reference/v6/#fun_plot)  call:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing repetition demo\")  \n  \n//@function Counts the number of elements in `this` array above the element at a specified `index`.  \nmethod  valuesAbove(array<float> this,  int  index) =>  \nint  result  =  0  \nfloat  reference  =  this.get(index)  \nfor [i,  value] in  this  \nif  i  ==  index  \ncontinue  \nif  value  >  reference  \nresult  +=  1  \nresult  \n  \n//@variable An array containing the most recent 100 `close` prices.  \nvar  array<float> data  =  array.new<float>(100)  \ndata.push(close)  \ndata.shift()  \n  \n//@variable The number values in the `data` array above the value at its last index.  \nint  count  =  data.valuesAbove(99)  \n  \n//@variable Returns `color.purple` with a varying transparency based on the `valuesAbove()`.  \ncolor  plotColor  =  switch  \ncount  <=  10  =>  color.new(color.purple,  90)  \ncount  <=  20  =>  color.new(color.purple,  80)  \ncount  <=  30  =>  color.new(color.purple,  70)  \ncount  <=  40  =>  color.new(color.purple,  60)  \ncount  <=  50  =>  color.new(color.purple,  50)  \ncount  <=  60  =>  color.new(color.purple,  40)  \ncount  <=  70  =>  color.new(color.purple,  30)  \ncount  <=  80  =>  color.new(color.purple,  20)  \ncount  <=  90  =>  color.new(color.purple,  10)  \ncount  <=  100  =>  color.new(color.purple,  0)  \n  \n// Plot the `count`.  \nplot(count,  color  =  plotColor,  style  =  plot.style_area)  \n``\n\nWith this modification, the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  show a significant improvement in performance, as the script now only needs to evaluate the  `valuesAbove()`  call  **once**  per execution rather than up to 11 separate times:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Reducing-repetition-3.Nge1aqtk_2w60SG.webp)\n\nNote that:\n\n-   Since this script only calls  `valuesAbove()`  once, the  [method‚Äôs](https://www.tradingview.com/pine-script-docs/language/methods/#user-defined-methods)  local code will now reflect the results from that specific call. See  [this section](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#user-defined-function-calls)  to learn more about interpreting profiled function and method call results.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "this.get",
      "array.new",
      "data.push",
      "data.shift",
      "color.purple",
      "data.values",
      "color.new",
      "plot.style_area",
      "indicator",
      "plot",
      "var",
      "method",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-406",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Avoiding  redrawing](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#avoiding-redrawing)",
    "content": "### [Minimizing ‚Äã`request.*()`‚Äã calls](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-request-calls)\n\nThe built-in functions in the  `request.*()`  namespace allow scripts to retrieve data from  [other contexts](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/). While these functions provide utility in many applications, it‚Äôs important to consider that each call to these functions can have a significant impact on a script‚Äôs resource usage.\n\nA single script can contain up to 40 unique calls to the  `request.*()`  family of functions, or up to 64 if the user has the  [Ultimate plan](https://www.tradingview.com/pricing/). However, we recommend programmers aim to keep their scripts‚Äô  `request.*()`  calls far  _below_  this limit to keep the performance impact of their data requests as low as possible.\n\nWhen a script requests the values of several expressions from the  _same_  context with multiple  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  or  [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf)  calls, one effective way to optimize such requests is to  _condense_  them into a single  `request.*()`  call that uses a  [tuple](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#tuples)  as its  `expression`  argument. This optimization not only helps improve the runtime of the requests; it also helps reduce the script‚Äôs  _memory usage_  and compiled size.\n\nAs a simple example, the following script requests nine  [ta.percentrank()](https://www.tradingview.com/pine-script-reference/v6/#fun_ta.percentrank)  values with different lengths from a specified symbol using nine separate calls to  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security). It then  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  all nine requested values on the chart to utilize them in the outputs:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Minimizing `request.*()` calls demo\")  \n  \n//@variable The symbol to request data from.  \nstring  symbolInput  =  input.symbol(\"BINANCE:BTCUSDT\",  \"Symbol\")  \n  \n// Request 9 `ta.percentrank()` values from the `symbolInput` context using 9 `request.security()` calls.  \nfloat  reqRank1  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  10))  \nfloat  reqRank2  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  20))  \nfloat  reqRank3  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  30))  \nfloat  reqRank4  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  40))  \nfloat  reqRank5  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  50))  \nfloat  reqRank6  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  60))  \nfloat  reqRank7  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  70))  \nfloat  reqRank8  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  80))  \nfloat  reqRank9  =  request.security(symbolInput,  timeframe.period,  ta.percentrank(close,  90))  \n  \n// Plot the `reqRank*` values.  \nplot(reqRank1)  \nplot(reqRank2)  \nplot(reqRank3)  \nplot(reqRank4)  \nplot(reqRank5)  \nplot(reqRank6)  \nplot(reqRank7)  \nplot(reqRank8)  \nplot(reqRank9)  \n``\n\nThe results from  [profiling the script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  show that it took the script 340.8 milliseconds to complete its requests and plot the values in this run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Minimizing-request-calls-1.Canv49So_1Cn30c.webp)\n\nSince all the  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  calls request data from the  **same context**, we can optimize the code‚Äôs resource usage by merging all of them into a single  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  call that uses a  [tuple](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#tuples)  as its  `expression`  argument:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Minimizing `request.*()` calls demo\")  \n  \n//@variable The symbol to request data from.  \nstring  symbolInput  =  input.symbol(\"BINANCE:BTCUSDT\",  \"Symbol\")  \n  \n// Request 9 `ta.percentrank()` values from the `symbolInput` context using a single `request.security()` call.  \n[reqRank1,  reqRank2,  reqRank3,  reqRank4,  reqRank5,  reqRank6,  reqRank7,  reqRank8,  reqRank9] =  \nrequest.security(  \nsymbolInput,  timeframe.period, [  \nta.percentrank(close,  10),  ta.percentrank(close,  20),  ta.percentrank(close,  30),  \nta.percentrank(close,  40),  ta.percentrank(close,  50),  ta.percentrank(close,  60),  \nta.percentrank(close,  70),  ta.percentrank(close,  80),  ta.percentrank(close,  90)  \n]  \n)  \n  \n// Plot the `reqRank*` values.  \nplot(reqRank1)  \nplot(reqRank2)  \nplot(reqRank3)  \nplot(reqRank4)  \nplot(reqRank5)  \nplot(reqRank6)  \nplot(reqRank7)  \nplot(reqRank8)  \nplot(reqRank9)  \n``\n\nAs we see below, the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  from running this version of the script show that it took 228.3 milliseconds this time, a decent improvement over the previous run:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Minimizing-request-calls-2.BZ75zb8R_Z21D1UV.webp)\n\nNote that:\n\n-   The computational resources available to a script  **fluctuate**  over time. As such, it‚Äôs typically a good idea to profile a script  [multiple times](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#repetitive-profiling)  to help solidify performance conclusions.\n-   Another way to request multiple values from the same context with a single  `request.*()`  call is to pass an  [object](https://www.tradingview.com/pine-script-docs/language/objects/)  of a  [user-defined type (UDT)](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types)  as the  `expression`  argument. See  [this section](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#user-defined-types)  of the  [Other timeframes and data](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/)  page to learn more about requesting  [UDTs](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types).\n-   Programmers can also reduce the total runtime of a  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security),  [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security_lower_tf), or  [request.seed()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.seed)  call by passing an argument to the function‚Äôs  `calc_bars_count`  parameter, which  _restricts_  the number of  _historical_  data points it can access from a context and execute required calculations on. In general, if calls to these  `request.*()`  functions retrieve  _more_  historical data than what a script  _needs_, limiting the requests with  `calc_bars_count`  can help improve the script‚Äôs performance.",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "request.security_lower_tf",
      "fun_request.security_lower_tf",
      "ta.percentrank",
      "fun_ta.percentrank",
      "tradingview.com",
      "input.symbol",
      "timeframe.period",
      "request.seed",
      "fun_request.seed",
      "indicator",
      "input",
      "plot",
      "var",
      "simple",
      "import",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-407",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Reducing drawing  updates](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-drawing-updates)",
    "content": "### [Avoiding  redrawing](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#avoiding-redrawing)\n\nPine Script‚Äôs  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  allow scripts to draw custom visuals on a chart that one cannot achieve through other outputs such as  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/). While these types provide greater visual flexibility, they also have a  _higher_  runtime and memory cost, especially when a script unnecessarily  _recreates_  drawings instead of directly updating their properties to change their appearance.\n\nMost  [drawing types](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types), excluding  [polylines](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#polylines), feature built-in  _setter functions_  in their namespaces that allow scripts to modify a drawing  _without_  deleting and recreating it. Utilizing these setters is typically less computationally expensive than creating a new drawing object when only  _specific properties_  require modification.\n\nFor example, the script below compares deleting and redrawing  [boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#boxes)  to using  `box.set*()`  functions. On the first bar, it declares the  `redrawnBoxes`  and  `updatedBoxes`  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  and executes a  [loop](https://www.tradingview.com/pine-script-docs/language/loops/)  to push 25  [box](https://www.tradingview.com/pine-script-reference/v6/#type_box)  elements into them.\n\nThe script uses a separate  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop to iterate across the  [arrays](https://www.tradingview.com/pine-script-docs/language/arrays/)  and update the drawings on each execution. It  _recreates_  the  [boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#boxes)  in the  `redrawnBoxes`  array using  [box.delete()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.delete)  and  [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.new), whereas it  _directly modifies_  the properties of the  [boxes](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#boxes)  in the  `updatedBoxes`  array using  [box.set_lefttop()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_lefttop)  and  [box.set_rightbottom()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_rightbottom). Both approaches achieve the same visual result. However, the latter is more efficient:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Avoiding redrawing demo\")  \n  \n//@variable An array of `box` IDs deleted with `box.delete()` and redrawn with `box.new()` on each execution.  \nvar  array<box> redrawnBoxes  =  array.new<box>()  \n//@variable An array of `box` IDs with properties that update across executions update via `box.set*()` functions.  \nvar  array<box> updatedBoxes  =  array.new<box>()  \n  \n// Populate both arrays with 25 elements on the first bar.  \nif  barstate.isfirst  \nfor  i  =  1  to  25  \narray.push(redrawnBoxes,  box(na))  \narray.push(updatedBoxes,  box.new(na,  na,  na,  na))  \n  \nfor  i  =  0  to  24  \n// Calculate coordinates.  \nint  x  =  bar_index  -  i  \nfloat  y  =  close[i  +  1] -  close  \n// Get the `box` ID from each array at the `i` index.  \nbox  redrawnBox  =  redrawnBoxes.get(i)  \nbox  updatedBox  =  updatedBoxes.get(i)  \n// Delete the `redrawnBox`, create a new `box` ID, and replace that element in the `redrawnboxes` array.  \nbox.delete(redrawnBox)  \nredrawnBox  :=  box.new(x  -  1,  y,  x,  0.0)  \narray.set(redrawnBoxes,  i,  redrawnBox)  \n// Update the properties of the `updatedBox` rather than redrawing it.  \nbox.set_lefttop(updatedBox,  x  -  1,  y)  \nbox.set_rightbottom(updatedBox,  x,  0.0)  \n``\n\nThe results from  [profiling this script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  show that line 24, which contains the  [box.new()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.new)  call, is the  _heaviest_  line in the  [code block](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)  that executes on each bar, with a runtime close to  **double**  the combined time spent on the  [box.set_lefttop()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_lefttop)  and  [box.set_rightbottom()](https://www.tradingview.com/pine-script-reference/v6/#fun_box.set_rightbottom)  calls on lines 27 and 28:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Avoiding-redrawing-1.CVCJc2lm_ZJcTqr.webp)\n\nNote that:\n\n-   The number of executions shown for the loop‚Äôs  _local code_  is 25 times the number shown for the code in the script‚Äôs  _global scope_, as each execution of the loop statement triggers 25 executions of the local block.\n-   This script updates its drawings over  _all bars_  in the chart‚Äôs history for  **testing**  purposes. However, it does  **not**  actually need to execute all these historical updates since users will only see the  **final**  result from the  _last historical bar_  and the changes across  _realtime bars_. See the  [next section](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-drawing-updates)  to learn more.",
    "keywords": [
      "www.tradingview",
      "box.set",
      "box.delete",
      "fun_box.delete",
      "box.new",
      "fun_box.new",
      "box.set_lefttop",
      "fun_box.set_lefttop",
      "box.set_rightbottom",
      "fun_box.set_rightbottom",
      "tradingview.com",
      "array.new",
      "barstate.isfirst",
      "array.push",
      "array.set",
      "indicator",
      "plot",
      "var",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-408",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Storing calculated  values](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#storing-calculated-values)",
    "content": "### [Reducing drawing  updates](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-drawing-updates)\n\nWhen a script produces  [drawing objects](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  that change across  _historical bars_, users will only ever see their  **final results**  on those bars since the script completes its historical executions when it first loads on the chart. The only time one will see such drawings  _evolve_  across executions is during  _realtime bars_, as new data flows in.\n\nSince the evolving outputs from dynamic  [drawings](https://www.tradingview.com/pine-script-docs/language/type-system/#drawing-types)  on historical bars are  **never visible**  to a user, one can often improve a script‚Äôs performance by  _eliminating_  the historical updates that don‚Äôt impact the final results.\n\nFor example, this script creates a  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table)  with two columns and 21 rows to visualize the history of an  [RSI](https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/)  in a paginated, tabular format. The script initializes the cells of the  `infoTable`  on the  [first bar](https://www.tradingview.com/pine-script-docs/concepts/bar-states/#barstateisfirst), and it references the history of the calculated  `rsi`  to update the  `text`  and  `bgcolor`  of the cells in the second column within a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop on each bar:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing drawing updates demo\")  \n  \n//@variable The first offset shown in the paginated table.  \nint  offsetInput  =  input.int(0,  \"Page\",  0,  249) *  20  \n  \n//@variable A table that shows the history of RSI values.  \nvar  table  infoTable  =  table.new(position.top_right,  2,  21,  border_color  =  chart.fg_color,  border_width  =  1)  \n// Initialize the table's cells on the first bar.  \nif  barstate.isfirst  \ntable.cell(infoTable,  0,  0,  \"Offset\",  text_color  =  chart.fg_color)  \ntable.cell(infoTable,  1,  0,  \"RSI\",  text_color  =  chart.fg_color)  \nfor  i  =  0  to  19  \ntable.cell(infoTable,  0,  i  +  1,  str.tostring(offsetInput  +  i))  \ntable.cell(infoTable,  1,  i  +  1)  \n  \nfloat  rsi  =  ta.rsi(close,  14)  \n  \n// Update the history shown in the `infoTable` on each bar.  \nfor  i  =  0  to  19  \nfloat  historicalRSI  =  rsi[offsetInput  +  i]  \ntable.cell_set_text(infoTable,  1,  i  +  1,  str.tostring(historicalRSI))  \ntable.cell_set_bgcolor(  \ninfoTable,  1,  i  +  1,  color.from_gradient(historicalRSI,  30,  70,  color.red,  color.green)  \n)  \n  \nplot(rsi,  \"RSI\")  \n``\n\nAfter  [profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  the script, we see that the code with the highest impact on performance is the  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop that starts on line 20, i.e., the  [code block](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)  that updates the table‚Äôs cells:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Reducing-drawing-updates-1.DGjGYc9o_Z2h4bJz.webp)\n\nThis critical code region executes  **excessively**  across the chart‚Äôs history, as users will only see the  [table‚Äôs](https://www.tradingview.com/pine-script-docs/visuals/tables/)  **final**  historical result. The only time that users will see the  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table)  update is on the  **last historical bar**  and across all subsequent  **realtime bars**. Therefore, we can optimize this script‚Äôs resource usage by restricting the executions of this code to only the  [last available bar](https://www.tradingview.com/pine-script-docs/concepts/bar-states/#barstateislast).\n\nIn this script version, we placed the  [loop](https://www.tradingview.com/pine-script-docs/language/loops/)  that updates the  [table](https://www.tradingview.com/pine-script-reference/v6/#type_table)  cells within an  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if)  structure that uses  [barstate.islast](https://www.tradingview.com/pine-script-reference/v6/#var_barstate.islast)  as its condition, effectively restricting the code block‚Äôs executions to only the last historical bar and all realtime bars. Now, the script  _loads_  more efficiently since all the table‚Äôs calculations only require  **one**  historical execution:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Reducing-drawing-updates-2.DVDSH-lG_Z1AqBk6.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing drawing updates demo\")  \n  \n//@variable The first offset shown in the paginated table.  \nint  offsetInput  =  input.int(0,  \"Page\",  0,  249) *  20  \n  \n//@variable A table that shows the history of RSI values.  \nvar  table  infoTable  =  table.new(position.top_right,  2,  21,  border_color  =  chart.fg_color,  border_width  =  1)  \n// Initialize the table's cells on the first bar.  \nif  barstate.isfirst  \ntable.cell(infoTable,  0,  0,  \"Offset\",  text_color  =  chart.fg_color)  \ntable.cell(infoTable,  1,  0,  \"RSI\",  text_color  =  chart.fg_color)  \nfor  i  =  0  to  19  \ntable.cell(infoTable,  0,  i  +  1,  str.tostring(offsetInput  +  i))  \ntable.cell(infoTable,  1,  i  +  1)  \n  \nfloat  rsi  =  ta.rsi(close,  14)  \n  \n// Update the history shown in the `infoTable` on the last available bar.  \nif  barstate.islast  \nfor  i  =  0  to  19  \nfloat  historicalRSI  =  rsi[offsetInput  +  i]  \ntable.cell_set_text(infoTable,  1,  i  +  1,  str.tostring(historicalRSI))  \ntable.cell_set_bgcolor(  \ninfoTable,  1,  i  +  1,  color.from_gradient(historicalRSI,  30,  70,  color.red,  color.green)  \n)  \n  \nplot(rsi,  \"RSI\")  \n``\n\nNote that:\n\n-   The script will still update the cells when new  **realtime**  updates come in, as users can observe those changes on the chart, unlike the changes that the script used to execute across historical bars.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "table.new",
      "position.top_right",
      "chart.fg_color",
      "barstate.isfirst",
      "table.cell",
      "str.tostring",
      "ta.rsi",
      "table.cell_set_text",
      "table.cell_set_bgcolor",
      "color.from_gradient",
      "color.red",
      "color.green",
      "i.e",
      "barstate.islast",
      "var_barstate.islast",
      "indicator",
      "input",
      "plot",
      "bgcolor",
      "var",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-409",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Eliminating  loops](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#eliminating-loops)",
    "content": "### [Storing calculated  values](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#storing-calculated-values)\n\nWhen a script performs a critical calculation that changes  _infrequently_  throughout all executions, one can reduce its runtime by  **saving the result**  to a variable declared with the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  or  [varip](https://www.tradingview.com/pine-script-reference/v6/#kw_varip)  keywords and  **only**  updating the value if the calculation changes. If the script calculates  _multiple_  values excessively, one can store them within  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections),  [matrices](https://www.tradingview.com/pine-script-docs/language/matrices/), and  [maps](https://www.tradingview.com/pine-script-docs/language/maps/)  or  [objects](https://www.tradingview.com/pine-script-docs/language/objects/)  of  [user-defined types](https://www.tradingview.com/pine-script-docs/language/type-system/#user-defined-types).\n\nLet‚Äôs look at an example. This script calculates a weighted moving average with custom weights based on a generalized  [window function](https://en.wikipedia.org/wiki/Window_function). The  `numerator`  is the sum of weighted  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values, and the  `denominator`  is the sum of the calculated weights. The script uses a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop that iterates  `lengthInput`  times to calculate these sums, then it plots their ratio, i.e., the resulting average:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Storing calculated values demo\",  overlay  =  true)  \n  \n//@variable The number of bars in the weighted average calculation.  \nint  lengthInput  =  input.int(50,  \"Length\",  1,  5000)  \n//@variable Window coefficient.  \nfloat  coefInput  =  input.float(0.5,  \"Window coefficient\",  0.0,  1.0,  0.01)  \n  \n//@variable The sum of weighted `close` prices.  \nfloat  numerator  =  0.0  \n//@variable The sum of weights.  \nfloat  denominator  =  0.0  \n  \n//@variable The angular step in the cosine calculation.  \nfloat  step  =  2.0  *  math.pi  /  lengthInput  \n// Accumulate weighted sums.  \nfor  i  =  0  to  lengthInput  -  1  \nfloat  weight  =  coefInput  - (1  -  coefInput) *  math.cos(step  *  i)  \nnumerator  +=  close[i] *  weight  \ndenominator  +=  weight  \n  \n// Plot the weighted average result.  \nplot(numerator  /  denominator,  \"Weighted average\",  color.purple,  3)  \n``\n\nAfter  [profiling](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script)  the script‚Äôs performance over our chart‚Äôs data, we see that it took about 241.3 milliseconds to calculate the default 50-bar average across 20,155 chart updates, and the critical code with the  _highest impact_  on the script‚Äôs performance is the loop  [block](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#code-block-results)  that starts on line 17:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Storing-calculated-values-1.Db6QOvTY_1SK8Tz.webp)\n\nSince the number of loop iterations  _depends_  on the  `lengthInput`  value, let‚Äôs test how its runtime scales with  [another configuration](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations)  requiring heavier looping. Here, we set the value to 2500. This time, the script took about 12 seconds to complete all of its executions:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Storing-calculated-values-2.DsxEbDvA_DT4zd.webp)\n\nNow that we‚Äôve pinpointed the script‚Äôs  _high-impact_  code and established a benchmark to improve, we can inspect the critical code block to identify optimization opportunities. After examining the calculations, we can observe the following:\n\n-   The only value that causes the  `weight`  calculation on line 18 to vary across loop iterations is the  _loop index_. All other values in its calculation remain consistent. Consequently, the  `weight`  calculated on each loop iteration  **does not vary**  across chart bars. Therefore, rather than calculating the weights on  **every update**, we can calculate them  **once**, on the first bar, and  **store them**  in a  [collection](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  for future access across subsequent script executions.\n-   Since the weights never change, the resulting  `denominator`  never changes. Therefore, we can add the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword to the  [variable declaration](https://www.tradingview.com/pine-script-docs/language/variable-declarations/)  and only calculate its value  **once**  to reduce the number of executed addition assignment ([+=](https://www.tradingview.com/pine-script-reference/v6/#op_+=)) operations.\n-   Unlike the  `denominator`, we  **cannot**  store the  `numerator`  value to simplify its calculation since it consistently  _changes_  over time.\n\nIn the modified script below, we‚Äôve added a  `weights`  variable to reference an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  that stores each calculated  `weight`. This variable and the  `denominator`  both include the  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  keyword in their declarations, meaning the values assigned to them will  _persist_  throughout all script executions until explicitly reassigned. The script calculates their values using a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop that executes only on the  [first chart bar](https://www.tradingview.com/pine-script-docs/concepts/bar-states/#barstateisfirst). Across all other bars, it calculates the  `numerator`  using a  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop that references the  _saved values_  from the  `weights`  array:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Storing calculated values demo\",  overlay  =  true)  \n  \n//@variable The number of bars in the weighted average calculation.  \nint  lengthInput  =  input.int(50,  \"Length\",  1,  5000)  \n//@variable Window coefficient.  \nfloat  coefInput  =  input.float(0.5,  \"Window coefficient\",  0.0,  1.0,  0.01)  \n  \n//@variable An array that stores the `weight` values calculated on the first chart bar.  \nvar  array<float> weights  =  array.new<float>()  \n  \n//@variable The sum of weighted `close` prices.  \nfloat  numerator  =  0.0  \n//@variable The sum of weights. The script now only calculates this value on the first bar.  \nvar  float  denominator  =  0.0  \n  \n//@variable The angular step in the cosine calculation.  \nfloat  step  =  2.0  *  math.pi  /  lengthInput  \n  \n// Populate the `weights` array and calculate the `denominator` only on the first bar.  \nif  barstate.isfirst  \nfor  i  =  0  to  lengthInput  -  1  \nfloat  weight  =  coefInput  - (1  -  coefInput) *  math.cos(step  *  i)  \narray.push(weights,  weight)  \ndenominator  +=  weight  \n// Calculate the `numerator` on each bar using the stored `weights`.  \nfor [i,  w] in  weights  \nnumerator  +=  close[i] *  w  \n  \n// Plot the weighted average result.  \nplot(numerator  /  denominator,  \"Weighted average\",  color.purple,  3)  \n``\n\nWith this optimized structure, the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  show that our modified script with a high  `lengthInput`  value of 2500 took about 5.9 seconds to calculate across the same data, about  _half_  the time of our previous version:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Storing-calculated-values-3.k6QQwb-Z_ZqmRWt.webp)\n\nNote that:\n\n-   Although we‚Äôve significantly improved this script‚Äôs performance by saving its  _execution-invariant_  values to variables, it does still involve a higher computational cost with  **large**  `lengthInput`  values due to the remaining loop calculations that execute on each bar.\n-   Another, more  _advanced_  way one can further enhance this script‚Äôs performance is by storing the weights in a  _single-row_  [matrix](https://www.tradingview.com/pine-script-reference/v6/#type_matrix)  on the first bar, using an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  as a  [queue](https://www.tradingview.com/pine-script-docs/language/arrays/#using-an-array-as-a-queue)  to hold recent  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  values, then replacing the  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop with a call to  [matrix.mult()](https://www.tradingview.com/pine-script-reference/v6/#fun_matrix.mult). See the  [Matrices](https://www.tradingview.com/pine-script-docs/language/matrices/)  page to learn more about working with  `matrix.*()`  functions.",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "i.e",
      "tradingview.com",
      "input.int",
      "input.float",
      "math.pi",
      "math.cos",
      "color.purple",
      "array.new",
      "barstate.isfirst",
      "array.push",
      "matrix.mult",
      "fun_matrix.mult",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "varip",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-410",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Optimizing  loops](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimizing-loops)",
    "content": "### [Eliminating  loops](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#eliminating-loops)\n\n[Loops](https://www.tradingview.com/pine-script-docs/language/loops/)  allow Pine scripts to perform  _iterative_  calculations on each execution. Each time a loop activates, its local code may execute  _several times_, often leading to a  _substantial increase_  in resource usage.\n\nPine loops are necessary for  _some_  calculations, such as manipulating elements within  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  or looking backward through a dataset‚Äôs history to calculate values  _only_  obtainable on the current bar. However, in many other cases, programmers use loops when they  **don‚Äôt need to**, leading to suboptimal runtime performance. In such cases, one may eliminate unnecessary loops in any of the following ways, depending on what their calculations entail:\n\n-   Identifying simplified,  **loop-free expressions**  that achieve the same result without iteration\n-   Replacing a loop with optimized  [built-ins](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#using-built-ins)  where possible\n-   Distributing a loop‚Äôs iterations  _across bars_  when feasible rather than evaluating them all at once\n\nThis simple example contains an  `avgDifference()`  function that calculates the average difference between the current bar‚Äôs  `source`  value and all the values from  `length`  previous bars. The script calls this function to calculate the average difference between the current  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  price and  `lengthInput`  previous prices, then it  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  the result on the chart:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Eliminating loops demo\")  \n  \n//@variable The number of bars in the calculation.  \nint  lengthInput  =  input.int(20,  \"Length\",  1)  \n  \n//@function Calculates the average difference between the current `source` and `length` previous `source` values.  \navgDifference(float  source,  int  length) =>  \nfloat  diffSum  =  0.0  \nfor  i  =  1  to  length  \ndiffSum  +=  source  -  source[i]  \ndiffSum  /  length  \n  \nplot(avgDifference(close,  lengthInput))  \n``\n\nAfter inspecting the script‚Äôs  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  with the default settings, we see that it took about 64 milliseconds to execute 20,157 times:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Eliminating-loops-1.CagHTlaL_Z1XidNw.webp)\n\nSince we use the  `lengthInput`  as the  `length`  argument in the  `avgDifference()`  call and that argument controls how many times the loop inside the function must iterate, our script‚Äôs runtime will  **grow**  with the  `lengthInput`  value. Here, we set the input‚Äôs value to 2000 in the script‚Äôs settings. This time, the script completed its executions in about 3.8 seconds:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Eliminating-loops-2.GHOgXfCo_Z2hwC8b.webp)\n\nAs we see from these results, the  `avgDifference()`  function can be costly to call, depending on the specified  `lengthInput`  value, due to its  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop that executes on each bar. However,  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  are  **not**  necessary to achieve the output. To understand why, let‚Äôs take a closer look at the loop‚Äôs calculations. We can represent them with the following expression:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`(source  -  source[1]) + (source  -  source[2]) + ... + (source  -  source[length])  \n`\n\nNotice that it adds the  _current_  `source`  value  `length`  times. These iterative additions are not necessary. We can simplify that part of the expression to  `source * length`, which reduces it to the following:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`source  *  length  -  source[1] -  source[2] - ... - source[length]  \n`\n\nor equivalently:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`source  *  length  - (source[1] +  source[2] + ... + source[length])  \n`\n\nAfter simplifying and rearranging this representation of the loop‚Äôs calculations, we see that we can compute the result in a simpler way and  **eliminate**  the loop by subtracting the previous bar‚Äôs rolling sum ([math.sum()](https://www.tradingview.com/pine-script-reference/v6/#fun_math.sum)) of  `source`  values from the  `source * length`  value, i.e.:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`source  *  length  -  math.sum(source,  length)[1]  \n`\n\nThe  `fastAvgDifference()`  function below is a  **loop-free**  alternative to the original  `avgDifference()`  function that uses the above expression to calculate the sum of  `source`  differences, then divides the expression by the  `length`  to return the average difference:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@function A faster way to calculate the `avgDifference()` result.  \n// Eliminates the `for` loop using the relationship:  \n// `(x - x[1]) + (x - x[2]) + ... + (x - x[n]) = x * n - math.sum(x, n)[1]`.  \nfastAvgDifference(float  source,  int  length) =>  \n(source  *  length  -  math.sum(source,  length)[1]) /  length  \n``\n\nNow that we‚Äôve identified a potential optimized solution, we can compare the performance of  `fastAvgDifference()`  to the original  `avgDifference()`  function. The script below is a modified form of the previous version that plots the results from calling both functions with the  `lengthInput`  as the  `length`  argument:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Eliminating loops demo\")  \n  \n//@variable The number of bars in the calculation.  \nint  lengthInput  =  input.int(20,  \"Length\",  1)  \n  \n//@function Calculates the average difference between the current `source` and `length` previous `source` values.  \navgDifference(float  source,  int  length) =>  \nfloat  diffSum  =  0.0  \nfor  i  =  1  to  length  \ndiffSum  +=  source  -  source[i]  \ndiffSum  /  length  \n  \n//@function A faster way to calculate the `avgDifference()` result.  \n// Eliminates the `for` loop using the relationship:  \n// `(x - x[1]) + (x - x[2]) + ... + (x - x[n]) = x * n - math.sum(x, n)[1]`.  \nfastAvgDifference(float  source,  int  length) =>  \n(source  *  length  -  math.sum(source,  length)[1]) /  length  \n  \nplot(avgDifference(close,  lengthInput))  \nplot(fastAvgDifference(close,  lengthInput))  \n``\n\nThe  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  for the script with the default  `lengthInput`  of 20 show a substantial difference in runtime spent on the two function calls. The call to the original function took about 47.3 milliseconds to execute 20,157 times on this run, whereas our optimized function only took 4.5 milliseconds:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Eliminating-loops-3.DiuPpBDh_1dyGfx.webp)\n\nNow, let‚Äôs compare the performance with the  _heavier_  `lengthInput`  value of 2000. As before, the runtime spent on the  `avgDifference()`  function increased significantly. However, the time spent executing the  `fastAvgDifference()`  call remained very close to the result from the previous  [configuration](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-across-configurations). In other words, while our original function‚Äôs runtime scales directly with its  `length`  argument, our optimized function demonstrates relatively  _consistent_  performance since it does not require a loop:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Eliminating-loops-4.V8AwhZcD_23XFmP.webp)\n\nNoteNot all iterative calculations have loop-free alternatives. If the  **only**  way to achieve a calculation is through iteration, programmers can still aim to identify ways to optimize their loops for improved performance. See the  [Optimizing loops](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimizing-loops)  section below for more information.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.int",
      "math.sum",
      "fun_math.sum",
      "i.e",
      "indicator",
      "input",
      "plot",
      "var",
      "simple",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-411",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Minimizing historical buffer  calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-historical-buffer-calculations)",
    "content": "### [Optimizing  loops](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimizing-loops)\n\nAlthough Pine‚Äôs  [execution model](https://www.tradingview.com/pine-script-docs/language/execution-model/)  and the available built-ins often  _eliminate_  the need for  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  in many cases, there are still instances where a script  **will**  require  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  for some types of tasks, including:\n\n-   Manipulating  [collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections)  or executing calculations over a collection‚Äôs elements when the available built-ins  **will not**  suffice\n-   Performing calculations across historical bars that one  **cannot**  achieve with simplified  _loop-free_  expressions or optimized  _built-ins_\n-   Calculating values that are  **only**  obtainable through iteration\n\nWhen a script uses  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  that a programmer cannot  [eliminate](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#eliminating-loops), there are  [several techniques](https://en.wikipedia.org/wiki/Loop_optimization)  one can use to reduce their performance impact. This section explains two of the most common, useful techniques that can help improve a required loop‚Äôs efficiency.\n\nTipBefore identifying ways to  _optimize_  a loop, we recommend searching for ways to  [eliminate](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#eliminating-loops)  it first. If  **no solution**  exists that makes the loop unnecessary, then proceed with attempting to reduce its overhead.\n\n#### [Reducing loop  calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#reducing-loop-calculations)\n\nThe code executed within a  [loop‚Äôs](https://www.tradingview.com/pine-script-docs/language/loops/)  local scope can have a  **multiplicative**  impact on its overall runtime, as each time a loop statement executes, it will typically trigger  _several_  iterations of the local code. Therefore, programmers should strive to keep a loop‚Äôs calculations as simple as possible by eliminating unnecessary structures, function calls, and operations to minimize the performance impact, especially when the script must evaluate its loops  _numerous times_  throughout all its executions.\n\nFor example, this script contains a  `filteredMA()`  function that calculates a moving average of up to  `length`  unique  `source`  values, depending on the  `true`  elements in a specified  `mask`  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array). The function queues the unique  `source`  values into a  `data`  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array), uses a  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop to iterate over the  `data`  and calculate the  `numerator`  and  `denominator`  sums, then returns the ratio of those sums. Within the loop, it only adds values to the sums when the  `data`  element is not  [na](https://www.tradingview.com/pine-script-reference/v6/#var_na)  and the  `mask`  element at the  `index`  is  `true`. The script utilizes this  [user-defined function](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/)  to calculate the average of up to 100 unique  [close](https://www.tradingview.com/pine-script-reference/v6/#var_close)  prices filtered by a  `randMask`  and plots the result on the chart:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing loop calculations demo\",  overlay  =  true)  \n  \n//@function Calculates a moving average of up to `length` unique `source` values filtered by a `mask` array.  \nfilteredMA(float  source,  int  length,  array<bool> mask) =>  \n// Raise a runtime error if the size of the `mask` doesn't equal the `length`.  \nif  mask.size() !=  length  \nruntime.error(\"The size of the `mask` array used in the `filteredMA()` call must match the `length`.\")  \n//@variable An array containing `length` unique `source` values.  \nvar  array<float> data  =  array.new<float>(length)  \n// Queue unique `source` values into the `data` array.  \nif  not  data.includes(source)  \ndata.push(source)  \ndata.shift()  \n// The numerator and denominator of the average.  \nfloat  numerator  =  0.0  \nfloat  denominator  =  0.0  \n// Loop to calculate sums.  \nfor  item  in  data  \nif  na(item)  \ncontinue  \nint  index  =  array.indexof(data,  item)  \nif  mask.get(index)  \nnumerator  +=  item  \ndenominator  +=  1.0  \n// Return the average, or the last non-`na` average value if the current value is `na`.  \nfixnan(numerator  /  denominator)  \n  \n//@variable An array of 100 pseudorandom \"bool\" values.  \nvar  array<bool> randMask  =  array.new<bool>(100,  true)  \n// Push the first element from `randMask` to the end and queue a new pseudorandom value.  \nrandMask.push(randMask.shift())  \nrandMask.push(math.random(seed  =  12345) <  0.5)  \nrandMask.shift()  \n  \n// Plot the `filteredMA()` of up to 100 unique `close` values filtered by the `randMask`.  \nplot(filteredMA(close,  100,  randMask))  \n``\n\nAfter  [profiling the script](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script), we see it took about two seconds to execute 21,778 times. The code with the highest performance impact is the expression on line 37, which calls the  `filteredMA()`  function. Within the  `filteredMA()`  function‚Äôs scope, the  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop has the highest impact, with the  `index`  calculation in the loop‚Äôs scope (line 22) contributing the most to the loop‚Äôs runtime:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Optimizing-loops-Reducing-loop-calculations-1.DATOq5cw_2jUPjt.webp)\n\nThe above code demonstrates suboptimal usage of a  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop, as we  **do not**  need to call  [array.indexof()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.indexof)  to retrieve the  `index`  in this case. The  [array.indexof()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.indexof)  function can be  _costly_  to call within a loop since it must search through the  [array‚Äôs](https://www.tradingview.com/pine-script-docs/language/arrays/)  contents and locate the corresponding element‚Äôs index  _each time_  the script calls it.\n\nTo eliminate this costly call from our  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop, we can use the  _second form_  of the structure, which produces a  _tuple_  containing the  **index**  and the element‚Äôs value on each iteration:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`for [index,  item] in  data  \n`\n\nIn this version of the script, we removed the  [array.indexof()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.indexof)  call on line 22 since it is  **not**  necessary to achieve the intended result, and we changed the  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop to use the alternative form:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Reducing loop calculations demo\",  overlay  =  true)  \n  \n//@function Calculates a moving average of up to `length` unique `source` values filtered by a `mask` array.  \nfilteredMA(float  source,  int  length,  array<bool> mask) =>  \n// Raise a runtime error if the size of the `mask` doesn't equal the `length`.  \nif  mask.size() !=  length  \nruntime.error(\"The size of the `mask` array used in the `filteredMA()` call must match the `length`.\")  \n//@variable An array containing `length` unique `source` values.  \nvar  array<float> data  =  array.new<float>(length)  \n// Queue unique `source` values into the `data` array.  \nif  not  data.includes(source)  \ndata.push(source)  \ndata.shift()  \n// The numerator and denominator of the average.  \nfloat  numerator  =  0.0  \nfloat  denominator  =  0.0  \n// Loop to calculate sums.  \nfor [index,  item] in  data  \nif  na(item)  \ncontinue  \nif  mask.get(index)  \nnumerator  +=  item  \ndenominator  +=  1.0  \n// Return the average, or the last non-`na` average value if the current value is `na`.  \nfixnan(numerator  /  denominator)  \n  \n//@variable An array of 100 pseudorandom \"bool\" values.  \nvar  array<bool> randMask  =  array.new<bool>(100,  true)  \n// Push the first element from `randMask` to the end and queue a new pseudorandom value.  \nrandMask.push(randMask.shift())  \nrandMask.push(math.random(seed  =  12345) <  0.5)  \nrandMask.shift()  \n  \n// Plot the `filteredMA()` of up to 100 unique `close` values filtered by the `randMask`.  \nplot(filteredMA(close,  100,  randMask))  \n``\n\nWith this simple change, our loop is much more efficient, as it no longer needs to redundantly search through the  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array)  on each iteration to keep track of the index. The  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  from this script run show that it took only 0.6 seconds to complete its executions, a significant improvement over the previous version‚Äôs result:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Optimizing-loops-Reducing-loop-calculations-2.ChKixPxa_1dGXff.webp)\n\n#### [Loop-invariant code  motion](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#loop-invariant-code-motion)\n\n_Loop-invariant code_  is any code region within a  [loop‚Äôs](https://www.tradingview.com/pine-script-docs/language/loops/)  scope that produces an  **unchanging**  result on each iteration. When a script‚Äôs  [loops](https://www.tradingview.com/pine-script-docs/language/loops/)  contain loop-invariant code, it can substantially impact performance in some cases due to excessive,  **unnecessary**  calculations.\n\nProgrammers can optimize a loop with invariant code by  _moving_  the unchanging calculations  **outside**  the loop‚Äôs scope so the script only needs to evaluate them once per execution rather than repetitively.\n\nThe following example contains a  `featureScale()`  function that creates a rescaled version of an  [array](https://www.tradingview.com/pine-script-reference/v6/#type_array). Within the function‚Äôs  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop, it scales each element by calculating its distance from the  [array.min()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.min)  and dividing the value by the  [array.range()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.range). The script uses this function to create a  `rescaled`  version of a  `prices`  array, then  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  the difference between the array‚Äôs  [array.first()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.first)  and  [array.avg()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.avg)  method call results on the chart:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Loop-invariant code motion demo\")  \n  \n//@function Returns a feature scaled version of `this` array.  \nfeatureScale(array<float> this) =>  \narray<float> result  =  array.new<float>()  \nfor  item  in  this  \nresult.push((item  -  array.min(this)) /  array.range(this))  \nresult  \n  \n//@variable An array containing the most recent 100 `close` prices.  \nvar  array<float> prices  =  array.new<float>(100,  close)  \n// Queue the `close` through the `prices` array.  \nprices.unshift(close)  \nprices.pop()  \n  \n//@variable A feature scaled version of the `prices` array.  \narray<float> rescaled  =  featureScale(prices)  \n  \n// Plot the difference between the first element and the average value in the `rescaled` array.  \nplot(rescaled.first() -  rescaled.avg())  \n``\n\nAs we see below, the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  for this script after 20,187 executions show it completed its run in about 3.3 seconds. The code with the highest impact on performance is the line containing the  `featureScale()`  function call, and the function‚Äôs critical code is the  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop block starting on line 7:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Optimizing-loops-Loop-invariant-code-motion-1.BAn098-h_10uiO5.webp)\n\nUpon examining the loop‚Äôs calculations, we can see that the  [array.min()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.min)  and  [array.range()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.range)  calls on line 8 are  **loop-invariant**, as they will always produce the  **same result**  across each iteration. We can make our loop much more efficient by assigning the results from these calls to variables  **outside**  its scope and referencing them as needed.\n\nThe  `featureScale()`  function in the script below assigns the  [array.min()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.min)  and  [array.range()](https://www.tradingview.com/pine-script-reference/v6/#fun_array.range)  values to  `minValue`  and  `rangeValue`  variables  _before_  executing the  [for‚Ä¶in](https://www.tradingview.com/pine-script-reference/v6/#kw_for...in)  loop. Inside the loop‚Äôs local scope, it  _references_  the variables across its iterations rather than repetitively calling these  `array.*()`  functions:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Loop-invariant code motion demo\")  \n  \n//@function Returns a feature scaled version of `this` array.  \nfeatureScale(array<float> this) =>  \narray<float> result  =  array.new<float>()  \nfloat  minValue  =  array.min(this)  \nfloat  rangeValue  =  array.range(this)  \nfor  item  in  this  \nresult.push((item  -  minValue) /  rangeValue)  \nresult  \n  \n//@variable An array containing the most recent 100 `close` prices.  \nvar  array<float> prices  =  array.new<float>(100,  close)  \n// Queue the `close` through the `prices` array.  \nprices.unshift(close)  \nprices.pop()  \n  \n//@variable A feature scaled version of the `prices` array.  \narray<float> rescaled  =  featureScale(prices)  \n  \n// Plot the difference between the first element and the average value in the `rescaled` array.  \nplot(rescaled.first() -  rescaled.avg())  \n``\n\nAs we see from the script‚Äôs  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results), moving the  _loop-invariant_  calculations outside the loop leads to a substantial performance improvement. This time, the script completed its executions in only 289.3 milliseconds:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Optimizing-loops-Loop-invariant-code-motion-2.9LhBcnjw_Zn7pRo.webp)",
    "keywords": [
      "www.tradingview",
      "en.wikipedia",
      "tradingview.com",
      "mask.size",
      "runtime.error",
      "array.new",
      "data.includes",
      "data.push",
      "data.shift",
      "array.indexof",
      "mask.get",
      "math.random",
      "fun_array.indexof",
      "array.min",
      "fun_array.min",
      "array.range",
      "fun_array.range",
      "array.first",
      "fun_array.first",
      "array.avg",
      "fun_array.avg",
      "result.push",
      "prices.unshift",
      "prices.pop",
      "rescaled.first",
      "rescaled.avg",
      "indicator",
      "overlay",
      "plot",
      "var",
      "simple",
      "method",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-412",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Tips](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#tips)",
    "content": "### [Minimizing historical buffer  calculations](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#minimizing-historical-buffer-calculations)\n\nPine scripts create  _historical buffers_  for all variables and function calls their outputs depend on. Each buffer contains information about the range of historical values the script can access with the history-referencing operator  [[]](https://www.tradingview.com/pine-script-reference/v6/#op_%5B%5D).\n\nA script  _automatically_  determines the required buffer size for all its variables and function calls by analyzing the historical references executed during the  **first 244 bars**  in a dataset. When a script only references the history of a calculated value  _after_  those initial bars, it will  **restart**  its executions repetitively across previous bars with successively larger historical buffers until it either determines the appropriate size or raises a runtime error. Those repetitive executions can significantly increase a script‚Äôs runtime in some cases.\n\nWhen a script  _excessively_  executes across a dataset to calculate historical buffers, one effective way to improve its performance is  _explicitly_  defining suitable buffer sizes using the  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  function. With appropriate buffer sizes declared explicitly, the script does not need to re-execute across past data to determine the sizes.\n\nFor example, the script below uses a  [polyline](https://www.tradingview.com/pine-script-docs/visuals/lines-and-boxes/#polylines)  to draw a basic histogram representing the distribution of calculated  `source`  values over 500 bars. On the  [last available bar](https://www.tradingview.com/pine-script-docs/concepts/bar-states/#barstateislast), the script uses a  [for](https://www.tradingview.com/pine-script-reference/v6/#kw_for)  loop to look back through historical values of the calculated  `source`  series and determine the  [chart points](https://www.tradingview.com/pine-script-docs/language/type-system/#chart-points)  used by the  [polyline](https://www.tradingview.com/pine-script-reference/v6/#type_polyline)  drawing. It also  [plots](https://www.tradingview.com/pine-script-docs/visuals/plots/)  the value of  `bar_index + 1`  to verify the number of bars it executed across:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Minimizing historical buffer calculations demo\",  overlay  =  true)  \n  \n//@variable A polyline with points that form a histogram of `source` values.  \nvar  polyline  display  =  na  \n//@variable The difference Q3 of `high` prices and Q1 of `low` prices over 500 bars.  \nfloat  innerRange  =  ta.percentile_nearest_rank(high,  500,  75) -  ta.percentile_nearest_rank(low,  500,  25)  \n// Calculate the highest and lowest prices, and the total price range, over 500 bars.  \nfloat  highest  =  ta.highest(500)  \nfloat  lowest  =  ta.lowest(500)  \nfloat  totalRange  =  highest  -  lowest  \n  \n//@variable The source series for histogram calculation. Its value is the midpoint between the `open` and `close`.  \nfloat  source  =  math.avg(open,  close)  \n  \nif  barstate.islast  \npolyline.delete(display)  \n// Calculate the number of histogram bins and their size.  \nint  bins  =  int(math.round(5  *  totalRange  /  innerRange))  \nfloat  binSize  =  totalRange  /  bins  \n//@variable An array of chart points for the polyline.  \narray<chart.point> points  =  array.new<chart.point>(bins,  chart.point.new(na,  na,  na))  \n// Loop to build the histogram.  \nfor  i  =  0  to  499  \n//@variable The histogram bin number. Uses past values of the `source` for its calculation.  \n// The script must execute across all previous bars AGAIN to determine the historical buffer for  \n// `source`, as initial references to the calculated series occur AFTER the first 244 bars.  \nint  index  =  int((source[i] -  lowest) /  binSize)  \nif  na(index)  \ncontinue  \nchart.point  currentPoint  =  points.get(index)  \nif  na(currentPoint.index)  \npoints.set(index,  chart.point.from_index(bar_index  +  1, (index  +  0.5) *  binSize  +  lowest))  \ncontinue  \ncurrentPoint.index  +=  1  \n// Add final points to the `points` array and draw the new `display` polyline.  \npoints.unshift(chart.point.now(lowest))  \npoints.push(chart.point.now(highest))  \ndisplay  :=  polyline.new(points,  closed  =  true)  \n  \nplot(bar_index  +  1,  \"Number of bars\",  display  =  display.data_window)  \n``\n\nSince the script  _only_  references past  `source`  values on the  _last bar_, it will  **not**  construct a suitable historical buffer for the series within the first 244 bars on a larger dataset. Consequently, it will  **re-execute**  across all historical bars to identify the appropriate buffer size.\n\nAs we see from the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  after running the script across 20,320 bars, the number of  _global_  code executions was 162,560, which is  **eight times**  the number of chart bars. In other words, the script had to  _repeat_  the historical executions  **seven more times**  to determine the appropriate buffer for the  `source`  series in this case:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Minimizing-historical-buffer-calculations-1.Cyx3FoQJ_Z1xcPM1.webp)\n\nThis script will only reference the most recent 500  `source`  values on the last historical bar and all realtime bars. Therefore, we can help it establish the correct buffer  _without_  re-execution by defining a 500-bar referencing length with  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back).\n\nIn the following script version, we added  [max_bars_back(source, 500)](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  after the variable declaration to explicitly specify that the script will access up to 500 historical  `source`  values throughout its executions:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Minimizing historical buffer calculations demo\",  overlay  =  true)  \n  \n//@variable A polyline with points that form a histogram of `source` values.  \nvar  polyline  display  =  na  \n//@variable The difference Q3 of `high` prices and Q1 of `low` prices over 500 bars.  \nfloat  innerRange  =  ta.percentile_nearest_rank(high,  500,  75) -  ta.percentile_nearest_rank(low,  500,  25)  \n// Calculate the highest and lowest prices, and the total price range, over 500 bars.  \nfloat  highest  =  ta.highest(500)  \nfloat  lowest  =  ta.lowest(500)  \nfloat  totalRange  =  highest  -  lowest  \n  \n//@variable The source series for histogram calculation. Its value is the midpoint between the `open` and `close`.  \nfloat  source  =  math.avg(open,  close)  \n// Explicitly define a 500-bar historical buffer for the `source` to prevent recalculation.  \nmax_bars_back(source,  500)  \n  \nif  barstate.islast  \npolyline.delete(display)  \n// Calculate the number of histogram bins and their size.  \nint  bins  =  int(math.round(5  *  totalRange  /  innerRange))  \nfloat  binSize  =  totalRange  /  bins  \n//@variable An array of chart points for the polyline.  \narray<chart.point> points  =  array.new<chart.point>(bins,  chart.point.new(na,  na,  na))  \n// Loop to build the histogram.  \nfor  i  =  0  to  499  \n//@variable The histogram bin number. Uses past values of the `source` for its calculation.  \n// Since the `source` now has an appropriate predefined buffer, the script no longer needs  \n// to recalculate across previous bars to determine the referencing length.  \nint  index  =  int((source[i] -  lowest) /  binSize)  \nif  na(index)  \ncontinue  \nchart.point  currentPoint  =  points.get(index)  \nif  na(currentPoint.index)  \npoints.set(index,  chart.point.from_index(bar_index  +  1, (index  +  0.5) *  binSize  +  lowest))  \ncontinue  \ncurrentPoint.index  +=  1  \n// Add final points to the `points` array and draw the new `display` polyline.  \npoints.unshift(chart.point.now(lowest))  \npoints.push(chart.point.now(highest))  \ndisplay  :=  polyline.new(points,  closed  =  true)  \n  \nplot(bar_index  +  1,  \"Number of bars\",  display  =  display.data_window)  \n``\n\nWith this change, our script no longer needs to re-execute across all the historical data to determine the buffer size. As we see in the  [profiled results](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#interpreting-profiled-results)  below, the number of global code executions now aligns with the number of chart bars, and the script took substantially less time to complete all of its historical executions:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Optimization-Minimizing-historical-buffer-calculations-2.DPrfVLfJ_Z1XIu4W.webp)\n\nNote that:\n\n-   This script only requires up to the most recent 501 historical bars to calculate its drawing output. In this case, another way to optimize resource usage is to include  `calc_bars_count = 501`  in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  function, which reduces unnecessary script executions by restricting the historical data the script can calculate across to 501 bars.\n\nNotice\n\nWhen using  [max_bars_back()](https://www.tradingview.com/pine-script-reference/v6/#fun_max_bars_back)  to explicitly define the buffer size for a series, ensure that the script  **does not**  reference more past bars than specified during its executions. If the specified buffer size is insufficient, the runtime system still re-executes the script across historical bars to calculate an appropriate size, leading to increased resource use.\n\n  \n\nAdditionally, it‚Äôs crucial to understand that large buffers elevate a script‚Äôs  _memory use_. Choosing buffer sizes that are larger than what a script needs is a suboptimal practice that yields no benefit. In some cases, excessively large buffers can cause a script to exceed its memory limits. Therefore, when defining a buffer‚Äôs size, choose the  **smallest**  possible size that accommodates the script‚Äôs historical references. For example, if a script requires only 500 past values from a series, set the buffer‚Äôs size to 500 bars. Setting the buffer to include 5000 bars in such a case causes the script to use significantly more memory than necessary.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "ta.percentile_nearest_rank",
      "ta.highest",
      "ta.lowest",
      "math.avg",
      "barstate.islast",
      "polyline.delete",
      "math.round",
      "chart.point",
      "array.new",
      "points.get",
      "points.set",
      "points.unshift",
      "points.push",
      "polyline.new",
      "display.data_window",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-413",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Working around Profiler  overhead](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#working-around-profiler-overhead)",
    "content": "## [Tips](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#tips)",
    "keywords": [
      "www.tradingview"
    ]
  },
  {
    "id": "doc-414",
    "type": "documentation",
    "source": "writing_scripts/profiling_and_optimization.md",
    "section": "writing_scripts",
    "title": "[Working around Profiler  overhead](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#working-around-profiler-overhead)",
    "content": "### [Working around Profiler  overhead](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#working-around-profiler-overhead)\n\nSince the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  must perform  _extra calculations_  to collect performance data, as explained in  [this section](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#a-look-into-the-profilers-inner-workings), the time it takes to execute a script  **increases**  while profiling.\n\nMost scripts will run as expected with the Profiler‚Äôs overhead included. However, when a complex script‚Äôs runtime approaches a  [plan‚Äôs limit](https://www.tradingview.com/support/solutions/43000579793/), using the  [Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  on it may cause its runtime to  _exceed_  the limit. Such a case indicates that the script likely needs  [optimization](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#optimization), but it can be challenging to know where to start without being able to  [profile the code](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#profiling-a-script). The most effective workaround in this scenario is reducing the number of bars the script must execute on. Users can achieve this reduction in any of the following ways:\n\n-   Selecting a dataset that has fewer data points in its history, e.g., a higher timeframe or a symbol with limited data\n-   Using conditional logic to limit code executions to a specific time or bar range\n-   Including a  `calc_bars_count`  argument in the script‚Äôs declaration statement to specify how many recent historical bars it can use\n\nReducing the number of data points works in most cases because it directly decreases the number of times the script must execute, typically resulting in less accumulated runtime.\n\nAs a demonstration, this script contains a  `gcd()`  function that uses a  _naive_  algorithm to calculate the  [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)  of two integers. The function initializes its  `result`  using the smallest absolute value of the two numbers. Then, it reduces the value of the  `result`  by one within a  [while](https://www.tradingview.com/pine-script-reference/v6/#kw_while)  loop until it can divide both numbers without remainders. This structure entails that the loop will iterate up to  _N_  times, where  _N_  is the smallest of the two arguments.\n\nIn this example, the script plots the value of  `gcd(10000, 10000 + bar_index)`. The smallest of the two arguments is always 10,000 in this case, meaning the  [while](https://www.tradingview.com/pine-script-reference/v6/#kw_while)  loop within the function will require up to 10,000 iterations per script execution, depending on the  [bar_index](https://www.tradingview.com/pine-script-reference/v6/#var_bar_index)  value:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Script takes too long while profiling demo\")  \n  \n//@function Calculates the greatest common divisor of `a` and `b` using a naive algorithm.  \ngcd(int  a,  int  b) =>  \n//@variable The greatest common divisor.  \nint  result  =  math.max(math.min(math.abs(a),  math.abs(b)),  1)  \n// Reduce the `result` by 1 until it divides `a` and `b` without remainders.  \nwhile  result  >  0  \nif  a  %  result  ==  0  and  b  %  result  ==  0  \nbreak  \nresult  -=  1  \n// Return the `result`.  \nresult  \n  \nplot(gcd(10000,  10000  +  bar_index),  \"GCD\")  \n``\n\nWhen we add the script to our chart, it takes a while to execute across our chart‚Äôs data, but it does not raise an error. However,  _after_  enabling the  [Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler), the script raises a runtime error stating that it exceeded the Premium plan‚Äôs  [runtime limit](https://www.tradingview.com/support/solutions/43000579793/)  (40 seconds):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Tips-Working-around-profiler-overhead-The-script-takes-too-long-to-execute-1.ChWuvP-N_1heDWT.webp)\n\nOur current chart has over 20,000 historical bars, which may be too many for the script to handle within the alloted time while the  [Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  is active. We can try limiting the number of historical executions to work around the issue in this case.\n\nBelow, we included  `calc_bars_count = 10000`  in the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  function, which limits the script‚Äôs available history to the most recent 10,000 historical bars. After restricting the script‚Äôs historical executions, it no longer exceeds the Premium plan‚Äôs limit while profiling, so we can now inspect its performance results:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Profiling-and-optimization-Tips-Working-around-profiler-overhead-The-script-takes-too-long-to-execute-2.DN-scZLp_Z1HYEfF.webp)\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"Script takes too long while profiling demo\",  calc_bars_count  =  10000)  \n  \n//@function Calculates the greatest common divisor of `a` and `b` using a naive algorithm.  \ngcd(int  a,  int  b) =>  \n//@variable The greatest common divisor.  \nint  result  =  math.max(math.min(math.abs(a),  math.abs(b)),  1)  \n// Reduce the `result` by 1 until it divides `a` and `b` without remainders.  \nwhile  result  >  0  \nif  a  %  result  ==  0  and  b  %  result  ==  0  \nbreak  \nresult  -=  1  \n// Return the `result`.  \nresult  \n  \nplot(gcd(10000,  10000  +  bar_index),  \"GCD\")  \n``\n\nTipThis process might require trial and error, because identifying the number of executions that a computationally heavy script can handle before timing out is not necessarily straightforward. If a script takes too long to execute after enabling the  [Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler), experiment with different ways to limit its executions until you can profile it successfully.",
    "keywords": [
      "www.tradingview",
      "e.g",
      "en.wikipedia",
      "tradingview.com",
      "math.max",
      "math.min",
      "math.abs",
      "indicator",
      "plot",
      "var",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-415",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Script  publications](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-publications)",
    "content": "# [Publishing  scripts](https://www.tradingview.com/pine-script-docs/writing/publishing/#publishing-scripts)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/writing/publishing/#introduction)\n\nTradingView hosts a large global community of Pine Script¬Æ programmers, and millions of traders. Script authors can publish their custom  [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator)  scripts,  [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/), and  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  publicly in the  [Community scripts](https://www.tradingview.com/scripts/)  repository, allowing others in our community to use and learn from them. They can also publish  _private_  scripts to create  _drafts_  for public releases, test features, or collaborate with friends.\n\nThis page explains the script publishing process and provides recommendations to help authors publish their Pine scripts effectively.\n\nNoticeBefore you publish a script, ensure you read and understand our  [House Rules](https://www.tradingview.com/house-rules/),  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/), and  [Vendor Requirements](https://www.tradingview.com/support/solutions/43000549951-vendor-requirements/).",
    "keywords": [
      "www.tradingview",
      "indicator",
      "for"
    ]
  },
  {
    "id": "doc-416",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Privacy  types](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types)",
    "content": "## [Script  publications](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-publications)\n\nWhen an  _editable_  script is on the chart and opened in the Pine Editor, users can select the ‚ÄúPublish indicator/strategy/library‚Äù button in the top-right corner to open the ‚ÄúPublish script‚Äù window and create a  _script publication_:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-publications-1.J697I8lX_Z2vfciF.webp)\n\nAfter the author follows all the necessary steps to  [prepare the publication](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  and selects the ‚ÄúPublish private/public script‚Äù button on the last page of the ‚ÄúPublish script‚Äù window, TradingView generates a dedicated  _script widget_  and  _script page_, which feature options for users to boost, share, report, and comment on the publication.\n\nThe script widget is a  _preview_  of the publication that appears in all relevant locations on TradingView, depending on the specified  [privacy](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types)  and  [visibility](https://www.tradingview.com/pine-script-docs/writing/publishing/#visibility-types)  settings. It shows the script‚Äôs title, a compressed view of the published chart, and a brief preview of the script‚Äôs description. An icon in the top-right corner of the widget indicates whether the published script is an  [indicator](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator),  [strategy](https://www.tradingview.com/pine-script-docs/concepts/strategies/), or  [library](https://www.tradingview.com/pine-script-docs/concepts/libraries/):\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-publications-2.G0ylHOYP_Z2tLh7z.webp)\n\nClicking on the widget opens the script page. The top of the page shows information about the script‚Äôs visibility, its title, and an enlarged view of the published chart:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-publications-3.s71gTejL_Z1gcreE.webp)\n\nFor published  [strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/), the script page also includes the option for users to view the  [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester)  report below the title.\n\nBelow the chart or strategy report are the publication‚Äôs complete description, release notes from script updates, additional information, and user comments.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "strategy",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-417",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)",
    "content": "## [Privacy  types](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types)\n\nScript publications have one of two  _privacy types_, which determine how users can discover them:  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  or  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private). Public scripts are discoverable to all members of the TradingView community, whereas private scripts are accessible only via their URLs. Authors set a script publication‚Äôs privacy type using the ‚ÄúPrivacy settings‚Äù field on the  _second page_  of the ‚ÄúPublish script‚Äù window:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Privacy-types-1.CSXHELy0_Z1x20xA.webp)\n\nNoticeEnsure you select the correct option in this field when you  [prepare](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  a publication, as you  **cannot**  change a script‚Äôs privacy type after you publish it.\n\n### [Public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)\n\nA script published with the ‚ÄúPublic‚Äù setting is available in the  [Community scripts](https://www.tradingview.com/scripts/)  feed and discoverable to all TradingView users worldwide. Unlike public ideas, everyone accesses the same  _global repository_  for public scripts, regardless of which localized TradingView version they use.\n\nUsers can discover public scripts by navigating the Community scripts feed directly, viewing the  [Scripts](https://www.tradingview.com/u/#published-scripts)  tab of an author‚Äôs profile, searching the ‚ÄúCommunity‚Äù tab of the ‚ÄúIndicators, Metrics & Strategies‚Äù menu, or specifying script keywords in the search bar at the top of many TradingView pages. We also feature exceptional public scripts in our  [Editors‚Äô picks](https://www.tradingview.com/scripts/editors-picks/).\n\nBecause public scripts are available to our global community and are  **not**  for private use, they must meet the criteria defined in our  [House Rules](https://www.tradingview.com/house-rules/),  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/), and  [Vendor Requirements](https://www.tradingview.com/support/solutions/43000549951-vendor-requirements/). Our  _script moderators_  analyze public scripts using these criteria. Script publications that do not follow these rules become  _hidden_  from the community.\n\nNoticeWhen you publish a public script, you have only  **15 minutes**  to edit or delete it. After that period expires, the publication is finalized and  **cannot**  be changed or removed. Therefore, before you publish a public script, validate that everything appears as intended and complies with our rules. The recommended approach is to start with a  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)  script, which you can  _always_  edit or delete.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-418",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Open](https://www.tradingview.com/pine-script-docs/writing/publishing/#open)",
    "content": "### [Private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)\n\nA script published with the ‚ÄúPrivate‚Äù setting is  _not_  available in the  [Community scripts](https://www.tradingview.com/scripts/)  feed, and users cannot find the publication using TradingView‚Äôs search features. The script widget is visible only to the author, from their profile‚Äôs  [Scripts](https://www.tradingview.com/u/#published-scripts)  tab. Other users cannot see the script widget, and they cannot view the script page without having access to its URL.\n\nAuthors can  **always**  edit or delete private script publications, unlike  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  scripts, using the available options in the top-right corner of the script page. This capability makes private scripts ideal for testing features, collaborating with friends, and creating  [draft publications](https://www.tradingview.com/pine-script-docs/writing/publishing/#private-drafts)  before committing to public releases. To learn more about how private publications differ from public ones, see  [this article](https://www.tradingview.com/support/solutions/43000548335-how-do-private-ideas-and-scripts-differ-from-public-ones/)  in our Help Center.\n\nNoticePrivate scripts are strictly for  **private use**. Our script moderators do not analyze privately published scripts as long as they  _remain_  private. As per our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  and  [Vendor Requirements](https://www.tradingview.com/support/solutions/43000549951-vendor-requirements/), you cannot reference or link to private publications in any public TradingView content. Additionally, if you share links to private scripts in social networks or other public content, those scripts are  _not_  considered private.\n\n## [Visibility  types](https://www.tradingview.com/pine-script-docs/writing/publishing/#visibility-types)\n\nA script publication‚Äôs  _visibility type_  determines whether other users can see the source code, and whether anyone or only authorized individuals can use the script. The possible types are  [open-source](https://www.tradingview.com/pine-script-docs/writing/publishing/#open),  [protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected), and  [invite-only](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only). The ‚ÄúVisibility‚Äù options on the  _second page_  of the ‚ÄúPublish script‚Äù window specify a script‚Äôs visibility type:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Visibility-types-1.CtdHkYFb_Z1YTPEf.webp)\n\nNoticeAs with the  [privacy type](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types), you  **cannot**  change a script‚Äôs visibility type after you publish it. Make sure you select the appropriate option while  [preparing](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  your publication.",
    "keywords": [
      "www.tradingview",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-419",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected)",
    "content": "### [Open](https://www.tradingview.com/pine-script-docs/writing/publishing/#open)\n\nA script published with the ‚ÄúOpen‚Äù setting is  _open-source_, meaning anyone who views the publication or uses the script can access its Pine Script code. Most script publications on TradingView use this setting because it allows programmers to demonstrate their Pine knowledge and provide code for others to verify, learn from, modify, and build upon.\n\nAn open-source script‚Äôs page displays the source code in an expandable window above the comments. The window also includes the option to view the source code directly inside the Pine Editor in a separate tab:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Visibility-types-Open-1.C0tgTdYX_1V7jDt.webp)\n\nWhen a user adds the script to their chart, they can also view the source code in the Pine Editor at any time by selecting the ‚ÄúSource code‚Äù option in the script‚Äôs status line:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Visibility-types-Open-2.CwLD-vSb_Z1gqBcd.webp)\n\nNote that:\n\n-   When a published script‚Äôs code is open inside the Pine Editor, it is  _read-only_. Users cannot edit the code without creating a  _working copy_, and any changes to that copied code do  **not**  affect the original published script.\n-   All open-source scripts on TradingView use the  [Mozilla Public License 2.0](https://www.mozilla.org/en-US/MPL/2.0/)  by default. Authors wanting to use alternative licenses can specify them in the source code.\n-   All script publications that  _reuse_  code from another open-source script must meet the ‚ÄúOpen-source reuse‚Äù criteria outlined in our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/). These rules take precedence over any provisions from an open-source license.\n\nTipOpen-source scripts are eligible for inclusion in our  [Editors‚Äô picks](https://www.tradingview.com/scripts/editors-picks/)  section, which showcases exceptional publications from our growing community of script authors. The Editors‚Äô picks are selected from  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public), open-source scripts that are original, provide potential value to users, include a helpful description, and comply with our  [House Rules](https://www.tradingview.com/house-rules/).",
    "keywords": [
      "www.tradingview",
      "www.mozilla",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-420",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Invite-only](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only)",
    "content": "### [Protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected)\n\nA script published with the ‚ÄúProtected‚Äù setting has  _closed-source_  code, meaning the code is protected and not viewable to any user except the author. Although users cannot access the source code, they can add the script to their charts and use it freely. This visibility option is available only to script authors with paid  [plans](https://www.tradingview.com/pricing/).\n\nClosed-source script publications are ideal for authors wanting to share their unique Pine Script creations with the community without exposing their distinct calculations and logic. They are  _not_  for sharing closed-source scripts that reproduce the behaviors of  [open-source](https://www.tradingview.com/pine-script-docs/writing/publishing/#open)  ones. As such, when an author publishes a closed-source script, the publication‚Äôs description should include information that helps users understand the script‚Äôs unique characteristics that require protecting the code. See our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  to learn more.",
    "keywords": [
      "www.tradingview",
      "for"
    ]
  },
  {
    "id": "doc-421",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Preparing a  publication](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)",
    "content": "### [Invite-only](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only)\n\nA script published with the ‚ÄúInvite-only‚Äù setting has closed-source code. No user except the author can view the code. Additionally, unlike a  [protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected)  script, only users  _invited_  by the author can add the script to their charts and use it. This visibility option is available only to script authors with Premium and higher-tier  [plans](https://www.tradingview.com/pricing/).\n\nBelow the description on the invite-only script page, the author can see a  _‚ÄúManage access‚Äù_  button. This button opens a dialog box where the author specifies which users have access to the script:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Visibility-types-Invite-only-1.CKjJWSSz_Z27d1y8.webp)\n\nScript authors typically use invite-only publications to provide interested users with unique scripts, often in exchange for payment. As such, invite-only script authors are considered  _vendors_. In addition to the  [House Rules](https://www.tradingview.com/house-rules/)  and  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/), which apply to  _all_  script authors, vendors must understand and follow our  [Vendor Requirements](https://www.tradingview.com/support/solutions/43000549951-vendor-requirements/).\n\nNotice\n\n[Public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  invite-only scripts are the  **only**  published scripts for which authors can require payment to access. Selling access to  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)  scripts is prohibited, and authors cannot charge users for access to  [open-source](https://www.tradingview.com/pine-script-docs/writing/publishing/#open)  or  [protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected)  scripts because they are, by definition,  _free_  to use.\n\n  \n\nTradingView does not benefit from script sales. Transactions concerning invite-only scripts are strictly between  _users_  and  _vendors_; they do not involve TradingView.",
    "keywords": [
      "www.tradingview",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-422",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Source  code](https://www.tradingview.com/pine-script-docs/writing/publishing/#source-code)",
    "content": "## [Preparing a  publication](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)\n\nAt the start of the script publishing process, authors verify and refine their  [source code](https://www.tradingview.com/pine-script-docs/writing/publishing/#source-code)  to ensure correct functionality. Then, they prepare their  [chart visuals](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)  and, for strategies, the  [strategy report](https://www.tradingview.com/pine-script-docs/writing/publishing/#strategy-report), to showcase their script‚Äôs behaviors. After finalizing these details, authors select the ‚ÄúPublish‚Ä¶‚Äù button to open the ‚ÄúPublish script‚Äù window, where they set the  [title](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description), write a helpful  [description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description), and then define the publication‚Äôs  [settings](https://www.tradingview.com/pine-script-docs/writing/publishing/#publication-settings).\n\nThe sections below provide a step-by-step overview of this preparation process and list practical recommendations for creating helpful, user-friendly publications based on our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  and best practices.",
    "keywords": [
      "www.tradingview",
      "strategy",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-423",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Chart](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)",
    "content": "### [Source  code](https://www.tradingview.com/pine-script-docs/writing/publishing/#source-code)\n\nWhen an author publishes a script, the publication creates an independent copy of the source code, which becomes part of the publication‚Äôs  _version history_. If the published code contains incorrect or misleading calculations, produces unexpected behaviors, or uses excessive runtime resources, those issues are only fixable through  [script updates](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates).\n\nTherefore, regardless of a publication‚Äôs intended  [visibility type](https://www.tradingview.com/pine-script-docs/writing/publishing/#visibility-types), we recommend validating the source code  _before_  publishing it to confirm that the script is readable, usable, programmed correctly, and compliant.\n\nWhen preparing source code to publish:\n\n-   Ensure the code is original to you and provides a potentially helpful script for the community.\n-   Use debugging techniques such as  [Pine Logs](https://www.tradingview.com/pine-script-docs/writing/debugging/#pine-logs)  to verify that the script works as intended, and to find and fix any issues in its calculations or logic.\n-   Fix any higher-timeframe  [request.security()](https://www.tradingview.com/pine-script-reference/v6/#fun_request.security)  calls that use a  _non-offset_  `expression`  argument and  [barmerge.lookahead_on](https://www.tradingview.com/pine-script-reference/v6/#const_barmerge.lookahead_on)  as the  `lookahead`  argument on historical bars. These calls are not suitable for script publications because they cause  _lookahead bias_. See the  [`lookahead`](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#lookahead)  section of the  [Other timeframes and data](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/)  page for more information.\n-   Use the  [Pine Profiler](https://www.tradingview.com/pine-script-docs/writing/profiling-and-optimization/#pine-profiler)  to analyze the script‚Äôs runtime performance. If the script contains unnecessary loops or other inefficient calculations, consider optimizing them to help ensure efficiency and usability.\n-   Include  `minval`,  `maxval`, and  `options`  arguments in applicable  `input.*()`  calls to prevent users from supplying  _unintended_  [input](https://www.tradingview.com/pine-script-docs/concepts/inputs/)  values. It is also helpful to include  [runtime.error()](https://www.tradingview.com/pine-script-reference/v6/#fun_runtime.error)  calls for other unintended use cases.\n-   Organize the source code, add helpful titles to inputs and plots, use readable names for identifiers, and include informative comments to make the code simpler to maintain and easier to understand. See the  [Style guide](https://www.tradingview.com/pine-script-docs/writing/style-guide/)  page for more information.\n-   Document exported functions and types of  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  with  [compiler annotations](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations). Annotation text is visible when hovering over an imported library‚Äôs identifiers or by using parameter hints. Additionally, the  [description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description)  field of the ‚ÄúPublish script‚Äù window automatically adds the text to exported code signatures.\n-   Use a meaningful, searchable title relating to the script‚Äôs purpose as the  `title`  argument of the  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator),  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy), or  [library()](https://www.tradingview.com/pine-script-reference/v6/#fun_library)  declaration statement. The title field of the ‚ÄúPublish script‚Äù window uses this text by default.",
    "keywords": [
      "www.tradingview",
      "request.security",
      "fun_request.security",
      "barmerge.lookahead_on",
      "const_barmerge.lookahead_on",
      "runtime.error",
      "fun_runtime.error",
      "indicator",
      "strategy",
      "input",
      "plot",
      "simple",
      "const",
      "export",
      "import",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-424",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Strategy  report](https://www.tradingview.com/pine-script-docs/writing/publishing/#strategy-report)",
    "content": "### [Chart](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)\n\nWhen an author publishes a script, the publication  _copies_  their current chart to showcase the visual outputs. If the author has drawings, images, or other scripts on their chart, the published chart also includes them. Therefore, before opening the ‚ÄúPublish script‚Äù window, confirm that the chart is clean and ready for publishing.\n\nWhen preparing a chart for a script publication:\n\n-   The script must be active on the chart. If the script is not running on the current chart, open its source code in the Pine Editor and select ‚ÄúAdd to chart‚Äù in the top-right corner.\n-   Ensure the chart contains only  _necessary_  visuals and is easy for users to understand. Remove any other scripts, drawings, or images unless using or demonstrating the script  _requires_  them. If the publication requires extra scripts or other visuals on the chart, explain their use in the  [description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description).\n-   The chart‚Äôs  _status line_  should show the current symbol and timeframe, and the script‚Äôs status line should show its name. These details help users understand what the displayed data represents. Enable the ‚ÄúTitle/Titles‚Äù checkboxes in the ‚ÄúStatus line‚Äù tab of the chart‚Äôs settings. If the text in the status lines is the same color as the chart‚Äôs background, change its color in the ‚ÄúCanvas‚Äù tab.\n-   The symbol‚Äôs price series and the script‚Äôs visual outputs should be visible on the chart. If the script is on the chart but hidden, select the ‚ÄúShow‚Äù icon in its status line to make it visible. If the symbol‚Äôs price series is invisible, select the ‚ÄúShow‚Äù option in the ‚ÄúMore‚Äù menu of the chart‚Äôs status line.\n-   Show the script‚Äôs  _default_  behavior so that users know what to expect when they add it to their charts. If an instance of the script on the chart does not use the default settings, select ‚ÄúReset settings‚Äù from the ‚ÄúDefaults‚Äù dropdown tab at the bottom of the script‚Äôs ‚ÄúSettings‚Äù menu.\n-   Do not use a  _non-standard chart_  ([Heikin Ashi](https://www.tradingview.com/support/solutions/43000619436),  [Renko](https://www.tradingview.com/support/solutions/43000502284),  [Line Break](https://www.tradingview.com/support/solutions/43000502273),  [Kagi](https://www.tradingview.com/support/solutions/43000502272),  [Point & Figure](https://www.tradingview.com/support/solutions/43000502276), or  [Range](https://www.tradingview.com/support/solutions/43000474007)) if the script is a  [strategy](https://www.tradingview.com/pine-script-docs/concepts/strategies/), issues  [alerts](https://www.tradingview.com/pine-script-docs/concepts/alerts/), or displays trade signals of  _any kind_  in its outputs. The OHLC series on non-standard charts represent  _synthetic_  (calculated) prices,  **not**  real-world prices. Scripts that create alert conditions or simulate trades on these charts can  **mislead**  users and produce  **unrealistic**  results.",
    "keywords": [
      "www.tradingview",
      "strategy",
      "alert",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-425",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Title and  description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description)",
    "content": "### [Strategy  report](https://www.tradingview.com/pine-script-docs/writing/publishing/#strategy-report)\n\n[Strategies](https://www.tradingview.com/pine-script-docs/concepts/strategies/)  simulate trades based on programmed rules, displaying their hypothetical performance results and properties inside the  [Strategy Tester](https://www.tradingview.com/pine-script-docs/concepts/strategies/#strategy-tester). When an author publishes a strategy script, the script page uses the Strategy Tester‚Äôs information to populate its  _‚ÄúStrategy report‚Äù_  display.\n\nBecause traders often use a strategy script‚Äôs performance information to determine the potential viability of a trading system, programmers must verify that their scripts have  _realistic_  properties and results. Before publishing a strategy script, check its information in the ‚ÄúStrategy Tester‚Äù tab to validate that everything appears as intended.\n\nTo maintain realism when publishing strategies, follow these guidelines based on our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/):\n\n-   In the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement, choose an  `initial_capital`  argument representing realistic starting capital for the average trader in the market. Do not use an excessive value to exaggerate hypothetical returns.\n-   Specify  `commission_*`  and  `slippage`  arguments that approximate real-world commission and slippage amounts. We also recommend using  `margin_*`  arguments that reflect realistic  [margin/leverage](https://www.tradingview.com/support/solutions/43000717375/)  levels for the chart symbol‚Äôs exchange.\n-   Set the strategy‚Äôs order placement logic to risk  _sustainable_  capital in the simulated trades. In most real-world settings, risking more than 10% of equity on a single trade is  _not_  typically considered sustainable.\n-   Choose a dataset and default strategy configuration that produces a reasonable number of simulated trades, ideally  _100 or more_. A strategy report with significantly fewer trades, especially over a short duration, does not typically provide enough information to help traders gauge a strategy‚Äôs hypothetical performance.\n-   Ensure the strategy uses the default  [properties](https://www.tradingview.com/support/solutions/43000628599-strategy-properties/)  set in the  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy)  declaration statement, and explain these defaults in the  [description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description).\n-   Resolve any warnings shown in the Strategy Tester before publishing the script.",
    "keywords": [
      "www.tradingview",
      "strategy",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-426",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Publication  settings](https://www.tradingview.com/pine-script-docs/writing/publishing/#publication-settings)",
    "content": "### [Title and  description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description)\n\nAfter preparing the  [source code](https://www.tradingview.com/pine-script-docs/writing/publishing/#source-code),  [chart visuals](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart), and  [strategy report](https://www.tradingview.com/pine-script-docs/writing/publishing/#strategy-report)  for a script publication, open the ‚ÄúPublish Script‚Äù window and draft a meaningful title and description to help users understand the script. First, confirm that the correct code is open in the Pine Editor, then select the ‚ÄúPublish‚Ä¶‚Äù button in the top-right corner.\n\nThe first page of the ‚ÄúPublish Script‚Äù window contains two text fields that  _cannot_  be empty:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Title-and-description-1.Ctto0oi1_1mSOeQ.webp)\n\nThe first field determines the publication‚Äôs  _title_, which appears at the top of the script widget and page. TradingView also uses the specified title to determine the publication‚Äôs  _URL_. By default, this field proposes the text from the  `title`  argument of the script‚Äôs declaration statement. It is typically best to use that title. However, some authors prefer to use different or modified titles.\n\nWhen defining the title of a script publication:\n\n-   Use text that hints at the script‚Äôs purpose or functionality. A meaningful title helps users understand and search for the publication.\n-   Use English text only. If the script is  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public), it is available to the  _global_  TradingView community. To help ensure the script is understandable, English is required by our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  because it is the most common language used for international communication.\n-   Include only standard 7-bit ASCII characters to ensure readability and searchability. Do not include emoji or other special characters in this text.\n-   Avoid using all capital letters in the text, except for abbreviations such as ‚ÄúRSI‚Äù, ‚ÄúEMA‚Äù, etc. Text with whole words written in ALL CAPS is distracting for users.\n-   Do not include misleading or unsubstantiated statements about the script (e.g., ‚Äú90% win rate‚Äù).\n-   Do not include website references, social media handles, or other forms of advertisement.\n\nThe second text field determines the publication‚Äôs  _description_. The toolbar at the top contains several options that insert  _markup tags_  into the field for adding text formats, Pine code blocks, lists, and more. The script page displays the complete, parsed text from this field below the published chart or strategy report:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Title-and-description-2.BFSUZFJ4_Z1Ya3IY.webp)\n\nMost of the markup for publication descriptions requires surrounding raw text with an  _opening tag_  (e.g.,  `[b]`) and a matching  _closing tag_  with a forward slash (e.g.,  `[/b]`). Some tags also require additional syntax. Here, we list the available tags and explain how they work:\n\n-   The  `[b][/b]`,  `[i][/i]`, and  `[s][/s]`  tag pairs respectively apply  **bold**,  _italic_, and  strikethrough  formatting to the enclosed text.\n-   The  `[pine][/pine]`  tags format the enclosed multi-line text as a Pine code block with syntax highlighting on a new line.\n-   The  `[list][/list]`  tags create a bulleted list. Each line between these tags that starts with the special  `[*]`  tag defines a separate bullet. To create a  _numbered_  list, use  `[list=1]`  as the  _opening tag_.\n-   The  `[quote][/quote]`  tags format the enclosed multi-line text as a  _block quotation_.\n-   The  `[url=][/url]`  tags create a hyperlink to a specified URL. For example,  `[url=https://www.tradingview.com/]myLink[/url]`  formats the text ‚ÄúmyLink‚Äù as a link to TradingView‚Äôs home page. Use these tags to create links to relevant TradingView pages and standard reference materials. Avoid linking to social media or other websites, as our  [House Rules](https://www.tradingview.com/house-rules/)  forbid advertising in publications.\n-   The  `[image][/image]`  tags render a  _chart image_  from an enclosed  _URL_  for either a  [snapshot](https://www.tradingview.com/support/solutions/43000482537-how-do-i-take-a-snapshot-and-share-it-afterwards/)  or an idea publication. These tags are  _optional_, as publications can render images from snapshot and idea URLs automatically. Before taking a snapshot,  [prepare the chart](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)  for readability, as you would for a publication‚Äôs chart.\n-   The  `$`  character adds a hyperlink to a specific symbol‚Äôs  _overview page_  when it precedes a valid  _symbol_  or  _ticker identifier_. For example,  `$AMEX:SPY`  creates a link to the  [SPY symbol overview](https://www.tradingview.com/symbols/AMEX-SPY/).\n\nWriting a helpful description is a  **critical step**  in the script publishing process, as users rely on the provided information to understand a published script. Below, we list a few helpful recommendations for preparing descriptions based on some of the key criteria outlined in our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/):\n\n-   Include relevant, self-contained details that help users understand the script‚Äôs purpose, how it works, how to use it, and why it is original, regardless of the intended  [visibility type](https://www.tradingview.com/pine-script-docs/writing/publishing/#visibility-types). Even if the publication is  [open-source](https://www.tradingview.com/pine-script-docs/writing/publishing/#open), the description should cover this information because not all users understand a script by reading its Pine Script code. Furthermore, an informative description helps users verify that the script works as intended.\n-   If the publication is closed-source ([protected](https://www.tradingview.com/pine-script-docs/writing/publishing/#protected)  or  [invite-only](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only)), include accurate details about the script‚Äôs  _unique qualities_  that require hiding the source code. Closed-source scripts that match the behaviors of open-source scripts  _do not_  benefit our community.\n-   Do not make unsubstantiated statements about the script‚Äôs capabilities or performance. If the text contains claims about the script, it should include details substantiating them to avoid misleading traders.\n-   If the text contains emoji or other non-ASCII characters, ensure it uses them  _sparingly_  to maintain readability. Likewise, avoid using all capital letters throughout the text because it reduces readability.\n-   The description  _can_  include languages other than English. However, the text should  _begin_  with an English explanation to help users in  _different regions_  understand the publication. Additionally, if the source code does not use English for input titles or other user interface text, the description should contain English translations of those elements.",
    "keywords": [
      "www.tradingview",
      "e.g",
      "strategy",
      "input",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-427",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Publishing and  editing](https://www.tradingview.com/pine-script-docs/writing/publishing/#publishing-and-editing)",
    "content": "### [Publication  settings](https://www.tradingview.com/pine-script-docs/writing/publishing/#publication-settings)\n\nThe  _second_  page of the ‚ÄúPublish script‚Äù window is where authors specify a script publication‚Äôs settings and search tags. This page is accessible only after adding a  [title and description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description)  for the script on the previous page and selecting the ‚ÄúContinue‚Äù button:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Publication-settings-1.CBK9Pq2e_1Ngf8B.webp)\n\nThe two fields at the top of the page specify the script‚Äôs  [privacy](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types)  and  [visibility](https://www.tradingview.com/pine-script-docs/writing/publishing/#visibility-types)  types. Ensure both fields use the correct options, as these settings  **cannot**  change after the script is published.\n\nTipEven if you intend to share your script publicly, we recommend publishing a  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)  version first. You can use the private publication as a  _draft_  of the release to ensure the content is correct, then create a new  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  version with the verified description. See the section on  [private drafts](https://www.tradingview.com/pine-script-docs/writing/publishing/#private-drafts)  below to learn more.\n\nNote that setting the publication‚Äôs visibility type to  [invite-only](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only)  reveals an additional  _‚ÄúAuthor‚Äôs instructions‚Äù_  field, which cannot remain empty. This field is where vendors provide necessary information for users to  _request access_  to their script, such as direct contact details and links to instructional pages. The contents of this field will appear below the description on the invite-only script page:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Publication-settings-2.BIum0zP5_2j0vvi.webp)\n\nThe remaining input fields on this page provide options to assign  _tags_  (keywords) to the publication for discoverability. The ‚ÄúCategory‚Äù field contains a menu where the author can select up to  _three_  preset category tags for the publication. If the script is  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public), users can search the specified categories to discover it:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Publication-settings-3.BWQCYFg3_TjS3V.webp)\n\nThe publication can also include  _custom_, non-preset search tags for additional discoverability. To add custom tags to the publication, select the ‚ÄúShow more‚Äù option, then enter a list of searchable keywords in the ‚ÄúTags‚Äù field:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Preparing-a-publication-Publication-settings-4.CJgiGbDf_Z2gQuPX.webp)",
    "keywords": [
      "www.tradingview",
      "input",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-428",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Script  updates](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates)",
    "content": "## [Publishing and  editing](https://www.tradingview.com/pine-script-docs/writing/publishing/#publishing-and-editing)\n\nAfter following all necessary steps to  [prepare](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  a script publication, including fine-tuning the source code, cleaning the chart, and adding a helpful  [title and description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description), select the ‚ÄúPublish‚Ä¶‚Äù button at the bottom of the last page of the ‚ÄúPublish script‚Äù window to publish the script.\n\nIf the publication‚Äôs  [privacy type](https://www.tradingview.com/pine-script-docs/writing/publishing/#privacy-types)  is set to  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public), there is a checkbox above the ‚ÄúPublish‚Ä¶‚Äù button, which the author must select before they can create the publication. This checkbox confirms awareness of the  [House Rules](https://www.tradingview.com/house-rules/)  and the consequence of the script becoming  _hidden_  from the community if it does not follow them:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Publishing-and-editing-1.DcohMtNY_2oKd8i.webp)\n\nWhen the script is published, the ‚ÄúPublish script‚Äù window closes automatically, and TradingView opens the new publication‚Äôs script page. The page includes ‚ÄúEdit‚Äù and ‚ÄúDelete‚Äù buttons in the top-right corner. If the script is public, these buttons are available for only  _15 minutes_. If private, they are  _always_  available.\n\nSelecting the ‚ÄúEdit‚Äù button opens the ‚ÄúEdit script‚Äù window, where the author can change the title, description, and search tags:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Publishing-and-editing-2.DdXiOIMi_19iWEp.webp)\n\nNote that:\n\n-   The ‚ÄúPrivacy settings‚Äù and ‚ÄúVisibility‚Äù fields on the second page of this window are  **not**  editable.\n-   The ‚ÄúEdit script‚Äù window does  **not**  provide options to edit the published source code, chart, or strategy report. To change these details, publish a  [script update](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates).",
    "keywords": [
      "www.tradingview",
      "strategy",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-429",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[Tips](https://www.tradingview.com/pine-script-docs/writing/publishing/#tips)",
    "content": "## [Script  updates](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates)\n\nAuthors can  _update_  their  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  or  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)  scripts over time to add new features, fix bugs, optimize performance, etc. To publish an update to an existing script, confirm that the new source code differs from the code in the last published version. Then, add the updated script to the chart and select the ‚ÄúPublish‚Ä¶‚Äù option in the top-right of the Pine Editor to open the ‚ÄúPublish script‚Äù window.\n\nAfter opening the window, select the ‚ÄúUpdate existing script‚Äù option at the top of the first page:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-updates-1.Dj2wF476_Z29Ahn9.webp)\n\nIn this publishing mode, the first text field specifies the  _existing_  script to update,  **not**  the title of a new publication. Enter the existing publication‚Äôs title in the field or select the title from the available options in the dropdown menu:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-updates-2.BD7A4eH9_Z1qAoUS.webp)\n\nBelow the title field is a checkbox specifying whether the update will affect the publication‚Äôs chart. If unchecked (default), the script page will copy the author‚Äôs  _current chart_  to showcase the changes. If checked, the publication will continue using its  _existing_  chart display:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-updates-3.Dbp2E4kN_21Iw12.webp)\n\nNoticeIf you plan to update the publication‚Äôs chart,  [prepare the chart](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)  before opening the ‚ÄúPublish script‚Äù window, just as you would with a new publication.\n\nThe text field below the checkbox is where the author explains the  _changes_  made to the script. The publication will display the parsed text from this field beneath the description as dated  _release notes_  on the script page. The contents of this field  **do not**  modify the publication‚Äôs original description and are displayed  _in addition_  to it:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-updates-4.C4AWjLxS_Z1Oq2Ej.webp)\n\nWhen publishing release notes, prepare them similarly to the  [description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description). Provide self-contained information allowing users to understand the changes included in the update, how they impact the script‚Äôs functionality, and what benefits the changes provide over the previous version.\n\nNoticeAfter you publish a script update, the release notes are finalized  _immediately_  and  **cannot**  be changed. Therefore, we recommend using  [private drafts](https://www.tradingview.com/pine-script-docs/writing/publishing/#private-drafts)  to validate script updates before committing to  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  releases.\n\nThe bottom of the page contains an expandable  _difference checker_, which displays a side-by-side or inline comparison between the new source code and the last published version. We recommend inspecting and confirming the code differences  _before_  publishing an update, because all updates are preserved in the script‚Äôs  _version history_:\n\n![image](https://www.tradingview.com/pine-script-docs/_astro/Publishing-scripts-Script-updates-5.0LHpw9wR_7PUkf.webp)\n\nAfter confirming the details on the first page of the ‚ÄúPublish script‚Äù window, select ‚ÄúContinue‚Äù to move to the final page, then select the ‚ÄúPublish new version‚Äù button at the bottom to finalize the script update.\n\nNote that:\n\n-   The ‚ÄúPrivacy settings‚Äù and ‚ÄúVisibility‚Äù fields appear grayed out on the last page of the window for script updates because authors  **cannot**  change these settings for existing script publications.",
    "keywords": [
      "www.tradingview",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-430",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[House  Rules](https://www.tradingview.com/pine-script-docs/writing/publishing/#house-rules)",
    "content": "## [Tips](https://www.tradingview.com/pine-script-docs/writing/publishing/#tips)\n\nUse the following tips and our recommendations in the  [Preparing a publication](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  section above to create helpful, compliant script publications.\n\n### [Private  drafts](https://www.tradingview.com/pine-script-docs/writing/publishing/#private-drafts)\n\nNew script authors occasionally overlook the importance of reviewing their content before sharing it publicly, leading to unintentional errors in their published script descriptions, such as typos, incorrect statements, or House Rule violations.\n\nThe title and description of a  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  script are editable for only 15 minutes. After that time, the content becomes  **final**. If the published text contains mistakes, the author  **cannot**  [edit](https://www.tradingview.com/pine-script-docs/writing/publishing/#publishing-and-editing)  or  [update](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates)  the publication to fix them.\n\nIn contrast,  [private](https://www.tradingview.com/pine-script-docs/writing/publishing/#private)  scripts are always editable, making them valuable tools for  _drafting_  public script releases. Private drafts help authors avoid uncaught mistakes in their public versions and ensure quality for script users. Therefore, we strongly recommend starting  _every_  script publication with a private draft.\n\nWhen using private publications as drafts for public releases, follow this simple process:\n\n1.  [Prepare](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  the draft publication‚Äôs content as you would for a public script, but set the ‚ÄúPrivacy settings‚Äù field to ‚ÄúPrivate‚Äù on the last page of the ‚ÄúPublish script‚Äù window.\n2.  Check the private draft‚Äôs script widget and script page to verify whether the publication‚Äôs content appears as intended. If there are mistakes in the draft‚Äôs source code, chart, or strategy report, fix them by publishing an  [update](https://www.tradingview.com/pine-script-docs/writing/publishing/#script-updates). To fix errors in the draft‚Äôs title or description, select the ‚ÄúEdit‚Äù option on the script page and add the corrected text to the appropriate field.\n3.  After validating the draft, open the ‚ÄúEdit script‚Äù window and copy the raw text from the description field.\n4.  Prepare a new, public script publication using the updated source code and verified description text.\n5.  After publishing the public version, you can delete the private draft using the ‚ÄúDelete‚Äù option at the top-right of its script page.",
    "keywords": [
      "www.tradingview",
      "strategy",
      "simple",
      "import",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-431",
    "type": "documentation",
    "source": "writing_scripts/publishing_scripts.md",
    "section": "writing_scripts",
    "title": "[House  Rules](https://www.tradingview.com/pine-script-docs/writing/publishing/#house-rules)",
    "content": "### [House  Rules](https://www.tradingview.com/pine-script-docs/writing/publishing/#house-rules)\n\nMany traders use  [public](https://www.tradingview.com/pine-script-docs/writing/publishing/#public)  scripts in their analysis to reinforce trade decisions. Likewise, many programmers learn from public scripts and use published  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  in their Pine projects. New and experienced users alike should be able to rely on the script publications from our community for helpful content and original, potentially beneficial tools.\n\nOur  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  establish the core criteria for publishing scripts on TradingView, and our  [Vendor Requirements](https://www.tradingview.com/support/solutions/43000549951-vendor-requirements/)  define additional criteria for  [vendors](https://www.tradingview.com/pine-script-docs/writing/publishing/#invite-only). The script moderators curate the  [Community scripts](https://www.tradingview.com/scripts/)  based on these rules and our  [House Rules](https://www.tradingview.com/house-rules/). If a publication does not meet these criteria, it becomes  _hidden_, and our moderators send the author a message explaining the issues that need correction. The author can then  [prepare](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  a  _new publication_  with the necessary corrections if they want to share their script publicly.\n\nWe recommend all authors review and understand our rules and verify a script publication‚Äôs compliance  _before_  publishing it. Below, we list a few simple tips:\n\n**Publish original content**\n\nPublish a script publicly if you believe it is original and might benefit the community. Avoid rehashing, mimicking, or copying existing scripts or other public domain code. Likewise, avoid publishing scripts that combine available indicators or other code without a clear purpose. In other words, aim to provide a helpful tool for the community based on  _your_  unique interests and expertise.\n\n**Reuse code responsibly**\n\nAuthors can publish scripts that reuse open-source code from other publications. However, they must meet the ‚ÄúOpen-source reuse‚Äù criteria in our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/), which take precedence over all open-source licenses. These criteria include crediting the original author, making meaningful improvements to the code, and sharing the code  [open-source](https://www.tradingview.com/pine-script-docs/writing/publishing/#open)  unless the original author grants  _explicit permission_  to publish it closed-source.\n\n**Use a clear chart**\n\nA script publication‚Äôs chart showcases the script‚Äôs visual outputs to help users understand how it works. This display is not for demonstrating complex charting setups with multiple scripts or drawing tools. If the chart of a published script contains unnecessary scripts or drawings, it will not add clarity for users, and it can potentially mislead them.\n\nTherefore, when publishing a public script, ensure the chart only includes what is  _necessary_  to demonstrate its outputs and behaviors. See the ‚ÄúChart‚Äù section of our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  to understand our chart criteria, and  [this portion](https://www.tradingview.com/pine-script-docs/writing/publishing/#chart)  of the  [Preparing a publication](https://www.tradingview.com/pine-script-docs/writing/publishing/#preparing-a-publication)  section above for detailed recommendations.\n\n**Provide helpful documentation**\n\nSimilar to how users rely on our documentation to understand Pine, users rely on the documentation in an author‚Äôs publications to understand their scripts. When a script publication does not include a helpful description that explains the script‚Äôs workings and how to use it, users often struggle to understand and use it effectively. Therefore, when sharing a script publicly, include a clear description explaining everything users need to know about it and its use.\n\nSee the ‚ÄúDescription‚Äù and ‚ÄúLanguage‚Äù sections of our  [Script Publishing Rules](https://www.tradingview.com/support/solutions/43000590599-script-publishing-rules/)  to understand the criteria for helpful script descriptions. The  [Title and description](https://www.tradingview.com/pine-script-docs/writing/publishing/#title-and-description)  section above provides detailed recommendations based on these criteria.\n\nFor examples of compliant script descriptions, refer to the publications featured in our  [Editors‚Äô picks](https://www.tradingview.com/scripts/editors-picks/). To see examples of our recommended description format, refer to the publications from the  [TradingView](https://www.tradingview.com/u/TradingView/#published-scripts)  and  [PineCoders](https://www.tradingview.com/u/PineCoders/#published-scripts)  accounts.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-432",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[<declaration_statement>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#declaration_statement)",
    "content": "# [Style  guide](https://www.tradingview.com/pine-script-docs/writing/style-guide/#style-guide)\n\n## [Introduction](https://www.tradingview.com/pine-script-docs/writing/style-guide/#introduction)\n\nThis style guide provides recommendations on how to name variables and organize your Pine scripts in a standard way that works well. Scripts that follow our best practices will be easier to read, understand and maintain.\n\nYou can see scripts using these guidelines published from the  [TradingView](https://www.tradingview.com/u/TradingView/#published-scripts)  and  [PineCoders](https://www.tradingview.com/u/PineCoders/#published-scripts)  accounts on the platform.\n\n## [Naming  Conventions](https://www.tradingview.com/pine-script-docs/writing/style-guide/#naming-conventions)\n\nWe recommend the use of:\n\n-   `camelCase`  for all identifiers, i.e., variable or function names:  `ma`,  `maFast`,  `maLengthInput`,  `maColor`,  `roundedOHLC()`,  `pivotHi()`.\n-   All caps  `SNAKE_CASE`  for constants:  `BULL_COLOR`,  `BEAR_COLOR`,  `MAX_LOOKBACK`.\n-   The use of qualifying suffixes when it provides valuable clues about the type or provenance of a variable:  `maShowInput`,  `bearColor`,  `bearColorInput`,  `volumesArray`,  `maPlotID`,  `resultsTable`,  `levelsColorArray`.\n\n## [Script  organization](https://www.tradingview.com/pine-script-docs/writing/style-guide/#script-organization)\n\nThe Pine Script¬Æ compiler is quite forgiving of the positioning of specific statements or the version  [compiler annotation](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations)  in the script. While other arrangements are syntactically correct, this is how we recommend organizing scripts:\n\n```\n\n```\n\n### [<license>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#license)\n\nIf you publish your open-source scripts publicly on TradingView (scripts can also be published privately), your open-source code is by default protected by the Mozilla license. You may choose any other license you prefer.\n\nThe reuse of code from those scripts is governed by our  [House Rules on Script Publishing](https://www.tradingview.com/support/solutions/43000590599)  which preempt the author‚Äôs license.\n\nThe standard license comments appearing at the beginning of scripts are:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/  \n// ¬© username  \n`\n\n### [<version>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#version)\n\nThis is the  [compiler annotation](https://www.tradingview.com/pine-script-docs/language/script-structure/#compiler-annotations)  defining the version of Pine Script the script will use. If none is present, v1 is used. For v6, use:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`//@version=6  \n`",
    "keywords": [
      "www.tradingview",
      "i.e",
      "tradingview.com",
      "mozilla.org",
      "input",
      "plot",
      "var",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-433",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[<constant_declarations>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#constant_declarations)",
    "content": "### [<declaration_statement>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#declaration_statement)\n\nThis is the mandatory declaration statement which defines the type of your script. It must be a call to either  [indicator()](https://www.tradingview.com/pine-script-reference/v6/#fun_indicator),  [strategy()](https://www.tradingview.com/pine-script-reference/v6/#fun_strategy), or  [library()](https://www.tradingview.com/pine-script-reference/v6/#fun_library).\n\n### [<import_statements>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#import_statements)\n\nIf your script uses one or more Pine Script  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/), your  [import](https://www.tradingview.com/pine-script-reference/v6/#kw_import)  statements belong here.",
    "keywords": [
      "www.tradingview",
      "indicator",
      "strategy",
      "import",
      "type",
      "if"
    ]
  },
  {
    "id": "doc-434",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[<inputs>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#inputs)",
    "content": "### [<constant_declarations>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#constant_declarations)\n\nScripts can declare variables qualified as ‚Äúconst‚Äù, i.e., ones referencing a constant value.\n\nWe refer to variables as ‚Äúconstants‚Äù when they meet these criteria:\n\n-   Their declaration uses the optional  `const`  keyword (see our User Manual‚Äôs section on  [type qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)  for more information).\n-   They are initialized using a literal (e.g.,  `100`  or  `\"AAPL\"`) or a built-in qualified as ‚Äúconst‚Äù (e.g.,  `color.green`).\n-   Their value does not change during the script‚Äôs execution.\n\nWe use  `SNAKE_CASE`  to name these variables and group their declaration near the top of the script. For example:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`// ‚Äî‚Äî‚Äî‚Äî‚Äî Constants  \nint  MS_IN_MIN  =  60  *  1000  \nint  MS_IN_HOUR  =  MS_IN_MIN  *  60  \nint  MS_IN_DAY  =  MS_IN_HOUR  *  24  \n  \ncolor  GRAY  =  #808080ff  \ncolor  LIME  =  #00FF00ff  \ncolor  MAROON  =  #800000ff  \ncolor  ORANGE  =  #FF8000ff  \ncolor  PINK  =  #FF0080ff  \ncolor  TEAL  =  #008080ff  \ncolor  BG_DIV  =  color.new(ORANGE,  90)  \ncolor  BG_RESETS  =  color.new(GRAY,  90)  \n  \nstring  RST1  =  \"No reset; cumulate since the beginning of the chart\"  \nstring  RST2  =  \"On a stepped higher timeframe (HTF)\"  \nstring  RST3  =  \"On a fixed HTF\"  \nstring  RST4  =  \"At a fixed time\"  \nstring  RST5  =  \"At the beginning of the regular session\"  \nstring  RST6  =  \"At the first visible chart bar\"  \nstring  RST7  =  \"Fixed rolling period\"  \n  \nstring  LTF1  =  \"Least precise, covering many chart bars\"  \nstring  LTF2  =  \"Less precise, covering some chart bars\"  \nstring  LTF3  =  \"More precise, covering less chart bars\"  \nstring  LTF4  =  \"Most precise, 1min intrabars\"  \n  \nstring  TT_TOTVOL  =  \"The 'Bodies' value is the transparency of the total volume candle bodies. Zero is opaque, 100 is transparent.\"  \nstring  TT_RST_HTF  =  \"This value is used when '\"  +  RST3  +\"' is selected.\"  \nstring  TT_RST_TIME  =  \"These values are used when '\"  +  RST4  +\"' is selected.  \nA  reset  will  occur  when  the  time  is  greater  or  equal  to  the  bar's open time, and less than its close time.\\nHour: 0-23\\nMinute: 0-59\"  \nstring  TT_RST_PERIOD  =  \"This value is used when '\"  +  RST7  +\"' is selected.\"  \n`\n\nIn this example:\n\n-   The  `RST*`  and  `LTF*`  constants will be used as tuple elements in the  `options`  argument of  `input.*()`  calls.\n-   The  `TT_*`  constants will be used as  `tooltip`  arguments in  `input.*()`  calls. Note how we use a line continuation for long string literals.\n-   We do not use  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  to initialize constants. The Pine Script runtime is optimized to handle declarations on each bar, but using  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  to initialize a variable only the first time it is declared incurs a minor penalty on script performance because of the maintenance that  [var](https://www.tradingview.com/pine-script-reference/v6/#kw_var)  variables require on further bars.\n\nNote that:\n\n-   Literals used in more than one place in a script should always be declared as a constant. Using the constant rather than the literal makes it more readable if it is given a meaningful name, and the practice makes code easier to maintain. Even though the quantity of milliseconds in a day is unlikely to change in the future,  `MS_IN_DAY`  is more meaningful than  `1000 * 60 * 60 * 24`.\n-   Constants only used in the local block of a function or  [if](https://www.tradingview.com/pine-script-reference/v6/#kw_if),  [while](https://www.tradingview.com/pine-script-reference/v6/#kw_while), etc., statement for example, can be declared in that local block.",
    "keywords": [
      "www.tradingview",
      "i.e",
      "e.g",
      "color.green",
      "tradingview.com",
      "color.new",
      "input",
      "var",
      "const",
      "type",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "doc-435",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[<function_declarations>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#function_declarations)",
    "content": "### [<inputs>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#inputs)\n\nIt is  **much**  easier to read scripts when all their inputs are in the same code section. Placing that section at the beginning of the script also reflects how they are processed at runtime, i.e., before the rest of the script is executed.\n\nSuffixing input variable names with  `input`  makes them more readily identifiable when they are used later in the script:  `maLengthInput`,  `bearColorInput`,  `showAvgInput`, etc.\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`// ‚Äî‚Äî‚Äî‚Äî‚Äî Inputs  \nstring  resetInput  =  input.string(RST2,  \"CVD Resets\",  inline  =  \"00\",  options  = [RST1,  RST2,  RST3,  RST4,  RST5,  RST6,  RST7])  \nstring  fixedTfInput  =  input.timeframe(\"D\",  \"‚ÄÉ‚ÄÉFixed HTF:‚ÄÉ‚ÄÉ\",  tooltip  =  TT_RST_HTF)  \nint  hourInput  =  input.int(9,  \"‚ÄÉ‚ÄÉFixed time hour:‚Äâ‚Äâ\",  inline  =  \"01\",  minval  =  0,  maxval  =  23)  \nint  minuteInput  =  input.int(30,  \"minute\",  inline  =  \"01\",  minval  =  0,  maxval  =  59,  tooltip  =  TT_RST_TIME)  \nint  fixedPeriodInput  =  input.int(20,  \"‚ÄÉ‚ÄÉFixed period:‚ÄÉ‚ÄÉ\",  inline  =  \"02\",  minval  =  1,  tooltip  =  TT_RST_PERIOD)  \nstring  ltfModeInput  =  input.string(LTF3,  \"Intrabar precision\",  inline  =  \"03\",  options  = [LTF1,  LTF2,  LTF3,  LTF4])  \n`",
    "keywords": [
      "www.tradingview",
      "i.e",
      "tradingview.com",
      "input.string",
      "input.timeframe",
      "input.int",
      "input",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-436",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[<alerts>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#alerts)",
    "content": "### [<function_declarations>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#function_declarations)\n\nAll user-defined functions must be defined in the script‚Äôs global scope; nested function definitions are not allowed in Pine Script.\n\nOptimal function design should minimize the use of global variables in the function‚Äôs scope, as they undermine function portability. When it can‚Äôt be avoided, those functions must follow the global variable declarations in the code, which entails they can‚Äôt always be placed in the <function_declarations> section. Such dependencies on global variables should ideally be documented in the function‚Äôs comments.\n\nIt will also help readers if you document the function‚Äôs objective, parameters and result. The same syntax used in  [libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)  can be used to document your functions. This can make it easier to port your functions to a library should you ever decide to do so:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n``//@version=6  \nindicator(\"<function_declarations>\",  \"\",  true)  \n  \nstring  SIZE_LARGE  =  \"Large\"  \nstring  SIZE_NORMAL  =  \"Normal\"  \nstring  SIZE_SMALL  =  \"Small\"  \n  \nstring  sizeInput  =  input.string(SIZE_NORMAL,  \"Size\",  options  = [SIZE_LARGE,  SIZE_NORMAL,  SIZE_SMALL])  \n  \n// @function Used to produce an argument for the `size` parameter in built-in functions.  \n// @param userSize (simple string) User-selected size.  \n// @returns One of the `size.*` built-in constants.  \n// Dependencies SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL  \ngetSize(simple  string  userSize) =>  \nresult  =  \nswitch  userSize  \nSIZE_LARGE  =>  size.large  \nSIZE_NORMAL  =>  size.normal  \nSIZE_SMALL  =>  size.small  \n=>  size.auto  \n  \nif  ta.rising(close,  3)  \nlabel.new(bar_index,  na,  yloc  =  yloc.abovebar,  style  =  label.style_arrowup,  size  =  getSize(sizeInput))  \n``\n\n### [<calculations>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#calculations)\n\nThis is where the script‚Äôs core calculations and logic should be placed. Code can be easier to read when variable declarations are placed near the code segment using the variables. Some programmers prefer to place all their non-constant variable declarations at the beginning of this section, which is not always possible for all variables, as some may require some calculations to have been executed before their declaration.\n\n### [<strategy_calls>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#strategy_calls)\n\nStrategies are easier to read when strategy calls are grouped in the same section of the script.\n\n### [<visuals>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#visuals)\n\nThis section should ideally include all the statements producing the script‚Äôs visuals, whether they be plots, drawings, background colors, candle-plotting, etc. See the Pine Script user manual‚Äôs section on  [Z-index](https://www.tradingview.com/pine-script-docs/visuals/overview/#z-index)  for more information on how the relative depth of visuals is determined.",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "input.string",
      "size.large",
      "size.normal",
      "size.small",
      "size.auto",
      "ta.rising",
      "label.new",
      "yloc.abovebar",
      "label.style_arrowup",
      "indicator",
      "strategy",
      "input",
      "plot",
      "var",
      "simple",
      "const",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "doc-437",
    "type": "documentation",
    "source": "writing_scripts/style_guide.md",
    "section": "writing_scripts",
    "title": "[Explicit  typing](https://www.tradingview.com/pine-script-docs/writing/style-guide/#explicit-typing)",
    "content": "### [<alerts>](https://www.tradingview.com/pine-script-docs/writing/style-guide/#alerts)\n\nAlert code will usually require the script‚Äôs calculations to have executed before it, so it makes sense to put it at the end of the script.\n\n## [Spacing](https://www.tradingview.com/pine-script-docs/writing/style-guide/#spacing)\n\nA space should be used on both sides of all operators, except unary operators (`-1`). A space is also recommended after all commas and when using named function arguments, as in  `plot(series = close)`:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`int  a  =  close  >  open  ?  1  :  -1  \nvar  int  newLen  =  2  \nnewLen  :=  min(20,  newlen  +  1)  \nfloat  a  =  -b  \nfloat  c  =  d  >  e  ?  d  -  e  :  d  \nint  index  =  bar_index  %  2  ==  0  ?  1  :  2  \nplot(close,  color  =  color.red)  \n`\n\n## [Line  wrapping](https://www.tradingview.com/pine-script-docs/writing/style-guide/#line-wrapping)\n\nLine wrapping can make long lines easier to read. Line wraps are defined by using an indentation level that is not a multiple of four, as four spaces or a tab are used to define local blocks. Here we use two spaces:\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`plot(  \nseries  =  close,  \ntitle  =  \"Close\",  \ncolor  =  color.blue,  \nshow_last  =  10  \n)  \n`\n\n## [Vertical  alignment](https://www.tradingview.com/pine-script-docs/writing/style-guide/#vertical-alignment)\n\nVertical alignment using tabs or spaces can be useful in code sections containing many similar lines such as constant declarations or inputs. They can make mass edits much easier using the Pine Editor‚Äôs multi-cursor feature (`ctrl`  +  `alt`  +  `ü†Ö`):\n\n[Pine Script¬Æ](https://tradingview.com/pine-script-docs)\n\nCopied\n\n`// Colors used as defaults in inputs.  \ncolor  COLOR_AQUA  =  #0080FFff  \ncolor  COLOR_BLACK  =  #000000ff  \ncolor  COLOR_BLUE  =  #013BCAff  \ncolor  COLOR_CORAL  =  #FF8080ff  \ncolor  COLOR_GOLD  =  #CCCC00ff  \n`\n\n## [Explicit  typing](https://www.tradingview.com/pine-script-docs/writing/style-guide/#explicit-typing)\n\nIncluding the type of variables when declaring them is not required. However, it helps make scripts easier to read, navigate, and understand. It can help clarify the expected types at each point in a script‚Äôs execution and distinguish a variable‚Äôs declaration (using  `=`) from its reassignments (using  `:=`). Using explicit typing can also make scripts easier to  [debug](https://www.tradingview.com/pine-script-docs/writing/debugging/).",
    "keywords": [
      "www.tradingview",
      "tradingview.com",
      "color.red",
      "color.blue",
      "input",
      "plot",
      "alert",
      "var",
      "series",
      "const",
      "type",
      "for",
      "if"
    ]
  }
]