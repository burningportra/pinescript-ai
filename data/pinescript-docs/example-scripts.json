[
  {
    "id": "script-0",
    "type": "example",
    "category": "channels",
    "title": "Aberration (ABBER)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Aberration (ABBER)\", \"ABBER\", overlay=true)\r\n\r\n//@function Calculates Aberration bands measuring deviation from a central moving average\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/abber.md\r\n//@param source Series to calculate aberration from\r\n//@param ma_line Pre-calculated moving average line\r\n//@param period Lookback period for deviation calculation\r\n//@param multiplier Multiplier for deviation bands\r\n//@returns [upper_band, lower_band, deviation] Aberration band values and deviation\r\n//@optimized Uses simple deviation averaging with O(n) complexity\r\nabber(series float source, series float ma_line, simple int period, simple float multiplier) =>\r\n    if period <= 0 or multiplier <= 0.0\r\n        runtime.error(\"Period and multiplier must be greater than 0\")\r\n    float deviation = math.abs(nz(source) - nz(ma_line))\r\n    float avg_deviation = ta.sma(deviation, period)\r\n    float upper_band = ma_line + multiplier * avg_deviation\r\n    float lower_band = ma_line - multiplier * avg_deviation\r\n    [upper_band, lower_band, avg_deviation]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_period = input.int(20, \"Period\", minval=1)\r\ni_ma_type = input.string(\"SMA\", \"Moving Average Type\", options=[\"SMA\", \"EMA\", \"WMA\", \"RMA\", \"HMA\"])\r\ni_multiplier = input.float(2.0, \"Deviation Multiplier\", minval=0.1, step=0.1)\r\ni_show_ma = input.bool(true, \"Show Moving Average Line\")\r\n\r\n// Calculate the moving average based on selected type\r\nma_line = switch i_ma_type\r\n    \"SMA\" => ta.sma(i_source, i_period)\r\n    \"EMA\" => ta.ema(i_source, i_period)\r\n    \"WMA\" => ta.wma(i_source, i_period)\r\n    \"RMA\" => ta.rma(i_source, i_period)\r\n    \"HMA\" => ta.wma(2 * ta.wma(i_source, i_period / 2) - ta.wma(i_source, i_period), math.round(math.sqrt(i_period)))\r\n    => ta.sma(i_source, i_period)\r\n\r\n// Calculation\r\n[upper_band, lower_band, deviation] = abber(i_source, ma_line, i_period, i_multiplier)\r\n\r\n// Plots\r\np_upper = plot(upper_band, \"Upper Band\", color=color.yellow, linewidth=2)\r\np_lower = plot(lower_band, \"Lower Band\", color=color.yellow, linewidth=2)\r\nplot(i_show_ma ? ma_line : na, \"MA\", color=color.yellow, linewidth=2)\r\nfill(p_upper, p_lower, color=color.new(color.blue, 90), title=\"Band Fill\")\r\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "ta.sma",
      "input.source",
      "input.int",
      "input.string",
      "input.float",
      "input.bool",
      "ta.ema",
      "ta.wma",
      "ta.rma",
      "math.round",
      "math.sqrt",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "aberration (abber)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "ta.sma",
      "input.source",
      "input.int",
      "input.string",
      "input.float",
      "input.bool",
      "ta.ema",
      "ta.wma",
      "ta.rma",
      "math.round",
      "math.sqrt",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "abber.md",
      "runtime.error",
      "math.abs",
      "ta.sma",
      "input.source",
      "input.int",
      "input.string",
      "input.float",
      "input.bool",
      "ta.ema",
      "ta.wma",
      "ta.rma",
      "math.round",
      "math.sqrt",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "series",
      "simple",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "script-1",
    "type": "example",
    "category": "channels",
    "title": "Acceleration Bands (ACCBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Acceleration Bands (ACCBANDS)\", \"ACCBANDS\", overlay=true)\n\n//@function Calculates Acceleration Bands using SMAs of high, low, close prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/accbands.md\n//@param high Series of high prices\n//@param low Series of low prices\n//@param close Series of close prices\n//@param period Lookback period for the moving average\n//@param factor Multiplier for band width calculation\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses circular buffers with O(1) complexity per bar\naccbands(series float high, series float low, series float close, simple int period, simple float factor = 2.0) =>\n    if period <= 0 or factor <= 0.0\n        runtime.error(\"Period and factor must be greater than 0\")\n    var int p = math.max(1, period)\n    var int head = 0\n    var int count = 0\n    var array<float> bufferHigh = array.new_float(p, na)\n    var array<float> bufferLow = array.new_float(p, na)\n    var array<float> bufferClose = array.new_float(p, na)\n    var float sumHigh = 0.0\n    var float sumLow = 0.0\n    var float sumClose = 0.0\n    float oldestHigh = array.get(bufferHigh, head)\n    float oldestLow = array.get(bufferLow, head)\n    float oldestClose = array.get(bufferClose, head)\n    if not na(oldestHigh)\n        sumHigh -= oldestHigh\n        sumLow -= oldestLow\n        sumClose -= oldestClose\n        count -= 1\n    float currentHigh = nz(high)\n    float currentLow = nz(low)\n    float currentClose = nz(close)\n    sumHigh += currentHigh\n    sumLow += currentLow\n    sumClose += currentClose\n    count += 1\n    array.set(bufferHigh, head, currentHigh)\n    array.set(bufferLow, head, currentLow)\n    array.set(bufferClose, head, currentClose)\n    head := (head + 1) % p\n    float smaHigh = nz(sumHigh / count)\n    float smaLow = nz(sumLow / count)\n    float smaClose = nz(sumClose / count)\n    float bandWidth = (smaHigh - smaLow) * factor\n    [smaClose, smaHigh + bandWidth, smaLow - bandWidth]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_factor = input.float(2.0, \"Factor\", minval=0.001)\n\n// Calculation\n[middle, upper, lower] = accbands(high, low, close, i_period, i_factor)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "acceleration bands (accbands)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "accbands.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-2",
    "type": "example",
    "category": "channels",
    "title": "Andrews",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Andrews' Pitchfork (AP)\", \"AP\", overlay=true)\r\n\r\n//@function Calculates Andrews' Pitchfork lines based on three pivot points\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/apchannel.md\r\n//@param p1_back Bars back to first pivot point (leftmost)\r\n//@param p2_back Bars back to second pivot point (middle)\r\n//@param p3_back Bars back to third pivot point (rightmost)\r\n//@returns tuple of [median, upper, lower] lines for current bar\r\n//@optimized Geometric projection with O(1) complexity per bar\r\napchannel(simple int p1_back, simple int p2_back, simple int p3_back) =>\r\n    if p1_back <= 0 or p2_back <= 0 or p3_back <= 0 or not (p1_back > p2_back and p2_back > p3_back)\r\n        runtime.error(\"Use P1 oldest, P2 newer, P3 newest — all >0\")\r\n        [na, na, na]\r\n    int p1_b = math.min(p1_back, bar_index)\r\n    int p2_b = math.min(p2_back, bar_index)\r\n    int p3_b = math.min(p3_back, bar_index)\r\n    int p1_time = bar_index - p1_b\r\n    int p2_time = bar_index - p2_b\r\n    int p3_time = bar_index - p3_b\r\n    float p1_price = nz(close[p1_b])\r\n    float p2_price = nz(high[p2_b])\r\n    float p3_price = nz(low[p3_b])\r\n    if na(close[p1_b]) or na(high[p2_b]) or na(low[p3_b])\r\n        [float(na), float(na), float(na)]\r\n    float mid_time_float = (float(p2_time) + float(p3_time)) / 2.0\r\n    float mid_price = (p2_price + p3_price) / 2.0\r\n    float time_diff = mid_time_float - float(p1_time)\r\n    float median_slope = math.abs(time_diff) > 1e-10 ? (mid_price - p1_price) / time_diff : 0.0\r\n    float median_value = p1_price + median_slope * (float(bar_index) - float(p1_time))\r\n    float upper_value = p2_price + median_slope * (float(bar_index) - float(p2_time))\r\n    float lower_value = p3_price + median_slope * (float(bar_index) - float(p3_time))\r\n    if math.abs(median_value) > 1e9 or math.abs(upper_value) > 1e9 or math.abs(lower_value) > 1e9\r\n        [float(na), float(na), float(na)]\r\n    [median_value, upper_value, lower_value]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_p1_back = input.int(45, \"Point 1 (Leftmost)\", minval=1)\r\ni_p2_back = input.int(30, \"Point 2 (Second)\", minval=1)\r\ni_p3_back = input.int(15, \"Point 3 (Third)\", minval=1)\r\n\r\n// Validation\r\nif i_p1_back <= i_p2_back or i_p2_back <= i_p3_back\r\n    runtime.error(\"Points must be in chronological order (P1 > P2 > P3)\")\r\n\r\n// Calculation\r\n[median, upper, lower] = apchannel(i_p1_back, i_p2_back, i_p3_back)\r\n\r\n// Plot\r\nplot(median, \"Median\", color=color.yellow, linewidth=2)\r\np1 = plot(upper, \"Upper\", color=color.new(color.blue, 50), linewidth=1)\r\np2 = plot(lower, \"Lower\", color=color.new(color.blue, 50), linewidth=1)\r\nfill(p1, p2, color=color.new(color.blue, 90))\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "andrews",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "apchannel.md",
      "runtime.error",
      "math.min",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-3",
    "type": "example",
    "category": "channels",
    "title": "Adaptive Price Zone",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Adaptive Price Zone\", \"APZ\", overlay=true)\n\n//@function Calculates Adaptive Price Zone using double-smoothed EMA\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/apz.md\n//@param source Series to calculate middle line from\n//@param period Lookback period (sqrt applied internally for smoothing)\n//@param bandPct Band width multiplier\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses compound warmup compensation for nested EMAs, O(1) complexity per bar\napz(series float source, simple int period, simple float bandPct) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if period > 5000\n        runtime.error(\"Period exceeds maximum of 5000\")\n    if bandPct <= 0.0\n        runtime.error(\"Band multiplier must be greater than 0\")\n\n    float smoothPeriod = math.sqrt(period)\n    float alpha = 2.0 / (smoothPeriod + 1.0)\n    float beta = 1.0 - alpha\n\n    var float ema1_price = 0.0\n    var float ema2_price = 0.0\n    var float ema1_range = 0.0\n    var float ema2_range = 0.0\n    var float e = 1.0\n    var bool warmup = true\n\n    float current_price = nz(source)\n    float current_range = nz(high - low)\n\n    ema1_price := alpha * current_price + beta * ema1_price\n    ema2_price := alpha * ema1_price + beta * ema2_price\n\n    ema1_range := alpha * current_range + beta * ema1_range\n    ema2_range := alpha * ema1_range + beta * ema2_range\n\n    float middle = ema2_price\n    float adaptiveRange = ema2_range\n\n    if warmup\n        e *= beta * beta\n        float compensator = 1.0 / (1.0 - e)\n        middle := compensator * ema2_price\n        adaptiveRange := compensator * ema2_range\n        warmup := e > 1e-10\n\n    float width = bandPct * adaptiveRange\n    float upper = middle + width\n    float lower = middle - width\n\n    [middle, upper, lower]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1, maxval=5000)\ni_bandPct = input.float(2.0, \"Band Multiplier\", minval=0.001, step=0.1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\n[middle, upper, lower] = apz(i_source, i_period, i_bandPct)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.new(color.yellow, 50), linewidth=1)\np2 = plot(lower, \"Lower\", color=color.new(color.yellow, 50), linewidth=1)\nfill(p1, p2, color=color.new(color.yellow, 90), title=\"Band Fill\")",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "color.new",
      "plot",
      "fill"
    ],
    "keywords": [
      "adaptive price zone",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "color.new",
      "plot",
      "fill",
      "github.com",
      "apz.md",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-4",
    "type": "example",
    "category": "channels",
    "title": "ATR Bands (ATRBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"ATR Bands (ATRBANDS)\", \"ATRBANDS\", overlay=true)\n\n//@function Calculates ATR Bands using ATR for width\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/atrbands.md\n//@param source Source series for the center line\n//@param length Period for ATR and MA calculations\n//@param multiplier ATR multiplier for band width\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses RMA with warmup compensator, O(1) complexity per bar\natrbands(series float source, simple int length, simple float multiplier) =>\n    if length <= 0 or multiplier <= 0.0\n        runtime.error(\"Length and multiplier must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    var int p = math.max(1, length)\n    var int head = 0\n    var int count = 0\n    var array<float> bufferSource = array.new_float(p, na)\n    var array<float> bufferTR = array.new_float(p, na)\n    var float sumSource = 0.0\n    var float sumTR = 0.0\n    float oldestSource = array.get(bufferSource, head)\n    float oldestTR = array.get(bufferTR, head)\n    if not na(oldestSource)\n        sumSource -= oldestSource\n        sumTR -= oldestTR\n        count -= 1\n    float currentSource = nz(source)\n    float currentTR = nz(trueRange)\n    sumSource += currentSource\n    sumTR += currentTR\n    count += 1\n    array.set(bufferSource, head, currentSource)\n    array.set(bufferTR, head, currentTR)\n    head := (head + 1) % p\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atrValue = na\n    if not na(trueRange)\n        float alpha = 1.0 / float(length)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e := (1 - alpha) * e\n        atrValue := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    float middleBand = nz(sumSource / count, source)\n    float width = nz(atrValue * multiplier)\n    [middleBand, middleBand + width, middleBand - width]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1)\ni_mult = input.float(2.0, \"ATR Multiplier\", minval=0.001)\n\n// Calculation\n[middle, upper, lower] = atrbands(i_source, i_length, i_mult)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "atr bands (atrbands)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "atrbands.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-5",
    "type": "example",
    "category": "channels",
    "title": "Bollinger Bands (BBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger Bands (BBANDS)\", \"BBANDS\", overlay=true)\n\n//@function Calculates Bollinger Bands with adjustable period and multiplier\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/bbands.md\n//@param source Series to calculate Bollinger Bands from\n//@param period Lookback period for calculations\n//@param multiplier Standard deviation multiplier for band width\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses circular buffer with running sums, O(1) complexity per bar\nbbands(series float source, simple int period, simple float multiplier) =>\n    if period <= 0 or multiplier <= 0.0\n        runtime.error(\"Period and multiplier must be greater than 0\")\n    var int p = math.max(1, period)\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0\n    var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float current_val = nz(source)\n    sum += current_val\n    sumSq += current_val * current_val\n    count += 1\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    float basis = nz(sum / count, source)\n    float dev = count > 1 ? multiplier * math.sqrt(math.max(0.0, sumSq / count - basis * basis)) : 0.0\n    [basis, basis + dev, basis - dev]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"StdDev Multiplier\", minval=0.001)\n\n// Calculation\n[basis, upper, lower] = bbands(i_source, i_period, i_multiplier)\n\n// Plot\nplot(basis, \"Basis\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "bollinger bands (bbands)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "bbands.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-6",
    "type": "example",
    "category": "channels",
    "title": "Donchian Channels (DCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Donchian Channels (DCHANNEL)\", \"DCHANNEL\", overlay=true)\n\n//@function Calculates the Donchian Channel (DC) efficiently using monotonic deques\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/dchannel.md\n//@param hi Source series for the highest high calculation (usually high)\n//@param lo Source series for the lowest low calculation (usually low)\n//@param p Lookback period (p > 0)\n//@returns Tuple containing [basis, upper_band, lower_band]\n//@optimized Uses monotonic deque for O(1) amortized complexity per bar\ndchannel(series float hi, series float lo, simple int p) =>\n    if p <= 0\n        runtime.error(\"Period must be > 0\")\n    var float[] hbuf = array.new_float(p, na)\n    var float[] lbuf = array.new_float(p, na)\n    var int[] hq = array.new_int()\n    var int[] lq = array.new_int()\n    int idx = bar_index % p\n    array.set(hbuf, idx, hi)\n    array.set(lbuf, idx, lo)\n    while array.size(hq) > 0 and array.get(hq, 0) <= bar_index - p\n        array.shift(hq)\n    while array.size(hq) > 0 and array.get(hbuf, array.get(hq, -1) % p) <= hi\n        array.pop(hq)\n    array.push(hq, bar_index)\n    while array.size(lq) > 0 and array.get(lq, 0) <= bar_index - p\n        array.shift(lq)\n    while array.size(lq) > 0 and array.get(lbuf, array.get(lq, -1) % p) >= lo\n        array.pop(lq)\n    array.push(lq, bar_index)\n    float top = array.get(hbuf, array.get(hq, 0) % p)\n    float bot = array.get(lbuf, array.get(lq, 0) % p)\n    [math.avg(top, bot), top, bot]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_high = input.source(high, \"High Source\")\ni_low = input.source(low, \"Low Source\")\n\n// Calculation\n[basis, upper, lower] = dchannel(i_high, i_low, i_period)\n\n// Plot\nplot(basis, \"Basis\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.avg",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "donchian channels (dchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.avg",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "dchannel.md",
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.avg",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "script-7",
    "type": "example",
    "category": "channels",
    "title": "Decay Min-Max Channel (DECAYCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Decay Min-Max Channel (DECAYCHANNEL)\", \"DECAYCHANNEL\", overlay=true)\n\n//@function Calculates the Decaying Min-Max Channel with decay towards midpoint\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/decaychannel.md\n//@param period Lookback period (period > 0)\n//@param hi Source series for the highest high calculation (usually high)\n//@param lo Source series for the lowest low calculation (usually low)\n//@returns Tuple containing [decaying_highest_high, decaying_lowest_low]\n//@optimized Uses exponential decay with O(n) complexity per bar\ndecaychannel(simple int period, series float hi = high, series float lo = low) =>\n    if period <= 0\n        runtime.error(\"Period must be > 0\")\n    float decayLambda = math.log(2.0) / period\n    var float[] hbuf = array.new_float(period, na)\n    var float[] lbuf = array.new_float(period, na)\n    var float currentMax = na\n    var float currentMin = na\n    var int timeSinceNewMax = 0\n    var int timeSinceNewMin = 0\n    int idx = bar_index % period\n    array.set(hbuf, idx, hi)\n    array.set(lbuf, idx, lo)\n    float periodMax = na\n    float periodMin = na\n    float periodSum = 0.0\n    int validCount = 0\n    for i = 0 to period - 1\n        float hVal = array.get(hbuf, i)\n        float lVal = array.get(lbuf, i)\n        if not na(hVal) and not na(lVal)\n            periodMax := na(periodMax) ? hVal : math.max(periodMax, hVal)\n            periodMin := na(periodMin) ? lVal : math.min(periodMin, lVal)\n            periodSum := periodSum + (hVal + lVal) / 2.0\n            validCount := validCount + 1\n    float periodAverage = validCount > 0 ? periodSum / validCount : (hi + lo) / 2.0\n    if na(currentMax) or na(currentMin)\n        currentMax := na(periodMax) ? hi : periodMax\n        currentMin := na(periodMin) ? lo : periodMin\n        timeSinceNewMax := 0\n        timeSinceNewMin := 0\n    else\n        if hi >= currentMax\n            currentMax := hi\n            timeSinceNewMax := 0\n        else\n            timeSinceNewMax := timeSinceNewMax + 1\n        if lo <= currentMin\n            currentMin := lo\n            timeSinceNewMin := 0\n        else\n            timeSinceNewMin := timeSinceNewMin + 1\n        if validCount > 0\n            float midpoint = (currentMax + currentMin) / 2.0\n            float maxDecayRate = 1 - math.exp(-decayLambda * timeSinceNewMax)\n            float minDecayRate = 1 - math.exp(-decayLambda * timeSinceNewMin)\n            currentMax := currentMax - maxDecayRate * (currentMax - midpoint)\n            currentMin := currentMin - minDecayRate * (currentMin - midpoint)\n            if not na(periodMax)\n                currentMax := math.min(currentMax, periodMax)\n            if not na(periodMin)\n                currentMin := math.max(currentMin, periodMin)\n    [currentMax, currentMin]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(100, \"Period\", minval=1)\n\n// Calculation\n[highest, lowest] = decaychann",
    "functions_used": [
      "runtime.error",
      "math.log",
      "array.new_float",
      "array.set",
      "array.get",
      "math.max",
      "math.min",
      "math.exp",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "decay min-max channel (decaychannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "array.new_float",
      "array.set",
      "array.get",
      "math.max",
      "math.min",
      "math.exp",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "decaychannel.md",
      "runtime.error",
      "math.log",
      "array.new_float",
      "array.set",
      "array.get",
      "math.max",
      "math.min",
      "math.exp",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-8",
    "type": "example",
    "category": "channels",
    "title": "Fractal Chaos Bands (FCB)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Fractal Chaos Bands (FCB)\", \"FCB\", overlay=true)\n\n//@function Calculates Fractal Chaos Bands based on fractal highs and lows\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/fcb.md\n//@param period Lookback period for highest/lowest calculation\n//@returns [upper_band, lower_band] Fractal Chaos Band values\n//@optimized Uses monotonic deque for O(1) amortized complexity\nfcb(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    bool is_fractal_high = high[1] > high[2] and high[1] > high[0]\n    bool is_fractal_low = low[1] < low[2] and low[1] < low[0]\n    var float hi_fractal = high\n    var float lo_fractal = low\n    if is_fractal_high\n        hi_fractal := high[1]\n    if is_fractal_low\n        lo_fractal := low[1]\n    var hi_deque = array.new_int(0)\n    var hi_buffer = array.new_float(period, na)\n    var int hi_current_index = 0\n    float hi_current_val = nz(hi_fractal)\n    array.set(hi_buffer, hi_current_index, hi_current_val)\n    while array.size(hi_deque) > 0 and array.get(hi_deque, 0) <= bar_index - period\n        array.shift(hi_deque)\n    while array.size(hi_deque) > 0\n        int last_index = array.get(hi_deque, array.size(hi_deque) - 1)\n        int buffer_lookup = last_index % period\n        if array.get(hi_buffer, buffer_lookup) <= hi_current_val\n            array.pop(hi_deque)\n        else\n            break\n    array.push(hi_deque, bar_index)\n    int highest_index = array.get(hi_deque, 0)\n    int highest_buffer_index = highest_index % period\n    float upper_band = array.get(hi_buffer, highest_buffer_index)\n    hi_current_index := (hi_current_index + 1) % period\n    var lo_deque = array.new_int(0)\n    var lo_buffer = array.new_float(period, na)\n    var int lo_current_index = 0\n    float lo_current_val = nz(lo_fractal)\n    array.set(lo_buffer, lo_current_index, lo_current_val)\n    while array.size(lo_deque) > 0 and array.get(lo_deque, 0) <= bar_index - period\n        array.shift(lo_deque)\n    while array.size(lo_deque) > 0\n        int last_index = array.get(lo_deque, array.size(lo_deque) - 1)\n        int buffer_lookup = last_index % period\n        if array.get(lo_buffer, buffer_lookup) >= lo_current_val\n            array.pop(lo_deque)\n        else\n            break\n    array.push(lo_deque, bar_index)\n    int lowest_index = array.get(lo_deque, 0)\n    int lowest_buffer_index = lowest_index % period\n    float lower_band = array.get(lo_buffer, lowest_buffer_index)\n    lo_current_index := (lo_current_index + 1) % period\n    [upper_band, lower_band]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1, maxval=999)\nplot_fractal_points = input.bool(false, \"Show Fractal Points\")\n\n// Calculation\n[upper_band, lower_band] = fcb(i_period)\n\n// Plots\np_upper = plot(upper_band, \"Upper Band\", color=color.yellow, linewidth=2)\np_lower = plot(lower_band, \"Lower Band\", color=color.yellow, li",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "fractal chaos bands (fcb)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "fcb.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-9",
    "type": "example",
    "category": "channels",
    "title": "Jurik Volatility Bands (JBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Jurik Volatility Bands (JBANDS)\", \"JBANDS\", overlay=true)\n\n//@function Calculates JBANDS using adaptive techniques to adjust width to market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/jbands.md\n//@param source Series to calculate Jvolty from\n//@param period Number of bars used in the calculation\n//@returns JBANDS volatility bands\n//@optimized Uses adaptive volatility weighting with O(1) complexity per bar\njbands(series float source, simple int period) =>\n    var simple float LEN1 = math.max((math.log(math.sqrt(0.5 * (period - 1))) / math.log(2.0)) + 2.0, 0.0)\n    var simple float POW1 = math.max(LEN1 - 2.0, 0.5)\n    var simple float LEN2 = math.sqrt(0.5 * (period - 1)) * LEN1\n    var simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65.0) + 1.0)\n    var simple float DIV = 1.0 / (10.0 + 10.0 * (math.min(math.max(period - 10, 0), 100) / 100.0))\n    var float upperBand = nz(source)\n    var float lowerBand = nz(source)\n    var float vSum = 0.0\n    var float avgVolty = 0.0\n    if na(source)\n        na\n    else\n        float del1 = (low + high) * 0.5 - upperBand\n        float del2 = (low + high) * 0.5 - lowerBand\n        float volty = math.max(math.abs(del1), math.abs(del2))\n        float past_volty = na(volty[10]) ? 0.0 : volty[10]\n        vSum := vSum + (volty - past_volty) * DIV\n        avgVolty := na(avgVolty) ? vSum : avgVolty + AVG_VOLTY_ALPHA * (vSum - avgVolty)\n        float rvolty = 1.0\n        if avgVolty > 0.0\n            rvolty := volty / avgVolty\n            rvolty := math.min(math.max(rvolty, 1.0), math.pow(LEN1, 1.0 / POW1))\n        float Kv = math.pow(LEN2 / (LEN2 + 1.0), math.sqrt(math.pow(rvolty, POW1)))\n        upperBand := del1 > 0.0 ? high : high - Kv * del1\n        lowerBand := del2 < 0.0 ? low : low - Kv * del2\n        [upperBand, lowerBand]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\n[upperBand, lowerBand] = jbands(i_source, i_period)\n\n// Plot\np1 = plot(upperBand, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lowerBand, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "jurik volatility bands (jbands)",
      "channels",
      "indicator",
      "v6",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "jbands.md",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-10",
    "type": "example",
    "category": "channels",
    "title": "Keltner Channel (KCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Keltner Channel (KCHANNEL)\", \"KCHANNEL\", overlay=true)\n\n//@function Calculates Keltner Channel using EMA and ATR\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/kchannel.md\n//@param source Series to calculate middle line from\n//@param length Lookback period for calculations\n//@param mult ATR multiplier for band width\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses EMA with warmup and ATR with compensator, O(1) complexity per bar\nkchannel(series float source, simple int length, simple float mult) =>\n    if length <= 0 or mult <= 0.0\n        runtime.error(\"Length and multiplier must be greater than 0\")\n    var float alpha = 2.0 / (length + 1)\n    var float sum = 0.0\n    var float weight = 0.0\n    float ema = na\n    if na(sum)\n        sum := source\n        weight := 1.0\n    sum := sum * (1.0 - alpha) + source * alpha\n    weight := weight * (1.0 - alpha) + alpha\n    ema := sum / weight\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atrValue = na\n    if not na(trueRange)\n        float alpha_atr = 1.0 / float(length)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e := (1.0 - alpha_atr) * e\n        atrValue := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    float width = mult * nz(atrValue, 0.0)\n    [ema, ema + width, ema - width]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1)\ni_mult = input.float(2.0, \"ATR Multiplier\", minval=0.001)\n\n// Calculation\n[middle, upper, lower] = kchannel(i_source, i_length, i_mult)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "keltner channel (kchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "kchannel.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-11",
    "type": "example",
    "category": "channels",
    "title": "MA Envelope (MAE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"MA Envelope (MAE)\", \"MAE\", overlay=true)\n\n//@function Calculates MA Envelope bands using a fixed percentage\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/maenv.md\n//@param source Series to calculate moving average from\n//@param length Lookback period for MA calculation\n//@param percentage Distance of bands from MA as percentage\n//@param ma_type Type of moving average (0:SMA, 1:EMA, 2:WMA)\n//@returns tuple with [middle, upper, lower] band values\n//@optimized SMA uses circular buffer O(1), EMA uses warmup O(1), WMA is O(n)\nmae(series float source, simple int length, simple float percentage, simple int ma_type = 1) =>\n    if length <= 0 or percentage <= 0.0\n        runtime.error(\"Length and percentage must be greater than 0\")\n    float middle = na\n    if ma_type == 0\n        var int head = 0\n        var int count = 0\n        var array<float> buffer = array.new_float(length, na)\n        var float sum = 0.0\n        float oldest = array.get(buffer, head)\n        if not na(oldest)\n            sum -= oldest\n            count -= 1\n        float current = nz(source)\n        sum += current\n        count += 1\n        array.set(buffer, head, current)\n        head := (head + 1) % length\n        middle := sum / count\n    else if ma_type == 1\n        var float alpha = 2.0 / (length + 1)\n        var float sum = 0.0\n        var float weight = 0.0\n        if na(sum)\n            sum := source\n            weight := 1.0\n        sum := sum * (1.0 - alpha) + source * alpha\n        weight := weight * (1.0 - alpha) + alpha\n        middle := sum / weight\n    else if ma_type == 2\n        float norm = 0.0\n        float sum = 0.0\n        for i = 0 to length - 1\n            float w = float((length - i) * length)\n            norm += w\n            sum += nz(source[i]) * w\n        middle := sum / norm\n    else\n        runtime.error(\"MA type must be 0 (SMA), 1 (EMA), or 2 (WMA)\")\n    float dist = middle * percentage / 100.0\n    [middle, middle + dist, middle - dist]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1)\ni_percentage = input.float(1.0, \"Percentage\", minval=0.001)\ni_ma_type = input.int(1, \"MA Type\", minval=0, maxval=2, tooltip=\"0:SMA, 1:EMA, 2:WMA\")\n\n// Calculation\n[middle, upper, lower] = mae(i_source, i_length, i_percentage, i_ma_type)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "ma envelope (mae)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "maenv.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-12",
    "type": "example",
    "category": "channels",
    "title": "Min-Max Channel (MMCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Min-Max Channel (MMCHANNEL)\", \"MMCHANNEL\", overlay=true)\n\n//@function Calculates the Min-Max Channel efficiently using monotonic deques\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/mmchannel.md\n//@param hi Source series for the highest high calculation (usually high)\n//@param lo Source series for the lowest low calculation (usually low)\n//@param period Lookback period (period > 0)\n//@returns Tuple containing [highest_high, lowest_low]\n//@optimized Uses monotonic deque for O(1) amortized complexity per bar\nmmchannel(series float hi, series float lo, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be > 0\")\n    var float[] hbuf = array.new_float(period, na)\n    var float[] lbuf = array.new_float(period, na)\n    var int[] hq = array.new_int()\n    var int[] lq = array.new_int()\n    int idx = bar_index % period\n    array.set(hbuf, idx, hi)\n    array.set(lbuf, idx, lo)\n    while array.size(hq) > 0 and array.get(hq, 0) <= bar_index - period\n        array.shift(hq)\n    while array.size(hq) > 0 and array.get(hbuf, array.get(hq, -1) % period) <= hi\n        array.pop(hq)\n    array.push(hq, bar_index)\n    while array.size(lq) > 0 and array.get(lq, 0) <= bar_index - period\n        array.shift(lq)\n    while array.size(lq) > 0 and array.get(lbuf, array.get(lq, -1) % period) >= lo\n        array.pop(lq)\n    array.push(lq, bar_index)\n    float highest = array.get(hbuf, array.get(hq, 0) % period)\n    float lowest = array.get(lbuf, array.get(lq, 0) % period)\n    [highest, lowest]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_high = input.source(high, \"High Source\")\ni_low = input.source(low, \"Low Source\")\n\n// Calculation\n[highest, lowest] = mmchannel(i_high, i_low, i_period)\n\n// Plot\np1 = plot(highest, \"Highest High\", color=color.yellow, linewidth=2)\np2 = plot(lowest, \"Lowest Low\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "min-max channel (mmchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "mmchannel.md",
      "runtime.error",
      "array.new_float",
      "array.new_int",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "while",
      "if"
    ]
  },
  {
    "id": "script-13",
    "type": "example",
    "category": "channels",
    "title": "Price Channel (PCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Price Channel (PCHANNEL)\", \"PCHANNEL\", overlay=true)\n\n//@function Calculates Price Channel\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/pchannel.md\n//@param length_param Lookback period for determining the highest high and lowest low\n//@returns tuple [upperChannel, middleChannel, lowerChannel]\n//@optimized Uses monotonic deque for O(1) amortized complexity per bar\npchannel(simple int length_param) =>\n    if length_param <= 0\n        runtime.error(\"Length must be greater than 0\")\n    var deque_hi = array.new_int(0)\n    var src_buffer_hi = array.new_float(0, na)\n    var int current_index_hi = 0\n    var deque_lo = array.new_int(0)\n    var src_buffer_lo = array.new_float(0, na)\n    var int current_index_lo = 0\n    if array.size(src_buffer_hi) != length_param\n        src_buffer_hi := array.new_float(length_param, na)\n        current_index_hi := 0\n        array.clear(deque_hi)\n        src_buffer_lo := array.new_float(length_param, na)\n        current_index_lo := 0\n        array.clear(deque_lo)\n    float cv_hi = nz(high)\n    array.set(src_buffer_hi, current_index_hi, cv_hi)\n    float cv_lo = nz(low)\n    array.set(src_buffer_lo, current_index_lo, cv_lo)\n    while array.size(deque_hi) > 0 and array.get(deque_hi, 0) <= bar_index - length_param\n        array.shift(deque_hi)\n    while array.size(deque_lo) > 0 and array.get(deque_lo, 0) <= bar_index - length_param\n        array.shift(deque_lo)\n    while array.size(deque_hi) > 0\n        if array.get(src_buffer_hi, array.get(deque_hi, array.size(deque_hi) - 1) % length_param) <= cv_hi\n            array.pop(deque_hi)\n        else\n            break\n    array.push(deque_hi, bar_index)\n    while array.size(deque_lo) > 0\n        if array.get(src_buffer_lo, array.get(deque_lo, array.size(deque_lo) - 1) % length_param) >= cv_lo\n            array.pop(deque_lo)\n        else\n            break\n    array.push(deque_lo, bar_index)\n    float highestHigh = array.get(src_buffer_hi, array.get(deque_hi, 0) % length_param)\n    current_index_hi := (current_index_hi + 1) % length_param\n    float lowestLow = array.get(src_buffer_lo, array.get(deque_lo, 0) % length_param)\n    current_index_lo := (current_index_lo + 1) % length_param\n    [highestHigh, (highestHigh + lowestLow) / 2.0, lowestLow]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1)\n\n// Calculation\n[upperCh, middleCh, lowerCh] = pchannel(i_length)\n\n// Plot\nplot(middleCh, \"Middle Channel\", color=color.yellow, linewidth=2)\np1 = plot(upperCh, \"Upper Channel\", color=color.yellow, linewidth=2)\np2 = plot(lowerCh, \"Lower Channel\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.size",
      "array.clear",
      "array.set",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "price channel (pchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.size",
      "array.clear",
      "array.set",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "pchannel.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.size",
      "array.clear",
      "array.set",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-14",
    "type": "example",
    "category": "channels",
    "title": "Regression Channels (REGCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Regression Channels (REGCHANNEL)\", \"REGCHANNEL\", overlay=true)\n\n//@function Calculates Regression Channels with parallel lines equidistant from a central linear regression line\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/regchannel.md\n//@param period Lookback period for regression calculation (period > 1)\n//@param source Source series for regression calculation (usually close)\n//@param multiplier Distance multiplier for channel bands (multiplier > 0)\n//@returns Tuple containing [upper_band, regression_line, lower_band]\n//@optimized Uses linear regression with O(n) complexity per bar\nregchannel(simple int period, series float source = close, simple float multiplier = 2.0) =>\n    if period <= 1\n        runtime.error(\"Period must be > 1\")\n    if multiplier <= 0.0\n        runtime.error(\"Multiplier must be > 0\")\n    float sumX = 0.0\n    float sumY = 0.0\n    float sumXY = 0.0\n    float sumX2 = 0.0\n    for i = 0 to period - 1\n        float x = float(i)\n        float y = source[period - 1 - i]\n        sumX := sumX + x\n        sumY := sumY + y\n        sumXY := sumXY + x * y\n        sumX2 := sumX2 + x * x\n    float n = float(period)\n    float slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)\n    float intercept = (sumY - slope * sumX) / n\n    float currentX = float(period - 1)\n    float regression = slope * currentX + intercept\n    float sumResiduals2 = 0.0\n    for i = 0 to period - 1\n        float x = float(i)\n        float y = source[period - 1 - i]\n        float predicted = slope * x + intercept\n        float residual = y - predicted\n        sumResiduals2 := sumResiduals2 + residual * residual\n    float stdDev = math.sqrt(sumResiduals2 / n)\n    float upperBand = regression + multiplier * stdDev\n    float lowerBand = regression - multiplier * stdDev\n    [upperBand, regression, lowerBand]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"Standard Deviation Multiplier\", minval=0.1, step=0.1)\n\n// Calculation\n[upperBand, midLine, lowerBand] = regchannel(i_period, i_source, i_multiplier)\n\n// Plot\np1 = plot(upperBand, \"Upper Band\", color=color.yellow, linewidth=2)\np2 = plot(midLine, \"Regression Line\", color=color.yellow, linewidth=2)\np3 = plot(lowerBand, \"Lower Band\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.red, 90), title=\"Upper Fill\")\nfill(p2, p3, color=color.new(color.green, 90), title=\"Lower Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "plot",
      "fill"
    ],
    "keywords": [
      "regression channels (regchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "plot",
      "fill",
      "github.com",
      "regchannel.md",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-15",
    "type": "example",
    "category": "channels",
    "title": "Standard Deviation Channel (SDCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Standard Deviation Channel (SDCHANNEL)\", \"SDCHANNEL\", overlay=true)\n\n//@function Calculates Standard Deviation Channel with lines N standard deviations above and below a linear regression line\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/sdchannel.md\n//@param period Lookback period for regression and standard deviation calculation (period > 1)\n//@param source Source series for analysis (usually close)\n//@param multiplier Standard deviation multiplier for channel distance (multiplier > 0)\n//@returns Tuple containing [upper_channel, regression_line, lower_channel]\n//@optimized Uses linear regression with O(n) complexity per bar\nsdchannel(simple int period, series float source = close, simple float multiplier = 2.0) =>\n    if period <= 1\n        runtime.error(\"Period must be > 1\")\n    if multiplier <= 0.0\n        runtime.error(\"Multiplier must be > 0\")\n    float sumX = 0.0\n    float sumY = 0.0\n    float sumXY = 0.0\n    float sumX2 = 0.0\n    for i = 0 to period - 1\n        float x = float(i)\n        float y = source[period - 1 - i]\n        sumX := sumX + x\n        sumY := sumY + y\n        sumXY := sumXY + x * y\n        sumX2 := sumX2 + x * x\n    float n = float(period)\n    float slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)\n    float intercept = (sumY - slope * sumX) / n\n    float currentX = float(period - 1)\n    float regressionLine = slope * currentX + intercept\n    float sumSquaredResiduals = 0.0\n    for i = 0 to period - 1\n        float x = float(i)\n        float y = source[period - 1 - i]\n        float predicted = slope * x + intercept\n        float residual = y - predicted\n        sumSquaredResiduals := sumSquaredResiduals + residual * residual\n    float stdDev = math.sqrt(sumSquaredResiduals / n)\n    float upperChannel = regressionLine + multiplier * stdDev\n    float lowerChannel = regressionLine - multiplier * stdDev\n    [upperChannel, regressionLine, lowerChannel]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"Standard Deviation Multiplier\", minval=0.1, step=0.1)\n\n// Calculation\n[upperLine, midLine, lowerLine] = sdchannel(i_period, i_source, i_multiplier)\n\n// Plot\np1 = plot(upperLine, \"Upper Channel\", color=color.yellow, linewidth=2)\np2 = plot(midLine, \"Regression Line\", color=color.yellow, linewidth=2)\np3 = plot(lowerLine, \"Lower Channel\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.red, 90), title=\"Upper Fill\")\nfill(p2, p3, color=color.new(color.green, 90), title=\"Lower Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "plot",
      "fill"
    ],
    "keywords": [
      "standard deviation channel (sdchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "plot",
      "fill",
      "github.com",
      "sdchannel.md",
      "runtime.error",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-16",
    "type": "example",
    "category": "channels",
    "title": "Stoller Average Range Channel (STARCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Stoller Average Range Channel (STARCHANNEL)\", \"STARCHANNEL\", overlay=true)\n\n//@function Calculates Stoller Average Range Channel using ATR for width and SMA for center\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/starchannel.md\n//@param source Source series for the center line\n//@param length Period for ATR and SMA calculations\n//@param multiplier ATR multiplier for band width\n//@returns tuple with [middle, upper, lower] band values\n//@optimized Uses circular buffer for SMA and ATR with compensator, O(1) complexity\nstarchannel(series float source, simple int length, simple float multiplier) =>\n    if length <= 0 or multiplier <= 0.0\n        runtime.error(\"Length and multiplier must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    var int p = math.max(1, length)\n    var int head = 0\n    var int count = 0\n    var array<float> bufferSource = array.new_float(p, na)\n    var array<float> bufferTR = array.new_float(p, na)\n    var float sumSource = 0.0\n    var float sumTR = 0.0\n    float oldestSource = array.get(bufferSource, head)\n    float oldestTR = array.get(bufferTR, head)\n    if not na(oldestSource)\n        sumSource -= oldestSource\n        sumTR -= oldestTR\n        count -= 1\n    float currentSource = nz(source)\n    float currentTR = nz(trueRange)\n    sumSource += currentSource\n    sumTR += currentTR\n    count += 1\n    array.set(bufferSource, head, currentSource)\n    array.set(bufferTR, head, currentTR)\n    head := (head + 1) % p\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atrValue = na\n    if not na(trueRange)\n        float alpha = 1.0 / float(length)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e := (1.0 - alpha) * e\n        atrValue := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    float middleBand = nz(sumSource / count, source)\n    float width = nz(atrValue * multiplier)\n    [middleBand, middleBand + width, middleBand - width]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1)\ni_mult = input.float(2.0, \"ATR Multiplier\", minval=0.001)\n\n// Calculation\n[middle, upper, lower] = starchannel(i_source, i_length, i_mult)\n\n// Plot\nplot(middle, \"Middle\", color=color.yellow, linewidth=2)\np1 = plot(upper, \"Upper\", color=color.yellow, linewidth=2)\np2 = plot(lower, \"Lower\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "stoller average range channel (starchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "starchannel.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-17",
    "type": "example",
    "category": "channels",
    "title": "Super Trend Bands (STBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Super Trend Bands (STBANDS)\", \"STBANDS\", overlay=true)\n\n//@function Calculates Super Trend Bands using ATR-based dynamic support/resistance\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/stbands.md\n//@param source Series to calculate bands from\n//@param period Lookback period for ATR calculation\n//@param multiplier ATR multiplier for band distance\n//@returns [upper_band, lower_band, trend] Super Trend band values and trend direction\n//@optimized for performance and dirty data\nstbands(series float source, simple int period, simple float multiplier) =>\n    if period <= 0 or multiplier <= 0.0\n        runtime.error(\"Period and multiplier must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0, var int count = 0\n    var array<float> tr_buffer = array.new_float(p, na)\n    var float tr_sum = 0.0\n    float high_val = nz(high), float low_val = nz(low), float close_val = nz(source)\n    float prev_close = nz(source[1], source)\n    float tr = math.max(high_val - low_val, math.max(math.abs(high_val - prev_close), math.abs(low_val - prev_close)))\n    float oldest_tr = array.get(tr_buffer, head)\n    if not na(oldest_tr)\n        tr_sum -= oldest_tr\n        count -= 1\n    tr_sum += tr\n    count += 1\n    array.set(tr_buffer, head, tr)\n    head := (head + 1) % p\n    float atr = count > 0 ? tr_sum / count : tr\n    float hl2_val = (high_val + low_val) / 2\n    float basic_upper = hl2_val + multiplier * atr\n    float basic_lower = hl2_val - multiplier * atr\n    var float final_upper = na, var float final_lower = na\n    var int trend = 1\n    \n    // Initialize on first bar\n    if bar_index == 0\n        final_upper := basic_upper\n        final_lower := basic_lower\n        trend := 1\n    else\n        prev_upper = nz(final_upper[1], basic_upper)\n        prev_lower = nz(final_lower[1], basic_lower)\n        prev_close_val = nz(source[1], source)\n        \n        final_upper := basic_upper < prev_upper or prev_close_val > prev_upper ? basic_upper : prev_upper\n        final_lower := basic_lower > prev_lower or prev_close_val < prev_lower ? basic_lower : prev_lower\n        \n        prev_trend = nz(trend[1], 1)\n        trend := close_val <= prev_lower ? 1 : close_val >= prev_upper ? -1 : prev_trend\n    \n    [final_upper, final_lower, trend]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"ATR Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(3.0, \"ATR Multiplier\", minval=0.001)\n\n// Calculation\n[upper_band, lower_band, trend] = stbands(i_source, i_period, i_multiplier)\n\n// Plot\np_upper = plot(upper_band, \"Upper Band\", color=color.yellow, linewidth=2)\np_lower = plot(lower_band, \"Lower Band\", color=color.yellow, linewidth=2)\nfill(p_upper, p_lower, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.abs",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "super trend bands (stbands)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.abs",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "stbands.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.abs",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-18",
    "type": "example",
    "category": "channels",
    "title": "Ehlers Ultimate Bands (UBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n// Ultimate Bands logic based on work by John F. Ehlers (c) 2024\n//@version=6\nindicator(\"Ehlers Ultimate Bands (UBANDS)\", \"UBANDS\", overlay=true)\n\n//@function Calculates Ultimate Bands\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/ubands.md\n//@param src Source series for the bands\n//@param length Lookback period for the Ehlers Ultrasmooth Filter and RMS\n//@param mult RMS multiplier for band width\n//@returns tuple [upperBand, middleBand, lowerBand]\nubands(series float src, simple int length, simple float mult) =>\n    var float usf_state = na, var float c1=0.0, var float c2=0.0, var float c3=0.0, var int prev_len = 0\n    if prev_len != length or na(c1)\n        float arg = (math.sqrt(2)*math.pi)/math.max(1,float(length))\n        float exp_arg = math.exp(-arg)\n        c2 := 2*exp_arg*math.cos(arg)\n        c3 := -exp_arg*exp_arg\n        c1 := (1+c2-c3)/4.0\n        prev_len := length\n        usf_state := na\n    float s = nz(src,src[1]), s1 = nz(src[1],s), s2 = nz(src[2],s1)\n    float current_usf = na(usf_state) or na(usf_state[1]) or na(usf_state[2]) ? s :\n      (1-c1)*s + (2*c1-c2)*s1 - (c1+c3)*s2 + c2*nz(usf_state[1],s1) + c3*nz(usf_state[2],s2)\n    usf_state := current_usf\n    float smooth = usf_state\n    series float residuals = src - smooth\n    float rms = 0.0\n    if length > 0\n        float sumSq_r = 0.0, int count_r = 0\n        for i = 0 to length - 1\n            float val_r = residuals[i]\n            if not na(val_r)\n                sumSq_r += val_r*val_r\n                count_r += 1\n        if count_r > 0\n            rms := math.sqrt(sumSq_r/count_r)\n    [smooth + mult*rms, smooth, smooth - mult*rms]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1, tooltip=\"Lookback period for smoothing and RMS calculation.\")\ni_mult = input.float(1.0, \"RMS Multiplier\", minval=0.01, tooltip=\"Band width as multiple of RMS value.\")\n\n// Calculation\n[upperBand, middleBand, lowerBand] = ubands(i_source, i_length, i_mult)\n\n// Plot\nplot(middleBand, \"Middle Band\", color=color.yellow, linewidth=2)\np1 = plot(upperBand, \"Upper Band\", color=color.yellow, linewidth=2)\np2 = plot(lowerBand, \"Lower Band\", color=color.yellow, linewidth=2)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Band Fill\")\n",
    "functions_used": [
      "math.sqrt",
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "ehlers ultimate bands (ubands)",
      "channels",
      "indicator",
      "v6",
      "math.sqrt",
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "ubands.md",
      "math.sqrt",
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-19",
    "type": "example",
    "category": "channels",
    "title": "Ultimate Channel (UCHANNEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n// Ultimate Channel logic based on work by John F. Ehlers (c) 2024\n//@version=6\nindicator(\"Ultimate Channel (UCHANNEL)\", \"UCHANNEL\", overlay=true)\n\n//@function Calculates Ultimate Channel\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/uchannel.md\n//@param src Source series for the centerline (typically close)\n//@param high_src Source series for high prices\n//@param low_src Source series for low prices\n//@param strLength Lookback period for smoothing the True Range\n//@param length Lookback period for smoothing the centerline\n//@param numSTRs Multiplier for the Smoothed True Range to define channel width\n//@returns tuple [upperChannel, middleChannel, lowerChannel]\nuchannel(series float src_centerline, series float high_src, series float low_src, simple int strLength_param, simple int length_param, simple float numSTRs_param) =>\n    if strLength_param <= 0 or length_param <= 0 or numSTRs_param <= 0\n        runtime.error(\"strLength, numSTR and length must be greater than 0\")\n    var float usf_s = na, var float usf_c = na\n    var float c1_s = 0.0, var float c2_s = 0.0, var float c3_s = 0.0\n    var float c1_c = 0.0, var float c2_c = 0.0, var float c3_c = 0.0\n    var int prev_sLen = 0, var int prev_cLen = 0\n    float th = math.max(high_src, nz(src_centerline[1], high_src))\n    float tl = math.min(low_src, nz(src_centerline[1], low_src))\n    series float tr_s = th - tl // true_range_series\n    if prev_sLen != strLength_param or na(c1_s)\n        float arg = (math.sqrt(2)*math.pi)/float(strLength_param)\n        float exp_arg = math.exp(-arg)\n        c2_s := 2*exp_arg*math.cos(arg)\n        c3_s := -exp_arg*exp_arg\n        c1_s := (1+c2_s-c3_s)/4.0\n        prev_sLen := strLength_param\n        usf_s := na\n    float s_str = nz(tr_s, tr_s[1]), s1_str = nz(tr_s[1], s_str), s2_str = nz(tr_s[2], s1_str)\n    float cur_usf_s = na(usf_s) or na(usf_s[1]) or na(usf_s[2]) ? s_str : (1-c1_s)*s_str + (2*c1_s-c2_s)*s1_str - (c1_s+c3_s)*s2_str + c2_s*nz(usf_s[1],s1_str) + c3_s*nz(usf_s[2],s2_str)\n    usf_s := cur_usf_s\n    float str_val = usf_s\n    if prev_cLen != length_param or na(c1_c)\n        float arg = (math.sqrt(2)*math.pi)/float(length_param)\n        float exp_arg = math.exp(-arg)\n        c2_c := 2*exp_arg*math.cos(arg)\n        c3_c := -exp_arg*exp_arg\n        c1_c := (1+c2_c-c3_c)/4.0\n        prev_cLen := length_param\n        usf_c := na\n    float s_cen = nz(src_centerline,src_centerline[1]), s1_cen = nz(src_centerline[1],s_cen), s2_cen = nz(src_centerline[2],s1_cen)\n    float cur_usf_c = na(usf_c) or na(usf_c[1]) or na(usf_c[2]) ? s_cen : (1-c1_c)*s_cen + (2*c1_c-c2_c)*s1_cen - (c1_c+c3_c)*s2_cen + c2_c*nz(usf_c[1],s1_cen) + c3_c*nz(usf_c[2],s2_cen)\n    usf_c := cur_usf_c\n    float centerline = usf_c\n    [centerline + numSTRs_param*str_val, centerline, centerline - numSTRs_param*str_val]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source for Centerline\")\ni_high",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.min",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill"
    ],
    "keywords": [
      "ultimate channel (uchannel)",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.min",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "plot",
      "fill",
      "github.com",
      "uchannel.md",
      "runtime.error",
      "math.max",
      "math.min",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.new",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-20",
    "type": "example",
    "category": "channels",
    "title": "VWAP Bands (VWAPBANDS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"VWAP Bands (VWAPBANDS)\", \"VWAPBANDS\", overlay=true)\r\n\r\n//@function Calculates VWAP Bands with standard deviation bands\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/vwapbands.md\r\n//@param src Source price series (typically hlc3)\r\n//@param vol Volume series\r\n//@param reset_condition Condition to reset VWAP calculation\r\n//@param multiplier Standard deviation multiplier for bands\r\n//@returns [vwap_value, upper_band1, lower_band1, upper_band2, lower_band2, stdev] VWAP and band values\r\n//@optimized for performance and dirty data\r\nvwapbands(series float src, series float vol, series bool reset_condition, series float multiplier) =>\r\n    var float sum_pv = 0.0, var float sum_vol = 0.0, var float sum_pv2 = 0.0, var int count = 0\r\n    float current_price = nz(src), float current_vol = nz(vol, 0.0)\r\n    if reset_condition\r\n        if current_vol > 0.0\r\n            sum_pv := current_price * current_vol\r\n            sum_vol := current_vol\r\n            sum_pv2 := current_price * current_price * current_vol\r\n            count := 1\r\n        else\r\n            sum_pv := 0.0, sum_vol := 0.0, sum_pv2 := 0.0, count := 0\r\n    else\r\n        if current_vol > 0.0\r\n            sum_pv += current_price * current_vol\r\n            sum_vol += current_vol\r\n            sum_pv2 += current_price * current_price * current_vol\r\n            count += 1\r\n    float vwap_val = sum_vol > 0.0 ? sum_pv / sum_vol : src\r\n    float variance = 0.0\r\n    if sum_vol > 0.0 and count > 1\r\n        mean_p2 = sum_pv2 / sum_vol\r\n        vwap_squared = vwap_val * vwap_val\r\n        variance := math.max(0.0, mean_p2 - vwap_squared)\r\n    float stdev = math.sqrt(variance)\r\n    float upper1 = vwap_val + multiplier * stdev\r\n    float lower1 = vwap_val - multiplier * stdev\r\n    float upper2 = vwap_val + 2.0 * multiplier * stdev\r\n    float lower2 = vwap_val - 2.0 * multiplier * stdev\r\n    [vwap_val, upper1, lower1, upper2, lower2, stdev]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(hlc3, \"Source\")\r\ni_session_type = input.string(\"1D\", \"Session Reset\", options=[\"1m\", \"2m\", \"3m\", \"5m\", \"10m\", \"15m\", \"30m\", \"45m\", \"1H\", \"2H\", \"3H\", \"4H\", \"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"12M\", \"Never\"])\r\ni_multiplier = input.float(1.0, \"Standard Deviation Multiplier\", minval=0.1, step=0.1)\r\ni_show_bands2 = input.bool(true, \"Show 2nd Standard Deviation Bands\")\r\n\r\n// Calculate reset condition\r\nreset_condition = switch i_session_type\r\n    \"1m\" => ta.change(time(\"1\")) != 0\r\n    \"2m\" => ta.change(time(\"2\")) != 0\r\n    \"3m\" => ta.change(time(\"3\")) != 0\r\n    \"5m\" => ta.change(time(\"5\")) != 0\r\n    \"10m\" => ta.change(time(\"10\")) != 0\r\n    \"15m\" => ta.change(time(\"15\")) != 0\r\n    \"30m\" => ta.change(time(\"30\")) != 0\r\n    \"45m\" => ta.change(time(\"45\")) != 0\r\n    \"1H\" => ta.change(time(\"60\")) != 0\r\n    \"2H\" => ta.change(time(\"120\")) != 0\r\n    \"3H\" => ta.change(time(\"180\")) != 0\r\n    \"4H\" => ta.change(time(\"240\")) != 0\r\n ",
    "functions_used": [
      "math.max",
      "math.sqrt",
      "input.source",
      "input.string",
      "input.float",
      "input.bool",
      "ta.change",
      "color.yellow",
      "color.blue",
      "color.purple",
      "color.new",
      "plot",
      "fill"
    ],
    "keywords": [
      "vwap bands (vwapbands)",
      "channels",
      "indicator",
      "v6",
      "math.max",
      "math.sqrt",
      "input.source",
      "input.string",
      "input.float",
      "input.bool",
      "ta.change",
      "color.yellow",
      "color.blue",
      "color.purple",
      "color.new",
      "plot",
      "fill",
      "github.com",
      "vwapbands.md",
      "math.max",
      "math.sqrt",
      "input.source",
      "input.string",
      "input.float",
      "input.bool",
      "ta.change",
      "color.yellow",
      "color.blue",
      "color.purple",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-21",
    "type": "example",
    "category": "channels",
    "title": "VWAP with Standard Deviation Bands",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"VWAP with Standard Deviation Bands\", \"VWAPSD\", overlay=true)\n\n//@function Calculate VWAP with Standard Deviation Bands\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/channels/vwapsd.md\n//@param src Source price series (typically hlc3)\n//@param vol Volume series\n//@param reset_condition Condition to reset VWAP calculation\n//@param num_devs Number of standard deviations for bands\n//@returns [vwap, upper_band, lower_band]\nvwapsd(series float src, series float vol, series bool reset_condition, simple float num_devs) =>\n    if num_devs <= 0\n        runtime.error(\"Number of deviations must be greater than 0\")\n    if num_devs > 5\n        runtime.error(\"Number of deviations exceeds maximum of 5\")\n    \n    var float sum_pv = 0.0, var float sum_vol = 0.0, var float sum_pv2 = 0.0\n    float current_price = nz(src), float current_vol = nz(vol, 0.0)\n    \n    if reset_condition\n        sum_pv := current_vol > 0.0 ? current_price * current_vol : 0.0\n        sum_vol := current_vol > 0.0 ? current_vol : 0.0\n        sum_pv2 := current_vol > 0.0 ? current_price * current_price * current_vol : 0.0\n    else\n        if current_vol > 0.0\n            sum_pv += current_price * current_vol\n            sum_vol += current_vol\n            sum_pv2 += current_price * current_price * current_vol\n    \n    float vwap = sum_vol > 0.0 ? sum_pv / sum_vol : src\n    float variance = sum_vol > 0.0 ? (sum_pv2 / sum_vol) - math.pow(vwap, 2) : 0.0\n    float stddev = math.sqrt(math.max(0.0, variance))\n    \n    float upper = vwap + (num_devs * stddev)\n    float lower = vwap - (num_devs * stddev)\n    \n    [vwap, upper, lower]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\ni_session_type = input.string(\"1D\", \"Session Reset\", options=[\"1m\", \"2m\", \"3m\", \"5m\", \"10m\", \"15m\", \"30m\", \"45m\", \"1H\", \"2H\", \"3H\", \"4H\", \"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"12M\", \"Never\"])\ni_num_devs = input.float(2.0, \"Standard Deviations\", minval=0.1, maxval=5.0, step=0.1, tooltip=\"Number of standard deviations for bands\")\n\n// Calculate reset condition\nreset_condition = switch i_session_type\n    \"1m\" => ta.change(time(\"1\")) != 0\n    \"2m\" => ta.change(time(\"2\")) != 0\n    \"3m\" => ta.change(time(\"3\")) != 0\n    \"5m\" => ta.change(time(\"5\")) != 0\n    \"10m\" => ta.change(time(\"10\")) != 0\n    \"15m\" => ta.change(time(\"15\")) != 0\n    \"30m\" => ta.change(time(\"30\")) != 0\n    \"45m\" => ta.change(time(\"45\")) != 0\n    \"1H\" => ta.change(time(\"60\")) != 0\n    \"2H\" => ta.change(time(\"120\")) != 0\n    \"3H\" => ta.change(time(\"180\")) != 0\n    \"4H\" => ta.change(time(\"240\")) != 0\n    \"1D\" => ta.change(time(\"1D\")) != 0\n    \"1W\" => ta.change(time(\"1W\")) != 0\n    \"1M\" => ta.change(time(\"1M\")) != 0\n    \"3M\" => ta.change(time(\"3M\")) != 0\n    \"6M\" => ta.change(time(\"6M\")) != 0\n    \"12M\" => ta.change(time(\"12M\")) != 0\n    \"Never\" => bar_index == 0\n    => false\n\n// Calculation\n[vwap, upper, lower] = vwapsd(i_source, volume, reset_conditio",
    "functions_used": [
      "runtime.error",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.string",
      "input.float",
      "ta.change",
      "color.yellow",
      "color.red",
      "color.green",
      "color.new",
      "color.gray",
      "plot",
      "fill"
    ],
    "keywords": [
      "vwap with standard deviation bands",
      "channels",
      "indicator",
      "v6",
      "runtime.error",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.string",
      "input.float",
      "ta.change",
      "color.yellow",
      "color.red",
      "color.green",
      "color.new",
      "color.gray",
      "plot",
      "fill",
      "github.com",
      "vwapsd.md",
      "runtime.error",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.string",
      "input.float",
      "ta.change",
      "color.yellow",
      "color.red",
      "plot.style_line",
      "color.green",
      "color.new",
      "color.gray",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-22",
    "type": "example",
    "category": "cycles",
    "title": "Composite Fractal Behavior (CFB)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Composite Fractal Behavior (CFB)\", \"CFB\", overlay=false)\r\n\r\n//@function Calculates CFB auxiliary value for a single depth\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/cfb.md\r\n//@param source Price series to analyze\r\n//@param depth Lookback period for fractal pattern analysis\r\n//@param maxSize Maximum buffer size (must be >= depth)\r\n//@returns Ratio representing fractal behavior at specified depth\r\n//@optimized O(n) complexity required for fractal pattern calculation across depth range\r\ncfb_aux(series float source, series int depth, simple int maxSize) =>\r\n    if maxSize < depth\r\n        runtime.error(\"maxSize must be greater than or equal to depth\")\r\n    \r\n    var array<float> buffer = array.new_float(maxSize, na)\r\n    var int head = 0\r\n    var int count = 0\r\n    \r\n    float current = nz(source)\r\n    array.set(buffer, head, current)\r\n    head := (head + 1) % maxSize\r\n    \r\n    if count < maxSize\r\n        count += 1\r\n    \r\n    int effectiveDepth = int(math.min(depth, count - 1))\r\n    int actualCount = math.max(1, count)\r\n    \r\n    if effectiveDepth > 0\r\n        float sumAbs = 0.0\r\n        float sumWeighted = 0.0\r\n        float sumLevel = 0.0\r\n        \r\n        for i = 0 to effectiveDepth - 1\r\n            int idx1 = (head - effectiveDepth + i + maxSize) % maxSize\r\n            int idx2 = (head - effectiveDepth + i + 1 + maxSize) % maxSize\r\n            float val1 = nz(array.get(buffer, idx1))\r\n            float val2 = nz(array.get(buffer, idx2))\r\n            float absDiff = math.abs(val1 - val2)\r\n            \r\n            sumAbs += absDiff\r\n            sumWeighted += absDiff * (effectiveDepth - i)\r\n            sumLevel += val2\r\n        \r\n        int currentIdx = (head - 1 + maxSize) % maxSize\r\n        float currentVal = nz(array.get(buffer, currentIdx))\r\n        float levelCompare = math.abs(effectiveDepth * currentVal - sumLevel)\r\n        \r\n        float result = sumWeighted > 0.0 ? levelCompare / sumWeighted : 0.0\r\n        float compensator = float(effectiveDepth + 1) / float(depth + 1)\r\n        result * compensator\r\n    else\r\n        0.0\r\n\r\n//@function Calculates Composite Fractal Behavior across multiple depths\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/cfb.md\r\n//@param source Price series to analyze\r\n//@param maxDepth Maximum depth level (1-10)\r\n//@param length Smoothing period for CFB values\r\n//@returns CFB value representing dominant cycle period\r\n//@optimized O(n²) complexity required for multi-depth fractal analysis\r\ncfb(series float source, simple int maxDepth, simple int length) =>\r\n    if maxDepth < 1 or maxDepth > 10\r\n        runtime.error(\"maxDepth must be between 1 and 10\")\r\n    if length < 1\r\n        runtime.error(\"length must be greater than 0\")\r\n    \r\n    int numDepths = maxDepth * 2\r\n    int maxBufferSize = int(2 + math.pow(2, maxDepth - 1) * maxDepth * 2)\r\n    \r\n    var array<int> periods = array.new_i",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.set",
      "math.min",
      "math.max",
      "array.get",
      "math.abs",
      "math.pow",
      "array.new_int",
      "math.log",
      "math.sqrt",
      "array.unshift",
      "array.pop",
      "input.source",
      "input.int",
      "math.ceil",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "composite fractal behavior (cfb)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.set",
      "math.min",
      "math.max",
      "array.get",
      "math.abs",
      "math.pow",
      "array.new_int",
      "math.log",
      "math.sqrt",
      "array.unshift",
      "array.pop",
      "input.source",
      "input.int",
      "math.ceil",
      "color.yellow",
      "plot",
      "github.com",
      "cfb.md",
      "runtime.error",
      "array.new_float",
      "array.set",
      "math.min",
      "math.max",
      "array.get",
      "math.abs",
      "math.pow",
      "array.new_int",
      "math.log",
      "math.sqrt",
      "array.unshift",
      "array.pop",
      "input.source",
      "input.int",
      "math.ceil",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-23",
    "type": "example",
    "category": "cycles",
    "title": "Center of Gravity (CG)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Center of Gravity (CG)\", \"CG\", overlay=false)\n\n//@function Calculates Ehlers' Center of Gravity indicator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/cg.md\n//@param src Series to calculate Center of Gravity from\n//@param length Period for the Center of Gravity calculation\n//@returns Center of Gravity value identifying cycle turning points\n//@optimized for performance and dirty data\ncg(series float src, simple int length) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    float num = 0.0, float den = 0.0\n    for count = 1 to length\n        float price = nz(src[count - 1])\n        num += count * price\n        den += price\n    float result = den != 0 ? num / den : (length + 1) / 2.0\n    result - (length + 1) / 2.0\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(10, \"Length\", minval=1, tooltip=\"Period for Center of Gravity calculation\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\ncg_value = cg(i_source, i_length)\n\n// Plot\nplot(cg_value, \"CG\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "center of gravity (cg)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "cg.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-24",
    "type": "example",
    "category": "cycles",
    "title": "Detrended Synthetic Price (DSP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Detrended Synthetic Price (DSP)\", \"DSP\", overlay=false)\n\n//@function Calculates Detrended Synthetic Price using Ehlers dual-EMA algorithm\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/dsp.md\n//@param source Series to detrend\n//@param period Dominant cycle period for quarter/half-cycle EMA calculation\n//@returns Detrended synthetic price (difference between quarter-cycle and half-cycle EMAs)\ndsp(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int fast_period = math.max(2, int(math.round(period / 4.0)))\n    int slow_period = math.max(3, int(math.round(period / 2.0)))\n    float alpha_fast = 2.0 / (fast_period + 1)\n    float alpha_slow = 2.0 / (slow_period + 1)\n    var float ema_fast_raw = 0.0\n    var float ema_slow_raw = 0.0\n    float current = nz(source)\n    ema_fast_raw += alpha_fast * (current - ema_fast_raw)\n    ema_slow_raw += alpha_slow * (current - ema_slow_raw)\n    var bool warmup = true\n    var float e_fast = 1.0\n    var float e_slow = 1.0\n    float ema_fast = ema_fast_raw\n    float ema_slow = ema_slow_raw\n    if warmup\n        e_fast *= (1.0 - alpha_fast)\n        e_slow *= (1.0 - alpha_slow)\n        float c_fast = 1.0 / (1.0 - e_fast)\n        float c_slow = 1.0 / (1.0 - e_slow)\n        ema_fast := c_fast * ema_fast_raw\n        ema_slow := c_slow * ema_slow_raw\n        warmup := e_fast > 1e-10 or e_slow > 1e-10\n    \n    // Return difference (detrended synthetic price)\n    ema_fast - ema_slow\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\ni_period = input.int(40, \"Dominant Cycle Period\", minval=4, maxval=200, tooltip=\"Dominant cycle period. Quarter-cycle and half-cycle EMAs calculated from this value.\")\n\n// Calculation\ndsp_val = dsp(i_source, i_period)\n\n// Plot\nplot(dsp_val, \"DSP\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "detrended synthetic price (dsp)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "dsp.md",
      "runtime.error",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-25",
    "type": "example",
    "category": "cycles",
    "title": "EACP: Ehlers Autocorrelation Periodogram",
    "version": "v6",
    "code": "// The MIT License (MIT)1\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"EACP: Ehlers Autocorrelation Periodogram\",\"EACP\",overlay=false)\r\n//@function Autocorrelation periodogram dominant cycle estimator\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/eacp.md\r\n//@param source Price input series\r\n//@param minPeriod Minimum period to evaluate\r\n//@param maxPeriod Maximum period to evaluate\r\n//@param avgLength Averaging length for Pearson correlation (0 uses lag length)\r\n//@param enhance Apply cubic emphasis to highlight dominant peaks\r\n//@returns Smoothed dominant cycle estimate\r\n//@optimized Removed buffer complexity, uses native PineScript historical operator for O(n) correlation\r\n//@validation wolfram:\"Wiener-Khinchin theorem\",\"Pearson correlation coefficient\" external:\"TradingView TASC 2025.02 Autocorrelation\",\"ImmortalFreedom Ehlers ACP\",\"QuantStrat autocorrPeriodogram\"\r\neacp(series float source,simple int minPeriod,simple int maxPeriod,simple int avgLength,simple bool enhance)=>\r\n    if minPeriod<3\r\n        runtime.error(\"Min period must be at least 3\")\r\n    if maxPeriod<=minPeriod\r\n        runtime.error(\"Max period must be greater than min period\")\r\n    if avgLength<0\r\n        runtime.error(\"Average length must be non-negative\")\r\n    int size=maxPeriod+1\r\n    var array<float> corr=array.new_float(0)\r\n    var array<float> power=array.new_float(0)\r\n    var array<float> smooth=array.new_float(0)\r\n    var int storedSize=0\r\n    var int storedMin=0\r\n    var int storedMax=0\r\n    var bool configured=false\r\n    var float hp=0.0\r\n    var float filt=0.0\r\n    var float dom=0.0\r\n    var float domPower=0.0\r\n    var float maxPwr=0.0\r\n    var float e=1.0\r\n    var bool warmup=true\r\n    if not configured or storedSize!=size or storedMin!=minPeriod or storedMax!=maxPeriod\r\n        corr:=array.new_float(size,0.0)\r\n        power:=array.new_float(size,0.0)\r\n        smooth:=array.new_float(size,0.0)\r\n        storedSize:=size\r\n        storedMin:=minPeriod\r\n        storedMax:=maxPeriod\r\n        configured:=true\r\n        hp:=0.0\r\n        filt:=0.0\r\n        dom:=(minPeriod+maxPeriod)*0.5\r\n        domPower:=0.0\r\n        maxPwr:=0.0\r\n        e:=1.0\r\n        warmup:=true\r\n    float price=nz(source)\r\n    float alphaHP=(math.cos(math.sqrt(2.0)*math.pi/float(maxPeriod))+math.sin(math.sqrt(2.0)*math.pi/float(maxPeriod))-1.0)/math.cos(math.sqrt(2.0)*math.pi/float(maxPeriod))\r\n    hp:=math.pow(1.0-alphaHP/2.0,2.0)*(price-2.0*nz(price[1])+nz(price[2]))+2.0*(1.0-alphaHP)*nz(hp[1])-math.pow(1.0-alphaHP,2.0)*nz(hp[2])\r\n    float a1=math.exp(-math.sqrt(2.0)*math.pi/float(minPeriod))\r\n    float b1=2.0*a1*math.cos(math.sqrt(2.0)*math.pi/float(minPeriod))\r\n    float c2=b1\r\n    float c3=-(a1*a1)\r\n    float c1=1.0-c2-c3\r\n    filt:=c1*(hp+nz(hp[1]))*0.5+c2*nz(filt[1])+c3*nz(filt[2])\r\n    for lag=0 to maxPeriod\r\n        if lag<2\r\n            array.set(corr,lag,0.0)\r\n        else\r\n            int window=avgLength==0?lag:avgLength\r\n            if window<2\r\n             ",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.cos",
      "math.sqrt",
      "math.pi",
      "math.sin",
      "math.pow",
      "math.exp",
      "array.set",
      "array.get",
      "math.min",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.orange",
      "plot"
    ],
    "keywords": [
      "eacp: ehlers autocorrelation periodogram",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "math.cos",
      "math.sqrt",
      "math.pi",
      "math.sin",
      "math.pow",
      "math.exp",
      "array.set",
      "array.get",
      "math.min",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.orange",
      "plot",
      "github.com",
      "eacp.md",
      "runtime.error",
      "array.new_float",
      "math.cos",
      "math.sqrt",
      "math.pi",
      "math.sin",
      "math.pow",
      "math.exp",
      "array.set",
      "array.get",
      "math.min",
      "math.max",
      "math.round",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "color.orange",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-26",
    "type": "example",
    "category": "cycles",
    "title": "Ehlers Even Better Sinewave (EBSW)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ehlers Even Better Sinewave (EBSW)\", \"EBSW\", overlay=false)\n\n//@function Calculates Ehlers Even Better Sinewave using HPF, SSF, and AGC\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ebsw.md\n//@param src Series to calculate EBSW from\n//@param hpLength int Period for the High-Pass Filter\n//@param ssfLength int Period for the Super Smoother Filter\n//@returns single normalized sinewave value\n//@optimized for performance and dirty data\nebsw(series float src, simple int hpLength, simple int ssfLength) =>\n    if hpLength <= 0 or ssfLength <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    float pi = 2 * math.asin(1)\n    float angle_hp = 2 * pi / hpLength\n    float alpha1_hp = (1 - math.sin(angle_hp)) / math.cos(angle_hp)\n    var float hp = 0.0\n    hp := (0.5 * (1 + alpha1_hp) * (src - nz(src[1]))) + (alpha1_hp * nz(hp[1]))\n    float angle_ssf = math.sqrt(2) * pi / ssfLength\n    float alpha2_ssf = math.exp(-angle_ssf)\n    float beta_ssf = 2 * alpha2_ssf * math.cos(angle_ssf)\n    float c2 = beta_ssf, c3 = -alpha2_ssf * alpha2_ssf, c1 = 1 - c2 - c3\n    var float filt = 0.0\n    filt := c1 * ((hp + nz(hp[1])) / 2) + c2 * nz(filt[1]) + c3 * nz(filt[2])\n    float waveVal = (filt + nz(filt[1]) + nz(filt[2])) / 3.0\n    float pwr = (math.pow(filt, 2) + math.pow(nz(filt[1]), 2) + math.pow(nz(filt[2]), 2)) / 3.0\n    float sineWave = pwr == 0 ? 0 : waveVal / math.sqrt(pwr)\n    math.min(1, math.max(-1, sineWave))\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_hpLength = input.int(40, \"High-Pass Filter Length\", minval=1, tooltip=\"Period for detrending the price data.\")\ni_ssfLength = input.int(10, \"Super Smoother Filter Length\", minval=1, tooltip=\"Period for smoothing the cycle component.\")\n\n// Calculation\nebsw_wave = ebsw(i_source, i_hpLength, i_ssfLength)\n\n// Plot\nplot(ebsw_wave, \"EBSW\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.pow",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ehlers even better sinewave (ebsw)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.pow",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "ebsw.md",
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.pow",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-27",
    "type": "example",
    "category": "cycles",
    "title": "HOMOD: Homodyne Discriminator Dominant Cycle",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HOMOD: Homodyne Discriminator Dominant Cycle\",\"HOMOD\",overlay=false)\n\n//@function Quadrant-aware angle calculation using stable atan2\n//@param y Imaginary component\n//@param x Real component\n//@returns Angle in radians from -π to π\natan2(series float y,series float x)=>\n    if y==0.0 and x==0.0\n        runtime.error(\"atan2: y and x cannot both be zero\")\n    float ay=math.abs(y)\n    float ax=math.abs(x)\n    float angle=0.0\n    if ax>ay\n        angle:=math.atan(ay/ax)\n    else\n        angle:=(math.pi/2.0)-math.atan(ax/ay)\n    if x<0.0\n        angle:=math.pi-angle\n    if y<0.0\n        angle:=-angle\n    angle\n\n//@function Measures dominant cycle period using Ehlers homodyne discriminator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/homod.md\n//@param source Price input series\n//@param minPeriod Minimum dominant cycle length\n//@param maxPeriod Maximum dominant cycle length\n//@returns Smoothed dominant cycle estimate\n//@optimized Exponential warmup compensation for dominant cycle smoothing\n//@validation wolfram:\"atan2(y,x)\" external:\"TradingView Homodyne Discriminator\",\"Forex-Station Homodyne Discriminator\",\"MQL5 Adaptive Lookback Homodyne\",\"tindicators hd.cc\"\nhomod(series float source,simple float minPeriod,simple float maxPeriod)=>\n    if minPeriod<=0\n        runtime.error(\"Min period must be greater than 0\")\n    if maxPeriod<=minPeriod\n        runtime.error(\"Max period must be greater than min period\")\n    var float smooth_price=0.0\n    var float detrender=0.0\n    var float i1=0.0\n    var float q1=0.0\n    var float ji=0.0\n    var float jq=0.0\n    var float i2=0.0\n    var float q2=0.0\n    var float re=0.0\n    var float im=0.0\n    var float period=15.0\n    var float smooth_period=15.0\n    var float warm_decay=1.0\n    var bool warmup=true\n    float price=nz(source)\n    float bandwidth=0.075*smooth_period+0.54\n    smooth_price:=(4.0*price+3.0*nz(price[1])+2.0*nz(price[2])+nz(price[3]))/10.0\n    detrender:=(0.0962*smooth_price+0.5769*nz(smooth_price[2])-0.5769*nz(smooth_price[4])-0.0962*nz(smooth_price[6]))*bandwidth\n    q1:=(0.0962*detrender+0.5769*nz(detrender[2])-0.5769*nz(detrender[4])-0.0962*nz(detrender[6]))*bandwidth\n    i1:=nz(detrender[3])\n    ji:=(0.0962*i1+0.5769*nz(i1[2])-0.5769*nz(i1[4])-0.0962*nz(i1[6]))*bandwidth\n    jq:=(0.0962*q1+0.5769*nz(q1[2])-0.5769*nz(q1[4])-0.0962*nz(q1[6]))*bandwidth\n    float i2_raw=i1-jq\n    float q2_raw=q1+ji\n    i2:=0.2*i2_raw+0.8*nz(i2[1])\n    q2:=0.2*q2_raw+0.8*nz(q2[1])\n    float re_raw=i2*nz(i2[1])+q2*nz(q2[1])\n    float im_raw=i2*nz(q2[1])-q2*nz(i2[1])\n    re:=0.2*re_raw+0.8*nz(re[1])\n    im:=0.2*im_raw+0.8*nz(im[1])\n    float magnitude=math.abs(re)+math.abs(im)\n    if magnitude>1e-10\n        float angle=atan2(im,re)\n        if math.abs(angle)>1e-10\n            float candidate=2.0*math.pi/angle\n            float clamped=math.max(minPeriod,math.min(maxPeriod,math.abs(candidate)))\n            period:=0.2*clamped+0.8",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "homod: homodyne discriminator dominant cycle",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "homod.md",
      "hd.cc",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-28",
    "type": "example",
    "category": "cycles",
    "title": "HT_DCPERIOD: Hilbert Transform Dominant Cycle Period",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HT_DCPERIOD: Hilbert Transform Dominant Cycle Period\", \"HT_DCPERIOD\", overlay=false)\n\n//@function Numerically stable atan2 implementation for quadrant-aware angle calculation\n//@param y Y-coordinate (imaginary/quadrature component)\n//@param x X-coordinate (real/in-phase component)\n//@returns Angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    angle\n\n//@function Calculates Hilbert Transform Dominant Cycle Period using Ehlers algorithm\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ht_dcperiod.md\n//@param source Series to analyze for dominant cycle\n//@returns Dominant cycle period in bars (typically 6-50)\nht_dcperiod(series float source) =>\n    var float smooth_price = 0.0\n    var float detrender = 0.0\n    var float i1 = 0.0\n    var float q1 = 0.0\n    var float ji = 0.0\n    var float jq = 0.0\n    var float i2 = 0.0\n    var float q2 = 0.0\n    var float re = 0.0\n    var float im = 0.0\n    var float period = 15.0\n    var float smooth_period = 15.0\n    float price = nz(source)\n    float bandwidth = 0.075 * smooth_period + 0.54\n    smooth_price := (4.0 * price + 3.0 * nz(price[1]) + 2.0 * nz(price[2]) + nz(price[3])) / 10.0\n    detrender := (0.0962 * smooth_price + 0.5769 * nz(smooth_price[2]) - 0.5769 * nz(smooth_price[4]) - 0.0962 * nz(smooth_price[6])) * bandwidth\n    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * bandwidth\n    i1 := nz(detrender[3])\n    ji := (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * bandwidth\n    jq := (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * bandwidth\n    i2 := i1 - jq\n    q2 := q1 + ji\n    i2 := 0.2 * i2 + 0.8 * nz(i2[1])\n    q2 := 0.2 * q2 + 0.8 * nz(q2[1])\n    re := i2 * nz(i2[1]) + q2 * nz(q2[1])\n    im := i2 * nz(q2[1]) - q2 * nz(i2[1])\n    re := 0.2 * re + 0.8 * nz(re[1])\n    im := 0.2 * im + 0.8 * nz(im[1])\n    if im != 0.0 or re != 0.0\n        float angle = atan2(im, re)\n        if angle != 0.0\n            period := 2.0 * math.pi / angle\n    period := math.max(6.0, math.min(50.0, period))\n    smooth_period := 0.33 * period + 0.67 * smooth_period\n    smooth_period\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\n\n// Calculation\ndcperiod = ht_dcperiod(i_source)\n\n// Plot\nplot(dcperiod, \"Dominant Cycle Period\", color=color.yellow, linewidth=2)\nhline(15, \"Short Cycle\", color=color.new(color.gray, 70), linestyle=hline.style_dashed)\nhline(30, \"Long Cycle\", color=color.new(color.gray, 70), linestyle=h",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.new",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ht_dcperiod: hilbert transform dominant cycle period",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.new",
      "color.gray",
      "plot",
      "hline",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "ht_dcperiod.md",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.new",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-29",
    "type": "example",
    "category": "cycles",
    "title": "HT_DCPHASE: Hilbert Transform Dominant Cycle Phase",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HT_DCPHASE: Hilbert Transform Dominant Cycle Phase\", \"HT_DCPHASE\", overlay=false)\n\n//@function Numerically stable atan2 implementation for quadrant-aware angle calculation\n//@param y Y-coordinate (imaginary/quadrature component)\n//@param x X-coordinate (real/in-phase component)\n//@returns Angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    angle\n\n//@function Calculates Hilbert Transform Dominant Cycle Phase using Ehlers algorithm\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ht_dcphase.md\n//@param source Series to analyze for dominant cycle phase\n//@returns Phase angle in radians (-π to π)\nht_dcphase(series float source) =>\n    var float smooth_price = 0.0\n    var float detrender = 0.0\n    var float i1 = 0.0\n    var float q1 = 0.0\n    var float ji = 0.0\n    var float jq = 0.0\n    var float i2 = 0.0\n    var float q2 = 0.0\n    var float re = 0.0\n    var float im = 0.0\n    var float period = 15.0\n    var float smooth_period = 15.0\n    var float phase = 0.0\n    float price = nz(source)\n    float bandwidth = 0.075 * smooth_period + 0.54\n    smooth_price := (4.0 * price + 3.0 * nz(price[1]) + 2.0 * nz(price[2]) + nz(price[3])) / 10.0\n    detrender := (0.0962 * smooth_price + 0.5769 * nz(smooth_price[2]) - 0.5769 * nz(smooth_price[4]) - 0.0962 * nz(smooth_price[6])) * bandwidth\n    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * bandwidth\n    i1 := nz(detrender[3])\n    ji := (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * bandwidth\n    jq := (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * bandwidth\n    i2 := i1 - jq\n    q2 := q1 + ji\n    i2 := 0.2 * i2 + 0.8 * nz(i2[1])\n    q2 := 0.2 * q2 + 0.8 * nz(q2[1])\n    re := i2 * nz(i2[1]) + q2 * nz(q2[1])\n    im := i2 * nz(q2[1]) - q2 * nz(i2[1])\n    re := 0.2 * re + 0.8 * nz(re[1])\n    im := 0.2 * im + 0.8 * nz(im[1])\n    if im != 0.0 or re != 0.0\n        float angle = atan2(im, re)\n        if angle != 0.0\n            period := 2.0 * math.pi / angle\n    period := math.max(6.0, math.min(50.0, period))\n    smooth_period := 0.33 * period + 0.67 * smooth_period\n    if i2 != 0.0 or q2 != 0.0\n        phase := atan2(q2, i2)\n    phase\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\n\n// Calculation\ndcphase = ht_dcphase(i_source)\n\n// Plot\nplot(dcphase, \"Dominant Cycle Phase\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Phase\", color=color.gray, linestyle=hline.style_solid)\nhline(1.5708, \"π/2\", colo",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "plot",
      "hline"
    ],
    "keywords": [
      "ht_dcphase: hilbert transform dominant cycle phase",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "plot",
      "hline",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "ht_dcphase.md",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.gray",
      "hline.style_solid",
      "color.new",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-30",
    "type": "example",
    "category": "cycles",
    "title": "HT_PHASOR: Hilbert Transform Phasor Components",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HT_PHASOR: Hilbert Transform Phasor Components\", \"HT_PHASOR\", overlay=false)\n\n//@function Numerically stable atan2 implementation for quadrant-aware angle calculation\n//@param y Y-coordinate (imaginary/quadrature component)\n//@param x X-coordinate (real/in-phase component)\n//@returns Angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    angle\n\n//@function Calculates Hilbert Transform Phasor Components (InPhase and Quadrature)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ht_phasor.md\n//@param source Series to analyze for phasor components\n//@returns Tuple [inphase, quadrature] components\nht_phasor(series float source) =>\n    var float smooth_price = 0.0\n    var float detrender = 0.0\n    var float i1 = 0.0\n    var float q1 = 0.0\n    var float ji = 0.0\n    var float jq = 0.0\n    var float i2 = 0.0\n    var float q2 = 0.0\n    var float re = 0.0\n    var float im = 0.0\n    var float period = 15.0\n    var float smooth_period = 15.0\n    float price = nz(source)\n    float bandwidth = 0.075 * smooth_period + 0.54\n    smooth_price := (4.0 * price + 3.0 * nz(price[1]) + 2.0 * nz(price[2]) + nz(price[3])) / 10.0\n    detrender := (0.0962 * smooth_price + 0.5769 * nz(smooth_price[2]) - 0.5769 * nz(smooth_price[4]) - 0.0962 * nz(smooth_price[6])) * bandwidth\n    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * bandwidth\n    i1 := nz(detrender[3])\n    ji := (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * bandwidth\n    jq := (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * bandwidth\n    i2 := i1 - jq\n    q2 := q1 + ji\n    i2 := 0.2 * i2 + 0.8 * nz(i2[1])\n    q2 := 0.2 * q2 + 0.8 * nz(q2[1])\n    re := i2 * nz(i2[1]) + q2 * nz(q2[1])\n    im := i2 * nz(q2[1]) - q2 * nz(i2[1])\n    re := 0.2 * re + 0.8 * nz(re[1])\n    im := 0.2 * im + 0.8 * nz(im[1])\n    if im != 0.0 or re != 0.0\n        float angle = atan2(im, re)\n        if angle != 0.0\n            period := 2.0 * math.pi / angle\n    period := math.max(6.0, math.min(50.0, period))\n    smooth_period := 0.33 * period + 0.67 * smooth_period\n    [i2, q2]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\n\n// Calculation\n[inphase, quadrature] = ht_phasor(i_source)\n\n// Plot\nplot(inphase, \"InPhase\", color=color.yellow, linewidth=2)\nplot(quadrature, \"Quadrature\", color=color.blue, linewidth=2)\nhline(0, \"Zero\", color=color.gray, linestyle=hline.style_solid)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ht_phasor: hilbert transform phasor components",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "plot",
      "hline",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "ht_phasor.md",
      "math.max",
      "math.min",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-31",
    "type": "example",
    "category": "cycles",
    "title": "HT_SINE: Hilbert Transform - SineWave",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HT_SINE: Hilbert Transform - SineWave\", \"HT_SINE\", overlay=false)\n\n//@function Numerically stable atan2 implementation for quadrant-aware angle calculation\n//@param y Y-coordinate (imaginary/quadrature component)\n//@param x X-coordinate (real/in-phase component)\n//@returns Angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    angle\n\n//@function Calculates Hilbert Transform SineWave and LeadSine\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ht_sine.md\n//@param source Series to analyze for dominant cycle\n//@returns Tuple [sine, leadsine] - sine wave and lead sine wave\nht_sine(series float source) =>\n    var float smooth_price = 0.0\n    var float detrender = 0.0\n    var float i1 = 0.0\n    var float q1 = 0.0\n    var float ji = 0.0\n    var float jq = 0.0\n    var float i2 = 0.0\n    var float q2 = 0.0\n    var float re = 0.0\n    var float im = 0.0\n    var float period = 15.0\n    var float smooth_period = 15.0\n    var float phase = 0.0\n    var float sine = 0.0\n    var float leadsine = 0.0\n    float price = nz(source)\n    float bandwidth = 0.075 * smooth_period + 0.54\n    smooth_price := (4.0 * price + 3.0 * nz(price[1]) + 2.0 * nz(price[2]) + nz(price[3])) / 10.0\n    detrender := (0.0962 * smooth_price + 0.5769 * nz(smooth_price[2]) - 0.5769 * nz(smooth_price[4]) - 0.0962 * nz(smooth_price[6])) * bandwidth\n    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * bandwidth\n    i1 := nz(detrender[3])\n    ji := (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * bandwidth\n    jq := (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * bandwidth\n    i2 := i1 - jq\n    q2 := q1 + ji\n    i2 := 0.2 * i2 + 0.8 * nz(i2[1])\n    q2 := 0.2 * q2 + 0.8 * nz(q2[1])\n    re := i2 * nz(i2[1]) + q2 * nz(q2[1])\n    im := i2 * nz(q2[1]) - q2 * nz(i2[1])\n    re := 0.2 * re + 0.8 * nz(re[1])\n    im := 0.2 * im + 0.8 * nz(im[1])\n    if im != 0.0 or re != 0.0\n        float angle = atan2(im, re)\n        if angle != 0.0\n            period := 2.0 * math.pi / angle\n    period := math.max(6.0, math.min(50.0, period))\n    smooth_period := 0.33 * period + 0.67 * smooth_period\n    if i2 != 0.0 or q2 != 0.0\n        phase := atan2(q2, i2)\n    sine := math.sin(phase)\n    leadsine := math.sin(phase + math.pi / 4.0)\n    [sine, leadsine]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\n\n// Calculation\n[sine, leadsine] = ht_sine(i_source)\n\n// Plot\nplot(sine, \"Sine\", color=color.yellow, linewidth",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "math.sin",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ht_sine: hilbert transform - sinewave",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "math.sin",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "plot",
      "hline",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "ht_sine.md",
      "math.max",
      "math.min",
      "math.sin",
      "input.source",
      "color.yellow",
      "color.blue",
      "color.gray",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-32",
    "type": "example",
    "category": "cycles",
    "title": "Lunar Phase (LUNAR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Lunar Phase (LUNAR)\", \"LUNAR\", overlay=false)\n\n//@function Calculates precise lunar phase using orbital mechanics\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/lunar.md\n//@param none Uses timestamp of open (start of the bar) for calculations\n//@returns float Lunar phase from 0.0 (new moon) through 1.0 (full moon)\n//@Includes orbital perturbation terms and epoch corrections\nlunar() =>\n    jd = (time / 86400000.0) + 2440587.5\n    T = (jd - 2451545.0) / 36525.0\n    Lp = (218.3164477 + 481267.88123421 * T - 0.0015786 * T * T + T * T * T / 538841.0 - T * T * T * T / 65194000.0) % 360.0\n    D = (297.8501921 + 445267.1114034 * T - 0.0018819 * T * T + T * T * T / 545868.0 - T * T * T * T / 113065000.0) % 360.0\n    M = (357.5291092 + 35999.0502909 * T - 0.0001536 * T * T + T * T * T / 24490000.0) % 360.0\n    Mp = (134.9633964 + 477198.8675055 * T + 0.0087414 * T * T + T * T * T / 69699.0 - T * T * T * T / 14712000.0) % 360.0\n    F = (93.2720950 + 483202.0175233 * T - 0.0036539 * T * T - T * T * T / 3526000.0 + T * T * T * T / 863310000.0) % 360.0\n    Lp_rad = Lp * math.pi / 180.0\n    D_rad = D * math.pi / 180.0\n    M_rad = M * math.pi / 180.0\n    Mp_rad = Mp * math.pi / 180.0\n    F_rad = F * math.pi / 180.0\n    dL = 6288.016 * math.sin(Mp_rad) + 1274.242 * math.sin(2.0 * D_rad - Mp_rad) +\n         658.314 * math.sin(2.0 * D_rad) + 214.818 * math.sin(2.0 * Mp_rad) +\n         186.986 * math.sin(M_rad) + 109.154 * math.sin(2.0 * F_rad)\n    L_moon = Lp + dL / 1000000.0\n    M_sun = (357.5291092 + 35999.0502909 * T - 0.0001536 * T * T + T * T * T / 24490000.0) % 360.0\n    L_sun = (280.46646 + 36000.76983 * T + 0.0003032 * T * T) % 360.0\n    phase_angle = ((L_moon - L_sun) % 360.0) * math.pi / 180.0\n    phase = (1.0 - math.cos(phase_angle)) / 2.0\n    phase\n\n// Calculation\nlunarPhase = lunar()\n\n// Plot\nplot(lunarPhase, \"Lunar Phase\", color=color.yellow, linewidth=2)\n\n// Calculate derivatives to find local maxima/minima and inflection points\ndelta1 = lunarPhase - lunarPhase[1]\n\n// New Moon detection (at the trough)\nnewMoonCondition = lunarPhase < 0.1 and lunarPhase[1] < 0.1 and delta1 > 0 and delta1[1] < 0\nplotchar(newMoonCondition ? lunarPhase : na, \"New Moon\", \"🌑\", location.absolute, color.white, size = size.small)\n\n// First Quarter detection (crossing 0.5 going up)\nfirstQuarterCondition = lunarPhase[1] < 0.5 and lunarPhase >= 0.5 and delta1 > 0\nplotchar(firstQuarterCondition ? lunarPhase : na, \"First Quarter\", \"🌓\", location.absolute, color.white, size = size.small)\n\n// Full Moon detection (at the peak)\nfullMoonCondition = lunarPhase > 0.9 and lunarPhase[1] > 0.9 and delta1 < 0 and delta1[1] > 0\nplotchar(fullMoonCondition ? lunarPhase : na, \"Full Moon\", \"🌕\", location.absolute, color.white, size = size.small)\n\n// Last Quarter detection (crossing 0.5 going down)\nlastQuarterCondition = lunarPhase[1] > 0.5 and lunarPhase <= 0.5 and delta1 < 0\nplotchar(lastQuarterCondition",
    "functions_used": [
      "math.pi",
      "math.sin",
      "math.cos",
      "color.yellow",
      "color.white",
      "plot",
      "plotchar"
    ],
    "keywords": [
      "lunar phase (lunar)",
      "cycles",
      "indicator",
      "v6",
      "math.pi",
      "math.sin",
      "math.cos",
      "color.yellow",
      "color.white",
      "plot",
      "plotchar",
      "github.com",
      "lunar.md",
      "math.pi",
      "math.sin",
      "math.cos",
      "color.yellow",
      "location.absolute",
      "color.white",
      "size.small",
      "indicator",
      "overlay",
      "plot",
      "for"
    ]
  },
  {
    "id": "script-33",
    "type": "example",
    "category": "cycles",
    "title": "Ehlers Phasor Analysis (PHASOR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj (Implementation based on John Ehlers' \"Phasor Analysis\" and user-provided v6 function structure)\n//@version=6\nindicator(\"Ehlers Phasor Analysis (PHASOR)\", shorttitle=\"PHASOR\", overlay=false)\n\n//@function Calculates the Ehlers Phasor Angle, Derived Period, and Trend State.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/phasor.md\n//@param src The source series to analyze.\n//@param period The fixed cycle period to correlate against. Default is 28.\n//@returns A tuple: `[float finalPhasorAngle, float derivedPeriod, int trendState]`.\nphasor(series float src, simple int period = 28) =>\n    float sx_corr = 0.0\n    float sy_cos_corr = 0.0\n    float sxx_corr = 0.0\n    float sxy_cos_corr = 0.0\n    float syy_cos_corr = 0.0\n    for i = 0 to period - 1\n        float x_val = nz(src[i])\n        float y_val_cos = math.cos(2 * math.pi * i / period)\n        sx_corr += x_val\n        sy_cos_corr += y_val_cos\n        sxx_corr += x_val * x_val\n        sxy_cos_corr += x_val * y_val_cos\n        syy_cos_corr += y_val_cos * y_val_cos\n    float real_part = 0.0\n    float den_cos = (period * sxx_corr - sx_corr * sx_corr) * (period * syy_cos_corr - sy_cos_corr * sy_cos_corr)\n    if den_cos > 0\n        real_part := (period * sxy_cos_corr - sx_corr * sy_cos_corr) / math.sqrt(den_cos)\n    sx_corr := 0.0\n    sxx_corr := 0.0\n    float sy_sin_corr = 0.0\n    float sxy_sin_corr = 0.0\n    float syy_sin_corr = 0.0\n    for i = 0 to period - 1\n        float x_val = nz(src[i])\n        float y_val_sin = -math.sin(2 * math.pi * i / period) // Negative sine as per Ehlers\n        sx_corr += x_val\n        sxx_corr += x_val * x_val\n        sy_sin_corr += y_val_sin\n        sxy_sin_corr += x_val * y_val_sin\n        syy_sin_corr += y_val_sin * y_val_sin\n    float imag_part = 0.0\n    float den_sin = (period * sxx_corr - sx_corr * sx_corr) * (period * syy_sin_corr - sy_sin_corr * sy_sin_corr)\n    if den_sin > 0\n        imag_part := (period * sxy_sin_corr - sx_corr * sy_sin_corr) / math.sqrt(den_sin)\n    float current_raw_phase = 0.0\n    if real_part != 0.0\n        current_raw_phase := 90.0 - math.atan(imag_part / real_part) * 180.0 / math.pi\n        if real_part < 0.0\n            current_raw_phase -= 180.0\n    else if imag_part != 0.0\n        current_raw_phase := imag_part > 0.0 ? 0.0 : 180.0\n    var float core_Phasor_unwrapped_state = na\n    if not na(core_Phasor_unwrapped_state[1])\n        float diff = current_raw_phase - core_Phasor_unwrapped_state[1]\n        if diff > 180.0\n            current_raw_phase -= 360.0\n        else if diff < -180.0\n            current_raw_phase += 360.0\n    core_Phasor_unwrapped_state := na(core_Phasor_unwrapped_state[1]) ? current_raw_phase : core_Phasor_unwrapped_state[1] + (current_raw_phase - core_Phasor_unwrapped_state[1])\n    float calculated_Phasor_val = core_Phasor_unwrapped_state\n    var float final_Phasor_state = na\n    if na(final_Phasor_state[1])\n        final_Phasor_state := calculated_Phas",
    "functions_used": [
      "math.cos",
      "math.pi",
      "math.sqrt",
      "math.sin",
      "math.atan",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ehlers phasor analysis (phasor)",
      "cycles",
      "indicator",
      "v6",
      "math.cos",
      "math.pi",
      "math.sqrt",
      "math.sin",
      "math.atan",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "phasor.md",
      "math.cos",
      "math.pi",
      "math.sqrt",
      "math.sin",
      "math.atan",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "plot.style_histogram",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-34",
    "type": "example",
    "category": "cycles",
    "title": "Ehlers Sine Wave (SINE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ehlers Sine Wave (SINE)\", \"SINE\", overlay=false)\n\n//@function Calculates Ehlers’ original Sine Wave using a two‑pole High‑Pass, a Super‑Smoother,\n//         and a Hilbert‑transform FIR pair (In‑phase I / Quadrature Q).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/sine.md\n//@param src Series to calculate the Sine Wave from\n//@param hpLength High‑Pass filter length (detrending period)\n//@param ssfLength Super‑Smoother filter length (cycle smoothing period)\n//@returns single normalized sine‑wave value in [‑1 … +1]\nsine(series float src, simple int hpLength, simple int ssfLength) =>\n    if hpLength <= 0 or ssfLength <= 0\n        runtime.error(\"Periods must be > 0\")\n    float pi = 2 * math.asin(1)\n    float angHP = 2 * pi / hpLength\n    float aHP = (1 - math.sin(angHP)) / math.cos(angHP)\n    var float hp = 0.0\n    hp := 0.5 * (1 + aHP) * (src - nz(src[1])) + aHP * nz(hp[1])\n    float angSSF = math.sqrt(2) * pi / ssfLength\n    float aSSF = math.exp(-angSSF)\n    float bSSF = 2 * aSSF * math.cos(angSSF)\n    float c2 = bSSF\n    float c3 = -aSSF * aSSF\n    float c1 = 1 - c2 - c3\n    var float filt = 0.0\n    filt := c1 * (hp + nz(hp[1])) / 2 + c2 * nz(filt[1]) + c3 * nz(filt[2])\n    float Q =  0.0962 * nz(filt[3])  + 0.5769 * nz(filt[1])\n             - 0.5769 * nz(filt[5])  - 0.0962 * nz(filt[7])\n    float I =  filt\n    float pwr = I*I + Q*Q\n    float sineWave = pwr == 0 ? 0 : I / math.sqrt(pwr)\n    math.min(1, math.max(-1, sineWave))\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source    = input.source(close,  \"Source\")\ni_hpLength  = input.int(40,        \"High‑Pass Filter Length\",      minval=1)\ni_ssfLength = input.int(10,        \"Super‑Smoother Filter Length\", minval=1)\n\n// Calculation\nsine_wave = sine(i_source, i_hpLength, i_ssfLength)\n\n// Plot\nplot(sine_wave, \"SINE\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ehlers sine wave (sine)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "sine.md",
      "runtime.error",
      "math.asin",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "math.exp",
      "math.min",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-35",
    "type": "example",
    "category": "cycles",
    "title": "Solar Cycle (SOLAR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Solar Cycle (SOLAR)\", \"SOLAR\", overlay=false)\n\n//@function Calculates precise solar cycle value using Sun's ecliptic longitude.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/solar.md\n//@param barTime int The timestamp of the bar (open time) in milliseconds.\n//@returns float Solar cycle value from -1.0 (winter solstice) through 0.0 (equinoxes) to +1.0 (summer solstice).\n//@optimized for performance and dirty data\nsolar(int barTime) =>\n    float jd = (barTime / 86400000.0) + 2440587.5\n    float T = (jd - 2451545.0) / 36525.0\n    float l0DegRaw = 280.46646 + 36000.76983 * T + 0.0003032 * T * T\n    float l0Deg = (l0DegRaw % 360.0 + 360.0) % 360.0\n    float mDegRaw = 357.52911 + 35999.05029 * T - 0.0001537 * T * T - 0.00000025 * T * T * T\n    float mDeg = (mDegRaw % 360.0 + 360.0) % 360.0\n    float mRad = mDeg * math.pi / 180.0\n    float cDeg = (1.914602 - 0.004817 * T - 0.000014 * T * T) * math.sin(mRad) + \n                 (0.019993 - 0.000101 * T) * math.sin(2.0 * mRad) + \n                 0.000289 * math.sin(3.0 * mRad)\n    float lambdaSunDegRaw = l0Deg + cDeg\n    float lambdaSunDeg = (lambdaSunDegRaw % 360.0 + 360.0) % 360.0\n    float lambdaSunRad = lambdaSunDeg * math.pi / 180.0\n    float valueRaw = math.sin(lambdaSunRad)\n    valueRaw\n\n// ---------- Main loop ----------\n// Calculation\nfloat solarCycleValue = solar(time)\nfloat delta1 = solarCycleValue - solarCycleValue[1]\n\nbool summerSolsticeCondition = solarCycleValue > 0.985 and solarCycleValue[1] > 0.985 and delta1 < 0 and delta1[1] > 0\nbool vernalEquinoxCondition = solarCycleValue[1] < 0.0 and solarCycleValue >= 0.0 and delta1 > 0\nbool winterSolsticeCondition = solarCycleValue < -0.985 and solarCycleValue[1] < -0.985 and delta1 > 0 and delta1[1] < 0\nbool autumnalEquinoxCondition = solarCycleValue[1] > 0.0 and solarCycleValue <= 0.0 and delta1 < 0\n\n// Plot\nplot(solarCycleValue, \"Solar Cycle\", color=color.yellow, linewidth=2)\n\n// Plotchars\nplotchar(summerSolsticeCondition ? solarCycleValue : na, \"Peak Summer\", \"•\", location.absolute, color.new(color.red,0), size = size.small)\nplotchar(vernalEquinoxCondition ? 0.0 : na, \"Spring Rise\", \"•\", location.absolute, color.new(color.yellow,0), size = size.small)\nplotchar(winterSolsticeCondition ? solarCycleValue : na, \"Peak Winter\", \"•\", location.absolute, color.new(color.blue,0), size = size.small)\nplotchar(autumnalEquinoxCondition ? 0.0 : na, \"Autumn Fall\", \"•\", location.absolute, color.new(color.yellow,0), size = size.small)\n",
    "functions_used": [
      "math.pi",
      "math.sin",
      "color.yellow",
      "color.new",
      "color.red",
      "color.blue",
      "plot",
      "plotchar"
    ],
    "keywords": [
      "solar cycle (solar)",
      "cycles",
      "indicator",
      "v6",
      "math.pi",
      "math.sin",
      "color.yellow",
      "color.new",
      "color.red",
      "color.blue",
      "plot",
      "plotchar",
      "github.com",
      "solar.md",
      "math.pi",
      "math.sin",
      "color.yellow",
      "location.absolute",
      "color.new",
      "color.red",
      "size.small",
      "color.blue",
      "indicator",
      "overlay",
      "plot",
      "for"
    ]
  },
  {
    "id": "script-36",
    "type": "example",
    "category": "cycles",
    "title": "SSF-Based Detrended Synthetic Price",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"SSF-Based Detrended Synthetic Price\", \"SSF-DSP\", overlay=false)\n\n//@function Calculates SSF-based Detrended Synthetic Price using dual Super Smooth Filters\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/ssfdsp.md\n//@param source Series to detrend\n//@param period Dominant cycle period for quarter/half-cycle SSF calculation\n//@returns Detrended synthetic price (difference between quarter-cycle and half-cycle SSFs)\nssfdsp(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int fast_period = math.max(2, int(math.round(period / 4.0)))\n    int slow_period = math.max(3, int(math.round(period / 2.0)))\n    float SQRT2_PI = math.sqrt(2.0) * math.pi\n    float arg_fast = SQRT2_PI / float(fast_period)\n    float exp_fast = math.exp(-arg_fast)\n    float c2_fast = 2.0 * exp_fast * math.cos(arg_fast)\n    float c3_fast = -exp_fast * exp_fast\n    float c1_fast = 1.0 - c2_fast - c3_fast\n    float arg_slow = SQRT2_PI / float(slow_period)\n    float exp_slow = math.exp(-arg_slow)\n    float c2_slow = 2.0 * exp_slow * math.cos(arg_slow)\n    float c3_slow = -exp_slow * exp_slow\n    float c1_slow = 1.0 - c2_slow - c3_slow\n    var float ssf_fast_1 = 0.0\n    var float ssf_fast_2 = 0.0\n    var int prev_fast_period = 0\n    var float ssf_slow_1 = 0.0\n    var float ssf_slow_2 = 0.0\n    var int prev_slow_period = 0\n    float current = nz(source)\n    float src_1 = nz(source[1], current)\n    float input = (current + src_1) * 0.5\n    if prev_fast_period != fast_period\n        ssf_fast_1 := input\n        ssf_fast_2 := input\n        prev_fast_period := fast_period\n    if prev_slow_period != slow_period\n        ssf_slow_1 := input\n        ssf_slow_2 := input\n        prev_slow_period := slow_period\n    float ssf_fast = c1_fast * input + c2_fast * ssf_fast_1 + c3_fast * ssf_fast_2\n    ssf_fast_2 := ssf_fast_1\n    ssf_fast_1 := ssf_fast\n    float ssf_slow = c1_slow * input + c2_slow * ssf_slow_1 + c3_slow * ssf_slow_2\n    ssf_slow_2 := ssf_slow_1\n    ssf_slow_1 := ssf_slow\n    ssf_fast - ssf_slow\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\ni_period = input.int(40, \"Dominant Cycle Period\", minval=4, maxval=200, \n  tooltip=\"Dominant cycle period. Quarter-cycle and half-cycle SSFs calculated from this value.\")\n\n// Calculation\nssfdsp_val = ssfdsp(i_source, i_period)\n\n// Plot\nplot(ssfdsp_val, \"SSF-DSP\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "ssf-based detrended synthetic price",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "ssfdsp.md",
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-37",
    "type": "example",
    "category": "cycles",
    "title": "Schaff Trend Cycle (STC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Schaff Trend Cycle (STC)\", \"STC\", overlay=false)\n\nema(series float source,simple int period=0,simple float alpha=0)=>\n    if alpha<=0 and period<=0\n        runtime.error(\"Alpha or period must be provided\")\n    float a=alpha>0?alpha:2.0/math.max(period,1)\n    var float raw_ema=na\n    var float ema=na\n    var float e=1.0 \n    var bool warmup=true\n    if not na(source)\n        if na(raw_ema)\n            raw_ema:=0\n            ema:=source\n        else\n            raw_ema:=a*(source-raw_ema)+raw_ema\n            if warmup\n                e*=(1-a)\n                float c=1.0/(1.0-e)\n                ema:=c*raw_ema\n                if e<=1e-10\n                    warmup:=false\n            else\n                ema:=raw_ema\n    ema\n\n//@function Calculates the Schaff Trend Cycle (STC) indicator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/cycles/stc.md\n//@param source Input price series\n//@param cycleLength Main cycle length parameter for lookback periods\n//@param fastLength Period for fast EMA calculation\n//@param slowLength Period for slow EMA calculation\n//@param smoothingType Type of smoothing (0:none, 1:ema, 2:sigmoid, 3:digital)\n//@returns Smoothed STC value\nstc(series float source, simple int cycleLength, simple int fastLength, simple int slowLength, simple int smoothingType = 2) =>\n    float fast_ema = ema(source, fastLength)\n    float slow_ema = ema(source, slowLength)\n    float macdLine = fast_ema - slow_ema\n\n    h1 = ta.highest(macdLine, cycleLength)\n    l1 = ta.lowest(macdLine, cycleLength)\n    float stoch1_raw = (h1 - l1) > 0 ? 100 * (macdLine - l1) / (h1 - l1) : 0\n    float stoch1 = ema(stoch1_raw, 3)\n    h2 = ta.highest(stoch1, cycleLength)\n    l2 = ta.lowest(stoch1, cycleLength)\n    float stoch2 = (h2 - l2) > 0 ? 100 * (stoch1 - l2) / (h2 - l2) : 0\n\n\n    float stcValue = stoch2\n    if smoothingType == 1\n        stcValue := ema(stoch2, 3)\n    else if smoothingType == 2\n        stcValue := 100 / (1 + math.exp(-0.1 * (stcValue - 50)))\n    else if smoothingType == 3\n        stcValue := stcValue > 75 ? 100 : stcValue < 25 ? 0 : stcValue[1]\n    stcValue\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, title=\"Source\")\ni_cycleLength = input.int(12, title=\"Cycle Length\", minval=2)\ni_fastLength = input.int(26, title=\"Fast Length\", minval=2)\ni_slowLength = input.int(50, title=\"Slow Length\", minval=2)\ni_smoothingType = input.int(2, title=\"Smoothing\", minval=0, maxval=3, tooltip=\"0: none, 1:ema, 2:sigmoid, 3:digital\")\n\n// Calculation\nstcValue = stc(i_source, i_cycleLength, i_fastLength, i_slowLength, i_smoothingType)\n\n// Plot\nplot(stcValue, \"STC\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "ta.highest",
      "ta.lowest",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "schaff trend cycle (stc)",
      "cycles",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "ta.highest",
      "ta.lowest",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "runtime.error",
      "math.max",
      "github.com",
      "stc.md",
      "ta.highest",
      "ta.lowest",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-38",
    "type": "example",
    "category": "dynamics",
    "title": "Average Directional Movement Index (ADX)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Average Directional Movement Index (ADX)\", \"ADX\", overlay=false)\r\n\r\n//@function Calculates ADX using Wilder's smoothing with compensated RMA\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/adx.md\r\n//@param period Number of bars used in the calculation\r\n//@returns tuple of ADX value, +DI, -DI\r\nadx(simple int period = 14) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    float tr = na(close[1]) ? high - low : math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))\r\n    float plus_dm = na(high[1]) ? 0.0 : high - high[1] > low[1] - low and high - high[1] > 0 ? high - high[1] : 0.0\r\n    float minus_dm = na(low[1]) ? 0.0 : low[1] - low > high - high[1] and low[1] - low > 0 ? low[1] - low : 0.0\r\n    var float tr_sum = 0.0\r\n    var float plus_dm_sum = 0.0\r\n    var float minus_dm_sum = 0.0\r\n\r\n    tr_sum := nz(tr_sum) - nz(tr_sum[period]) + tr\r\n    plus_dm_sum := nz(plus_dm_sum) - nz(plus_dm_sum[period]) + plus_dm\r\n    minus_dm_sum := nz(minus_dm_sum) - nz(minus_dm_sum[period]) + minus_dm\r\n\r\n    float plus_di = tr_sum != 0.0 ? math.min(100 * plus_dm_sum / tr_sum, 50.0) : 0.0\r\n    float minus_di = tr_sum != 0.0 ? math.min(100 * minus_dm_sum / tr_sum, 50.0) : 0.0\r\n    float dx = plus_di + minus_di != 0.0 ? 100 * math.abs(plus_di - minus_di) / (plus_di + minus_di) : 0.0\r\n\r\n    var float dx_sum = 0.0\r\n    dx_sum := nz(dx_sum) - nz(dx_sum[period]) + dx\r\n    float adx_value = dx_sum / period\r\n    [adx_value, plus_di, minus_di]\r\n\r\n// Inputs\r\ni_period = input.int(14, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\r\n\r\n// Calculate ADX\r\n[adx_value, plus_di, minus_di] = adx(i_period)\r\n\r\n// Plot\r\nplot(adx_value, \"ADX\", color=color.yellow, linewidth=2)\r\nplot(plus_di, \"+DI\", color=color.yellow, linewidth=2)\r\nplot(minus_di, \"-DI\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average directional movement index (adx)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "adx.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-39",
    "type": "example",
    "category": "dynamics",
    "title": "Average Directional Movement Index Rating (ADXR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Average Directional Movement Index Rating (ADXR)\", \"ADXR\", overlay=false)\r\n\r\n//@function Calculates ADX Rating (ADXR) using current and historical ADX values\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/adxr.md\r\n//@param period Number of bars used in ADX calculation\r\n//@param rating_period Number of bars between current and historical ADX\r\n//@returns tuple of ADXR value, ADX value, +DI, -DI\r\nadxr(simple int period, simple int rating_period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    if rating_period <= 0\r\n        runtime.error(\"Rating period must be greater than 0\")\r\n    var float EPSILON = 1e-10\r\n    float alpha = 1.0/float(period)\r\n    float tr = na(close[1]) ? high - low : math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))\r\n    float plus_dm = na(high[1]) ? 0.0 : high - high[1] > low[1] - low and high - high[1] > 0 ? high - high[1] : 0.0\r\n    float minus_dm = na(low[1]) ? 0.0 : low[1] - low > high - high[1] and low[1] - low > 0 ? low[1] - low : 0.0\r\n    var float e = 1.0\r\n    var float tr_raw = na\r\n    tr_raw := na(tr_raw) ? tr : (tr_raw * (period - 1) + tr) / period\r\n    float tr_smooth = e > EPSILON ? tr_raw / (1.0 - e) : tr_raw\r\n    var float pdm_raw = na\r\n    pdm_raw := na(pdm_raw) ? plus_dm : (pdm_raw * (period - 1) + plus_dm) / period\r\n    float plus_dm_smooth = e > EPSILON ? pdm_raw / (1.0 - e) : pdm_raw\r\n    var float mdm_raw = na\r\n    mdm_raw := na(mdm_raw) ? minus_dm : (mdm_raw * (period - 1) + minus_dm) / period\r\n    float minus_dm_smooth = e > EPSILON ? mdm_raw / (1.0 - e) : mdm_raw\r\n    float plus_di = tr_smooth != 0.0 ? math.min(100 * plus_dm_smooth / tr_smooth, 50.0) : 0.0\r\n    float minus_di = tr_smooth != 0.0 ? math.min(100 * minus_dm_smooth / tr_smooth, 50.0) : 0.0\r\n    float dx = plus_di + minus_di != 0.0 ? 100 * math.abs(plus_di - minus_di) / (plus_di + minus_di) : 0.0\r\n    var float adx_raw = na\r\n    adx_raw := na(adx_raw) ? 0.0 : (adx_raw * (period - 1) + dx) / period\r\n    float adx_value = e > EPSILON ? adx_raw / (1.0 - e) : adx_raw\r\n    e *= (1 - alpha)\r\n    float historical_adx = adx_value[math.min(rating_period, bar_index)]\r\n    float adxr_value = (adx_value + nz(historical_adx,0)) / 2.0\r\n    [adxr_value, adx_value, plus_di, minus_di]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_period = input.int(14, \"ADX Period\", minval=1, tooltip=\"Number of bars used in ADX calculation\")\r\ni_rating_period = input.int(14, \"Rating Period\", minval=1, tooltip=\"Number of bars between current and historical ADX\")\r\n\r\n// Calculate ADXR\r\n[adxr_value, adx_value, plus_di, minus_di] = adxr(i_period, i_rating_period)\r\n\r\n// Plot\r\nplot(adxr_value, \"ADXR\", color=color.yellow, linewidth=2)\r\nplot(adx_value, \"ADX\", color=color.yellow, linewidth=2)\r\nplot(plus_di, \"+DI\", color=color.yellow, linewidth=2)\r\nplot(minus_di, \"-DI\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average directional movement index rating (adxr)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "adxr.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.min",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-40",
    "type": "example",
    "category": "dynamics",
    "title": "Williams Alligator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Williams Alligator\", \"ALLIGATOR\", overlay=true)\n\n//@function Calculates Williams Alligator indicator using SMMA (RMA)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/alligator.md\n//@param source Series to calculate Alligator from\n//@param jawPeriod Period for Jaw line (typically 13)\n//@param jawOffset Forward offset for Jaw line (typically 8)\n//@param teethPeriod Period for Teeth line (typically 8)\n//@param teethOffset Forward offset for Teeth line (typically 5)\n//@param lipsPeriod Period for Lips line (typically 5)\n//@param lipsOffset Forward offset for Lips line (typically 3)\n//@returns Tuple [jaw, teeth, lips] values\n//@optimized Uses Wilder's RMA (SMMA) with exponential warmup compensator for O(1) complexity\nalligator(series float source, simple int jawPeriod, simple int jawOffset, simple int teethPeriod, simple int teethOffset, simple int lipsPeriod, simple int lipsOffset) =>\n    if jawPeriod <= 0 or teethPeriod <= 0 or lipsPeriod <= 0\n        runtime.error(\"All periods must be greater than 0\")\n    if jawOffset < 0 or teethOffset < 0 or lipsOffset < 0\n        runtime.error(\"All offsets must be non-negative\")\n    float alphaJaw = 1.0 / float(jawPeriod)\n    float alphaTeeth = 1.0 / float(teethPeriod)\n    float alphaLips = 1.0 / float(lipsPeriod)\n    var bool warmupJaw = true\n    var bool warmupTeeth = true\n    var bool warmupLips = true\n    var float eJaw = 1.0\n    var float eTeeth = 1.0\n    var float eLips = 1.0\n    var float emaJaw = 0.0\n    var float emaTeeth = 0.0\n    var float emaLips = 0.0\n    var float jaw = source\n    var float teeth = source\n    var float lips = source\n    emaJaw := alphaJaw * (source - emaJaw) + emaJaw\n    emaTeeth := alphaTeeth * (source - emaTeeth) + emaTeeth\n    emaLips := alphaLips * (source - emaLips) + emaLips\n    if warmupJaw\n        eJaw *= (1.0 - alphaJaw)\n        float cJaw = 1.0 / (1.0 - eJaw)\n        jaw := cJaw * emaJaw\n        warmupJaw := eJaw > 1e-10\n    else\n        jaw := emaJaw\n    if warmupTeeth\n        eTeeth *= (1.0 - alphaTeeth)\n        float cTeeth = 1.0 / (1.0 - eTeeth)\n        teeth := cTeeth * emaTeeth\n        warmupTeeth := eTeeth > 1e-10\n    else\n        teeth := emaTeeth\n    if warmupLips\n        eLips *= (1.0 - alphaLips)\n        float cLips = 1.0 / (1.0 - eLips)\n        lips := cLips * emaLips\n        warmupLips := eLips > 1e-10\n    else\n        lips := emaLips\n    [jaw, teeth, lips]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\ni_jawPeriod = input.int(13, \"Jaw Period\", minval=1)\ni_jawOffset = input.int(8, \"Jaw Offset\", minval=0)\ni_teethPeriod = input.int(8, \"Teeth Period\", minval=1)\ni_teethOffset = input.int(5, \"Teeth Offset\", minval=0)\ni_lipsPeriod = input.int(5, \"Lips Period\", minval=1)\ni_lipsOffset = input.int(3, \"Lips Offset\", minval=0)\n\n// Calculation\n[jaw, teeth, lips] = alligator(i_source, i_jawPeriod, i_jawOffset, i_teethPeriod, i_teethOffset, i",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "williams alligator",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "alligator.md",
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-41",
    "type": "example",
    "category": "dynamics",
    "title": "Archer Moving Averages Trends (AMAT)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Archer Moving Averages Trends (AMAT)\", \"AMAT\", overlay=false)\n\n//@function Calculates AMAT using multiple EMAs to identify trend direction\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/amat.md\n//@param source Series to calculate AMAT from\n//@param fast Fast EMA period\n//@param slow Slow EMA period\n//@returns Tuple [bullish_count, bearish_count, trend_strength]\namat(series float source, simple int fast = 10, simple int slow = 50) =>\n    if fast <= 0 or slow <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    if fast >= slow\n        runtime.error(\"Fast period must be less than slow period\")\n    \n    float alpha_fast = 2.0 / (fast + 1)\n    float alpha_slow = 2.0 / (slow + 1)\n    \n    var float ema_fast = source\n    var float ema_slow = source\n    var float ema_fast_prev = source\n    var float ema_slow_prev = source\n    \n    ema_fast := alpha_fast * (source - ema_fast) + ema_fast\n    ema_slow := alpha_slow * (source - ema_slow) + ema_slow\n    \n    float long_trend = ema_fast > ema_slow and ema_fast > ema_fast_prev and ema_slow > ema_slow_prev ? 1.0 : 0.0\n    float short_trend = ema_fast < ema_slow and ema_fast < ema_fast_prev and ema_slow < ema_slow_prev ? -1.0 : 0.0\n    \n    ema_fast_prev := ema_fast\n    ema_slow_prev := ema_slow\n    \n    float trend = long_trend + short_trend\n    float strength = math.abs(ema_fast - ema_slow) / ema_slow * 100\n    \n    [trend, strength, ema_fast, ema_slow]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_fast = input.int(10, \"Fast Period\", minval=1)\ni_slow = input.int(50, \"Slow Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\n[trend, strength, ema_fast, ema_slow] = amat(i_source, i_fast, i_slow)\n\n// Plot\nplot(trend, \"AMAT Trend\", color=trend > 0 ? color.green : trend < 0 ? color.red : color.gray, style=plot.style_columns, linewidth=3)\nplot(strength, \"Trend Strength %\", color=color.yellow, linewidth=2)\nhline(0, \"Zero\", color=color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "input.int",
      "input.source",
      "color.green",
      "color.red",
      "color.gray",
      "color.yellow",
      "plot",
      "hline"
    ],
    "keywords": [
      "archer moving averages trends (amat)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "input.int",
      "input.source",
      "color.green",
      "color.red",
      "color.gray",
      "color.yellow",
      "plot",
      "hline",
      "github.com",
      "amat.md",
      "runtime.error",
      "math.abs",
      "input.int",
      "input.source",
      "color.green",
      "color.red",
      "color.gray",
      "plot.style_columns",
      "color.yellow",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-42",
    "type": "example",
    "category": "dynamics",
    "title": "Aroon (AROON)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Aroon (AROON)\", \"AROON\", overlay=false)\r\n\r\n//@function Calculates Aroon Up and Down values\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/aroon.md\r\n//@param period Number of bars used in the calculation\r\n//@returns tuple of Aroon Up and Aroon Down values\r\naroon(simple int period = 25) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n\r\n    // Find highest high and lowest low positions\r\n    float highest_pos = ta.highestbars(high, period)\r\n    float lowest_pos = ta.lowestbars(low, period)\r\n\r\n    // Calculate Aroon values\r\n    float aroon_up = 100 * (period + highest_pos) / period\r\n    float aroon_down = 100 * (period + lowest_pos) / period\r\n\r\n    [aroon_up, aroon_down]\r\n\r\n// Inputs\r\ni_period = input.int(25, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\r\n\r\n// Calculate Aroon\r\n[aroon_up, aroon_down] = aroon(i_period)\r\n\r\n// Plot\r\nplot(aroon_up, \"Aroon Up\", color=color.yellow, linewidth=2)\r\nplot(aroon_down, \"Aroon Down\", color=color.yellow, linewidth=2)\r\nhline(50, \"Mid Level\", color.gray)\r\nhline(70, \"Upper Level\", color.gray)\r\nhline(30, \"Lower Level\", color.gray)\r\n\r\n// Alert conditions\r\nalertcondition(ta.crossover(aroon_up, aroon_down), \"Aroon Up crosses above Down\", \"Bullish crossover on {{ticker}}\")\r\nalertcondition(ta.crossunder(aroon_up, aroon_down), \"Aroon Down crosses above Up\", \"Bearish crossover on {{ticker}}\")\r\nalertcondition(aroon_up > 70 and aroon_down < 30, \"Strong uptrend\", \"Strong uptrend detected on {{ticker}}\")\r\nalertcondition(aroon_down > 70 and aroon_up < 30, \"Strong downtrend\", \"Strong downtrend detected on {{ticker}}\")\r\n",
    "functions_used": [
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "ta.crossover",
      "ta.crossunder",
      "plot",
      "hline",
      "alertcondition"
    ],
    "keywords": [
      "aroon (aroon)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "ta.crossover",
      "ta.crossunder",
      "plot",
      "hline",
      "alertcondition",
      "github.com",
      "aroon.md",
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "ta.crossover",
      "ta.crossunder",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "alert",
      "alertcondition",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-43",
    "type": "example",
    "category": "dynamics",
    "title": "Aroon Oscillator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Aroon Oscillator\", \"AROONOSC\", overlay=false)\n\n//@function Calculates Aroon Oscillator (Aroon Up - Aroon Down)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/aroonosc.md\n//@param period Number of bars used in the calculation\n//@returns Aroon Oscillator value ranging from -100 to +100\naroonosc(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    float highest_pos = ta.highestbars(high, period)\n    float lowest_pos = ta.lowestbars(low, period)\n    \n    float aroon_up = 100 * (period + highest_pos) / period\n    float aroon_down = 100 * (period + lowest_pos) / period\n    \n    float oscillator = aroon_up - aroon_down\n    oscillator\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(25, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\n\n// Calculation\noscillator = aroonosc(i_period)\n\n// Plot\nplot(oscillator, \"Aroon Oscillator\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)\nhline(50, \"Upper Level\", color=color.gray, linestyle=hline.style_dashed)\nhline(-50, \"Lower Level\", color=color.gray, linestyle=hline.style_dashed)\n\n// Color fill for positive/negative regions\nbgcolor(oscillator > 0 ? color.new(color.green, 90) : color.new(color.red, 90), title=\"Background\")\n\n// Alert conditions\nalertcondition(ta.crossover(oscillator, 0), \"Bullish Crossover\", \"Aroon Oscillator crossed above zero on {{ticker}}\")\nalertcondition(ta.crossunder(oscillator, 0), \"Bearish Crossover\", \"Aroon Oscillator crossed below zero on {{ticker}}\")\nalertcondition(oscillator > 70, \"Strong Uptrend\", \"Strong uptrend detected on {{ticker}} (Oscillator > 70)\")\nalertcondition(oscillator < -70, \"Strong Downtrend\", \"Strong downtrend detected on {{ticker}} (Oscillator < -70)\")\n",
    "functions_used": [
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "ta.crossover",
      "ta.crossunder",
      "plot",
      "hline",
      "bgcolor",
      "alertcondition"
    ],
    "keywords": [
      "aroon oscillator",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "ta.crossover",
      "ta.crossunder",
      "plot",
      "hline",
      "bgcolor",
      "alertcondition",
      "github.com",
      "aroonosc.md",
      "runtime.error",
      "ta.highestbars",
      "ta.lowestbars",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_solid",
      "hline.style_dashed",
      "color.new",
      "color.green",
      "color.red",
      "ta.crossover",
      "ta.crossunder",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "alert",
      "alertcondition",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-44",
    "type": "example",
    "category": "dynamics",
    "title": "Choppiness Index",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Choppiness Index\", \"CHOP\", overlay=false)\n\n//@function Calculates Choppiness Index to measure market trendiness\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/chop.md\n//@param length Lookback period for calculation\n//@returns CHOP value between 0 and 100 (lower=trending, higher=choppy)\n//@references E.W. Dreiss, Australian commodity trader\n//@optimized O(n) with circular buffers for TR sum and high/low tracking\nchop(simple int length) =>\n    if length <= 1\n        runtime.error(\"Length must be > 1\")\n    var float sum_tr = 0.0\n    var int head = 0\n    var int filled = 0\n    var array<float> atr_buf = array.new_float(length, na)\n    var array<float> high_buf = array.new_float(length, na)\n    var array<float> low_buf = array.new_float(length, na)\n    float prevClose = nz(close[1], close)\n    float tr = math.max(high - low, math.max(math.abs(high - prevClose), math.abs(low - prevClose)))\n    float out = array.get(atr_buf, head)\n    if not na(out)\n        sum_tr -= out\n    else\n        filled += 1\n    array.set(atr_buf, head, tr)\n    array.set(high_buf, head, high)\n    array.set(low_buf, head, low)\n    sum_tr += tr\n    int win = math.min(filled, length)\n    float hhv = -1e100\n    float llv = 1e100\n    for k = 0 to win - 1\n        int idx = (head - k + length) % length\n        float h = array.get(high_buf, idx)\n        float l = array.get(low_buf, idx)\n        if not na(h)\n            hhv := math.max(hhv, h)\n        if not na(l)\n            llv := math.min(llv, l)\n    head := (head + 1) % length\n    float price_range = hhv - llv\n    float chop_value = na\n    if win >= 2 and price_range > 0\n        float log_ratio = math.log10(sum_tr / price_range)\n        float log_len = math.log10(win)\n        chop_value := 100.0 * log_ratio / log_len\n        chop_value := math.max(0.0, math.min(100.0, chop_value))\n    chop_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=2)\n\n// Calculation\nchop_value = chop(i_length)\n\n// Plot\nplot(chop_value, \"CHOP\", color=color.yellow, linewidth=2)\nhline(61.8, \"High Threshold\", color=color.new(color.red, 50), linestyle=hline.style_dashed)\nhline(38.2, \"Low Threshold\", color=color.new(color.green, 50), linestyle=hline.style_dashed)\nhline(50, \"Midline\", color=color.new(color.gray, 70), linestyle=hline.style_dotted)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.max",
      "math.abs",
      "array.get",
      "array.set",
      "math.min",
      "math.log10",
      "input.int",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "choppiness index",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "math.max",
      "math.abs",
      "array.get",
      "array.set",
      "math.min",
      "math.log10",
      "input.int",
      "color.yellow",
      "color.new",
      "color.red",
      "color.green",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "chop.md",
      "runtime.error",
      "array.new_float",
      "math.max",
      "math.abs",
      "array.get",
      "array.set",
      "math.min",
      "math.log",
      "input.int",
      "color.yellow",
      "color.new",
      "color.red",
      "hline.style_dashed",
      "color.green",
      "color.gray",
      "hline.style_dotted",
      "math.log10",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "fill",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-45",
    "type": "example",
    "category": "dynamics",
    "title": "Jurik Directional Movement Index (DMX)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Jurik Directional Movement Index (DMX)\", \"DMX\", overlay=false)\r\n\r\n//@function Calculates DMX using Jurik's smoothing of ADX\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/dmx.md\r\n//@param period Number of bars used in the calculation\r\n//@returns dmx value\r\ndmx(simple int period = 14) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    float tr = na(close[1]) ? high - low : math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))\r\n    float upDm = na(high[1]) ? 0.0 : high - high[1] > low[1] - low and high - high[1] > 0 ? high - high[1] : 0.0\r\n    float downDm = na(low[1]) ? 0.0 : low[1] - low > high - high[1] and low[1] - low > 0 ? low[1] - low : 0.0\r\n    float wilderAlpha = 1.0 / period\r\n    var float upEma = na, var float upDi = na, var float upE = 1.0\r\n    var bool upWarmup = true\r\n    if not na(upDm)\r\n        if na(upEma)\r\n            upEma := 0\r\n            upDi := upDm\r\n        else\r\n            upEma := wilderAlpha * (upDm - upEma) + upEma\r\n            if upWarmup\r\n                upE *= (1 - wilderAlpha)\r\n                float upC = 1.0 / (1.0 - upE)\r\n                upDi := upC * upEma\r\n                if upE <= 1e-10\r\n                    upWarmup := false\r\n            else\r\n                upDi := upEma\r\n    var float downEma = na, var float downDi = na, var float downE = 1.0, var bool downWarmup = true\r\n    if not na(downDm)\r\n        if na(downEma)\r\n            downEma := 0\r\n            downDi := downDm\r\n        else\r\n            downEma := wilderAlpha * (downDm - downEma) + downEma\r\n            if downWarmup\r\n                downE *= (1 - wilderAlpha)\r\n                float downC = 1.0 / (1.0 - downE)\r\n                downDi := downC * downEma\r\n                if downE <= 1e-10\r\n                    downWarmup := false\r\n            else\r\n                downDi := downEma\r\n    float sumDi = upDi + downDi\r\n    float source = sumDi != 0.0 ? (upDi - downDi) / sumDi : 0.0\r\n    var simple float PHASE_VALUE = 0.5\r\n    var float power = 0.20\r\n    var simple float BETA = power * (period - 1) / ((power * (period - 1)) + 2)\r\n    var simple float LEN1 = math.max((math.log(math.sqrt(0.5*(period-1))) / math.log(2.0)) + 2.0, 0)\r\n    var simple float POW1 = math.max(LEN1 - 2.0, 0.5)\r\n    var simple float LEN2 = math.sqrt(0.5*(period-1))*LEN1\r\n    var simple float POW1_RECIPROCAL = 1.0 / POW1\r\n    var simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)\r\n    var simple float DIV = 1.0/(10.0 + 10.0*(math.min(math.max(period-10,0),100))/100.0)\r\n    var float upperBand_state = na, var float lowerBand_state = na, var float ma1_state = na, var float jma_state = na\r\n    var float vSum_state = 0.0, var float det0_state = 0.0, var float det1_state = 0.0, var float avgVolty_state = na\r\n    var volty_array_state = array.new_float(11, 0.0)\r\n    float dmx = na\r\n    if not na(source)\r\n        ",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "jurik directional movement index (dmx)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "dmx.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-46",
    "type": "example",
    "category": "dynamics",
    "title": "Directional Movement Index (DX)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Directional Movement Index (DX)\", \"DX\", overlay=false)\n\n//@function Calculates DX using Wilder's smoothing with compensated RMA\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/dx.md\n//@param period Number of bars used in the calculation\n//@returns tuple of DX value, +DI, -DI\n//@optimized Uses Wilder's smoothing (RMA) with warmup compensation for accurate values from bar 1\ndx(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float alpha = 1.0 / period\n    float beta = 1.0 - alpha\n    float tr = 0.0\n    float plus_dm = 0.0\n    float minus_dm = 0.0\n    if na(close[1])\n        tr := high - low\n    else\n        tr := math.max(high - low, math.max(math.abs(high - close[1]), math.abs(low - close[1])))\n        float upMove = high - high[1]\n        float downMove = low[1] - low\n        if upMove > downMove and upMove > 0\n            plus_dm := upMove\n        if downMove > upMove and downMove > 0\n            minus_dm := downMove\n    var bool warmup = true\n    var float e = 1.0\n    var float tr_ema = 0.0\n    var float tr_result = tr\n    var float plus_dm_ema = 0.0\n    var float plus_dm_result = plus_dm\n    var float minus_dm_ema = 0.0\n    var float minus_dm_result = minus_dm\n    tr_ema := alpha * (tr - tr_ema) + tr_ema\n    plus_dm_ema := alpha * (plus_dm - plus_dm_ema) + plus_dm_ema\n    minus_dm_ema := alpha * (minus_dm - minus_dm_ema) + minus_dm_ema\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        tr_result := c * tr_ema\n        plus_dm_result := c * plus_dm_ema\n        minus_dm_result := c * minus_dm_ema\n        warmup := e > 1e-10\n    else\n        tr_result := tr_ema\n        plus_dm_result := plus_dm_ema\n        minus_dm_result := minus_dm_ema\n    float plus_di = tr_result != 0.0 ? 100.0 * plus_dm_result / tr_result : 0.0\n    float minus_di = tr_result != 0.0 ? 100.0 * minus_dm_result / tr_result : 0.0\n    float di_sum = plus_di + minus_di\n    float dx_value = di_sum != 0.0 ? 100.0 * math.abs(plus_di - minus_di) / di_sum : 0.0\n    [dx_value, plus_di, minus_di]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\n\n// Calculation\n[dx_value, plus_di, minus_di] = dx(i_period)\n\n// Plot\nplot(dx_value, \"DX\", color=color.yellow, linewidth=2)\nplot(plus_di, \"+DI\", color=color.green, linewidth=1)\nplot(minus_di, \"-DI\", color=color.red, linewidth=1)\nhline(25, \"Strong Trend Threshold\", color=color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.green",
      "color.red",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "directional movement index (dx)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.green",
      "color.red",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "dx.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.green",
      "color.red",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-47",
    "type": "example",
    "category": "dynamics",
    "title": "HT_TRENDMODE: Hilbert Transform Trend Mode",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"HT_TRENDMODE: Hilbert Transform Trend Mode\", \"HT_TRENDMODE\", overlay=false)\n\n//@function Numerically stable atan2 implementation for quadrant-aware angle calculation\n//@param y Y-coordinate (imaginary/quadrature component)\n//@param x X-coordinate (real/in-phase component)\n//@returns Angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    angle\n\n//@function Determines if market is in trend mode (1) or cycle mode (0)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/ht_trendmode.md\n//@param source Series to analyze for trend/cycle state\n//@returns 1 for trend mode, 0 for cycle mode\nht_trendmode(series float source) =>\n    var float smooth_price = 0.0\n    var float detrender = 0.0\n    var float i1 = 0.0\n    var float q1 = 0.0\n    var float ji = 0.0\n    var float jq = 0.0\n    var float i2 = 0.0\n    var float q2 = 0.0\n    var float re = 0.0\n    var float im = 0.0\n    var float period = 15.0\n    var float smooth_period = 15.0\n    var float dc_phase = 0.0\n    var float inst_period = 15.0\n    var int trend_mode = 0\n    float price = nz(source)\n    float bandwidth = 0.075 * smooth_period + 0.54\n    smooth_price := (4.0 * price + 3.0 * nz(price[1]) + 2.0 * nz(price[2]) + nz(price[3])) / 10.0\n    detrender := (0.0962 * smooth_price + 0.5769 * nz(smooth_price[2]) - 0.5769 * nz(smooth_price[4]) - 0.0962 * nz(smooth_price[6])) * bandwidth\n    q1 := (0.0962 * detrender + 0.5769 * nz(detrender[2]) - 0.5769 * nz(detrender[4]) - 0.0962 * nz(detrender[6])) * bandwidth\n    i1 := nz(detrender[3])\n    ji := (0.0962 * i1 + 0.5769 * nz(i1[2]) - 0.5769 * nz(i1[4]) - 0.0962 * nz(i1[6])) * bandwidth\n    jq := (0.0962 * q1 + 0.5769 * nz(q1[2]) - 0.5769 * nz(q1[4]) - 0.0962 * nz(q1[6])) * bandwidth\n    i2 := i1 - jq\n    q2 := q1 + ji\n    i2 := 0.2 * i2 + 0.8 * nz(i2[1])\n    q2 := 0.2 * q2 + 0.8 * nz(q2[1])\n    re := i2 * nz(i2[1]) + q2 * nz(q2[1])\n    im := i2 * nz(q2[1]) - q2 * nz(i2[1])\n    re := 0.2 * re + 0.8 * nz(re[1])\n    im := 0.2 * im + 0.8 * nz(im[1])\n    if im != 0.0 or re != 0.0\n        float angle = atan2(im, re)\n        if angle != 0.0\n            period := 2.0 * math.pi / angle\n    period := math.max(6.0, math.min(50.0, period))\n    smooth_period := 0.33 * period + 0.67 * smooth_period\n    if im != 0.0 or re != 0.0\n        dc_phase := atan2(im, re)\n    float delta_phase = dc_phase - nz(dc_phase[1])\n    if math.abs(delta_phase) < 0.1\n        delta_phase := nz(delta_phase[1])\n    if delta_phase != 0.0\n        float temp_period = 2.0 * math.pi / delta_phase\n        inst_period := 0.33 * temp_period + 0.67 * nz(ins",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.green",
      "color.red",
      "plot"
    ],
    "keywords": [
      "ht_trendmode: hilbert transform trend mode",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "math.max",
      "math.min",
      "input.source",
      "color.green",
      "color.red",
      "plot",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "github.com",
      "ht_trendmode.md",
      "math.max",
      "math.min",
      "input.source",
      "color.green",
      "color.red",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-48",
    "type": "example",
    "category": "dynamics",
    "title": "Ichimoku Cloud",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ichimoku Cloud\", \"ICHIMOKU\", overlay=true)\n\n//@function Calculate Ichimoku Cloud components\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/ichimoku.md\n//@param tenkan_period Tenkan-sen (Conversion Line) period\n//@param kijun_period Kijun-sen (Base Line) period\n//@param senkou_b_period Senkou Span B (Leading Span B) period\n//@returns [tenkan, kijun, senkou_a, senkou_b, chikou] Five Ichimoku components\n//@optimized Single-pass calculation of all three Donchian midpoints\nichimoku(simple int tenkan_period, simple int kijun_period, simple int senkou_b_period) =>\n    if tenkan_period <= 0\n        runtime.error(\"Tenkan period must be greater than 0\")\n    if kijun_period <= 0\n        runtime.error(\"Kijun period must be greater than 0\")\n    if senkou_b_period <= 0\n        runtime.error(\"Senkou B period must be greater than 0\")\n    \n    int max_period = math.max(tenkan_period, math.max(kijun_period, senkou_b_period))\n    int effective_period = math.min(bar_index + 1, max_period)\n    \n    float tenkan_high = high\n    float tenkan_low = low\n    float kijun_high = high\n    float kijun_low = low\n    float senkou_b_high = high\n    float senkou_b_low = low\n    \n    for i = 1 to effective_period - 1\n        float h = nz(high[i])\n        float l = nz(low[i])\n        \n        if not na(h) and not na(l)\n            if i < tenkan_period\n                if h > tenkan_high\n                    tenkan_high := h\n                if l < tenkan_low\n                    tenkan_low := l\n            \n            if i < kijun_period\n                if h > kijun_high\n                    kijun_high := h\n                if l < kijun_low\n                    kijun_low := l\n            \n            if i < senkou_b_period\n                if h > senkou_b_high\n                    senkou_b_high := h\n                if l < senkou_b_low\n                    senkou_b_low := l\n    \n    float tenkan = (tenkan_high + tenkan_low) / 2.0\n    float kijun = (kijun_high + kijun_low) / 2.0\n    float senkou_a = (tenkan + kijun) / 2.0\n    float senkou_b = (senkou_b_high + senkou_b_low) / 2.0\n    float chikou = close\n    \n    [tenkan, kijun, senkou_a, senkou_b, chikou]\n\n// ---------- Main loop ----------\n\ni_tenkan = input.int(9, \"Tenkan Period\", minval=1, maxval=5000)\ni_kijun = input.int(26, \"Kijun Period\", minval=1, maxval=5000)\ni_senkou_b = input.int(52, \"Senkou B Period\", minval=1, maxval=5000)\ni_displacement = input.int(26, \"Displacement\", minval=1, maxval=500)\n\n[tenkan, kijun, senkou_a, senkou_b, chikou] = ichimoku(i_tenkan, i_kijun, i_senkou_b)\n\nplot(tenkan, \"Tenkan-sen\", color=color.blue, linewidth=1)\nplot(kijun, \"Kijun-sen\", color=color.red, linewidth=1)\nplot(chikou, \"Chikou Span\", color=color.purple, linewidth=1, offset=-i_displacement)\n\np1 = plot(senkou_a, \"Senkou Span A\", color=color.green, linewidth=1, offset=i_displacement)\np2 = plot(senkou_b, \"Senkou Span B\", color=color.red, linewidth=1, offset=i_di",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.purple",
      "color.green",
      "color.new",
      "plot",
      "fill"
    ],
    "keywords": [
      "ichimoku cloud",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.purple",
      "color.green",
      "color.new",
      "plot",
      "fill",
      "github.com",
      "ichimoku.md",
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.purple",
      "color.green",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-49",
    "type": "example",
    "category": "dynamics",
    "title": "Intraday Momentum Index (IMI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Intraday Momentum Index (IMI)\", \"IMI\", overlay=false)\n\n//@function Calculates IMI using intraday price ranges (open vs close)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/imi.md\n//@param period Number of bars used in the calculation\n//@returns IMI value (0-100)\n//@optimized Uses circular buffer for O(1) per-bar complexity\nimi(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float gain = 0.0\n    float loss = 0.0\n    if close > open\n        gain := close - open\n    else if close < open\n        loss := open - close\n    var array<float> gain_buffer = array.new_float(period, 0.0)\n    var array<float> loss_buffer = array.new_float(period, 0.0)\n    var int idx = 0\n    var float gain_sum = 0.0\n    var float loss_sum = 0.0\n    gain_sum -= array.get(gain_buffer, idx)\n    loss_sum -= array.get(loss_buffer, idx)\n    array.set(gain_buffer, idx, gain)\n    array.set(loss_buffer, idx, loss)\n    gain_sum += gain\n    loss_sum += loss\n    idx := (idx + 1) % period\n    float total = gain_sum + loss_sum\n    float imi_value = total != 0.0 ? 100.0 * gain_sum / total : 50.0\n    imi_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\n\n// Calculate IMI\nimi_value = imi(i_period)\n\n// Plot\nplot(imi_value, \"IMI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "intraday momentum index (imi)",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "imi.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-50",
    "type": "example",
    "category": "dynamics",
    "title": "Qstick Indicator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Qstick Indicator\", \"QSTICK\", overlay=false)\n\n//@function Calculates Qstick (moving average of close-open difference)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/qstick.md\n//@param source_close Closing price series\n//@param source_open Opening price series\n//@param length Lookback period for moving average\n//@param use_ema Use EMA (true) or SMA (false)\n//@returns Qstick value\nqstick(series float source_close, series float source_open, simple int length, simple bool use_ema) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    \n    float diff = source_close - source_open\n    \n    float result = 0.0\n    if use_ema\n        float alpha = 2.0 / (length + 1)\n        var float ema = 0.0\n        ema := alpha * (diff - ema) + ema\n        result := ema\n    else\n        var int count = 0\n        var float sum = 0.0\n        var int head = 0\n        var array<float> buffer = array.new_float(length, na)\n        \n        float oldest = array.get(buffer, head)\n        if not na(oldest)\n            sum -= oldest\n        else\n            count += 1\n        \n        float current = nz(diff)\n        sum += current\n        array.set(buffer, head, current)\n        head := (head + 1) % length\n        \n        result := sum / math.max(1, count)\n    \n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, tooltip=\"Lookback period for moving average calculation\")\ni_ma_type = input.string(\"SMA\", \"MA Type\", options=[\"SMA\", \"EMA\"], tooltip=\"Simple (SMA) or Exponential (EMA) moving average\")\ni_source_close = input.source(close, \"Close Source\", tooltip=\"Source for closing price\")\ni_source_open = input.source(open, \"Open Source\", tooltip=\"Source for opening price\")\n\n// Calculation\nbool use_ema = i_ma_type == \"EMA\"\nqstick_value = qstick(i_source_close, i_source_open, i_length, use_ema)\n\n// Plot\nplot(qstick_value, \"Qstick\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_dashed)\n\n// Color fill for positive/negative regions\nbgcolor(qstick_value > 0 ? color.new(color.green, 90) : color.new(color.red, 90), title=\"Background\")\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.string",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "bgcolor"
    ],
    "keywords": [
      "qstick indicator",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.string",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "bgcolor",
      "github.com",
      "qstick.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.string",
      "input.source",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "color.new",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "fill",
      "bgcolor",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-51",
    "type": "example",
    "category": "dynamics",
    "title": "SuperTrend",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"SuperTrend\", \"SUPER\", overlay=true)\n\n//@function Calculates SuperTrend using ATR-based dynamic support/resistance\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/super.md\n//@param source Price series for calculation (typically hlc3 or close)\n//@param atr_period Lookback period for ATR calculation\n//@param multiplier Multiplier applied to ATR for band calculation\n//@returns Tuple [supertrend, direction] where direction is 1 (bullish) or -1 (bearish)\n//@optimized O(1) with proper warmup handling\nsuper(series float source, simple int atr_period, simple float multiplier) =>\n    if atr_period <= 0\n        runtime.error(\"ATR period must be greater than 0\")\n    if multiplier <= 0.0\n        runtime.error(\"Multiplier must be greater than 0\")\n    float hl2_value = (high + low) / 2.0\n    float tr = math.max(high - low, math.max(math.abs(high - nz(close[1])), math.abs(low - nz(close[1]))))\n    float alpha = 1.0 / atr_period\n    float beta = 1.0 - alpha\n    var bool warmup = true\n    var float e = 1.0\n    var float atr = 0.0\n    var float compensated_atr = tr\n    atr := alpha * (tr - atr) + atr\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        compensated_atr := c * atr\n        warmup := e > 1e-10\n    else\n        compensated_atr := atr\n    float basic_ub = hl2_value + (multiplier * compensated_atr)\n    float basic_lb = hl2_value - (multiplier * compensated_atr)\n    var float final_ub = basic_ub\n    var float final_lb = basic_lb\n    var int trend = 1\n    final_ub := basic_ub < final_ub or nz(close[1]) > final_ub ? basic_ub : final_ub\n    final_lb := basic_lb > final_lb or nz(close[1]) < final_lb ? basic_lb : final_lb\n    int prev_trend = nz(trend[1], 1)\n    trend := close > final_ub ? 1 : close < final_lb ? -1 : prev_trend\n    float supertrend = trend == 1 ? final_lb : final_ub\n    [supertrend, trend]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_atr_period = input.int(10, \"ATR Period\", minval=1, maxval=100)\ni_multiplier = input.float(3.0, \"Multiplier\", minval=0.1, step=0.1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\n[st_line, st_direction] = super(i_source, i_atr_period, i_multiplier)\n\n// Colors\ncolor bullish_color = color.new(color.green, 0)\ncolor bearish_color = color.new(color.red, 0)\ncolor line_color = st_direction == 1 ? bullish_color : bearish_color\n\n// Plot\nplot(st_line, \"SuperTrend\", color=line_color, linewidth=2, style=plot.style_line)\n\n// Optional: Plot buy/sell signals when direction changes\nbool direction_changed = st_direction != nz(st_direction[1])\nplotshape(direction_changed and st_direction == 1, \"Buy Signal\", shape.labelup, location.belowbar, color=bullish_color, text=\"BUY\", textcolor=color.white, size=size.small)\nplotshape(direction_changed and st_direction == -1, \"Sell Signal\", shape.labeldown, location.abovebar, color=bearish_color, text=\"SELL\", textcolor=color.white, size=size.small)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "input.float",
      "input.source",
      "color.new",
      "color.green",
      "color.red",
      "color.white",
      "plot",
      "plotshape"
    ],
    "keywords": [
      "supertrend",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "input.float",
      "input.source",
      "color.new",
      "color.green",
      "color.red",
      "color.white",
      "plot",
      "plotshape",
      "github.com",
      "super.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "input.int",
      "input.float",
      "input.source",
      "color.new",
      "color.green",
      "color.red",
      "plot.style_line",
      "shape.labelup",
      "location.belowbar",
      "color.white",
      "size.small",
      "shape.labeldown",
      "location.abovebar",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-52",
    "type": "example",
    "category": "dynamics",
    "title": "TTM Trend",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"TTM Trend\", \"TTM\", overlay=true)\n\n//@function Calculates TTM Trend using 6-period moving average with color-coded trend\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/ttm.md\n//@param source Series to calculate TTM from\n//@param period Lookback period for moving average\n//@returns Tuple [ttm_line, trend, strength] where trend is -1/0/1 and strength is percentage change\nttm(series float source, simple int period = 6) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    float alpha = 2.0 / (period + 1)\n    var float ema = source\n    var float ema_prev = source\n    \n    ema := alpha * (source - ema) + ema\n    \n    float trend = math.sign(ema - ema_prev)\n    float strength = math.abs(ema - ema_prev) / math.max(ema_prev, 1e-10) * 100\n    \n    ema_prev := ema\n    \n    [ema, trend, strength]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(6, \"Period\", minval=1)\ni_source = input.source(hlc3, \"Source\")\ni_show_strength = input.bool(true, \"Show Trend Strength %\")\n\n// Calculation\n[ttm_line, trend, strength] = ttm(i_source, i_period)\n\n// Colors\ncolor up_color = color.new(color.green, 0)\ncolor down_color = color.new(color.red, 0)\ncolor neutral_color = color.new(color.gray, 50)\ncolor line_color = trend > 0 ? up_color : trend < 0 ? down_color : neutral_color\n\n// Plot\nplot(ttm_line, \"TTM Trend\", color=line_color, linewidth=3, style=plot.style_line)\n\n// Strength band (optional)\nfloat strength_multiplier = 0.01\nfloat upper_band = i_show_strength ? ttm_line + (ttm_line * strength * strength_multiplier) : na\nfloat lower_band = i_show_strength ? ttm_line - (ttm_line * strength * strength_multiplier) : na\n\np1 = plot(upper_band, \"Upper Strength\", color=color.new(color.blue, 80), linewidth=1)\np2 = plot(lower_band, \"Lower Strength\", color=color.new(color.blue, 80), linewidth=1)\nfill(p1, p2, color=color.new(color.blue, 90), title=\"Strength Band\")\n\n// Optional: Plot trend change signals\nbool trend_change = trend != nz(trend[1], 0) and bar_index > 0\nplotshape(trend_change and trend > 0, \"Up\", shape.triangleup, location.belowbar, color=up_color, size=size.tiny)\nplotshape(trend_change and trend < 0, \"Down\", shape.triangledown, location.abovebar, color=down_color, size=size.tiny)\n",
    "functions_used": [
      "runtime.error",
      "math.sign",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.new",
      "color.green",
      "color.red",
      "color.gray",
      "color.blue",
      "plot",
      "fill",
      "plotshape"
    ],
    "keywords": [
      "ttm trend",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "math.sign",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.new",
      "color.green",
      "color.red",
      "color.gray",
      "color.blue",
      "plot",
      "fill",
      "plotshape",
      "github.com",
      "ttm.md",
      "runtime.error",
      "math.sign",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.new",
      "color.green",
      "color.red",
      "color.gray",
      "plot.style_line",
      "color.blue",
      "shape.triangleup",
      "location.belowbar",
      "size.tiny",
      "shape.triangledown",
      "location.abovebar",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-53",
    "type": "example",
    "category": "dynamics",
    "title": "Vortex Indicator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Vortex Indicator\", \"VORTEX\", overlay=false)\n\n//@function Calculates Vortex Indicator (VI+ and VI-)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/dynamics/vortex.md\n//@param period Lookback period for summing vortex movements and true range\n//@returns Tuple [vi_plus, vi_minus] normalized vortex indicator values\n//@optimized Uses running sums for O(1) complexity with circular buffer\nvortex(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int head = 0\n    var array<float> vmPlusBuffer = array.new_float(period, na)\n    var array<float> vmMinusBuffer = array.new_float(period, na)\n    var array<float> trBuffer = array.new_float(period, na)\n    var float sumVMPlus = 0.0\n    var float sumVMMinus = 0.0\n    var float sumTR = 0.0\n    var int count = 0\n    float tr1 = high - low\n    float tr2 = na(close[1]) ? 0 : math.abs(high - close[1])\n    float tr3 = na(close[1]) ? 0 : math.abs(low - close[1])\n    float tr = math.max(tr1, math.max(tr2, tr3))\n    float vmPlus = na(low[1]) ? tr : math.abs(high - low[1])\n    float vmMinus = na(high[1]) ? tr : math.abs(low - high[1])\n    float oldVMPlus = array.get(vmPlusBuffer, head)\n    float oldVMMinus = array.get(vmMinusBuffer, head)\n    float oldTR = array.get(trBuffer, head)\n    if not na(oldVMPlus)\n        sumVMPlus -= oldVMPlus\n        sumVMMinus -= oldVMMinus\n        sumTR -= oldTR\n    else\n        count += 1\n    sumVMPlus += vmPlus\n    sumVMMinus += vmMinus\n    sumTR += tr\n    array.set(vmPlusBuffer, head, vmPlus)\n    array.set(vmMinusBuffer, head, vmMinus)\n    array.set(trBuffer, head, tr)\n    head := (head + 1) % period\n    float viPlus = sumTR > 0 ? sumVMPlus / sumTR : 0\n    float viMinus = sumTR > 0 ? sumVMMinus / sumTR : 0\n    [viPlus, viMinus]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1)\n\n// Calculation\n[vi_plus, vi_minus] = vortex(i_period)\n\n// Plot\nplot(vi_plus, \"VI+\", color=color.green, linewidth=2)\nplot(vi_minus, \"VI-\", color=color.red, linewidth=2)\nhline(1.0, \"Reference\", color=color.gray, linestyle=hline.style_dotted)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.abs",
      "math.max",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "vortex indicator",
      "dynamics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "math.abs",
      "math.max",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "vortex.md",
      "runtime.error",
      "array.new_float",
      "math.abs",
      "math.max",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "color.gray",
      "hline.style_dotted",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-54",
    "type": "example",
    "category": "errors",
    "title": "Dirty Data Injection (DIRTY)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Dirty Data Injection (DIRTY)\", \"DIRTY\", overlay=false, format=format.percent)\n\n//@function Injects NA values into a data series at regular intervals\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/dirty.md\n//@param source Series to inject NA values into\n//@param interval Frequency of NA value injections\n//@returns Series with NA values injected at specified intervals\ndirty(float source, simple int interval = 10, simple int gap_size = 1) =>\n    result = source\n    if bar_index == 0\n        result := na\n    else\n        cycle_position = bar_index % interval\n        if cycle_position < gap_size\n            result := na\n    result\n\n// Inputs\nsource = input.source(close, \"Source\")\ninterval = input.int(10, \"NA Injection Interval\", minval=2)\ngap_size = input.int(5, \"NA Gap Size\", minval=1)\n\n// Calculation\ndirty = dirty(source, interval, gap_size)\n\n// Plot\nplot(dirty, \"Dirty Data\", color=color.yellow, linewidth = 2)",
    "functions_used": [
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "dirty data injection (dirty)",
      "errors",
      "indicator",
      "v6",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "dirty.md",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-55",
    "type": "example",
    "category": "errors",
    "title": "Huber Loss (HUBER)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Huber Loss (HUBER)\", \"HUBER\")\n\n//@function Calculates Huber Loss between two sources using SMA for averaging\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/huber.md\n//@param source1 First series to compare\n//@param source2 Second series to compare\n//@param period Lookback period for error averaging\n//@param delta Threshold that determines switch between MSE and MAE behavior\n//@returns Huber loss value averaged over the specified period using SMA\nhuber(series float source1, series float source2, simple int period, simple float delta = 1.345) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(math.max(1, period), 4000)\n    error = source1 - source2\n    huber_error = math.abs(error) <= delta ? 0.5 * math.pow(error, 2) : delta * math.abs(error) - 0.5 * math.pow(delta, 2)\n    var float[] buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum := sum - oldest\n        valid_count := valid_count - 1\n    if not na(huber_error)\n        sum := sum + huber_error\n        valid_count := valid_count + 1\n    array.set(buffer, head, huber_error)\n    head := (head + 1) % p\n    valid_count > 0 ? sum / valid_count : huber_error\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source1 = input.source(close, \"Source\")\ni_period = input.int(100, \"Period\", minval=1)\ni_delta = input.float(1.345, \"Delta\", minval=0.1)\ni_source2 = ta.ema(i_source1, i_period) \n\n// Calculation\nerror = huber(i_source1, i_source2, i_period, i_delta)\n\n// Plot\nplot(error, \"Huber\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "math.pow",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "huber loss (huber)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "math.pow",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "huber.md",
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "math.pow",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "input.float",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "script-56",
    "type": "example",
    "category": "errors",
    "title": "Mean Absolute Error (MAE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Mean Absolute Error (MAE)\", \"MAE\")\n\n//@function Calculates Mean Absolute Error between two sources using SMA for averaging\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mae.md\n//@param source1 First series to compare\n//@param source2 Second series to compare\n//@param period Lookback period for error averaging\n//@returns MAE value averaged over the specified period using SMA\nmae(series float source1, series float source2, simple int period) =>\n    absolute_error = math.abs(source1 - source2)\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(math.max(1, period), 4000)\n    var float[] buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum := sum - oldest\n        valid_count := valid_count - 1\n    if not na(absolute_error)\n        sum := sum + absolute_error\n        valid_count := valid_count + 1\n    array.set(buffer, head, absolute_error)\n    head := (head + 1) % p\n    valid_count > 0 ? sum / valid_count : absolute_error\n\n    \n// ---------- Main loop ----------\n\n// Inputs\ni_source1 = input.source(close, \"Source\")\ni_period = input.int(100, \"Period\", minval=1)\ni_source2 = ta.ema(i_source1, i_period)\n\n// Calculation\nerror = mae(i_source1, i_source2, i_period)\n\n// Plot\nplot(error, \"MAE\", color.new(color.blue, 60, color=color.yellow, linewidth=2), linewidth = 2, style = plot.style_area)\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\n",
    "functions_used": [
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.blue",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean absolute error (mae)",
      "errors",
      "indicator",
      "v6",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.blue",
      "color.yellow",
      "plot",
      "github.com",
      "mae.md",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.blue",
      "color.yellow",
      "plot.style_area",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-57",
    "type": "example",
    "category": "errors",
    "title": "Mean Absolute %Deviation (MAPD)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean Absolute %Deviation (MAPD)\", \"MAPD\")\r\n\r\n//@function Calculates Mean Absolute Percentage Deviation between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mapd.md\r\n//@param source1 First series to compare\r\n//@param source2 Second series to compare\r\n//@param period Lookback period for error averaging\r\n//@returns MAPD value averaged over the specified period using SMA\r\nmapd(series float source1, series float source2, simple int period) =>\r\n    percentage_error = 100 * math.abs((source1 - source2) / source2)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(percentage_error)\r\n        sum := sum + percentage_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, percentage_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : percentage_error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = mapd(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"MAPD\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean absolute %deviation (mapd)",
      "errors",
      "indicator",
      "v6",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "mapd.md",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-58",
    "type": "example",
    "category": "errors",
    "title": "Mean Absolute %Error (MAPE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean Absolute %Error (MAPE)\", \"MAPE\")\r\n\r\n//@function Calculates Mean Absolute Percentage Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mape.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns MAPE value averaged over the specified period using SMA\r\nmape(series float source1, series float source2, simple int period) =>\r\n    percentage_error = 100 * math.abs((source1 - source2) / source1)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(percentage_error)\r\n        sum := sum + percentage_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, percentage_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : percentage_error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = mape(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"MAPE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean absolute %error (mape)",
      "errors",
      "indicator",
      "v6",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "mape.md",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-59",
    "type": "example",
    "category": "errors",
    "title": "Mean Absolute Scaled Error (MASE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean Absolute Scaled Error (MASE)\", \"MASE\")\r\n\r\n//@function Calculates Mean Absolute Scaled Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mase.md\r\n//@param source1 First series to compare\r\n//@param source2 Second series to compare\r\n//@param period Lookback period for error averaging\r\n//@returns MASE value averaged over the specified period using SMA\r\nmase(series float source1, series float source2, simple int period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    error = source1 - source2\r\n    abs_error = math.abs(error)\r\n    var float scale = na\r\n    if na(scale)\r\n        sum = 0.0\r\n        count = 0\r\n        for i = 1 to p\r\n            if not na(source1[i]) and not na(source1[i-1])\r\n                sum += math.abs(source1[i] - source1[i-1])\r\n                count += 1\r\n        scale := count > 0 ? sum / count : 1.0\r\n    scaled_error = abs_error / (scale == 0 ? 1.0 : scale)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(scaled_error)\r\n        sum := sum + scaled_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, scaled_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : scaled_error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = mase(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"MASE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean absolute scaled error (mase)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "mase.md",
      "runtime.error",
      "math.min",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-60",
    "type": "example",
    "category": "errors",
    "title": "Mean Error (ME)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean Error (ME)\", \"ME\")\r\n\r\n//@function Calculates Mean Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/me.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns ME value averaged over the specified period using SMA\r\nme(series float source1, series float source2, simple int period) =>\r\n    error = source1 - source2\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(error)\r\n        sum := sum + error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = me(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"ME\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean error (me)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "me.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-61",
    "type": "example",
    "category": "errors",
    "title": "Mean %Error (MPE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean %Error (MPE)\", \"MPE\")\r\n\r\n//@function Calculates Mean Percentage Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mpe.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns MPE value averaged over the specified period using SMA\r\nmpe(series float source1, series float source2, simple int period) =>\r\n    percentage_error = 100 * ((source1 - source2) / source1)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(percentage_error)\r\n        sum := sum + percentage_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, percentage_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : percentage_error\r\n\r\n// ---------- Main loop ----------\r\n\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = mpe(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"MPE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean %error (mpe)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "mpe.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-62",
    "type": "example",
    "category": "errors",
    "title": "Mean Squared Error (MSE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Mean Squared Error (MSE)\", \"MSE\")\n\n\n//@function Calculates Mean Squared Error between two sources using SMA for averaging\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/mse.md\n//@param source1 First series to compare\n//@param source2 Second series to compare\n//@param period Lookback period for error averaging\n//@returns MSE value averaged over the specified period using SMA\nmse(series float source1, series float source2, simple int period) =>\n    squared_error = math.pow(source1 - source2, 2)\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(math.max(1, period), 4000)\n    var float[] buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum := sum - oldest\n        valid_count := valid_count - 1\n    if not na(squared_error)\n        sum := sum + squared_error\n        valid_count := valid_count + 1\n    array.set(buffer, head, squared_error)\n    head := (head + 1) % p\n    valid_count > 0 ? sum / valid_count : squared_error\n\n    \n// ---------- Main loop ----------\n\n// Inputs\ni_source1 = input.source(close, \"Source\")\ni_period = input.int(100, \"Period\", minval=1)\ni_source2 = ta.ema(i_source1, i_period)\n\n// Calculation\nerror = mse(i_source1, i_source2, i_period)\n\n// Plot\nplot(error, \"MSE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\n",
    "functions_used": [
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean squared error (mse)",
      "errors",
      "indicator",
      "v6",
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "mse.md",
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-63",
    "type": "example",
    "category": "errors",
    "title": "Mean Squared Logarithmic Error (MSLE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mean Squared Logarithmic Error (MSLE)\", \"MSLE\")\r\n\r\n//@function Calculates Mean Squared Logarithmic Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/msle.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns MSLE value averaged over the specified period using SMA\r\nmsle(series float source1, series float source2, simple int period) =>\r\n    log_error = math.pow(math.log(1 + source1) - math.log(1 + source2), 2)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(log_error)\r\n        sum := sum + log_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, log_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : log_error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = msle(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"MSLE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mean squared logarithmic error (msle)",
      "errors",
      "indicator",
      "v6",
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "msle.md",
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-64",
    "type": "example",
    "category": "errors",
    "title": "Relative Absolute Error (RAE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Relative Absolute Error (RAE)\", \"RAE\")\r\n\r\n//@function Calculates Relative Absolute Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/rae.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns RAE value averaged over the specified period using SMA\r\nrae(series float source1, series float source2, simple int period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float sum_source1 = 0.0\r\n    var float[] buffer_source1 = array.new_float(p, na)\r\n    var int head_source1 = 0\r\n    var int valid_count_source1 = 0\r\n    float oldest_source1 = array.get(buffer_source1, head_source1)\r\n    if not na(oldest_source1)\r\n        sum_source1 := sum_source1 - oldest_source1\r\n        valid_count_source1 := valid_count_source1 - 1\r\n    if not na(source1)\r\n        sum_source1 := sum_source1 + source1\r\n        valid_count_source1 := valid_count_source1 + 1\r\n    array.set(buffer_source1, head_source1, source1)\r\n    head_source1 := (head_source1 + 1) % p\r\n    float mean_source1 = valid_count_source1 > 0 ? sum_source1 / valid_count_source1 : source1\r\n    float abs_error = math.abs(source1 - source2)\r\n    float abs_baseline_error = math.abs(source1 - mean_source1)\r\n    var float sum_abs_error = 0.0\r\n    var float[] buffer_abs_error = array.new_float(p, na)\r\n    var int head_abs_error = 0\r\n    var int valid_count_abs_error = 0\r\n    float oldest_abs_error = array.get(buffer_abs_error, head_abs_error)\r\n    if not na(oldest_abs_error)\r\n        sum_abs_error := sum_abs_error - oldest_abs_error\r\n        valid_count_abs_error := valid_count_abs_error - 1\r\n    if not na(abs_error)\r\n        sum_abs_error := sum_abs_error + abs_error\r\n        valid_count_abs_error := valid_count_abs_error + 1\r\n    array.set(buffer_abs_error, head_abs_error, abs_error)\r\n    head_abs_error := (head_abs_error + 1) % p\r\n    var float sum_baseline_error = 0.0\r\n    var float[] buffer_baseline_error = array.new_float(p, na)\r\n    var int head_baseline_error = 0\r\n    var int valid_count_baseline_error = 0\r\n    float oldest_baseline_error = array.get(buffer_baseline_error, head_baseline_error)\r\n    if not na(oldest_baseline_error)\r\n        sum_baseline_error := sum_baseline_error - oldest_baseline_error\r\n        valid_count_baseline_error := valid_count_baseline_error - 1\r\n    if not na(abs_baseline_error)\r\n        sum_baseline_error := sum_baseline_error + abs_baseline_error\r\n        valid_count_baseline_error := valid_count_baseline_error + 1\r\n    array.set(buffer_baseline_error, head_baseline_error, abs_baseline_error)\r\n    head_baseline_error := (head_baseline_error + 1) % p\r\n    float total_abs_error = valid_count_abs_error > 0 ? sum_abs_error : abs_error\r\n    ",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "relative absolute error (rae)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "rae.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-65",
    "type": "example",
    "category": "errors",
    "title": "Root Mean Squared Error (RMSE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Root Mean Squared Error (RMSE)\", \"RMSE\")\r\n\r\n//@function Calculates Root Mean Squared Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/rmse.md\r\n//@param source1 First series to compare\r\n//@param source2 Second series to compare\r\n//@param period Lookback period for error averaging\r\n//@returns RMSE value averaged over the specified period using SMA\r\nrmse(series float source1, series float source2, simple int period) =>\r\n    squared_error = math.pow(source1 - source2, 2)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(squared_error)\r\n        sum := sum + squared_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, squared_error)\r\n    head := (head + 1) % p\r\n    float mse = valid_count > 0 ? sum / valid_count : squared_error\r\n    math.sqrt(mse)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = rmse(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"RMSE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "root mean squared error (rmse)",
      "errors",
      "indicator",
      "v6",
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "rmse.md",
      "math.pow",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-66",
    "type": "example",
    "category": "errors",
    "title": "Root Mean Squared Logarithmic Error (RMSLE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Root Mean Squared Logarithmic Error (RMSLE)\", \"RMSLE\")\r\n\r\n//@function Calculates Root Mean Squared Logarithmic Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/rmsle.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns RMSLE value averaged over the specified period using SMA\r\nrmsle(series float source1, series float source2, simple int period) =>\r\n    log_squared_error = math.pow(math.log(1 + source1) - math.log(1 + source2), 2)\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(log_squared_error)\r\n        sum := sum + log_squared_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, log_squared_error)\r\n    head := (head + 1) % p\r\n    float msle = valid_count > 0 ? sum / valid_count : log_squared_error\r\n    math.sqrt(msle)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = rmsle(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"RMSLE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "root mean squared logarithmic error (rmsle)",
      "errors",
      "indicator",
      "v6",
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "rmsle.md",
      "math.pow",
      "math.log",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-67",
    "type": "example",
    "category": "errors",
    "title": "Relative Squared Error (RSE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Relative Squared Error (RSE)\", \"RSE\")\r\n\r\n//@function Calculates Relative Squared Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/rse.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns RSE value averaged over the specified period using SMA\r\nrse(series float source1, series float source2, simple int period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float sum_source1 = 0.0\r\n    var float[] buffer_source1 = array.new_float(p, na)\r\n    var int head_source1 = 0\r\n    var int valid_count_source1 = 0\r\n    float oldest_source1 = array.get(buffer_source1, head_source1)\r\n    if not na(oldest_source1)\r\n        sum_source1 := sum_source1 - oldest_source1\r\n        valid_count_source1 := valid_count_source1 - 1\r\n    if not na(source1)\r\n        sum_source1 := sum_source1 + source1\r\n        valid_count_source1 := valid_count_source1 + 1\r\n    array.set(buffer_source1, head_source1, source1)\r\n    head_source1 := (head_source1 + 1) % p\r\n    float mean_source1 = valid_count_source1 > 0 ? sum_source1 / valid_count_source1 : source1\r\n    float squared_error = math.pow(source1 - source2, 2)\r\n    float squared_baseline_error = math.pow(source1 - mean_source1, 2)\r\n    var float sum_squared_error = 0.0\r\n    var float[] buffer_squared_error = array.new_float(p, na)\r\n    var int head_squared_error = 0\r\n    var int valid_count_squared_error = 0\r\n    float oldest_squared_error = array.get(buffer_squared_error, head_squared_error)\r\n    if not na(oldest_squared_error)\r\n        sum_squared_error := sum_squared_error - oldest_squared_error\r\n        valid_count_squared_error := valid_count_squared_error - 1\r\n    if not na(squared_error)\r\n        sum_squared_error := sum_squared_error + squared_error\r\n        valid_count_squared_error := valid_count_squared_error + 1\r\n    array.set(buffer_squared_error, head_squared_error, squared_error)\r\n    head_squared_error := (head_squared_error + 1) % p\r\n    var float sum_baseline_error = 0.0\r\n    var float[] buffer_baseline_error = array.new_float(p, na)\r\n    var int head_baseline_error = 0\r\n    var int valid_count_baseline_error = 0\r\n    float oldest_baseline_error = array.get(buffer_baseline_error, head_baseline_error)\r\n    if not na(oldest_baseline_error)\r\n        sum_baseline_error := sum_baseline_error - oldest_baseline_error\r\n        valid_count_baseline_error := valid_count_baseline_error - 1\r\n    if not na(squared_baseline_error)\r\n        sum_baseline_error := sum_baseline_error + squared_baseline_error\r\n        valid_count_baseline_error := valid_count_baseline_error + 1\r\n    array.set(buffer_baseline_error, head_baseline_error, squared_baseline_error)\r\n    head_baseline_error :",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "relative squared error (rse)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "rse.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-68",
    "type": "example",
    "category": "errors",
    "title": "R² Coefficient of Determination (RSQUARED)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"R² Coefficient of Determination (RSQUARED)\", \"RSQUARED\")\r\n\r\n//@function Calculates the R-squared (Coefficient of Determination) between two sources\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/rsquared.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for averaging\r\n//@returns R-squared value averaging over the specified period\r\nrsquared(series float source1, series float source2, simple int period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float sum_source1 = 0.0\r\n    var float[] buffer_source1 = array.new_float(p, na)\r\n    var int head_source1 = 0\r\n    var int valid_count_source1 = 0\r\n    float oldest_source1 = array.get(buffer_source1, head_source1)\r\n    if not na(oldest_source1)\r\n        sum_source1 := sum_source1 - oldest_source1\r\n        valid_count_source1 := valid_count_source1 - 1\r\n    if not na(source1)\r\n        sum_source1 := sum_source1 + source1\r\n        valid_count_source1 := valid_count_source1 + 1\r\n    array.set(buffer_source1, head_source1, source1)\r\n    head_source1 := (head_source1 + 1) % p\r\n    float mean_source1 = valid_count_source1 > 0 ? sum_source1 / valid_count_source1 : source1\r\n    float squared_residual = math.pow(source1 - source2, 2)\r\n    float total_ss = math.pow(source1 - mean_source1, 2)\r\n    var float sum_squared_residual = 0.0\r\n    var float[] buffer_squared_residual = array.new_float(p, na)\r\n    var int head_squared_residual = 0\r\n    var int valid_count_squared_residual = 0\r\n    float oldest_squared_residual = array.get(buffer_squared_residual, head_squared_residual)\r\n    if not na(oldest_squared_residual)\r\n        sum_squared_residual := sum_squared_residual - oldest_squared_residual\r\n        valid_count_squared_residual := valid_count_squared_residual - 1\r\n    if not na(squared_residual)\r\n        sum_squared_residual := sum_squared_residual + squared_residual\r\n        valid_count_squared_residual := valid_count_squared_residual + 1\r\n    array.set(buffer_squared_residual, head_squared_residual, squared_residual)\r\n    head_squared_residual := (head_squared_residual + 1) % p\r\n    var float sum_total_ss = 0.0\r\n    var float[] buffer_total_ss = array.new_float(p, na)\r\n    var int head_total_ss = 0\r\n    var int valid_count_total_ss = 0\r\n    float oldest_total_ss = array.get(buffer_total_ss, head_total_ss)\r\n    if not na(oldest_total_ss)\r\n        sum_total_ss := sum_total_ss - oldest_total_ss\r\n        valid_count_total_ss := valid_count_total_ss - 1\r\n    if not na(total_ss)\r\n        sum_total_ss := sum_total_ss + total_ss\r\n        valid_count_total_ss := valid_count_total_ss + 1\r\n    array.set(buffer_total_ss, head_total_ss, total_ss)\r\n    head_total_ss := (head_total_ss + 1) % p\r\n    float rss = valid_count_squared_residual > 0 ? sum_s",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "r² coefficient of determination (rsquared)",
      "errors",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "rsquared.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot.style_area",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-69",
    "type": "example",
    "category": "errors",
    "title": "Symmetric Mean Absolute %Error (SMAPE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Symmetric Mean Absolute %Error (SMAPE)\", \"SMAPE\")\r\n\r\n//@function Calculates Symmetric Mean Absolute Percentage Error between two sources using SMA for averaging\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/errors/smape.md\r\n//@param source1 First series to compare (actual)\r\n//@param source2 Second series to compare (predicted)\r\n//@param period Lookback period for error averaging\r\n//@returns SMAPE value averaged over the specified period using SMA (in percentage)\r\nsmape(series float source1, series float source2, simple int period) =>\r\n    // Calculate symmetric absolute percentage error (scaled to 100%)\r\n    abs_diff = math.abs(source1 - source2)\r\n    sum_abs = math.abs(source1) + math.abs(source2)\r\n    symmetric_error = sum_abs != 0 ? 200 * abs_diff / sum_abs : 0\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    int p = math.min(math.max(1, period), 4000)\r\n    var float[] buffer = array.new_float(p, na)\r\n    var int head = 0\r\n    var float sum = 0.0\r\n    var int valid_count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum := sum - oldest\r\n        valid_count := valid_count - 1\r\n    if not na(symmetric_error)\r\n        sum := sum + symmetric_error\r\n        valid_count := valid_count + 1\r\n    array.set(buffer, head, symmetric_error)\r\n    head := (head + 1) % p\r\n    valid_count > 0 ? sum / valid_count : symmetric_error\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source1 = input.source(close, \"Source\")\r\ni_period = input.int(100, \"Period\", minval=1)\r\ni_source2 = ta.ema(i_source1, i_period)\r\n\r\n// Calculation\r\nerror = smape(i_source1, i_source2, i_period)\r\n\r\n// Plot\r\nplot(error, \"SMAPE\", color=color.new(color.red, 60), linewidth=2, style = plot.style_area)\r\nplot(i_source2, \"EMA\", color=color.yellow, linewidth=1, style = plot.style_line, force_overlay = true)\r\n",
    "functions_used": [
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "symmetric mean absolute %error (smape)",
      "errors",
      "indicator",
      "v6",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "color.yellow",
      "plot",
      "github.com",
      "smape.md",
      "math.abs",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "ta.ema",
      "color.new",
      "color.red",
      "plot.style_area",
      "color.yellow",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-70",
    "type": "example",
    "category": "filters",
    "title": "Bessel 2nd Order Filter (BESSEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bessel 2nd Order Filter (BESSEL)\", \"BESSEL\", overlay=true)\n\n//@function Calculates 2nd Order Bessel Lowpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/bessel.md\n//@param src Series to calculate Bessel filter from\n//@param length Cutoff period (related to -3dB frequency)\n//@returns Bessel filter value\n//@optimized Uses IIR 2nd order filter with O(1) complexity per bar\nbessel(series float src, simple int length) =>\n    float pi = math.pi\n    int safe_length = math.max(length, 2)\n    float a = math.exp(-pi / safe_length)\n    float b = 2.0 * a * math.cos(1.738 * pi / safe_length)\n    float c2 = b\n    float c3 = -a * a\n    float c1 = 1.0 - c2 - c3\n    var float filt = na\n    if bar_index < 2\n        filt := nz(src, 0.0)\n    else\n        float ssrc = nz(src, src[1])\n        float filt1 = nz(filt[1], ssrc)\n        float filt2 = nz(filt[2], filt1)\n        filt := c1 * ssrc + c2 * filt1 + c3 * filt2\n    filt\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nbessel_val = bessel(i_source, i_length)\n\n// Plot\nplot(bessel_val, \"Bessel\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bessel 2nd order filter (bessel)",
      "filters",
      "indicator",
      "v6",
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "bessel.md",
      "math.pi",
      "math.max",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-71",
    "type": "example",
    "category": "filters",
    "title": "Bilateral Filter (BILATERAL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bilateral Filter (BILATERAL)\", \"BILATERAL\", overlay=true)\n\n//@function Calculates Bilateral Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/bilateral.md\n//@param src Series to calculate Bilateral Filter from\n//@param length Number of bars used in the calculation (spatial domain)\n//@param sigma_s_ratio Ratio to determine spatial standard deviation\n//@param sigma_r_mult Multiplier for range standard deviation\n//@returns Bilateral Filter value\n//@optimized Uses edge-preserving bilateral smoothing with O(n) complexity per bar\nbilateral(series float src, simple int length, simple float sigma_s_ratio, simple float sigma_r_mult) =>\n    float sigma_s = math.max(length * sigma_s_ratio, 1e-10)\n    float sigma_r = math.max(ta.stdev(src, length) * sigma_r_mult, 1e-10)\n    float sum_weights = 0.0\n    float sum_weighted_src = 0.0\n    float center_val = nz(src[0], src[1])\n    for i = 0 to length - 1\n        float val = nz(src[i], center_val)\n        float diff_spatial = float(i)\n        float diff_range = center_val - val\n        float weight_spatial = math.exp(-(diff_spatial * diff_spatial) / (2.0 * sigma_s * sigma_s))\n        float weight_range = math.exp(-(diff_range * diff_range) / (2.0 * sigma_r * sigma_r))\n        float weight = weight_spatial * weight_range\n        sum_weights += weight\n        sum_weighted_src += weight * val\n    float result = sum_weights == 0.0 ? center_val : sum_weighted_src / sum_weights\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=2)\ni_sigma_s_ratio = input.float(0.5, \"Spatial Sigma Ratio\", minval=0.01, step=0.05)\ni_sigma_r_mult = input.float(1.0, \"Range Sigma Multiplier\", minval=0.01, step=0.1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nfiltered_value = bilateral(i_source, i_length, i_sigma_s_ratio, i_sigma_r_mult)\n\n// Plot\nplot(filtered_value, \"Bilateral\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "ta.stdev",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bilateral filter (bilateral)",
      "filters",
      "indicator",
      "v6",
      "math.max",
      "ta.stdev",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "bilateral.md",
      "math.max",
      "ta.stdev",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-72",
    "type": "example",
    "category": "filters",
    "title": "Bandpass Filter (BPF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bandpass Filter (BPF)\", \"BPF\", overlay=true)\n\n//@function Optimized Bandpass Filter combining highpass and lowpass filters\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/bpf.md\n//@param source Series to calculate bandpass from\n//@param lp Lower cutoff period for highpass filter\n//@param up Upper cutoff period for lowpass filter\n//@returns Optimized bandpass filtered series\n//@optimized Uses combined HP and LP IIR filters with O(1) complexity per bar\nbpf(series float src, simple int lp, simple int up) =>\n    var float SQRT2_PI = math.sqrt(2.0) * math.pi\n    var float hp = na\n    var float hp_c1 = 0.0\n    var float hp_c2 = 0.0\n    var float hp_c3 = 0.0\n    var int prev_hp_length = 0\n    var float bpf_val = na\n    var float lp_c1 = 0.0\n    var float lp_c2 = 0.0\n    var float lp_c3 = 0.0\n    var int prev_lp_length = 0\n    if prev_hp_length != lp\n        float hp_arg = SQRT2_PI / float(lp)\n        float hp_exp_arg = math.exp(-hp_arg)\n        hp_c2 := 2.0 * hp_exp_arg * math.cos(hp_arg)\n        hp_c3 := -hp_exp_arg * hp_exp_arg\n        hp_c1 := (1.0 + hp_c2 - hp_c3) / 4.0\n        prev_hp_length := lp\n    if prev_lp_length != up\n        float lp_arg = SQRT2_PI / float(up)\n        float lp_exp_arg = math.exp(-lp_arg)\n        lp_c2 := 2.0 * lp_exp_arg * math.cos(lp_arg)\n        lp_c3 := -lp_exp_arg * lp_exp_arg\n        lp_c1 := 1.0 - lp_c2 - lp_c3\n        prev_lp_length := up\n    float ssrc = nz(src, src[1])\n    float src1 = nz(src[1], ssrc)\n    float src2 = nz(src[2], src1)\n    float hp1 = nz(hp[1], 0.0)\n    float hp2 = nz(hp[2], 0.0)\n    hp := hp_c1 * (ssrc - 2.0 * src1 + src2) + hp_c2 * hp1 + hp_c3 * hp2\n    float bp1 = nz(bpf_val[1], hp)\n    float bp2 = nz(bpf_val[2], bp1)\n    bpf_val := lp_c1 * hp + lp_c2 * bp1 + lp_c3 * bp2\n    bpf_val\n\n// ---------- Main loop ----------\n\n// Inputs\ni_lower = input.int(10, \"Lower Cutoff\", minval=1)\ni_upper = input.int(20, \"Higher Cutoff\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nfilt = bpf(i_source, i_lower, i_upper)\n\n// Plot\nplot(i_source - filt, \"Bandpass\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bandpass filter (bpf)",
      "filters",
      "indicator",
      "v6",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "bpf.md",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-73",
    "type": "example",
    "category": "filters",
    "title": "Butterworth 2nd Order Filter (BUTTER)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Butterworth 2nd Order Filter (BUTTER)\", \"BUTTER\", overlay=true)\n\n//@function Calculates 2nd Order Butterworth Lowpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/butter.md\n//@param src Series to calculate Butterworth filter from\n//@param length Cutoff period (related to -3dB frequency)\n//@returns Butterworth filter value\n//@optimized Uses IIR 2nd order Butterworth filter with O(1) complexity per bar\nbutter(series float src, simple int length) =>\n    float pi = math.pi\n    int safe_length = math.max(length, 2)\n    float omega = 2.0 * pi / safe_length\n    float sin_omega = math.sin(omega)\n    float cos_omega = math.cos(omega)\n    float alpha = sin_omega / math.sqrt(2.0)\n    float a0 = 1.0 + alpha\n    float a1 = -2.0 * cos_omega\n    float a2 = 1.0 - alpha\n    float b0 = (1.0 - cos_omega) / 2.0\n    float b1 = 1.0 - cos_omega\n    float b2 = (1.0 - cos_omega) / 2.0\n    var float filt = na\n    if bar_index < 2\n        filt := nz(src, 0.0)\n    else\n        float ssrc = nz(src, src[1])\n        float src1 = nz(src[1], ssrc)\n        float src2 = nz(src[2], src1)\n        float filt1 = nz(filt[1], ssrc)\n        float filt2 = nz(filt[2], filt1)\n        filt := (b0 * ssrc + b1 * src1 + b2 * src2 - a1 * filt1 - a2 * filt2) / a0\n    filt\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nbutter_val = butter(i_source, i_length)\n\n// Plot\nplot(butter_val, \"Butterworth\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.max",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "butterworth 2nd order filter (butter)",
      "filters",
      "indicator",
      "v6",
      "math.pi",
      "math.max",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "butter.md",
      "math.pi",
      "math.max",
      "math.sin",
      "math.cos",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-74",
    "type": "example",
    "category": "filters",
    "title": "Chebyshev Type I Filter (CHEBY1)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chebyshev Type I Filter (CHEBY1)\", \"CHEBY1\", overlay=true)\n\n//@function Calculates 2nd Order Chebyshev Type I Lowpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/cheby1.md\n//@param src Series to calculate Chebyshev filter from\n//@param length Cutoff period (related to cutoff frequency)\n//@param ripple Passband ripple in decibels (dB) > 0\n//@returns Chebyshev Type I filter value\n//@optimized Uses IIR 2nd order Chebyshev Type I filter with O(1) complexity per bar\ncheby1(series float src, simple int length, simple float ripple) =>\n    float pi = math.pi\n    int safe_length = math.max(length, 2)\n    float safe_ripple = math.max(ripple, 0.01)\n    float wc = 2.0 * pi / safe_length\n    float Wc = math.tan(wc / 2.0)\n    float epsilon = math.sqrt(math.pow(10.0, safe_ripple / 10.0) - 1.0)\n    float asinh_inv_eps = math.log(1.0 / epsilon + math.sqrt(1.0 / (epsilon * epsilon) + 1.0))\n    float mu = asinh_inv_eps / 2.0\n    float sinh_mu = (math.exp(mu) - math.exp(-mu)) / 2.0\n    float cosh_mu = (math.exp(mu) + math.exp(-mu)) / 2.0\n    float sigma = -sinh_mu * Wc\n    float omega_d = cosh_mu * Wc\n    float K = sigma * sigma + omega_d * omega_d\n    float a0_z = 1.0 - 2.0 * sigma + K\n    float a1_z = 2.0 * K - 2.0\n    float a2_z = 1.0 + 2.0 * sigma + K\n    float b0_z = K\n    float b1_z = 2.0 * K\n    float b2_z = K\n    float B0 = b0_z / a0_z\n    float B1 = b1_z / a0_z\n    float B2 = b2_z / a0_z\n    float A1 = a1_z / a0_z\n    float A2 = a2_z / a0_z\n    var float filt = na\n    if bar_index < 2\n        filt := nz(src, 0.0)\n    else\n        float ssrc = nz(src, src[1])\n        float src1 = nz(src[1], ssrc)\n        float src2 = nz(src[2], src1)\n        float filt1 = nz(filt[1], ssrc)\n        float filt2 = nz(filt[2], filt1)\n        filt := B0 * ssrc + B1 * src1 + B2 * src2 - A1 * filt1 - A2 * filt2\n    filt\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=2)\ni_ripple = input.float(1.0, \"Passband Ripple (dB)\", minval=0.01, step=0.1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ncheby1_val = cheby1(i_source, i_length, i_ripple)\n\n// Plot\nplot(cheby1_val, \"Cheby1\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "chebyshev type i filter (cheby1)",
      "filters",
      "indicator",
      "v6",
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "if",
      "else"
    ]
  },
  {
    "id": "script-75",
    "type": "example",
    "category": "filters",
    "title": "Chebyshev Type II Filter (CHEBY2)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chebyshev Type II Filter (CHEBY2)\", \"CHEBY2\", overlay=true)\n\n//@function Calculates 2nd Order Chebyshev Type II Lowpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/cheby2.md\n//@param src Series to calculate Chebyshev filter from\n//@param length Cutoff period (related to cutoff frequency)\n//@param attenuation Stopband attenuation in decibels (dB) > 0\n//@returns Chebyshev Type II filter value\n//@optimized Uses IIR 2nd order Chebyshev Type II filter with O(1) complexity per bar\ncheby2(series float src, simple int length, simple float attenuation) =>\n    float pi = math.pi\n    int safe_length = math.max(length, 2)\n    float safe_atten = math.max(attenuation, 0.1)\n    float wc = 2.0 * pi / safe_length\n    float Wc = 2.0 * math.tan(wc / 2.0)\n    float epsilon = 1.0 / math.sqrt(math.pow(10.0, safe_atten / 10.0) - 1.0)\n    float asinh_inv_eps = math.log(1.0 / epsilon + math.sqrt(1.0 / (epsilon * epsilon) + 1.0))\n    float mu = asinh_inv_eps / 2.0\n    float sinh_mu = (math.exp(mu) - math.exp(-mu)) / 2.0\n    float cosh_mu = (math.exp(mu) + math.exp(-mu)) / 2.0\n    float sqrt2 = math.sqrt(2.0)\n    float sigma_p = -Wc * sinh_mu / sqrt2\n    float omega_p = Wc * cosh_mu / sqrt2\n    float omega_z = Wc / math.cos(pi / 4.0)\n    float Kp = sigma_p * sigma_p + omega_p * omega_p\n    float Kz = omega_z * omega_z\n    float DC_gain = Kz / Kp\n    float a0_z = 1.0 - 2.0 * sigma_p + Kp\n    float a1_z = 2.0 * Kp - 2.0\n    float a2_z = 1.0 + 2.0 * sigma_p + Kp\n    float b0_z = DC_gain * (1.0 + Kz)\n    float b1_z = DC_gain * (2.0 * Kz - 2.0)\n    float b2_z = DC_gain * (1.0 + Kz)\n    float B0 = b0_z / a0_z\n    float B1 = b1_z / a0_z\n    float B2 = b2_z / a0_z\n    float A1 = a1_z / a0_z\n    float A2 = a2_z / a0_z\n    float sumB = B0 + B1 + B2\n    float sumA = 1.0 + A1 + A2\n    float norm = sumA / sumB\n    B0 *= norm\n    B1 *= norm\n    B2 *= norm\n    var float filt = na\n    if bar_index < 2\n        filt := nz(src, 0.0)\n    else\n        float s0 = nz(src, 0.0)\n        float s1 = nz(src[1], s0)\n        float s2 = nz(src[2], s1)\n        float f1 = nz(filt[1], s0)\n        float f2 = nz(filt[2], f1)\n        filt := B0 * s0 + B1 * s1 + B2 * s2 - A1 * f1 - A2 * f2\n    filt\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(10, \"Length\", minval=2)\ni_attenuation = input.float(5.0, \"Stopband Attenuation (dB)\", minval=0.1, step=1.0)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ncheby2_val = cheby2(i_source, i_length, i_attenuation)\n\n// Plot\nplot(cheby2_val, \"Cheby2\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "math.cos",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "chebyshev type ii filter (cheby2)",
      "filters",
      "indicator",
      "v6",
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "math.cos",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "math.pi",
      "math.max",
      "math.tan",
      "math.sqrt",
      "math.pow",
      "math.log",
      "math.exp",
      "math.cos",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "if",
      "else"
    ]
  },
  {
    "id": "script-76",
    "type": "example",
    "category": "filters",
    "title": "Elliptic 2nd Order Filter (ELLIPTIC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Elliptic 2nd Order Filter (ELLIPTIC)\", \"ELLIPTIC\", overlay=true)\n\n//@function Calculates 2nd Order Elliptic Lowpass Filter (Rp=1dB, Rs=40dB)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/elliptic.md\n//@param src Series to calculate Elliptic filter from\n//@param length Cutoff period (related to cutoff frequency)\n//@returns Elliptic filter value\n//@optimized Uses IIR 2nd order Elliptic filter with O(1) complexity per bar\nelliptic(series float src, simple int length) =>\n    var float C_wz = 2.15499\n    var float C_sigma = -0.31323\n    var float C_omega_d = 0.90436\n    var float C_Kp_norm = 0.91598\n    var float C_k = 0.14735\n    float pi = math.pi\n    int safe_length = math.max(length, 2)\n    float Wc = math.tan(pi / safe_length)\n    if Wc < 1e-9\n        Wc := 1e-9\n    float omega_z_scaled = C_wz * Wc\n    float sigma_scaled = C_sigma * Wc\n    float Kp_scaled = C_Kp_norm * Wc * Wc\n    float a0_denom = 1.0 - 2.0 * sigma_scaled + Kp_scaled\n    if math.abs(a0_denom) < 1e-9\n        a0_denom := 1e-9\n    float norm_factor = C_Kp_norm / (C_k * C_wz * C_wz)\n    float b0 = norm_factor * C_k * (1.0 + omega_z_scaled * omega_z_scaled) / a0_denom\n    float b1 = norm_factor * C_k * (2.0 * omega_z_scaled * omega_z_scaled - 2.0) / a0_denom\n    float b2 = b0\n    float a1 = (2.0 * Kp_scaled - 2.0) / a0_denom\n    float a2 = (1.0 + 2.0 * sigma_scaled + Kp_scaled) / a0_denom\n    var float filt = na\n    if bar_index < 2\n        filt := nz(src, 0.0)\n    else\n        float s0 = nz(src, 0.0)\n        float s1 = nz(src[1], s0)\n        float s2 = nz(src[2], s1)\n        float f1 = nz(filt[1], s0)\n        float f2 = nz(filt[2], f1)\n        filt := b0 * s0 + b1 * s1 + b2 * s2 - a1 * f1 - a2 * f2\n    filt\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nelliptic_val = elliptic(i_source, i_length)\n\n// Plot\nplot(elliptic_val, \"Elliptic (Rp=1, Rs=40)\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.max",
      "math.tan",
      "math.abs",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "elliptic 2nd order filter (elliptic)",
      "filters",
      "indicator",
      "v6",
      "math.pi",
      "math.max",
      "math.tan",
      "math.abs",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "elliptic.md",
      "math.pi",
      "math.max",
      "math.tan",
      "math.abs",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-77",
    "type": "example",
    "category": "filters",
    "title": "Gaussian Filter (GAUSS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Gaussian Filter (GAUSS)\", \"GAUSS\", overlay=true)\r\n\r\n//@function Calculates Gaussian Filter using true convolution\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/gauss.md\r\n//@param src Series to calculate Gaussian filter from\r\n//@param sigma Standard deviation of the Gaussian kernel\r\n//@returns Gaussian filter value\r\n//@optimized Uses Gaussian kernel convolution with O(n) complexity per bar\r\ngauss(series float src, simple float sigma) =>\r\n    int kernel_size = 2 * math.ceil(3.0 * sigma) + 1\r\n    var array<float> kernel = array.new_float(0)\r\n    var array<float> norm_kernel = array.new_float(1, 1.0)\r\n    var int last_kernel_size = 1\r\n    if last_kernel_size != kernel_size\r\n        float center = math.floor(kernel_size / 2.0)\r\n        array.clear(kernel)\r\n        float kernel_sum = 0.0\r\n        for i = 0 to kernel_size - 1\r\n            float x = i - center\r\n            float weight = math.exp(-(x * x) / (2.0 * sigma * sigma))\r\n            array.push(kernel, weight)\r\n            kernel_sum += weight\r\n        norm_kernel := array.copy(kernel)\r\n        if kernel_sum != 0.0\r\n            float inv_sum = 1.0 / kernel_sum\r\n            for i = 0 to kernel_size - 1\r\n                array.set(norm_kernel, i, array.get(kernel, i) * inv_sum)\r\n        last_kernel_size := kernel_size\r\n    int p = math.min(bar_index + 1, kernel_size)\r\n    float sum = 0.0\r\n    float weight_sum = 0.0\r\n    for i = 0 to p - 1\r\n        float price = src[i]\r\n        if not na(price)\r\n            float w = array.get(norm_kernel, i)\r\n            sum += price * w\r\n            weight_sum += w\r\n    nz(sum / weight_sum, src)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_sigma = input.float(1.0, \"Sigma\", minval=0.1, maxval=10.0, step=0.1)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\ngauss_val = gauss(i_source, i_sigma)\r\n\r\n// Plot\r\nplot(gauss_val, \"Gaussian\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "math.ceil",
      "array.new_float",
      "math.floor",
      "array.clear",
      "math.exp",
      "array.push",
      "array.copy",
      "array.set",
      "array.get",
      "math.min",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "gaussian filter (gauss)",
      "filters",
      "indicator",
      "v6",
      "math.ceil",
      "array.new_float",
      "math.floor",
      "array.clear",
      "math.exp",
      "array.push",
      "array.copy",
      "array.set",
      "array.get",
      "math.min",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "gauss.md",
      "math.ceil",
      "array.new_float",
      "math.floor",
      "array.clear",
      "math.exp",
      "array.push",
      "array.copy",
      "array.set",
      "array.get",
      "math.min",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-78",
    "type": "example",
    "category": "filters",
    "title": "Hann FIR Filter (HANN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hann FIR Filter (HANN)\", \"HANN\", overlay=true)\n\n//@function Calculates a Finite Impulse Response (FIR) filter using Hann window coefficients\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/hann.md\n//@param src Series to calculate the Hann FIR filter from\n//@param len The lookback period (length) of the Hann window\n//@returns Hann FIR filter value\n//@optimized Uses FIR convolution with Hann window, O(n) complexity per bar\nhann(series float src, simple int len) =>\n    if len <= 0\n        runtime.error(\"Length must be greater than 0\")\n    var float[] w = array.new_float(0)\n    var float coefSum = 0.0\n    var int lastLen = 0\n    if len != lastLen or array.size(w) == 0\n        if len > 0\n            w := array.new_float(len)\n            coefSum := 0.0\n            for i = 0 to len - 1\n                float c = 0.5 * (1.0 - math.cos(2.0 * math.pi * i / (len - 1)))\n                array.set(w, i, c)\n                coefSum += c\n            if coefSum == 0.0\n                coefSum := 1.0\n        lastLen := len\n    int p = math.min(bar_index + 1, len)\n    float acc = 0.0\n    float currentWeightSum = 0.0\n    if array.size(w) > 0 and p > 0\n        for i = 0 to p - 1\n            float price = src[p - 1 - i]\n            if not na(price)\n                float weight = array.get(w, i)\n                acc += price * weight\n                currentWeightSum += weight\n    nz(currentWeightSum == 0.0 ? src : acc / currentWeightSum, src)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_len = input.int(10, \"Length\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhann_val = hann(i_source, i_len)\n\n// Plot\nplot(hann_val, \"HANN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.size",
      "math.cos",
      "math.pi",
      "array.set",
      "math.min",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hann fir filter (hann)",
      "filters",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.size",
      "math.cos",
      "math.pi",
      "array.set",
      "math.min",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hann.md",
      "runtime.error",
      "array.new_float",
      "array.size",
      "math.cos",
      "math.pi",
      "array.set",
      "math.min",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-79",
    "type": "example",
    "category": "filters",
    "title": "Hodrick-Prescott Filter (HP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hodrick-Prescott Filter (HP)\", \"HP\", overlay=false)\n\n//@function Calculates a causal approximation of the Hodrick-Prescott Filter trend component\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/hp.md\n//@param src Input series\n//@param lambda Smoothing parameter (lambda)\n//@returns HP Filter trend component series\n//@optimized Uses causal HP approximation with O(1) complexity per bar\nhp(series float src, simple float lambda) =>\n    if lambda <= 0.0\n        runtime.error(\"Lambda must be positive\")\n    float alpha = (math.sqrt(lambda) * 0.5 - 1.0) / (math.sqrt(lambda) * 0.5 + 1.0)\n    alpha := math.max(alpha, 0.0001)\n    alpha := math.min(alpha, 0.9999)\n    float price = nz(src, 0.0)\n    var float hp_trend = na\n    float prev_trend = nz(hp_trend[1], price)\n    float prev_price = nz(src[1], price)\n    hp_trend := bar_index >= 1 ? (1.0 - alpha) * price + alpha * prev_trend + 0.5 * alpha * (prev_trend - nz(hp_trend[2], prev_trend)) : price\n    hp_trend\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_lambda = input.float(677.0, \"Lambda (Smoothing)\", minval=0.1, step=10.0)\n\n// Calculation\nhp_trend_val = hp(i_source, i_lambda)\nhp_cycle_val = i_source - hp_trend_val\n\n// Plot\nplot(hp_trend_val, \"HP Trend\", color=color.yellow, linewidth=2, force_overlay=true)\nplot(hp_cycle_val, \"HP Cycle\", color=color.blue, linewidth=2, force_overlay=false)\n",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "hodrick-prescott filter (hp)",
      "filters",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "hp.md",
      "runtime.error",
      "math.sqrt",
      "math.max",
      "math.min",
      "input.source",
      "input.float",
      "color.yellow",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-80",
    "type": "example",
    "category": "filters",
    "title": "Highpass Filter (2-Pole) (HPF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Highpass Filter (2-Pole) (HPF)\", \"HPF\", overlay=true)\n\n//@function Calculates 2-Pole Highpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/hpf.md\n//@param src Series to calculate HPF from\n//@param length Cutoff period (determines alpha)\n//@returns HPF value\n//@optimized Uses 2-pole IIR highpass filter with O(1) complexity per bar\nhpf(series float src, simple int length) =>\n    int safe_length = math.max(length, 1)\n    float pi = math.pi\n    float omega = 2.0 * pi / safe_length\n    float alpha = (math.cos(omega) + math.sin(omega) - 1.0) / math.cos(omega)\n    var float hp_val_internal = 0.0\n    float hp1 = nz(hp_val_internal[1], 0.0)\n    float hp2 = nz(hp_val_internal[2], 0.0)\n    float ssrc = nz(src, src[1])\n    float src1 = nz(src[1], ssrc)\n    float src2 = nz(src[2], src1)\n    float alpha_div_2 = alpha / 2.0\n    float one_minus_alpha = 1.0 - alpha\n    hp_val_internal := (1.0 - alpha_div_2) * (1.0 - alpha_div_2) * (ssrc - 2.0 * src1 + src2) + 2.0 * one_minus_alpha * hp1 - one_minus_alpha * one_minus_alpha * hp2\n    hp_val_internal\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(40, \"Length\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhp_component = hpf(i_source, i_length)\n\n// Plot\nplot(i_source - hp_component, \"Trend Component\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "math.pi",
      "math.cos",
      "math.sin",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "highpass filter (2-pole) (hpf)",
      "filters",
      "indicator",
      "v6",
      "math.max",
      "math.pi",
      "math.cos",
      "math.sin",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hpf.md",
      "math.max",
      "math.pi",
      "math.cos",
      "math.sin",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple"
    ]
  },
  {
    "id": "script-81",
    "type": "example",
    "category": "filters",
    "title": "Kalman Filter (KF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Kalman Filter (KF)\", \"KF\", overlay=true)\n\n//@function Applies a Kalman Filter to the input series\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/kf.md\n//@param src Input series (measurement)\n//@param q Process noise covariance\n//@param r Measurement noise covariance\n//@returns Filtered series\n//@optimized Uses Kalman filter with O(1) complexity per bar\nkf(series float src, simple float q, simple float r) =>\n    if q <= 0.0 or r <= 0.0\n        runtime.error(\"Process noise covariance (q) and measurement noise covariance (r) must be positive\")\n    var float x = na\n    var float p = na\n    float measurement = nz(src, 0.0)\n    if bar_index == 0 or na(x)\n        x := measurement\n        p := 1.0\n    float x_pred = x\n    float p_pred = p + q\n    float denom = p_pred + r\n    float k_gain = denom == 0.0 ? 0.0 : p_pred / denom\n    x := x_pred + k_gain * (measurement - x_pred)\n    p := (1.0 - k_gain) * p_pred\n    x\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_q = input.float(0.01, \"Process Noise (Q)\", minval=1e-9, step=0.01)\ni_r = input.float(0.1, \"Measurement Noise (R)\", minval=1e-9, step=0.1)\n\n// Calculation\nkf_val = kf(i_source, i_q, i_r)\n\n// Plot\nplot(kf_val, \"KF\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "kalman filter (kf)",
      "filters",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "kf.md",
      "runtime.error",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-82",
    "type": "example",
    "category": "filters",
    "title": "LOESS Filter",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"LOESS Filter\", \"LOESS\", overlay=true)\n\n//@function Applies LOESS (LOcally Estimated Scatterplot Smoothing) filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/loess.md\n//@param src Input series to filter\n//@param length Window size (rounded down to nearest odd number)\n//@returns LOESS smoothed series\n//@optimized Uses locally weighted regression with O(n) complexity per bar\nloess(series float src, simple int length) =>\n    int adj_length = math.max(3, length % 2 == 0 ? length - 1 : length)\n    var array<float> weights = array.new_float(0)\n    array.clear(weights)\n    int half_window = int(adj_length / 2)\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = -half_window to half_window\n        float x = math.abs(float(i)) / float(half_window)\n        float w = math.pow(1.0 - math.pow(x, 3.0), 3.0)\n        array.push(weights, w)\n    float x_sum = 0.0\n    float xy_sum = 0.0\n    float x2_sum = 0.0\n    float w_sum = 0.0\n    for i = 0 to adj_length - 1\n        float price = src[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            float x = float(i - half_window)\n            x_sum += x * w\n            xy_sum += x * price * w\n            x2_sum += x * x * w\n            w_sum += w\n            sum += price * w\n            weight_sum += w\n    if weight_sum == 0.0\n        src\n    else\n        float x_mean = x_sum / weight_sum\n        float y_mean = sum / weight_sum\n        float slope = (xy_sum - x_mean * sum) / (x2_sum - x_mean * x_sum)\n        float intercept = (y_mean * x2_sum - x_mean * xy_sum) / (x2_sum - x_mean * x_sum)\n        intercept\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(7, \"Length\", minval=3)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nloess_val = loess(i_source, i_length)\n\n// Plot\nplot(loess_val, \"LOESS\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "array.new_float",
      "array.clear",
      "math.abs",
      "math.pow",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "loess filter",
      "filters",
      "indicator",
      "v6",
      "math.max",
      "array.new_float",
      "array.clear",
      "math.abs",
      "math.pow",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "loess.md",
      "math.max",
      "array.new_float",
      "array.clear",
      "math.abs",
      "math.pow",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-83",
    "type": "example",
    "category": "filters",
    "title": "Notch Filter (NOTCH)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Notch Filter (NOTCH)\", \"NOTCH\", overlay=true)\n\n//@function Applies a second-order IIR notch filter to remove a specific frequency component\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/notch.md\n//@param src Input series\n//@param period The period of the cycle to remove (center frequency of the notch)\n//@param bandwidth The relative bandwidth of the notch (e.g., 0.1 for 10%)\n//@returns Filtered series with the specified frequency component attenuated\n//@optimized Uses 2nd order IIR notch filter with O(1) complexity per bar\nnotch(series float src, simple int period, simple float bandwidth) =>\n    if period < 2\n        runtime.error(\"Period must be >= 2\")\n    if bandwidth <= 0.0 or bandwidth >= 1.0\n        runtime.error(\"Bandwidth must be > 0 and < 1\")\n    float omega = 2.0 * math.pi / period\n    float bw_abs = bandwidth * omega\n    float alpha_tan_arg = bw_abs / 2.0\n    alpha_tan_arg := math.max(math.min(alpha_tan_arg, math.pi * 0.499), 0.0001)\n    float tan_bw_half = math.tan(alpha_tan_arg)\n    float alpha = (1.0 - tan_bw_half) / (1.0 + tan_bw_half)\n    float beta = math.cos(omega)\n    float a1 = -2.0 * beta * alpha\n    float a2 = alpha * alpha\n    float b0 = (1.0 + alpha * alpha) / 2.0\n    float b1 = a1\n    float b2 = b0\n    var float y1 = 0.0\n    var float y2 = 0.0\n    var float x1 = 0.0\n    var float x2 = 0.0\n    float x0 = nz(src, 0.0)\n    if bar_index < 1\n        x1 := x0\n        x2 := x0\n        y1 := x0\n        y2 := x0\n    float y0 = 0.0\n    y0 := b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2\n    y2 := y1\n    y1 := y0\n    x2 := x1\n    x1 := x0\n    y0\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_period = input.int(14, \"Period to Remove\", minval=2)\ni_bandwidth = input.float(0.3, \"Relative Bandwidth\", minval=0.01, maxval=0.99, step=0.01)\n\n// Calculation\nnotch_val = notch(i_source, i_period, i_bandwidth)\n\n// Plot\nplot(notch_val, \"Notch\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.pi",
      "math.max",
      "math.min",
      "math.tan",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "notch filter (notch)",
      "filters",
      "indicator",
      "v6",
      "runtime.error",
      "math.pi",
      "math.max",
      "math.min",
      "math.tan",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "notch.md",
      "e.g",
      "runtime.error",
      "math.pi",
      "math.max",
      "math.min",
      "math.tan",
      "math.cos",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-84",
    "type": "example",
    "category": "filters",
    "title": "Savitzky-Golay Filter (SGF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Savitzky-Golay Filter (SGF)\", \"SGF\", overlay=true)\r\n\r\n//@function Applies Savitzky-Golay filter to input series\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/sgf.md\r\n//@param src Input series to filter\r\n//@param window_size Window size (rounded down to nearest odd number)\r\n//@param poly_order Polynomial order (2 or 4 recommended)\r\n//@returns Filtered series\r\n//@optimized Uses polynomial convolution with O(n) complexity per bar\r\nsgf(series float src, simple int window_size, simple int poly_order) =>\r\n    int adj_size = math.max(1, window_size % 2 == 0 ? window_size - 1 : window_size)\r\n    if poly_order >= adj_size\r\n        runtime.error(\"Polynomial order must be less than window size\")\r\n    var array<float> coeffs = array.new_float(0)\r\n    array.clear(coeffs)\r\n    int half_window = int(adj_size / 2)\r\n    float sum_denom = 0.0\r\n    if poly_order == 2\r\n        for i = -half_window to half_window\r\n            float weight = 3.0 * (3.0 * adj_size * adj_size - 7.0 - 20.0 * i * i)\r\n            array.push(coeffs, weight)\r\n            sum_denom += weight\r\n    else if poly_order == 4\r\n        for i = -half_window to half_window\r\n            float i2 = i * i\r\n            float weight = 15.0 + i2 * (-20.0 + i2 * 6.0)\r\n            array.push(coeffs, weight)\r\n            sum_denom += weight\r\n    else\r\n        for i = -half_window to half_window\r\n            float weight = 1.0 - math.abs(float(i)) / float(half_window)\r\n            array.push(coeffs, weight)\r\n            sum_denom += weight\r\n    if sum_denom != 0.0\r\n        for i = 0 to adj_size - 1\r\n            array.set(coeffs, i, array.get(coeffs, i) / sum_denom)\r\n    float sum = 0.0\r\n    float weight_sum = 0.0\r\n    for i = 0 to adj_size - 1\r\n        float price = src[i]\r\n        if not na(price)\r\n            float w = array.get(coeffs, i)\r\n            sum += price * w\r\n            weight_sum += w\r\n    nz(sum / weight_sum, src)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_window = input.int(21, \"Window Size\", minval=1, step=2)\r\ni_order = input.int(2, \"Polynomial Order\", minval=2, maxval=4, step=2)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\nsgf_val = sgf(i_source, i_window, i_order)\r\n\r\n// Plot\r\nplot(sgf_val, \"SGF\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "math.abs",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "savitzky-golay filter (sgf)",
      "filters",
      "indicator",
      "v6",
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "math.abs",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "sgf.md",
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "math.abs",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-85",
    "type": "example",
    "category": "filters",
    "title": "Supersmooth Filter (SSF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n// Indicator algorithm (C) 2004-2024 John F. Ehlers\n//@version=6\nindicator(\"Supersmooth Filter (SSF)\", \"SSF\", overlay=true)\n\n//@function Calculates Supersmooth Lowpass Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/ssf.md\n//@param source Series to calculate SSF from\n//@param length Number of bars used in the calculation\n//@returns SSF value with optimized smoothing\n//@optimized Uses 2-pole IIR Butterworth-style filter with O(1) complexity per bar\nssf(series float src, simple int length) =>\n    var float SQRT2_PI = math.sqrt(2.0) * math.pi\n    var float ssf_internal = 0.0\n    var float c1 = 0.0\n    var float c2 = 0.0\n    var float c3 = 0.0\n    var int prev_length = 0\n    if prev_length != length\n        float arg = SQRT2_PI / float(length)\n        float exp_arg = math.exp(-arg)\n        c2 := 2.0 * exp_arg * math.cos(arg)\n        c3 := -exp_arg * exp_arg\n        c1 := 1.0 - c2 - c3\n        prev_length := length\n    float ssrc = nz(src, src[1])\n    float src1 = nz(src[1], ssrc)\n    float src2 = nz(src[2], src1)\n    ssf_internal := c1 * ssrc + c2 * nz(ssf_internal[1], src1) + c3 * nz(ssf_internal[2], src2)\n    ssf_internal\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nssf_val = ssf(i_source, i_length)\n\n// Plot\nplot(ssf_val, \"SSF\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "supersmooth filter (ssf)",
      "filters",
      "indicator",
      "v6",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "ssf.md",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-86",
    "type": "example",
    "category": "filters",
    "title": "Ultrasmooth Filter (USF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ultrasmooth Filter (USF)\", \"USF\", overlay=true)\n\n//@function Calculates Ultrasmooth Filter\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/usf.md\n//@param src Series to calculate USF from\n//@param length Number of bars used in the calculation\n//@returns USF value with optimized smoothing\n//@optimized Uses 2-pole IIR filter with momentum enhancement, O(1) complexity per bar\nusf(series float src, simple int length) =>\n    var float SQRT2_PI = math.sqrt(2.0) * math.pi\n    var float usf_val = na\n    var float c1 = 0.0\n    var float c2 = 0.0\n    var float c3 = 0.0\n    var int prev_length = 0\n    if prev_length != length\n        float arg = SQRT2_PI / float(length)\n        float exp_arg = math.exp(-arg)\n        c2 := 2.0 * exp_arg * math.cos(arg)\n        c3 := -exp_arg * exp_arg\n        c1 := (1.0 + c2 - c3) / 4.0\n        prev_length := length\n    float ssrc = nz(src, src[1])\n    float src1 = nz(src[1], ssrc)\n    float src2 = nz(src[2], src1)\n    float us1 = nz(usf_val[1], src1)\n    float us2 = nz(usf_val[2], src2)\n    usf_val := (1.0 - c1) * ssrc + (2.0 * c1 - c2) * src1 - (c1 + c3) * src2 + c2 * us1 + c3 * us2\n    usf_val\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nfilt = usf(i_source, i_length)\n\n// Plot\nplot(filt, \"UltraSmooth\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ultrasmooth filter (usf)",
      "filters",
      "indicator",
      "v6",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "usf.md",
      "math.sqrt",
      "math.pi",
      "math.exp",
      "math.cos",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-87",
    "type": "example",
    "category": "filters",
    "title": "Wiener Filter (WIENER)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Wiener Filter (WIENER)\", \"WIENER\", overlay=true)\r\n\r\n//@function Calculates Wiener Filter that minimizes mean square error\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/filters/wiener.md\r\n//@param src Series to filter\r\n//@param length Window size for noise estimation\r\n//@param smooth_len Length for signal power estimation\r\n//@returns Wiener filtered value\r\n//@optimized Uses adaptive noise estimation with O(n) complexity per bar\r\nwiener(series float src, simple int length, simple int smooth_len = 10) =>\r\n    var array<float> diffs = array.new_float(0)\r\n    array.clear(diffs)\r\n    for i = 0 to length - 2\r\n        float diff = src[i] - src[i + 1]\r\n        array.push(diffs, diff * diff)\r\n    float noise_var = 0.0\r\n    float sum_diffs = array.sum(diffs)\r\n    int num_diffs = array.size(diffs)\r\n    if num_diffs > 0\r\n        noise_var := sum_diffs / (2.0 * float(num_diffs))\r\n    float signal_plus_noise = ta.sma(math.pow(src - ta.sma(src, smooth_len), 2.0), smooth_len)\r\n    float signal_var = math.max(signal_plus_noise - noise_var, 0.0)\r\n    float k = signal_var / (signal_var + noise_var)\r\n    float mean = ta.sma(src, smooth_len)\r\n    mean + k * (src - mean)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_length = input.int(20, \"Length\", minval=5, maxval=500)\r\ni_smooth = input.int(10, \"Smoothing\", minval=2, maxval=100)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\nwiener_val = wiener(i_source, i_length, i_smooth)\r\n\r\n// Plot\r\nplot(wiener_val, \"Wiener\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "array.new_float",
      "array.clear",
      "array.push",
      "array.sum",
      "array.size",
      "ta.sma",
      "math.pow",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "wiener filter (wiener)",
      "filters",
      "indicator",
      "v6",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.sum",
      "array.size",
      "ta.sma",
      "math.pow",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "wiener.md",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.sum",
      "array.size",
      "ta.sma",
      "math.pow",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-88",
    "type": "example",
    "category": "forecasts",
    "title": "Autoregressive FIR Moving Average (AFIRMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Autoregressive FIR Moving Average (AFIRMA)\", \"AFIRMA\", overlay=true)\n\n//@function Calculates AFIRMA using various windowing functions with optional least squares cubic spline fitting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/forecasts/afirma.md\n//@param source Series to calculate AFIRMA from\n//@param period Lookback period - window size\n//@param windowType Window function type (1:Hanning, 2:Hamming, 3:Blackman, 4:Blackman-Harris)\n//@param leastSquares Apply least squares cubic polynomial fitting for autoregressive prediction\n//@returns AFIRMA value, calculates from first bar using available data\n//@optimized Uses windowing functions with O(n) complexity; least squares adds O(n) for polynomial fitting\nafirma(series float src, simple int period, simple int windowType=4, simple bool leastSquares=false) =>\n    float result = src\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if windowType < 1 or windowType > 4\n        runtime.error(\"WindowType should be in range [1-4]\")\n    int p = math.min(bar_index + 1, period)\n\n    if p > 1\n        var array<float> coefs = array.new_float(1, 0.0)\n        var int prevPeriod = 0\n        var int prevWindowType = -1\n        if p != prevPeriod or windowType != prevWindowType\n            coefs := array.new_float(p, 0.0)\n            float a0 = 0.35875\n            float a1 = -0.48829\n            float a2 = 0.14128\n            float a3 = -0.01168\n            if windowType == 1\n                a0 := 0.50\n                a1 := -0.50\n            else if windowType == 2\n                a0 := 0.54\n                a1 := -0.46\n            else if windowType == 3\n                a0 := 0.42\n                a1 := -0.50\n                a2 := 0.08\n            float TWO_PI = 6.28318530718\n            float twoPiDivP = TWO_PI / p\n            for k = 0 to p - 1\n                float kTwoPiDivP = k * twoPiDivP\n                float coef = a0 + a1 * math.cos(kTwoPiDivP)\n                if a2 != 0.0\n                    coef += a2 * math.cos(2.0 * kTwoPiDivP)\n                if a3 != 0.0\n                    coef += a3 * math.cos(3.0 * kTwoPiDivP)\n                array.set(coefs, k, coef)\n            prevPeriod := p\n            prevWindowType := windowType\n        float sum = 0.0\n        float weightSum = 0.0\n        int validCount = 0\n        for i = 0 to p - 1\n            float price = src[i]\n            if not na(price)\n                float coef = array.get(coefs, i)\n                sum += price * coef\n                weightSum += coef\n                validCount += 1\n        result := validCount > 0 and weightSum > 0 ? sum / weightSum : src\n\n        if leastSquares and p > 2\n            int n = math.min(math.floor((p - 1) / 2), 50)\n            if n >= 2\n                var float sx = 0.0\n                var float sx2 = 0.0\n                var int prevN = 0\n\n                if n != prevN\n                    sx := 0.0\n   ",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "array.set",
      "array.get",
      "math.floor",
      "math.abs",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "autoregressive fir moving average (afirma)",
      "forecasts",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "array.set",
      "array.get",
      "math.floor",
      "math.abs",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "afirma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "array.set",
      "array.get",
      "math.floor",
      "math.abs",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "method",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-89",
    "type": "example",
    "category": "forecasts",
    "title": "Multilayer Perceptron Predictor",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Multilayer Perceptron Predictor\", \"MLP\", overlay=true)\n\nvar int offset = 5\nvar int numInputs = 6\nvar array<int> nodesPerLayer = array.from(8, 4, 1)\nvar float learning_rate = 0.0025\nvar float learning_rate_decay = 0.000015\nvar float max_gradient = 5.0\nvar float error_k = 0.7\nvar int algoType = 4\nvar bool tanh = true\n\ntype matrices\n    matrix<float> l0 = na\n    matrix<float> l1 = na\n    matrix<float> l2 = na\n    matrix<float> l3 = na\n    matrix<float> l4 = na\n    matrix<float> l5 = na\n    matrix<float> l6 = na\n    matrix<float> l7 = na\n    matrix<float> l8 = na\n    matrix<float> l9 = na\nvar matrices w = na\nvar matrices b = na\n\n// ---------- Main loop ----------\n\n//@function Compresses an unbounded value to the range [-1, 1] using tanh or scaled sigmoid\n//@param x The input value (can be any real number)\n//@param useTanh Whether to use tanh (true) or scaled sigmoid (false)\n//@returns A compressed value in range [-1, 1]\ncompressToRange(float x, bool useTanh = true) =>\n    if x >= 20.0\n        1.0\n    else if x <= -20.0\n        -1.0\n    else\n        if useTanh\n            ex = math.exp(x)\n            emx = math.exp(-x)\n            (ex - emx) / (ex + emx)\n        else\n            sigmoid = 1.0 / (1.0 + math.exp(-x))\n            2.0 * sigmoid - 1.0\n\n//@function Calculates and normalizes input features in one step\n//@param off Offset value\n//@returns Array of normalized feature values\ncalculateInputs(int off) =>\n    norm_arr = array.new_float(0)\n    float f0 = ta.hma(close[off],20) / ta.sma(ta.hma(close[off],20), 100) - 1\n    array.push(norm_arr, compressToRange(f0, tanh))\n\n    if numInputs > 1\n        float f1 = ta.rsi(close[off], 14) / 100\n        array.push(norm_arr, compressToRange(f1, tanh))\n\n    if numInputs > 2\n        float f2 = ta.atr(14)[off] / ta.sma(ta.atr(14), 14)[off]\n        array.push(norm_arr, compressToRange(f2, tanh))\n\n    if numInputs > 3\n        float f3 = close[off] / ta.sma(close, 20)[off]\n        array.push(norm_arr, compressToRange(f3, tanh))\n\n    if numInputs > 4\n        float f4 = ta.mom(close[off], 10) / close[off]\n        array.push(norm_arr, compressToRange(f4, tanh))\n\n    if numInputs > 5\n        float f5 = ta.ema(close[off], 5) / ta.ema(close[off], 20) - 1\n        array.push(norm_arr, compressToRange(f5, tanh))\n\n    if numInputs > 6\n        float f6 = ta.bbw(close[off], 20, 2) / 2\n        array.push(norm_arr, compressToRange(f6, tanh))\n    norm_arr\n\n//@function Converts price format to return format\n//@param reference_price The reference price to compare against\n//@param new_price The current price value\n//@param algo_type Algorithm type: 1=absolute change, 2=return ratio, 3=percentage change, 4=log return\n//@returns The price return format\ntransform(float reference_price, float new_price, int algo_type) =>\n    if na(new_price) or na(reference_price) or na(algo_type)\n        na\n    else if reference_price <= 0 and (algo_type > 1)\n        na\n    else if algo_ty",
    "functions_used": [
      "array.from",
      "math.exp",
      "array.new_float",
      "ta.hma",
      "ta.sma",
      "array.push",
      "ta.rsi",
      "ta.atr",
      "ta.mom",
      "ta.ema",
      "ta.bbw",
      "math.log",
      "math.max",
      "math.min",
      "math.abs",
      "math.sign",
      "matrix.new",
      "math.sqrt",
      "math.sin",
      "matrix.set",
      "array.size",
      "array.get",
      "matrix.rows",
      "matrix.columns",
      "matrix.get",
      "matrix.copy",
      "matrix.mult",
      "str.tostring",
      "color.green",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "multilayer perceptron predictor",
      "forecasts",
      "indicator",
      "v6",
      "array.from",
      "math.exp",
      "array.new_float",
      "ta.hma",
      "ta.sma",
      "array.push",
      "ta.rsi",
      "ta.atr",
      "ta.mom",
      "ta.ema",
      "ta.bbw",
      "math.log",
      "math.max",
      "math.min",
      "math.abs",
      "math.sign",
      "matrix.new",
      "math.sqrt",
      "math.sin",
      "matrix.set",
      "array.size",
      "array.get",
      "matrix.rows",
      "matrix.columns",
      "matrix.get",
      "matrix.copy",
      "matrix.mult",
      "str.tostring",
      "color.green",
      "color.yellow",
      "plot",
      "array.from",
      "math.exp",
      "array.new_float",
      "ta.hma",
      "ta.sma",
      "array.push",
      "ta.rsi",
      "ta.atr",
      "ta.mom",
      "ta.ema",
      "ta.bbw",
      "math.log",
      "math.max",
      "math.min",
      "math.abs",
      "math.sign",
      "matrix.new",
      "math.sqrt",
      "math.sin",
      "matrix.set",
      "matrices.new",
      "array.size",
      "array.get",
      "new_w.l",
      "new_b.l",
      "matrix.rows",
      "matrix.columns",
      "matrix.get",
      "matrices_obj.l",
      "matrix.copy",
      "matrix.mult",
      "barstate.isfirst",
      "barstate.isrealtime",
      "label.new",
      "str.tostring",
      "color.green",
      "label.style_label_down",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "const",
      "method",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-90",
    "type": "example",
    "category": "forecasts",
    "title": "Time Series Forecast",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Time Series Forecast\", \"TSF\", overlay=true)\n\n//@function Time Series Forecast - linear regression extrapolated N periods forward\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/forecasts/tsf.md\n//@param source Price data to analyze\n//@param period Number of bars for linear regression calculation\n//@param forecast Number of periods to forecast ahead (default 1)\n//@returns Forecasted value N periods ahead\n//@optimized O(1) complexity using incremental sumXY maintenance\ntsf(series float source, simple int period, simple int forecast = 1) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if period > 5000\n        runtime.error(\"Period exceeds maximum of 5000\")\n    if forecast <= 0\n        runtime.error(\"Forecast must be greater than 0\")\n    \n    var int count = 0\n    var int head = 0\n    var float sumY = 0.0\n    var float sumXY = 0.0\n    var array<float> buffer = array.new_float(period, na)\n    \n    if na(source)\n        na\n    else\n        float oldest = array.get(buffer, head)\n        if not na(oldest)\n            sumY -= oldest\n            sumXY -= sumY\n            sumXY += (period - 1) * source\n        else\n            sumXY += count * source\n            count += 1\n        \n        sumY += source\n        array.set(buffer, head, source)\n        head := (head + 1) % period\n        \n        if count < period\n            na\n        else\n            float sumX = period * (period - 1) / 2\n            float sumX2 = period * (period - 1) * (2 * period - 1) / 6\n            float denomX = period * sumX2 - sumX * sumX\n            \n            float slope = (period * sumXY - sumX * sumY) / denomX\n            float intercept = (sumY - slope * sumX) / period\n            float result = intercept + slope * (period - 1 + forecast - 1)\n            \n            result\n\n// ---------- Main loop ----------\n\ni_period = input.int(14, \"Period\", minval=1, maxval=5000)\ni_forecast = input.int(1, \"Forecast Periods\", minval=1, maxval=100)\ni_source = input.source(close, \"Source\")\n\nresult = tsf(i_source, i_period, i_forecast)\n\nplot(result, \"TSF\", color=color.yellow, linewidth=2)\nplot(i_source, \"Source\", color=color.gray, linewidth=1)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot"
    ],
    "keywords": [
      "time series forecast",
      "forecasts",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot",
      "github.com",
      "tsf.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-91",
    "type": "example",
    "category": "momentum",
    "title": "Absolute Price Oscillator (APO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Absolute Price Oscillator (APO)\", \"APO\", overlay=false)\n\n//@function Calculates Absolute Price Oscillator using compensated EMAs\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/apo.md\n//@param src Source series to calculate APO for\n//@param fast_len Fast EMA period\n//@param slow_len Slow EMA period\n//@returns APO value (difference between fast and slow EMAs)\n//@optimized Uses embedded EMA with unified warmup compensation for accuracy from bar 1\napo(series float src, simple int fast_len, simple int slow_len) =>\n    if fast_len <= 0 or slow_len <= 0\n        runtime.error(\"Lengths must be greater than 0\")\n    if fast_len >= slow_len\n        runtime.error(\"Fast length must be less than slow length\")\n    float alpha_fast = 2.0 / (fast_len + 1)\n    float beta_fast = 1.0 - alpha_fast\n    float alpha_slow = 2.0 / (slow_len + 1)\n    float beta_slow = 1.0 - alpha_slow\n    var bool warmup = true\n    var float e_fast = 1.0\n    var float e_slow = 1.0\n    var float ema_fast = 0.0\n    var float ema_slow = 0.0\n    var float result_fast = src\n    var float result_slow = src\n    ema_fast := alpha_fast * (src - ema_fast) + ema_fast\n    ema_slow := alpha_slow * (src - ema_slow) + ema_slow\n    if warmup\n        e_fast *= beta_fast\n        e_slow *= beta_slow\n        float c_fast = 1.0 / (1.0 - e_fast)\n        float c_slow = 1.0 / (1.0 - e_slow)\n        result_fast := c_fast * ema_fast\n        result_slow := c_slow * ema_slow\n        warmup := e_fast > 1e-10 or e_slow > 1e-10\n    else\n        result_fast := ema_fast\n        result_slow := ema_slow\n    result_fast - result_slow\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_fast_len = input.int(12, \"Fast Length\", minval=1)\ni_slow_len = input.int(26, \"Slow Length\", minval=1)\n\n// Calculation\napo_value = apo(i_source, i_fast_len, i_slow_len)\n\n// Plot\nplot(apo_value, \"APO\", color=color.yellow, linewidth=2)\nhline(0, \"Zero\", color=color.gray)\n",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "absolute price oscillator (apo)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "apo.md",
      "runtime.error",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-92",
    "type": "example",
    "category": "momentum",
    "title": "Balance of Power (BOP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Balance of Power (BOP)\", \"BOP\", overlay=false)\r\n\r\n//@function Calculates Balance of Power with optional smoothing\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/bop.md\r\n//@param length Smoothing period (0 for no smoothing)\r\n//@returns BOP value measuring buying/selling pressure\r\nbop(simple int length) =>\r\n    if length < 0\r\n        runtime.error(\"Length must be non-negative\")\r\n    float rawBop = high == low ? 0.0 : (close - open) / (high - low)\r\n    if length == 0\r\n        rawBop\r\n    else\r\n        float alpha = 2.0 / (length + 1.0)\r\n        var float smoothBop = na\r\n        var float e = 1.0\r\n        var bool warmupComplete = false\r\n        var float result = na\r\n        if na(smoothBop)\r\n            smoothBop := rawBop, result := rawBop\r\n        else\r\n            smoothBop := alpha * (rawBop - smoothBop) + smoothBop\r\n            if not warmupComplete\r\n                e *= (1.0 - alpha)\r\n                float c = e > 1e-10 ? 1.0 / (1.0 - e) : 1.0\r\n                result := smoothBop * c\r\n                if e <= 1e-10\r\n                    warmupComplete := true\r\n            else\r\n                result := smoothBop\r\n        result\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_smooth = input.int(14, \"Smoothing Length\", minval=0, tooltip=\"0 for no smoothing\")\r\n\r\n// Calculation\r\nbop_value = bop(i_smooth)\r\n\r\n// Plot\r\nplot(bop_value, \"BOP\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "balance of power (bop)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "bop.md",
      "runtime.error",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-93",
    "type": "example",
    "category": "momentum",
    "title": "Commodity Channel Index (CCI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Commodity Channel Index (CCI)\", \"CCI\", overlay=false)\r\n\r\n//@function Calculates Commodity Channel Index using circular buffer for efficiency\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/cci.md\r\n//@param length Lookback period for calculations\r\n//@returns CCI value measuring price deviation from its moving average\r\ncci(simple int length) =>\r\n    if length <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    float tp = (high + low + close) / 3.0\r\n    var int p = math.max(1, length)\r\n    var array<float> buffer = array.new_float(p, na)\r\n    var int head = 0, var float sum = 0.0, var int count = 0\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum -= oldest\r\n        count -= 1\r\n    if not na(tp)\r\n        sum += tp\r\n        count += 1\r\n    array.set(buffer, head, tp)\r\n    head := (head + 1) % p\r\n    float sma = count > 0 ? sum / count : tp\r\n    float dev_sum = 0.0\r\n    int dev_count = 0\r\n    for i = 0 to p - 1\r\n        float val = array.get(buffer, i)\r\n        if not na(val)\r\n            dev_sum += math.abs(val - sma)\r\n            dev_count += 1\r\n    float mean_dev = dev_count > 0 ? dev_sum / dev_count : 0.0\r\n    mean_dev > 0.0 ? (tp - sma) / (0.015 * mean_dev) : 0.0\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_length = input.int(20, \"Length\", minval=1)\r\n\r\n// Calculation\r\ncci_value = cci(i_length)\r\n\r\n// Plot\r\nplot(cci_value, \"CCI\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "commodity channel index (cci)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "cci.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-94",
    "type": "example",
    "category": "momentum",
    "title": "Chande Momentum Oscillator (CMO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Chande Momentum Oscillator (CMO)\", \"CMO\", overlay=false)\r\n\r\n//@function Calculates Chande Momentum Oscillator using circular buffer for efficiency\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/cmo.md\r\n//@param src Source series to calculate CMO for\r\n//@param len Lookback period for calculations\r\n//@returns CMO value measuring momentum strength and direction\r\ncmo(series float src, simple int len) =>\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    var float sum_up = 0.0, var float sum_down = 0.0\r\n    var array<float> up_buffer = array.new_float(len, na)\r\n    var array<float> down_buffer = array.new_float(len, na)\r\n    var int head = 0\r\n    float diff = src - src[1]\r\n    float up = diff > 0 ? diff : 0.0\r\n    float down = diff < 0 ? -diff : 0.0\r\n    float old_up = array.get(up_buffer, head)\r\n    float old_down = array.get(down_buffer, head)\r\n    if not na(old_up)\r\n        sum_up -= old_up\r\n        sum_down -= old_down\r\n    array.set(up_buffer, head, up)\r\n    array.set(down_buffer, head, down)\r\n    sum_up += up\r\n    sum_down += down\r\n    head := (head + 1) % len\r\n    float denom = sum_up + sum_down\r\n    denom != 0.0 ? 100 * (sum_up - sum_down) / denom : 0.0\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_length = input.int(14, \"Length\", minval=1)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\ncmo_value = cmo(i_source, i_length)\r\n\r\n// Plot\r\nplot(cmo_value, \"CMO\", color=color.yellow, linewidth=2)",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "chande momentum oscillator (cmo)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "cmo.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-95",
    "type": "example",
    "category": "momentum",
    "title": "Moving Average Convergence Divergence (MACD)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Moving Average Convergence Divergence (MACD)\", \"MACD\", overlay=false)\n\n//@function Calculates MACD with fast and slow EMAs and signal line\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/macd.md\n//@param src Source series to calculate MACD from\n//@param fast_length Period for fast EMA\n//@param slow_length Period for slow EMA\n//@param signal_length Period for signal line EMA\n//@returns Tuple [macd, signal, histogram] values\n//@optimized for performance and dirty data with embedded EMA calculations\nmacd(series float src, simple int fast_length, simple int slow_length, simple int signal_length) =>\n    if fast_length <= 0 or slow_length <= 0 or signal_length <= 0\n        runtime.error(\"All periods must be greater than 0\")\n    if fast_length >= slow_length\n        runtime.error(\"Fast length must be less than slow length\")\n    float alpha_fast = 2.0 / (fast_length + 1)\n    float alpha_slow = 2.0 / (slow_length + 1)\n    float alpha_signal = 2.0 / (signal_length + 1)\n    float beta_fast = 1.0 - alpha_fast\n    float beta_slow = 1.0 - alpha_slow\n    float beta_signal = 1.0 - alpha_signal\n    var bool warmup = true\n    var float e_fast = 1.0\n    var float e_slow = 1.0\n    var float e_signal = 1.0\n    var float ema_fast = 0.0\n    var float ema_slow = 0.0\n    var float ema_signal = 0.0\n    var float result_fast = src\n    var float result_slow = src\n    var float result_signal = 0.0\n    ema_fast := alpha_fast * (src - ema_fast) + ema_fast\n    ema_slow := alpha_slow * (src - ema_slow) + ema_slow\n    if warmup\n        e_fast *= beta_fast\n        e_slow *= beta_slow\n        e_signal *= beta_signal\n        float c_fast = 1.0 / (1.0 - e_fast)\n        float c_slow = 1.0 / (1.0 - e_slow)\n        float c_signal = 1.0 / (1.0 - e_signal)\n        result_fast := c_fast * ema_fast\n        result_slow := c_slow * ema_slow\n        float macd_line = result_fast - result_slow\n        ema_signal := alpha_signal * (macd_line - ema_signal) + ema_signal\n        result_signal := c_signal * ema_signal\n        warmup := e_fast > 1e-10 or e_slow > 1e-10 or e_signal > 1e-10\n    else\n        result_fast := ema_fast\n        result_slow := ema_slow\n        float macd_line = result_fast - result_slow\n        ema_signal := alpha_signal * (macd_line - ema_signal) + ema_signal\n        result_signal := ema_signal\n    float macd_line = result_fast - result_slow\n    float histogram = macd_line - result_signal\n    [macd_line, result_signal, histogram]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_fast = input.int(12, \"Fast Length\", minval=1)\ni_slow = input.int(26, \"Slow Length\", minval=2)\ni_signal = input.int(9, \"Signal Length\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\n[macd_line, signal_line, histogram] = macd(i_source, i_fast, i_slow, i_signal)\n\n// Plot\nhline(0, \"Zero Line\", color=color.gray)\nplot(histogram, \"Histogram\", style=plot.style_columns, color=histogram >= 0 ? (hist",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.gray",
      "color.green",
      "color.red",
      "color.blue",
      "plot",
      "hline"
    ],
    "keywords": [
      "moving average convergence divergence (macd)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.gray",
      "color.green",
      "color.red",
      "color.blue",
      "plot",
      "hline",
      "github.com",
      "macd.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.gray",
      "plot.style_columns",
      "color.green",
      "color.red",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-96",
    "type": "example",
    "category": "momentum",
    "title": "Momentum (MOM)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Momentum (MOM)\", \"MOM\", overlay=false)\r\n\r\n//@function Calculates price momentum over specified period\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/mom.md\r\n//@param src Source series to calculate momentum for\r\n//@param len Lookback period for momentum calculation\r\n//@returns Momentum value measuring rate of price change\r\nmom(series float src, simple int len) =>\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    float result = 0.0\r\n    if not na(src) and not na(src[len])\r\n        result := src - src[len]\r\n    result\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_length = input.int(10, \"Length\", minval=1)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\nmom_value = mom(i_source, i_length)\r\n\r\n// Plot\r\nplot(mom_value, \"MOM\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "momentum (mom)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "mom.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-97",
    "type": "example",
    "category": "momentum",
    "title": "Price Momentum Oscillator (PMO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Price Momentum Oscillator (PMO)\", \"PMO\", overlay=false)\r\n\r\n//@function Calculates Price Momentum Oscillator using double-smoothed ROC\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/pmo.md\r\n//@param src Source series to calculate PMO for\r\n//@param roc_len Lookback period for ROC calculation\r\n//@param smooth1_len First smoothing period\r\n//@param smooth2_len Second smoothing period\r\n//@returns PMO value measuring smoothed momentum\r\npmo(series float src, simple int roc_len, simple int smooth1_len=20, simple int smooth2_len=10)=>\r\n    if roc_len<=0 or smooth1_len<=0 or smooth2_len<=0\r\n        runtime.error(\"Lengths must be greater than 0\")\r\n    float roc=100*(src-src[math.min(roc_len, bar_index)])/src[math.min(roc_len,bar_index)]\r\n    float alpha1=2/(smooth1_len+1)\r\n    var float smooth1=na\r\n    smooth1:=na(smooth1)?roc:smooth1*(1-alpha1)+roc*alpha1\r\n    float alpha2=2/(smooth2_len+1)\r\n    var float smooth2=na\r\n    smooth2:=na(smooth2)?smooth1:smooth2*(1-alpha2)+smooth1*alpha2\r\n    smooth2\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_roc_len = input.int(35, \"ROC Length\", minval=1)\r\ni_smooth1_len = input.int(20, \"First Smoothing Length\", minval=1)\r\ni_smooth2_len = input.int(10, \"Second Smoothing Length\", minval=1)\r\ni_signal_len = input.int(10, \"Signal Line Length\", minval=1)\r\n\r\n// Calculation\r\npmo_value = pmo(i_source, i_roc_len, i_smooth1_len, i_smooth2_len)\r\nfloat alpha_signal = 2.0 / (i_signal_len + 1)\r\nvar float signal_line = na\r\nsignal_line := na(signal_line) ? pmo_value : signal_line * (1.0 - alpha_signal) + pmo_value * alpha_signal\r\n\r\n// Plot\r\nplot(pmo_value, \"PMO\", color=color.blue, linewidth=2)\r\nplot(signal_line, \"Signal\", color=color.red, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "plot"
    ],
    "keywords": [
      "price momentum oscillator (pmo)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "plot",
      "github.com",
      "pmo.md",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-98",
    "type": "example",
    "category": "momentum",
    "title": "Percentage Price Oscillator (PPO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Percentage Price Oscillator (PPO)\", \"PPO\", overlay=false)\r\n\r\n//@function Calculates Percentage Price Oscillator using compensated EMAs\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/ppo.md\r\n//@param src Source series to calculate PPO for\r\n//@param fast_len Fast EMA period\r\n//@param slow_len Slow EMA period\r\n//@param signal_len Signal line period\r\n//@returns Tuple containing PPO line and signal line values\r\nppo(series float src, simple int fast_len, simple int slow_len, simple int signal_len)=>\r\n    if fast_len<=0 or slow_len<=0 or signal_len<=0\r\n        runtime.error(\"Lengths must be greater than 0\")\r\n    if fast_len>=slow_len\r\n        runtime.error(\"Fast length must be less than slow length\")\r\n    float alpha_fast = 2.0/math.max(fast_len,1)\r\n    var float fast_ema = na, var float fast_result = na\r\n    var float fast_e = 1.0, var bool fast_warmup = true\r\n    float alpha_slow = 2.0/math.max(slow_len,1)\r\n    var float slow_ema = na, var float slow_result = na\r\n    var float slow_e = 1.0, var bool slow_warmup = true\r\n    float alpha_signal = 2.0/math.max(signal_len,1)\r\n    var float signal_ema = na, var float signal_result = na\r\n    var float signal_e = 1.0, var bool signal_warmup = true\r\n    if not na(src)\r\n        if na(fast_ema)\r\n            fast_ema := 0.0\r\n            fast_result := src\r\n        else\r\n            fast_ema := alpha_fast*(src-fast_ema)+fast_ema\r\n            if fast_warmup\r\n                fast_e *= (1-alpha_fast)\r\n                float fast_c = 1.0/(1.0-fast_e)\r\n                fast_result := fast_c*fast_ema\r\n                if fast_e<=1e-10\r\n                    fast_warmup := false\r\n            else\r\n                fast_result := fast_ema\r\n        if na(slow_ema)\r\n            slow_ema := 0.0\r\n            slow_result := src\r\n        else\r\n            slow_ema := alpha_slow*(src-slow_ema)+slow_ema\r\n            if slow_warmup\r\n                slow_e *= (1-alpha_slow)\r\n                float slow_c = 1.0/(1.0-slow_e)\r\n                slow_result := slow_c*slow_ema\r\n                if slow_e<=1e-10\r\n                    slow_warmup := false\r\n            else\r\n                slow_result := slow_ema\r\n    float ppo_line = 100 * (fast_result - slow_result) / slow_result\r\n    if not na(ppo_line)\r\n        if na(signal_ema)\r\n            signal_ema := 0.0\r\n            signal_result := ppo_line\r\n        else\r\n            signal_ema := alpha_signal*(ppo_line-signal_ema)+signal_ema\r\n            if signal_warmup\r\n                signal_e *= (1-alpha_signal)\r\n                float signal_c = 1.0/(1.0-signal_e)\r\n                signal_result := signal_c*signal_ema\r\n                if signal_e<=1e-10\r\n                    signal_warmup := false\r\n            else\r\n                signal_result := signal_ema\r\n    float hist = ppo_line - signal_result\r\n    [ppo_line, signal_result, hist]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.",
    "functions_used": [
      "runtime.error",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.gray",
      "plot"
    ],
    "keywords": [
      "percentage price oscillator (ppo)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.gray",
      "plot",
      "github.com",
      "ppo.md",
      "runtime.error",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "color.gray",
      "plot.style_histogram",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-99",
    "type": "example",
    "category": "momentum",
    "title": "Price Relative Strength (PRS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Price Relative Strength (PRS)\", \"PRS\", overlay=false)\r\n\r\n//@function Calculates Price Relative Strength comparing two assets\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/prs.md\r\n//@param base Base asset price series\r\n//@param comp Compare asset price series\r\n//@param smooth_len Smoothing period for ratio\r\n//@returns Tuple containing raw ratio and smoothed ratio\r\nprs(series float base, series float comp, simple int smooth_len=1)=>\r\n    if smooth_len<=0\r\n        runtime.error(\"Smoothing length must be greater than 0\")\r\n    float ratio = na\r\n    if not na(base) and not na(comp) and comp != 0\r\n        ratio := base/comp\r\n    float alpha = 2.0/math.max(smooth_len,1)\r\n    var float ema = na, var float result = na, var float e = 1.0, var bool warmup = true\r\n    if not na(ratio)\r\n        if na(ema)\r\n            ema := 0\r\n            result := ratio\r\n        else\r\n            ema := alpha*(ratio-ema)+ema\r\n            if warmup\r\n                e *= (1-alpha)\r\n                float c = 1.0/(1.0-e)\r\n                result := c*ema\r\n                if e<=1e-10\r\n                    warmup := false\r\n            else\r\n                result := ema\r\n    [ratio, result]\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_base = input.source(close, \"Base Asset\")\r\ni_comp = input.symbol(\"SPY\", \"Compare Symbol\")\r\ni_smooth = input.int(1, \"Smoothing Length\", minval=1)\r\ni_norm = input.bool(false, \"Normalize to 100\")\r\ni_log = input.bool(false, \"Logarithmic Scale\")\r\n\r\n// Get comparison data\r\nfloat comp_close = request.security(i_comp, timeframe.period, close, barmerge.gaps_off, barmerge.lookahead_off)\r\n\r\n// Calculate PRS\r\n[raw_ratio, smooth_ratio] = prs(i_base, comp_close, i_smooth)\r\n\r\n// Apply optional normalization\r\nif i_norm\r\n    raw_ratio := raw_ratio/raw_ratio[1] * 100\r\n    smooth_ratio := smooth_ratio/smooth_ratio[1] * 100\r\n\r\n// Apply optional log scale\r\nif i_log\r\n    raw_ratio := math.log(raw_ratio)\r\n    smooth_ratio := math.log(smooth_ratio)\r\n\r\n// Plot\r\nplot(raw_ratio, \"Raw Ratio\", color=color.yellow, linewidth=2)\r\nplot(smooth_ratio, \"Smoothed\", color=color.blue, linewidth=2, display=i_smooth>1?display.all:display.none)\r\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "input.source",
      "input.symbol",
      "input.int",
      "input.bool",
      "request.security",
      "timeframe.period",
      "math.log",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "price relative strength (prs)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "input.source",
      "input.symbol",
      "input.int",
      "input.bool",
      "request.security",
      "timeframe.period",
      "math.log",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "prs.md",
      "runtime.error",
      "math.max",
      "input.source",
      "input.symbol",
      "input.int",
      "input.bool",
      "request.security",
      "timeframe.period",
      "barmerge.gaps_off",
      "barmerge.lookahead_off",
      "math.log",
      "color.yellow",
      "color.blue",
      "display.all",
      "display.none",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-100",
    "type": "example",
    "category": "momentum",
    "title": "Rate of Change (ROC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Rate of Change (ROC)\", \"ROC\", overlay=false)\r\n\r\n//@function Calculates absolute Rate of Change between current price and N periods ago\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/roc.md\r\n//@param source Source price series\r\n//@param length Lookback period\r\n//@returns Absolute price change value\r\nroc(series float source, simple int length)=>\r\n    if length<=0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    var int count = 0\r\n    float change = na\r\n    if not na(source[count])\r\n        change := source - source[count]\r\n        count := math.min(count + 1, length)\r\n    change\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(9, \"Length\", minval=1)\r\n\r\n// Calculate ROC\r\nfloat roc_val = roc(i_source, i_length)\r\n\r\n// Plot\r\nplot(roc_val, \"ROC\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "rate of change (roc)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "roc.md",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-101",
    "type": "example",
    "category": "momentum",
    "title": "Rate of Change Percentage (ROCP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Rate of Change Percentage (ROCP)\", \"ROCP\", overlay=false)\r\n\r\n//@function Calculates percentage Rate of Change between current price and N periods ago\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/rocp.md\r\n//@param source Source price series\r\n//@param length Lookback period\r\n//@returns Percentage price change value\r\nrocp(series float source, simple int length)=>\r\n    if length<=0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    var int count = 0\r\n    float change = na\r\n    if not na(source[count]) and source[count] != 0\r\n        change := 100 * (source - source[count]) / source[count]\r\n        count := math.min(count + 1, length)\r\n    change\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(9, \"Length\", minval=1)\r\n\r\n// Calculate ROCP\r\nfloat rocp_val = rocp(i_source, i_length)\r\n\r\n// Plot\r\nplot(rocp_val, \"ROCP\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "rate of change percentage (rocp)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "rocp.md",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-102",
    "type": "example",
    "category": "momentum",
    "title": "Rate of Change Ratio (ROCR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Rate of Change Ratio (ROCR)\", \"ROCR\", overlay=false)\r\n\r\n//@function Calculates ratio between current price and N periods ago\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/rocr.md\r\n//@param source Source price series\r\n//@param length Lookback period\r\n//@returns Price ratio value\r\nrocr(series float source, simple int length)=>\r\n    if length<=0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    var int count = 0\r\n    float ratio = na\r\n    if not na(source[count]) and source[count] != 0\r\n        ratio := source / source[count]\r\n        count := math.min(count + 1, length)\r\n    ratio\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(9, \"Length\", minval=1)\r\n\r\n// Calculate ROCR\r\nfloat rocr_val = rocr(i_source, i_length)\r\n\r\n// Plot\r\nplot(rocr_val, \"ROCR\", color=color.yellow, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "rate of change ratio (rocr)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "rocr.md",
      "runtime.error",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if"
    ]
  },
  {
    "id": "script-103",
    "type": "example",
    "category": "momentum",
    "title": "Relative Strength Index (RSI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Relative Strength Index (RSI)\", \"RSI\", overlay=false)\r\n\r\n//@function Calculates Relative Strength Index using Wilder's smoothing\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/rsi.md\r\n//@param src Source series to calculate RSI for\r\n//@param len Lookback period for RSI calculation\r\n//@returns RSI value measuring momentum and overbought/oversold conditions\r\nrsi(series float src, simple int len) =>\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    float u = math.max(src - src[1], 0)\r\n    float d = math.max(src[1] - src, 0)\r\n    float alpha = 1/len, float smoothUp = 0.0,  float smoothDown = 0.0\r\n    if bar_index < len\r\n        smoothUp := u\r\n        smoothDown := d\r\n    else\r\n        smoothUp := nz(smoothUp[1]) * (1 - alpha) + u * alpha\r\n        smoothDown := nz(smoothDown[1]) * (1 - alpha) + d * alpha\r\n    float rs = smoothDown == 0 ? 0 : smoothUp/smoothDown\r\n    float rsi = smoothDown == 0 ? 100 : 100 - (100 / (1 + rs))\r\n    rsi\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_length = input.int(14, \"Length\", minval=1)\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\nrsi_value = rsi(i_source, i_length)\r\n\r\n// Plot\r\nplot(rsi_value, \"RSI\", color=color.yellow, linewidth=2)",
    "functions_used": [
      "runtime.error",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "relative strength index (rsi)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "rsi.md",
      "runtime.error",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-104",
    "type": "example",
    "category": "momentum",
    "title": "Relative Strength Xtra (RSX)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Relative Strength Xtra (RSX)\", \"RSX\", overlay=false)\r\n\r\n//@function Calculates RSX (Relative Strength Xtra) using integrated JMA smoothing\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/rsx.md\r\n//@param src Source series to calculate RSX for\r\n//@param len Lookback period for RSX calculation\r\n//@returns RSX value measuring momentum with reduced noise\r\nrsx(series float src,simple int len)=>\r\n    if len<=0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    float u=math.max(src-src[1],0),d=math.max(src[1]-src,0)\r\n    var simple float power=0.5\r\n    var simple float PHASE_VALUE=0.5\r\n    var simple float BETA=power*(len-1)/((power*(len-1))+2)\r\n    var simple float LEN1=math.max((math.log(math.sqrt(0.5*(len-1)))/math.log(2.0))+2.0,0)\r\n    var simple float POW1=math.max(LEN1-2.0,0.5)\r\n    var simple float LEN2=math.sqrt(0.5*(len-1))*LEN1\r\n    var simple float POW1_RECIPROCAL=1.0/POW1\r\n    var simple float AVG_VOLTY_ALPHA=2.0/(math.max(4.0*len,65)+1.0)\r\n    var simple float DIV=1.0/(10.0+10.0*(math.min(math.max(len-10,0),100))/100.0)\r\n    var float upperBand_state_up=na,var float lowerBand_state_up=na\r\n    var float ma1_state_up=na,var float jma_state_up=na\r\n    var float vSum_state_up=0.0,var float det0_state_up=0.0,var float det1_state_up=0.0\r\n    var float avgVolty_state_up=na,var float smoothUp=na\r\n    var volty_array_state_up=array.new_float(11,0.0)\r\n    var float upperBand_state_down=na,var float lowerBand_state_down=na\r\n    var float ma1_state_down=na,var float jma_state_down=na\r\n    var float vSum_state_down=0.0,var float det0_state_down=0.0,var float det1_state_down=0.0\r\n    var float avgVolty_state_down=na,var float smoothDown=na\r\n    var volty_array_state_down=array.new_float(11,0.0)\r\n    if not na(u)\r\n        float del1_up=u-nz(upperBand_state_up,u),float del2_up=u-nz(lowerBand_state_up,u)\r\n        float volty_up=math.abs(del1_up)==math.abs(del2_up)?0.0:math.max(math.abs(del1_up),math.abs(del2_up))\r\n        array.unshift(volty_array_state_up,nz(volty_up,0.0))\r\n        array.pop(volty_array_state_up)\r\n        if not na(volty_up)\r\n            vSum_state_up:=vSum_state_up+(volty_up-array.get(volty_array_state_up,10))*DIV\r\n            avgVolty_state_up:=nz(avgVolty_state_up,vSum_state_up)+AVG_VOLTY_ALPHA*(vSum_state_up-nz(avgVolty_state_up,vSum_state_up))\r\n        float rvolty_up=math.min(math.max(nz(avgVolty_state_up,0)>0?nz(volty_up,0.0)/nz(avgVolty_state_up,1.0):1.0,1.0),math.pow(LEN1,POW1_RECIPROCAL))\r\n        float pow2_up=math.pow(rvolty_up,POW1)\r\n        float Kv_up=math.pow(LEN2/(LEN2+1),math.sqrt(pow2_up))\r\n        upperBand_state_up:=del1_up>0?u:u-Kv_up*del1_up\r\n        lowerBand_state_up:=del2_up<0?u:u-Kv_up*del2_up\r\n        float alpha_up=math.pow(BETA,pow2_up)\r\n        float alphaSquared_up=alpha_up*alpha_up,float oneMinusAlpha_up=1.0-alpha_up\r\n        float oneMinusAlphaSquared_up=oneMinusAlpha_up*oneMinusAlpha_up\r\n        ma1_",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "relative strength xtra (rsx)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "rsx.md",
      "runtime.error",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-105",
    "type": "example",
    "category": "momentum",
    "title": "True Strength Index (TSI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"True Strength Index (TSI)\", \"TSI\", overlay=false)\n\n//@function Calculates the True Strength Index and its signal line.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/tsi.md\n//@param src series float The source series.\n//@param longLen simple int The lookback period for the first EMA smoothing (typically 25).\n//@param shortLen simple int The lookback period for the second EMA smoothing (typically 13).\n//@param signalLen simple int The lookback period for the signal line EMA (typically 13).\n//@returns tuple [float, float] A tuple containing the TSI value and its signal line.\n//@optimized for performance and dirty data\ntsi(series float src, simple int longLen, simple int shortLen, simple int signalLen) =>\n    if longLen <= 0 or shortLen <= 0 or signalLen <= 0\n        runtime.error(\"Lengths must be greater than 0\")\n    float mom = src - nz(src[1])\n    float absMom = math.abs(mom)\n    var float emaMomLong = na, var float emaMomLong_e = 1.0, var bool emaMomLong_warmup = true\n    var float emaMomShort = na, var float emaMomShort_e = 1.0, var bool emaMomShort_warmup = true\n    var float emaAbsMomLong = na, var float emaAbsMomLong_e = 1.0, var bool emaAbsMomLong_warmup = true\n    var float emaAbsMomShort = na, var float emaAbsMomShort_e = 1.0, var bool emaAbsMomShort_warmup = true\n    var float emaSignal = na, var float emaSignal_e = 1.0, var bool emaSignal_warmup = true\n    float alphaLong = 2.0 / math.max(longLen, 1)\n    float alphaShort = 2.0 / math.max(shortLen, 1)\n    float alphaSignal = 2.0 / math.max(signalLen, 1)\n    float smoothedMomLong = 0.0\n    float smoothedAbsMomLong = 0.0\n    float doubleSmoothedMom = 0.0\n    float doubleSmoothedAbsMom = 0.0\n    float tsiValue = 0.0\n    float signalLineValue = 0.0\n    if not na(mom)\n        if na(emaMomLong)\n            emaMomLong := 0.0\n            smoothedMomLong := mom\n        else\n            emaMomLong := alphaLong * (mom - emaMomLong) + emaMomLong\n            if emaMomLong_warmup\n                emaMomLong_e *= (1 - alphaLong)\n                smoothedMomLong := (1.0 / (1.0 - emaMomLong_e)) * emaMomLong\n                if emaMomLong_e <= 1e-10\n                    emaMomLong_warmup := false\n            else\n                smoothedMomLong := emaMomLong\n        if na(emaMomShort)\n            emaMomShort := 0.0\n            doubleSmoothedMom := smoothedMomLong\n        else\n            emaMomShort := alphaShort * (smoothedMomLong - emaMomShort) + emaMomShort\n            if emaMomShort_warmup\n                emaMomShort_e *= (1 - alphaShort)\n                doubleSmoothedMom := (1.0 / (1.0 - emaMomShort_e)) * emaMomShort\n                if emaMomShort_e <= 1e-10\n                    emaMomShort_warmup := false\n            else\n                doubleSmoothedMom := emaMomShort\n        if na(emaAbsMomLong)\n            emaAbsMomLong := 0.0\n            smoothedAbsMomLong := absMom\n        else\n            emaAbsMomLong :=",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "plot"
    ],
    "keywords": [
      "true strength index (tsi)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "plot",
      "github.com",
      "tsi.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.source",
      "input.int",
      "color.blue",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-106",
    "type": "example",
    "category": "momentum",
    "title": "Velocity (VEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Velocity (VEL)\", \"VEL\", overlay=false)\r\n\r\n//@function Calculates zero-lag velocity using JMA smoothing\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/momentum/vel.md\r\n//@param src Source series to calculate velocity for\r\n//@param period Lookback period for velocity calculation\r\n//@returns Smoothed velocity value measuring rate of price change\r\nvel(series float src, simple int period) =>\r\n    if period <= 0\r\n        runtime.error(\"Period must be greater than 0\")\r\n    float source = 0.0\r\n    if not na(src) and not na(src[period])\r\n        source := src - src[period]\r\n    var simple float phase = 100, var simple float power = 0.2\r\n    var simple float PHASE_VALUE = math.min(math.max((phase * 0.01) + 1.5, 0.5), 2.5)\r\n    var simple float BETA = power * (period - 1) / ((power * (period - 1)) + 2)\r\n    var simple float LEN1 = math.max((math.log(math.sqrt(0.5*(period-1))) / math.log(2.0)) + 2.0, 0)\r\n    var simple float POW1 = math.max(LEN1 - 2.0, 0.5)\r\n    var simple float LEN2 = math.sqrt(0.5*(period-1))*LEN1\r\n    var simple float POW1_RECIPROCAL = 1.0 / POW1\r\n    var simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)\r\n    var simple float DIV = 1.0/(10.0 + 10.0*(math.min(math.max(period-10,0),100))/100.0)\r\n    var float upperBand_state = na, var float lowerBand_state = na\r\n    var float ma1_state = na, var float jma_state = na\r\n    var float vSum_state = 0.0, var float det0_state = 0.0, var float det1_state = 0.0\r\n    var float avgVolty_state = na, var float vel = na\r\n    var volty_array_state = array.new_float(11, 0.0)\r\n    if not na(source)\r\n        float del1 = source - nz(upperBand_state, source), float del2 = source - nz(lowerBand_state, source)\r\n        float volty = math.abs(del1) == math.abs(del2) ? 0.0 : math.max(math.abs(del1), math.abs(del2))\r\n        array.unshift(volty_array_state, nz(volty, 0.0))\r\n        array.pop(volty_array_state)\r\n        if not na(volty)\r\n            vSum_state := vSum_state + (volty - array.get(volty_array_state, 10)) * DIV\r\n            avgVolty_state := nz(avgVolty_state, vSum_state) + AVG_VOLTY_ALPHA * (vSum_state - nz(avgVolty_state, vSum_state))\r\n        float rvolty = math.min(math.max(nz(avgVolty_state, 0) > 0 ? nz(volty, 0.0) / nz(avgVolty_state, 1.0) : 1.0, 1.0), math.pow(LEN1, POW1_RECIPROCAL))\r\n        float pow2 = math.pow(rvolty, POW1)\r\n        float Kv = math.pow(LEN2/(LEN2+1), math.sqrt(pow2))\r\n        upperBand_state := del1 > 0 ? source : source - Kv * del1\r\n        lowerBand_state := del2 < 0 ? source : source - Kv * del2\r\n        float alpha = math.pow(BETA, pow2)\r\n        float alphaSquared = alpha * alpha, float oneMinusAlpha = 1.0 - alpha\r\n        float oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha\r\n        ma1_state := source + (alpha * (nz(ma1_state, source) - source))\r\n        det0_state := (source - ma1_state) * (1 - BETA) + BETA * nz(det0_state, 0)\r\n        float ma2 = ma1_",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "velocity (vel)",
      "momentum",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "vel.md",
      "runtime.error",
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-107",
    "type": "example",
    "category": "numerics",
    "title": "Acceleration (Slope of Slope) (ACCEL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Acceleration (Slope of Slope) (ACCEL)\", \"ACCEL\", overlay=false, precision=8)\n\n//@function Calculates acceleration (slope of slope)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/accel.md\n//@param src Source series to calculate slope from\n//@param len Lookback period for calculation\n//@returns acceleration\naccel(series float src, simple int len1) =>\n    if len1 <= 1\n        runtime.error(\"Length 1 for slope calculation must be greater than 1\")\n    var float sumX1 = 0.0, var float sumY1 = 0.0, var float sumXY1 = 0.0, var float sumX21 = 0.0\n    var int   validCount1 = 0\n    var array<float> x_values1 = array.new_float(len1)\n    var array<float> y_values1 = array.new_float(len1)\n    var int   head1 = 0\n    var int internal_time_counter1 = 0\n    if internal_time_counter1 >= len1\n        float oldX1 = array.get(x_values1, head1)\n        float oldY1 = array.get(y_values1, head1)\n        if not na(oldY1)\n            sumX1 := sumX1 - oldX1, sumY1 := sumY1 - oldY1\n            sumXY1 := sumXY1 - oldX1 * oldY1, sumX21 := sumX21 - oldX1 * oldX1\n            validCount1 := validCount1 - 1\n    float currentX1 = internal_time_counter1\n    float currentY1 = src\n    array.set(x_values1, head1, currentX1)\n    array.set(y_values1, head1, currentY1)\n    if not na(currentY1)\n        sumX1 := sumX1 + currentX1, sumY1 := sumY1 + currentY1\n        sumXY1 := sumXY1 + currentX1 * currentY1, sumX21 := sumX21 + currentX1 * currentX1\n        validCount1 := validCount1 + 1\n    head1 := (head1 + 1) % len1\n    internal_time_counter1 := internal_time_counter1 + 1\n    float current_slope = na\n    if validCount1 >= 2\n        float n1 = validCount1\n        float divisor1 = n1 * sumX21 - sumX1 * sumX1\n        if divisor1 != 0.0\n            current_slope := (n1 * sumXY1 - sumX1 * sumY1) / divisor1\n    var float sumX2 = 0.0, var float sumY2 = 0.0, var float sumXY2 = 0.0, var float sumX22 = 0.0\n    var int   validCount2 = 0\n    var array<float> x_values2 = array.new_float(len1)\n    var array<float> y_values2 = array.new_float(len1)\n    var int   head2 = 0\n    var int internal_time_counter2 = 0\n    if internal_time_counter2 >= len1\n        float oldX2 = array.get(x_values2, head2)\n        float oldY2 = array.get(y_values2, head2)\n        if not na(oldY2)\n            sumX2 := sumX2 - oldX2, sumY2 := sumY2 - oldY2\n            sumXY2 := sumXY2 - oldX2 * oldY2, sumX22 := sumX22 - oldX2 * oldX2\n            validCount2 := validCount2 - 1\n    float currentX2 = internal_time_counter2\n    float currentY2 = current_slope\n    array.set(x_values2, head2, currentX2)\n    array.set(y_values2, head2, currentY2)\n    if not na(currentY2)\n        sumX2 := sumX2 + currentX2, sumY2 := sumY2 + currentY2\n        sumXY2 := sumXY2 + currentX2 * currentY2, sumX22 := sumX22 + currentX2 * currentX2\n        validCount2 := validCount2 + 1\n    head2 := (head2 + 1) % len1\n    internal_time_counter2 := internal_time_counter2 + 1",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "acceleration (slope of slope) (accel)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "accel.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-108",
    "type": "example",
    "category": "numerics",
    "title": "Two-Argument Arctangent (ATAN2)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Two-Argument Arctangent (ATAN2)\", \"ATAN2\", overlay=false, precision=6)\n\n//@function Calculates the two-argument arctangent (atan2) with proper quadrant handling.\n// Formula: atan2(y, x) returns the angle θ in radians from the positive x-axis to the point (x, y)\n// Output range: (-π, π]\n// Handles all four quadrants correctly, avoiding the ambiguity of atan(y/x)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/atan2.md\n//@param y The y-coordinate (opposite side)\n//@param x The x-coordinate (adjacent side)\n//@returns The angle in radians from -π to π\natan2(series float y, series float x) =>\n    if y == 0.0 and x == 0.0\n        runtime.error(\"atan2: Both y and x cannot be zero\")\n    ay = math.abs(y)\n    ax = math.abs(x)\n    angle = 0.0\n    if ax > ay\n        angle := math.atan(ay / ax)\n    else\n        angle := (math.pi / 2.0) - math.atan(ax / ay)\n    if x < 0.0\n        angle := math.pi - angle\n    if y < 0.0\n        angle := -angle\n    \n    angle\n\n// ---------- Main loop ----------\n\n// Inputs\ni_y = input.source(high - low, \"Y (Numerator)\")\ni_x = input.source((high + low) / 2.0, \"X (Denominator)\")\n\n// Calculation\natan2Value = atan2(i_y, i_x)\n\n// Plot\nplot(atan2Value, \"ATAN2\", color=color.yellow, linewidth=2)\nhline(0, \"Zero\", color=color.gray)\nhline(1.5708, \"π/2\", color=color.new(color.gray, 70))\nhline(-1.5708, \"-π/2\", color=color.new(color.gray, 70))\nhline(3.1416, \"π\", color=color.new(color.gray, 70))\nhline(-3.1416, \"-π\", color=color.new(color.gray, 70))\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "plot",
      "hline"
    ],
    "keywords": [
      "two-argument arctangent (atan2)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "plot",
      "hline",
      "github.com",
      "runtime.error",
      "math.abs",
      "math.atan",
      "math.pi",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-109",
    "type": "example",
    "category": "numerics",
    "title": "Percentage Change (CHANGE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Percentage Change (CHANGE)\", \"CHANGE\", overlay=false, format=format.percent)\n\n//@function Calculates the percentage change of a source series over a specified length using the history referencing operator for efficiency.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/change.md\n//@param source The source series (e.g. close price).\n//@param length The lookback period (number of bars). Must be > 0.\n//@returns float The percentage change over the specified length. Returns `na` if the historical value is `na` or zero.\n//@optimized Uses direct history access `source[length]` instead of array manipulation.\nchange(float source, int length) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    float oldValue = source[length]\n    if na(oldValue) or oldValue == 0\n        na\n    else\n        (source / oldValue - 1) // Already a percentage, Pine handles plotting format\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(1, \"Length\", minval = 1)\n\n// Calculation\nresult = change(i_source, i_length)\n\n// Plot\nplot(result, \"Change %\", color.blue, color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "percentage change (change)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "change.md",
      "e.g",
      "runtime.error",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-110",
    "type": "example",
    "category": "numerics",
    "title": "Exponential Transformation (EXP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Exponential Transformation (EXP)\", \"EXP\", overlay=false)\n\n//@function Applies an exponential transformation (y = e^x) to the input series.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/exp.md\n//@param source series float The input series to transform.\n//@returns series float The exponentially transformed series.\n//@optimized for performance and dirty data\nexpT(series float source) =>\n    if na(source)\n        runtime.error(\"Parameter 'source' cannot be na.\")\n    math.exp(source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input(close, \"Source\")\n\n// Calculation\ntransformedSource = expT(i_source)\n\n// Plot\nplot(transformedSource, \"Exponential Transformation\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.exp",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "exponential transformation (exp)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "math.exp",
      "color.yellow",
      "plot",
      "github.com",
      "exp.md",
      "runtime.error",
      "math.exp",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "script-111",
    "type": "example",
    "category": "numerics",
    "title": "Highest Value (HIGHEST)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Highest Value (HIGHEST)\", \"HIGHEST\", overlay=true)\n\n//@function Highest value over a specified period using a monotonic deque.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/highest.md\n//@param src {series float} Source series.\n//@param len {int} Lookback length. `len` > 0.\n//@returns {series float} Highest value of `src` for `len` bars back. Returns the highest value seen so far during initial bars.\nhighest(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"Length must be greater than 0\")\n    var deque = array.new_int(0)\n    var src_buffer = array.new_float(len, na)\n    var int current_index = 0\n    float current_val = nz(src)\n    array.set(src_buffer, current_index, current_val)\n    while array.size(deque) > 0 and array.get(deque, 0) <= bar_index - len\n        array.shift(deque)\n    while array.size(deque) > 0\n        int last_index_in_deque = array.get(deque, array.size(deque) - 1)\n        int buffer_lookup_index = last_index_in_deque % len\n        if array.get(src_buffer, buffer_lookup_index) <= current_val\n            array.pop(deque)\n        else\n            break\n    array.push(deque, bar_index)\n    int highest_index = array.get(deque, 0)\n    int highest_buffer_index = highest_index % len\n    float result = array.get(src_buffer, highest_buffer_index)\n    current_index := (current_index + 1) % len\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1) // Default period 14\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhighest_value = highest(i_source, i_period)\n\n// Plot\nplot(highest_value, \"Highest\", color=color.yellow, linewidth=2) // Changed color\n",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "highest value (highest)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "highest.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-112",
    "type": "example",
    "category": "numerics",
    "title": "Midprice (HL2)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Midprice (HL2)\", \"HL2\", overlay=true)\n\n//@function Calculates the midprice as the average of high and low prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/hl2.md\n//@param h High price series\n//@param l Low price series\n//@returns float The midprice value (high + low) * 0.5\n//@optimized Uses multiplication instead of division for performance\nhl2(series float h, series float l) =>\n    (h + l) * 0.5\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = hl2(high, low)\n\n// Plot\nplot(result, \"HL2\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "midprice (hl2)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-113",
    "type": "example",
    "category": "numerics",
    "title": "Typical Price (HLC3)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Typical Price (HLC3)\", \"HLC3\", overlay=true)\n\n//@function Calculates the typical price as the average of high, low, and close prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/hlc3.md\n//@param h High price series\n//@param l Low price series\n//@param c Close price series\n//@returns float The typical price (high + low + close) * 0.333333\n//@optimized Uses multiplication instead of division for performance\nhlc3(series float h, series float l, series float c) =>\n    (h + l + c) * 0.333333\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = hlc3(high, low, close)\n\n// Plot\nplot(result, \"HLC3\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "typical price (hlc3)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-114",
    "type": "example",
    "category": "numerics",
    "title": "Weighted Close (HLCC4)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Weighted Close (HLCC4)\", \"HLCC4\", overlay=true)\n\n//@function Calculates the weighted close price with double weight on close\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/hlcc4.md\n//@param h High price series\n//@param l Low price series\n//@param c Close price series\n//@returns float The weighted close (high + low + close × 2) * 0.25\n//@optimized Uses multiplication instead of division for performance\nhlcc4(series float h, series float l, series float c) =>\n    (h + l + c + c ) * 0.25\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = hlcc4(high, low, close)\n\n// Plot\nplot(result, \"HLCC4\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "weighted close (hlcc4)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-115",
    "type": "example",
    "category": "numerics",
    "title": "Acceleration, Slope of Slope (JOLT)",
    "version": "v6",
    "code": "\n// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Acceleration, Slope of Slope (JOLT)\", \"JOLT\", overlay=false, precision=8)\n\n//@function Calculates jolt (slope of slope of slope)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/jolt.md\n//@param src Source series to calculate slope from\n//@param len Lookback period for calculation\n//@returns jolt\njolt(series float src, simple int len1) =>\n    if len1 <= 1\n        runtime.error(\"Length 1 for first slope calculation must be greater than 1\")\n    var float sumX1 = 0.0, var float sumY1 = 0.0, var float sumXY1 = 0.0, var float sumX21 = 0.0\n    var int   validCount1 = 0\n    var array<float> x_values1 = array.new_float(len1)\n    var array<float> y_values1 = array.new_float(len1)\n    var int   head1 = 0\n    var int internal_time_counter1 = 0\n    if internal_time_counter1 >= len1\n        float oldX1 = array.get(x_values1, head1)\n        float oldY1 = array.get(y_values1, head1)\n        if not na(oldY1)\n            sumX1 := sumX1 - oldX1, sumY1 := sumY1 - oldY1\n            sumXY1 := sumXY1 - oldX1 * oldY1, sumX21 := sumX21 - oldX1 * oldX1\n            validCount1 := validCount1 - 1\n    float currentX1 = internal_time_counter1\n    float currentY1 = src\n    array.set(x_values1, head1, currentX1)\n    array.set(y_values1, head1, currentY1)\n    if not na(currentY1)\n        sumX1 := sumX1 + currentX1, sumY1 := sumY1 + currentY1\n        sumXY1 := sumXY1 + currentX1 * currentY1, sumX21 := sumX21 + currentX1 * currentX1\n        validCount1 := validCount1 + 1\n    head1 := (head1 + 1) % len1\n    internal_time_counter1 := internal_time_counter1 + 1\n    float current_slope1 = na\n    if validCount1 >= 2\n        float n1 = validCount1\n        float divisor1 = n1 * sumX21 - sumX1 * sumX1\n        if divisor1 != 0.0\n            current_slope1 := (n1 * sumXY1 - sumX1 * sumY1) / divisor1\n    var float sumX2 = 0.0, var float sumY2 = 0.0, var float sumXY2 = 0.0, var float sumX22 = 0.0\n    var int   validCount2 = 0\n    var array<float> x_values2 = array.new_float(len1)\n    var array<float> y_values2 = array.new_float(len1)\n    var int   head2 = 0\n    var int internal_time_counter2 = 0\n    if internal_time_counter2 >= len1\n        float oldX2 = array.get(x_values2, head2)\n        float oldY2 = array.get(y_values2, head2)\n        if not na(oldY2)\n            sumX2 := sumX2 - oldX2, sumY2 := sumY2 - oldY2\n            sumXY2 := sumXY2 - oldX2 * oldY2, sumX22 := sumX22 - oldX2 * oldX2\n            validCount2 := validCount2 - 1\n    float currentX2 = internal_time_counter2\n    float currentY2 = current_slope1\n    array.set(x_values2, head2, currentX2)\n    array.set(y_values2, head2, currentY2)\n    if not na(currentY2)\n        sumX2 := sumX2 + currentX2, sumY2 := sumY2 + currentY2\n        sumXY2 := sumXY2 + currentX2 * currentY2, sumX22 := sumX22 + currentX2 * currentX2\n        validCount2 := validCount2 + 1\n    head2 := (head2 + 1) % len1\n    internal_time_counter2 := internal_time_counter2 + 1\n ",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "acceleration, slope of slope (jolt)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "jolt.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-116",
    "type": "example",
    "category": "numerics",
    "title": "Linear Transformation (LINEAR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Linear Transformation (LINEAR)\", \"LINEAR\", overlay=false)\n\n//@function Applies a linear transformation (y = a*(x - sma) + sma + b) relative to the source's SMA, calculated internally.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/linear.md\n//@param source series float The input series to transform.\n//@param period simple int The lookback period for the internal SMA calculation.\n//@param a float The scaling factor (slope).\n//@param b float The offset (intercept).\n//@returns series float The linearly transformed series relative to its internally calculated SMA.\n//@optimized for performance and dirty data\nlinear(series float source, float a, float b) =>\n    if na(source) or na(a) or na(b)\n        runtime.error(\"Parameters 'source', 'a', 'b' cannot be na and 'period' must be > 0.\")\n    var int p = 200\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        valid_count -= 1\n    if not na(source)\n        sum += source\n        valid_count += 1\n    array.set(buffer, head, source)\n    head := (head + 1) % p\n    smaValue = nz(sum / valid_count, source)\n    a * (source - smaValue) + smaValue + b\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input(close, \"Source\")\ni_smaPeriod = input.int(200, \"SMA Period\", minval=1)\ni_a = input.float(2.0, \"Scale (a)\")\ni_b = input.float(20.0, \"Offset (b)\")\n\n// Calculation\ntransformedSource = linear(i_source, i_a, i_b)\n\n// Plot\nplot(transformedSource, \"Linear Transformation\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "linear transformation (linear)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "linear.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-117",
    "type": "example",
    "category": "numerics",
    "title": "Logarithmic Transformation (LOG)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Logarithmic Transformation (LOG)\", \"LOG\", overlay=false)\n\n//@function Applies a natural logarithmic transformation (y = ln(x)) to the input series.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/log.md\n//@param source series float The input series to transform. Must contain positive values.\n//@returns series float The logarithmically transformed series. Returns na if source <= 0.\n//@optimized for performance and dirty data\nlogT(series float source) =>\n    if na(source)\n        runtime.error(\"Parameter 'source' cannot be na.\")\n    if source <= 0\n        na\n    else\n        math.log(source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input(close, \"Source\")\n\n// Calculation\ntransformedSource = logT(i_source)\n\n// Plot\nplot(transformedSource, \"Log Transformation\", color=color.green, color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "log.md",
      "runtime.error",
      "math.log",
      "color.green",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "logarithmic transformation (log)",
      "numerics",
      "indicator",
      "v6",
      "log.md",
      "runtime.error",
      "math.log",
      "color.green",
      "color.yellow",
      "plot",
      "github.com",
      "log.md",
      "runtime.error",
      "math.log",
      "color.green",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-118",
    "type": "example",
    "category": "numerics",
    "title": "Lowest Value (LOWEST)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Lowest Value (LOWEST)\", \"LOWEST\", overlay=true)\n\n//@function Lowest value over a specified period using a monotonic deque.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/lowest.md\n//@param src {series float} Source series.\n//@param len {int} Lookback length. `len` > 0.\n//@returns {series float} Lowest value of `src` for `len` bars back. Returns the lowest value seen so far during initial bars.\nlowest(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"Length must be greater than 0\")\n    var deque = array.new_int(0)\n    var src_buffer = array.new_float(len, na)\n    var int current_index = 0\n    float current_val = nz(src)\n    array.set(src_buffer, current_index, current_val)\n    while array.size(deque) > 0 and array.get(deque, 0) <= bar_index - len\n        array.shift(deque)\n    while array.size(deque) > 0\n        int last_index_in_deque = array.get(deque, array.size(deque) - 1)\n        int buffer_lookup_index = last_index_in_deque % len\n        if array.get(src_buffer, buffer_lookup_index) >= current_val\n            array.pop(deque)\n        else\n            break\n    array.push(deque, bar_index)\n    int lowest_index = array.get(deque, 0)\n    int lowest_buffer_index = lowest_index % len\n    float result = array.get(src_buffer, lowest_buffer_index)\n    current_index := (current_index + 1) % len\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1) // Default period 14\ni_source = input.source(close, \"Source\")\n\n// Calculation\nlowest_value = lowest(i_source, i_period)\n\n// Plot\nplot(lowest_value, \"Lowest\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "lowest value (lowest)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "lowest.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-119",
    "type": "example",
    "category": "numerics",
    "title": "Midpoint (MIDPOINT)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Midpoint (MIDPOINT)\", \"MIDPOINT\", overlay=true)\n\n//@function Calculates the midpoint of the highest high and lowest low over a specified period\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/midpoint.md\n//@param src Source series to calculate midpoint for\n//@param len Lookback period for finding highest and lowest values\n//@returns float The midpoint value (highest + lowest) * 0.5 over the period\n//@optimized Uses multiplication instead of division for performance\nmidpoint(series float src, simple int len) =>\n    if len <= 0\n        runtime.error(\"Length must be greater than 0\")\n    float highest_val = ta.highest(src, len)\n    float lowest_val = ta.lowest(src, len)\n    (highest_val + lowest_val) * 0.5\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(14, \"Length\", minval=1)\n\n// Calculation\nresult = midpoint(i_source, i_length)\n\n// Plot\nplot(result, \"Midpoint\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "midpoint (midpoint)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "midpoint.md",
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-120",
    "type": "example",
    "category": "numerics",
    "title": "Min-Max Normalization (NORMALIZE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Min-Max Normalization (NORMALIZE)\", \"NORMALIZE\", overlay=false, precision=6)\n\n//@function Normalizes a source series to the fixed range [0, 1] using Min-Max scaling over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/normalize.md\n//@param src The source series to normalize.\n//@param len The lookback period to determine min and max values. Must be >= 1.\n//@returns The normalized series (scaled to [0, 1]).\nnormalize(series float src, simple int len) =>\n    float min_val_in_period = src\n    float max_val_in_period = src\n    for i = 1 to len - 1 \n        current_val = src[i]\n        if na(current_val)\n            continue\n        if current_val < min_val_in_period\n            min_val_in_period := current_val\n        if current_val > max_val_in_period\n            max_val_in_period := current_val\n    range_val = max_val_in_period - min_val_in_period\n    normalized_value = 0.0 \n    if range_val != 0.0 and not na(range_val) \n        normalized_value := (src - min_val_in_period) / range_val\n    normalized_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(200, \"Lookback Length\", minval=1, tooltip=\"Lookback period for finding min/max. Must be >= 1.\")\n\n// Calculation\nnormalizedValue = normalize(i_source, i_length)\n\n// Plot\nplot(normalizedValue, \"Normalized Value [0,1]\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "min-max normalization (normalize)",
      "numerics",
      "indicator",
      "v6",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "normalize.md",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-121",
    "type": "example",
    "category": "numerics",
    "title": "Open-Close Midpoint (OC2)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Open-Close Midpoint (OC2)\", \"OC2\", overlay=true)\n\n//@function Calculates the midpoint between open and close prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/oc2.md\n//@param o Open price series\n//@param c Close price series\n//@returns float The midpoint value (open + close) * 0.5\n//@optimized Uses multiplication instead of division for performance\noc2(series float o, series float c) =>\n    (o + c) * 0.5\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = oc2(open, close)\n\n// Plot\nplot(result, \"OC2\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "open-close midpoint (oc2)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-122",
    "type": "example",
    "category": "numerics",
    "title": "Open-High-Low Average (OHL3)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Open-High-Low Average (OHL3)\", \"OHL3\", overlay=true)\n\n//@function Calculates the average of open, high, and low prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/ohl3.md\n//@param o Open price series\n//@param h High price series\n//@param l Low price series\n//@returns float The average value (open + high + low) * 0.333333\n//@optimized Uses multiplication instead of division for performance\nohl3(series float o, series float h, series float l) =>\n    (o + h + l) * 0.333333\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = ohl3(open, high, low)\n\n// Plot\nplot(result, \"OHL3\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "open-high-low average (ohl3)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-123",
    "type": "example",
    "category": "numerics",
    "title": "OHLC Average (OHLC4)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"OHLC Average (OHLC4)\", \"OHLC4\", overlay=true)\n\n//@function Calculates the average of open, high, low, and close prices\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/ohlc4.md\n//@param o Open price series\n//@param h High price series\n//@param l Low price series\n//@param c Close price series\n//@returns float The average value (open + high + low + close) * 0.25\n//@optimized Uses multiplication instead of division for performance\nohlc4(series float o, series float h, series float l, series float c) =>\n    (o + h + l + c) * 0.25\n\n// ---------- Main loop ----------\n\n// Calculation\nresult = ohlc4(open, high, low, close)\n\n// Plot\nplot(result, \"OHLC4\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ohlc average (ohlc4)",
      "numerics",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-124",
    "type": "example",
    "category": "numerics",
    "title": "Rectified Linear Unit (ReLU)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Rectified Linear Unit (ReLU)\", \"ReLU\", overlay=false, precision=6)\n\n//@function Applies the Rectified Linear Unit (ReLU) activation function to a series.\n// ReLU returns the input directly if it is positive, otherwise, it returns zero.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/relu.md\n//@param src The source series.\n//@returns The ReLU transformed series.\nrelu(series float src) =>\n    math.max(0, src)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\n\n// Calculation of relu on SMA(source)-source\nreluDn = -relu(ta.sma(i_source,20)-i_source)\nreluUp = relu(i_source-ta.sma(i_source,20))\n\n// Plot\nplot(reluUp, \"ReLU\", color=color.green, linewidth=2)\nplot(reluDn, \"ReLU\", color=color.red, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "input.source",
      "ta.sma",
      "color.green",
      "color.red",
      "plot"
    ],
    "keywords": [
      "rectified linear unit (relu)",
      "numerics",
      "indicator",
      "v6",
      "math.max",
      "input.source",
      "ta.sma",
      "color.green",
      "color.red",
      "plot",
      "github.com",
      "relu.md",
      "math.max",
      "input.source",
      "ta.sma",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "script-125",
    "type": "example",
    "category": "numerics",
    "title": "Logistic Function (SIGMOID)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Logistic Function (SIGMOID)\", \"SIGMOID\", overlay=false, precision=6)\n\n//@function Applies the logistic (sigmoid) function to a source series.\n// Formula: S(x) = 1 / (1 + exp(-k * (x - x0)))\n// Maps any real-valued input to the range (0, 1).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/sigmoid.md\n//@param src The source series.\n//@param k The steepness factor of the sigmoid curve. Higher k means a steeper curve.\n//@param x0 The x-value of the sigmoid's midpoint (where the output is 0.5).\n//@returns The sigmoid transformed series, values between 0 and 1.\nsigmoid(series float src, simple float k, float x0) =>\n    1 / (1 + math.exp(-k * (src - x0)))\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_steepness_k = input.float(0.5, \"Steepness (k)\", minval = 0.000001, step = 0.1)\n\n// Calculation\nsigmoidValue = sigmoid(i_source, i_steepness_k, ta.sma(i_source,200))\n\n// Plot\nplot(sigmoidValue, \"Sigmoid\", color=color.yellow, linewidth=2)\n\n",
    "functions_used": [
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "logistic function (sigmoid)",
      "numerics",
      "indicator",
      "v6",
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "plot",
      "github.com",
      "sigmoid.md",
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for"
    ]
  },
  {
    "id": "script-126",
    "type": "example",
    "category": "numerics",
    "title": "Slope, Linear Regression (SLOPE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Slope, Linear Regression (SLOPE)\", \"SLOPE\", overlay=false, precision=8)\n\n//@function Calculates slope (linear regression)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/slope.md\n//@param src Source series to calculate slope from\n//@param len Lookback period for calculation\n//@returns Slope value properly calculated\nslope(series float src, simple int len) =>\n    if len <= 1\n        runtime.error(\"Length must be greater than 1\")\n    var float sumX = 0.0\n    var float sumY = 0.0\n    var float sumXY = 0.0\n    var float sumX2 = 0.0\n    var int   validCount = 0\n    var array<float> x_values = array.new_float(len)\n    var array<float> y_values = array.new_float(len)\n    var int   head = 0\n    var int internal_time_counter = 0\n    if internal_time_counter >= len\n        float oldX = array.get(x_values, head)\n        float oldY = array.get(y_values, head)\n        if not na(oldY)\n            sumX := sumX - oldX\n            sumY := sumY - oldY\n            sumXY := sumXY - oldX * oldY\n            sumX2 := sumX2 - oldX * oldX\n            validCount := validCount - 1\n    float currentX = internal_time_counter\n    float currentY = src\n    array.set(x_values, head, currentX)\n    array.set(y_values, head, currentY)\n    if not na(currentY)\n        sumX := sumX + currentX\n        sumY := sumY + currentY\n        sumXY := sumXY + currentX * currentY\n        sumX2 := sumX2 + currentX * currentX\n        validCount := validCount + 1\n    head := (head + 1) % len\n    internal_time_counter := internal_time_counter + 1\n    float calculatedSlope = na\n    if validCount >= 2\n        float n = validCount\n        float divisor = n * sumX2 - sumX * sumX\n        if divisor != 0.0\n            calculatedSlope := (n * sumXY - sumX * sumY) / divisor\n    calculatedSlope\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ns = slope(i_source, i_period)\n\n// Plot\nplot(s, \"Slope\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "slope, linear regression (slope)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "slope.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-127",
    "type": "example",
    "category": "numerics",
    "title": "Square Root Transformation (SQRT)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Square Root Transformation (SQRT)\", \"SQRT\", overlay=false)\n\n//@function Applies a square root transformation (y = √x) to the input series.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/sqrt.md\n//@param source series float The input series to transform. Must contain non-negative values.\n//@returns series float The square root transformed series. Returns na if source < 0.\n//@optimized for performance and dirty data\nsqrtT(series float source) =>\n    if na(source)\n        runtime.error(\"Parameter 'source' cannot be na.\")\n    if source < 0\n        na\n    else\n        math.sqrt(source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input(close, \"Source\")\n\n// Calculation\ntransformedSource = sqrtT(i_source)\n\n// Plot\nplot(transformedSource, \"Square Root Transformation\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "square root transformation (sqrt)",
      "numerics",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "color.yellow",
      "plot",
      "github.com",
      "sqrt.md",
      "runtime.error",
      "math.sqrt",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-128",
    "type": "example",
    "category": "numerics",
    "title": "Standardization (Z-score)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Standardization (Z-score)\", \"STANDARDIZE\", overlay=false, precision=4)\n\n//@function Calculates the Z-score of a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/standardize.md\n//@param src series float Input data series.\n//@param len simple int Lookback period for calculating mean and standard deviation (must be > 1 for sample stdev).\n//@returns series float The Z-score of the current data point, or na if issues like insufficient data or zero stdev for a non-mean current value.\nstandardize(series float src, simple int len) =>\n    if len <= 1\n        float(na)\n    var S1 = 0.0\n    var S2 = 0.0\n    var N = 0\n    var float[] window_data_vals = array.new_float(0)\n    var bool[]  window_data_is_na = array.new_bool(0)\n    float x_new = src[0]\n    bool x_new_is_na = na(x_new)\n    if array.size(window_data_vals) == len\n        float x_old_val = array.get(window_data_vals, 0)\n        bool x_old_was_na = array.get(window_data_is_na, 0)\n        array.shift(window_data_vals)\n        array.shift(window_data_is_na)\n        if not x_old_was_na\n            S1 -= x_old_val\n            S2 -= x_old_val * x_old_val\n            N -= 1\n    array.push(window_data_vals, x_new_is_na ? 0.0 : x_new)\n    array.push(window_data_is_na, x_new_is_na)\n    if not x_new_is_na\n        S1 += x_new\n        S2 += x_new * x_new\n        N += 1\n    float z_score = na\n    if N < 2\n        z_score := na\n    else\n        float mean_val = S1 / N\n        float variance_pop = (S2 / N) - (mean_val * mean_val)\n        variance_pop := variance_pop < 1e-10 ? 0.0 : variance_pop\n        float variance_sample = variance_pop * N / (N - 1)\n        float stdev_val = math.sqrt(variance_sample)\n        if x_new_is_na\n            z_score := na\n        else if stdev_val > 1e-10\n            z_score := (x_new - mean_val) / stdev_val\n        else\n            z_score := (math.abs(x_new - mean_val) < 1e-10) ? 0.0 : na\n    z_score\n\n// Inputs\ni_source = input.source(close, title=\"Source\")\ni_length = input.int(20, title=\"Lookback Period\", minval=2, tooltip=\"Period for mean and standard deviation. Must be at least 2 for stdev.\")\n\n// Calculation\nz_score_value = standardize(i_source, i_length) // Renamed for clarity\n\n// Plot\nplot(z_score_value, \"Z-score\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "array.shift",
      "array.push",
      "math.sqrt",
      "math.abs",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "standardization (z-score)",
      "numerics",
      "indicator",
      "v6",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "array.shift",
      "array.push",
      "math.sqrt",
      "math.abs",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "standardize.md",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "array.shift",
      "array.push",
      "math.sqrt",
      "math.abs",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-129",
    "type": "example",
    "category": "numerics",
    "title": "Hyperbolic Tangent (TANH)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hyperbolic Tangent (TANH)\", \"TANH\", overlay=false, precision=6)\n\n//@function Applies the hyperbolic tangent (tanh) function to a source series.\n// Formula: S(x) = tanh(k * (x - x0))\n// where tanh(y) = (exp(y) - exp(-y)) / (exp(y) + exp(-y))\n// Maps any real-valued input to the range (-1, 1).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/numerics/tanh.md\n//@param src The source series.\n//@param k The steepness factor. Higher k means a steeper curve around x0.\n//@param x0 The x-value of the inflection point (where the output is 0).\n//@returns The tanh transformed series, values between -1 and 1.\ntanh(series float src, simple float k, float x0) =>\n    y = k * (src - x0)\n    exp_y = math.exp(y)\n    exp_neg_y = math.exp(-y)\n    numerator = exp_y - exp_neg_y\n    denominator = exp_y + exp_neg_y\n    result = float(na)\n    if denominator == 0.0\n        if numerator > 0\n            result := 1.0\n        else if numerator < 0\n            result := -1.0\n        else\n            result := 0.0\n    else\n        result := numerator / denominator\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_steepness_k = input.float(0.5, \"Steepness (k)\", minval = 0.1, step = 0.1)\n\n// Calculation\ntanhValue = tanh(i_source, i_steepness_k, ta.sma(i_source,200))\n\n// Plot\nplot(tanhValue, \"Tanh\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hyperbolic tangent (tanh)",
      "numerics",
      "indicator",
      "v6",
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "plot",
      "github.com",
      "tanh.md",
      "math.exp",
      "input.source",
      "input.float",
      "ta.sma",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-130",
    "type": "example",
    "category": "oscillators",
    "title": "Accelerator Oscillator (AC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Accelerator Oscillator (AC)\", \"AC\", overlay=false)\r\n\r\n//@function Calculates Bill Williams' Accelerator Oscillator\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/ac.md\r\n//@param fastLength Period for fast MA calculation\r\n//@param slowLength Period for slow MA calculation\r\n//@returns AC value measuring acceleration/deceleration of market momentum\r\nac(simple int fastLength, simple int slowLength) =>\r\n    if fastLength <= 0 or slowLength <= 0\r\n        runtime.error(\"Lengths must be greater than 0\")\r\n    if fastLength >= slowLength\r\n        runtime.error(\"Fast length must be less than slow length\")\r\n    float mp = (high + low) / 2.0\r\n    var array<float> fastBuf = array.new_float(fastLength, na)\r\n    var array<float> slowBuf = array.new_float(slowLength, na)\r\n    var int fastHead = 0, var int slowHead = 0\r\n    var float fastSum = 0.0, var float slowSum = 0.0\r\n    var int fastCount = 0, var int slowCount = 0\r\n    float fastOldest = array.get(fastBuf, fastHead)\r\n    if not na(fastOldest)\r\n        fastSum -= fastOldest\r\n        fastCount -= 1\r\n    if not na(mp)\r\n        fastSum += mp\r\n        fastCount += 1\r\n    array.set(fastBuf, fastHead, mp)\r\n    fastHead := (fastHead + 1) % fastLength\r\n    float slowOldest = array.get(slowBuf, slowHead)\r\n    if not na(slowOldest)\r\n        slowSum -= slowOldest\r\n        slowCount -= 1\r\n    if not na(mp)\r\n        slowSum += mp\r\n        slowCount += 1\r\n    array.set(slowBuf, slowHead, mp)\r\n    slowHead := (slowHead + 1) % slowLength\r\n    float fastMA = fastCount > 0 ? fastSum / fastCount : na\r\n    float slowMA = slowCount > 0 ? slowSum / slowCount : na\r\n    float ao = fastMA - slowMA\r\n    var array<float> acBuf = array.new_float(5, na)\r\n    var int acHead = 0, var float acSum = 0.0, var int acCount = 0\r\n    float acOldest = array.get(acBuf, acHead)\r\n    if not na(acOldest)\r\n        acSum -= acOldest\r\n        acCount -= 1\r\n    if not na(ao)\r\n        acSum += ao\r\n        acCount += 1\r\n    array.set(acBuf, acHead, ao)\r\n    acHead := (acHead + 1) % 5\r\n    float aoSMA = acCount > 0 ? acSum / acCount : na\r\n    ao - aoSMA\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_fastLength = input.int(5, \"Fast Length\", minval=1)\r\ni_slowLength = input.int(34, \"Slow Length\", minval=1)\r\n\r\n// Calculation\r\nac_value = ac(i_fastLength, i_slowLength)\r\n\r\n// Plot\r\nplot(ac_value, \"AC\", ac_value >= 0 ? color.green : color.red, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "plot"
    ],
    "keywords": [
      "accelerator oscillator (ac)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "plot",
      "github.com",
      "ac.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-131",
    "type": "example",
    "category": "oscillators",
    "title": "Awesome Oscillator (AO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Awesome Oscillator (AO)\", \"AO\", overlay=false)\r\n\r\n//@function Calculates Bill Williams' Awesome Oscillator\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/ao.md\r\n//@param fastLength Period for fast MA calculation\r\n//@param slowLength Period for slow MA calculation\r\n//@returns AO value measuring market momentum\r\nao(simple int fastLength, simple int slowLength) =>\r\n    if fastLength <= 0 or slowLength <= 0\r\n        runtime.error(\"Lengths must be greater than 0\")\r\n    if fastLength >= slowLength\r\n        runtime.error(\"Fast length must be less than slow length\")\r\n    float mp = (high + low) / 2.0\r\n    var array<float> fastBuf = array.new_float(fastLength, na)\r\n    var array<float> slowBuf = array.new_float(slowLength, na)\r\n    var int fastHead = 0, var int slowHead = 0\r\n    var float fastSum = 0.0, var float slowSum = 0.0\r\n    var int fastCount = 0, var int slowCount = 0\r\n    float fastOldest = array.get(fastBuf, fastHead)\r\n    if not na(fastOldest)\r\n        fastSum -= fastOldest\r\n        fastCount -= 1\r\n    if not na(mp)\r\n        fastSum += mp\r\n        fastCount += 1\r\n    array.set(fastBuf, fastHead, mp)\r\n    fastHead := (fastHead + 1) % fastLength\r\n    float slowOldest = array.get(slowBuf, slowHead)\r\n    if not na(slowOldest)\r\n        slowSum -= slowOldest\r\n        slowCount -= 1\r\n    if not na(mp)\r\n        slowSum += mp\r\n        slowCount += 1\r\n    array.set(slowBuf, slowHead, mp)\r\n    slowHead := (slowHead + 1) % slowLength\r\n    float fastMA = fastCount > 0 ? fastSum / fastCount : na\r\n    float slowMA = slowCount > 0 ? slowSum / slowCount : na\r\n    fastMA - slowMA\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_fastLength = input.int(5, \"Fast Length\", minval=1)\r\ni_slowLength = input.int(34, \"Slow Length\", minval=1)\r\n\r\n// Calculation\r\nao_value = ao(i_fastLength, i_slowLength)\r\nao_prev = ao_value[1]\r\n\r\n// Plot\r\nplot(ao_value, \"AO\", ao_value >= ao_prev ? color.green : color.red, linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "plot"
    ],
    "keywords": [
      "awesome oscillator (ao)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "plot",
      "github.com",
      "ao.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-132",
    "type": "example",
    "category": "oscillators",
    "title": "Absolute Price Oscillator (APO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Absolute Price Oscillator (APO)\", \"APO\", overlay=false)\r\n\r\n//@function Calculates Absolute Price Oscillator (APO) as difference between fast and slow EMAs\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/apo.md\r\n//@param source Series to calculate APO from\r\n//@param fastLength Period for fast EMA\r\n//@param slowLength Period for slow EMA\r\n//@returns APO value (fast EMA - slow EMA)\r\napo(series float source, simple int fastLength, simple int slowLength) =>\r\n    if fastLength <= 0 or slowLength <= 0\r\n        runtime.error(\"Lengths must be greater than 0\")\r\n    if fastLength >= slowLength\r\n        runtime.error(\"Fast length must be less than slow length\")\r\n    float alphaFast = 2.0 / (fastLength + 1.0)\r\n    float alphaSlow = 2.0 / (slowLength + 1.0)\r\n    var float emaFast = na var float emaSlow = na, var float e = 1.0\r\n    var bool warmup = true, var float result = na\r\n    if not na(source)\r\n        if na(emaFast)\r\n            emaFast := source, emaSlow := source, result := 0\r\n        else\r\n            emaFast := alphaFast * (source - emaFast) + emaFast\r\n            emaSlow := alphaSlow * (source - emaSlow) + emaSlow\r\n            if warmup\r\n                e *= (1.0 - alphaSlow)\r\n                float c = e > 1e-10 ? 1.0 / (1.0 - e) : 1.0\r\n                float aFast = emaFast * c\r\n                float aSlow = emaSlow * c\r\n                result := aFast - aSlow\r\n                if e <= 1e-10\r\n                    warmup := false\r\n            else\r\n                result := emaFast - emaSlow\r\n    result\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_fastLength = input.int(12, \"Fast Length\", minval=1)\r\ni_slowLength = input.int(26, \"Slow Length\", minval=1)\r\n\r\n// Calculation\r\napo_value = apo(i_source, i_fastLength, i_slowLength)\r\n\r\n// Plot\r\nplot(apo_value, \"APO\", color.new(color.yellow, 0), 2)\r\n",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "absolute price oscillator (apo)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "apo.md",
      "runtime.error",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-133",
    "type": "example",
    "category": "oscillators",
    "title": "Bollinger %B",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger %B\", \"BBB\", overlay=false)\n\n//@function Calculates Bollinger Bands components for %B calculation\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/bbb.md\n//@param source Series to calculate from\n//@param period Lookback period for SMA and standard deviation\n//@param multiplier Standard deviation multiplier for band width\n//@returns Bollinger %B value (typically 0-1 range; can overshoot)\n//@optimized Uses circular buffer with running sums, O(1) complexity per bar\nbbb(series float source, simple int period, simple float multiplier) =>\n    if period <= 0 or multiplier <= 0.0\n        runtime.error(\"Period and multiplier must be greater than 0\")\n\n    var int p = 0\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(0)\n    var float sum = 0.0\n    var float sumSq = 0.0\n    var string lastSymbol = \"\"\n    var string lastTimeframe = \"\"\n\n    string currentSymbol = syminfo.tickerid\n    string currentTimeframe = timeframe.period\n    bool needsReset = (p != period) or (currentSymbol != lastSymbol) or (currentTimeframe != lastTimeframe)\n\n    if needsReset\n        p := period\n        head := 0\n        count := 0\n        buffer := array.new_float(p, na)\n        sum := 0.0\n        sumSq := 0.0\n        lastSymbol := currentSymbol\n        lastTimeframe := currentTimeframe\n\n    float result = na\n\n    if not na(source)\n        float oldest = array.get(buffer, head)\n        if not na(oldest)\n            sum -= oldest\n            sumSq -= oldest * oldest\n        else\n            count += 1\n\n        sum += source\n        sumSq += source * source\n        array.set(buffer, head, source)\n        head := (head + 1) % p\n\n        int n = math.max(1, count)\n        float basis = sum / n\n        float variance = math.max(0.0, sumSq / n - basis * basis)\n        float stddev = math.sqrt(variance)\n        float dev = multiplier * stddev\n\n        float upper = basis + dev\n        float lower = basis - dev\n        float bandWidth = upper - lower\n\n        result := bandWidth > 0 ? (source - lower) / bandWidth : 0.5\n\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"StdDev Multiplier\", minval=0.001, step=0.1)\n\n// Calculation\nresult = bbb(i_source, i_period, i_multiplier)\n\n// Plot\nplot(result, \"Bollinger %B\", color=color.yellow, linewidth=2)\nhline(1.0, \"Upper Band Level\", color=color.gray, linestyle=hline.style_dashed)\nhline(0.8, \"Overbought\", color=color.red, linestyle=hline.style_dotted)\nhline(0.5, \"Midline\", color=color.gray, linestyle=hline.style_solid)\nhline(0.2, \"Oversold\", color=color.green, linestyle=hline.style_dotted)\nhline(0.0, \"Lower Band Level\", color=color.gray, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "timeframe.period",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.gray",
      "color.red",
      "color.green",
      "plot",
      "hline"
    ],
    "keywords": [
      "bollinger %b",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "timeframe.period",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.gray",
      "color.red",
      "color.green",
      "plot",
      "hline",
      "github.com",
      "bbb.md",
      "runtime.error",
      "array.new_float",
      "syminfo.tickerid",
      "timeframe.period",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "color.red",
      "hline.style_dotted",
      "hline.style_solid",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-134",
    "type": "example",
    "category": "oscillators",
    "title": "Bollinger Band Squeeze (BBS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger Band Squeeze (BBS)\", \"BBS\", overlay=true)\n\n//@function Calculates Bollinger Bands for squeeze detection\n//@param source Series to calculate from\n//@param period Lookback period\n//@returns tuple with [middle, deviation] values\nbbands_calc(series float source, simple int period) =>\n    var int p = math.max(1, period)\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0\n    var float sumSq = 0.0\n    \n    float oldest = array.get(buffer, head)\n    float current_val = nz(source)\n    \n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n    else\n        count := math.min(count + 1, p)\n    \n    sum += current_val\n    sumSq += current_val * current_val\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    \n    int n = math.max(1, count)\n    float basis = sum / n\n    float variance = n > 1 ? math.max(0.0, (sumSq / n) - (basis * basis)) : 0.0\n    float dev = math.sqrt(variance)\n    \n    [basis, dev]\n\n//@function Calculates Average True Range for Keltner Channels\n//@param period Lookback period for ATR calculation\n//@returns ATR value with proper warmup\natr_calc(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    float tr = math.max(high - low, math.max(math.abs(high - nz(close[1])), math.abs(low - nz(close[1]))))\n    float alpha = 2.0 / (period + 1)\n    float beta = 1.0 - alpha\n    \n    var bool warmup = true\n    var float e = 1.0\n    var float atr = 0.0\n    \n    atr := alpha * tr + beta * atr\n    \n    float result = tr\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := c * atr\n        warmup := e > 1e-10\n    else\n        result := atr\n    \n    result\n\n//@function Calculates Keltner Channels using SMA and ATR\n//@param source Series to calculate from\n//@param period Lookback period\n//@param atr_mult ATR multiplier for channel width\n//@param atr_val Pre-calculated ATR value\n//@returns tuple with [middle, upper, lower] channel values\nkeltner_calc(series float source, simple int period, simple float atr_mult, series float atr_val) =>\n    var int p = math.max(1, period)\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0\n    \n    float oldest = array.get(buffer, head)\n    float current_val = nz(source)\n    \n    if not na(oldest)\n        sum -= oldest\n    else\n        count := math.min(count + 1, p)\n    \n    sum += current_val\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    \n    int n = math.max(1, count)\n    float middle = sum / n\n    float offset = atr_mult * atr_val\n    \n    [middle, middle + offset, middle - offset]\n\n//@function Detects Bollinger Band Squeeze condition\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/bbs.md\n//@param source Series to analyze\n//@param bb_peri",
    "functions_used": [
      "math.max",
      "array.new_float",
      "array.get",
      "math.min",
      "array.set",
      "math.sqrt",
      "runtime.error",
      "math.abs",
      "input.int",
      "input.float",
      "input.source",
      "input.bool",
      "color.red",
      "color.green",
      "color.new",
      "color.blue",
      "color.orange",
      "plot",
      "bgcolor",
      "plotshape"
    ],
    "keywords": [
      "bollinger band squeeze (bbs)",
      "oscillators",
      "indicator",
      "v6",
      "math.max",
      "array.new_float",
      "array.get",
      "math.min",
      "array.set",
      "math.sqrt",
      "runtime.error",
      "math.abs",
      "input.int",
      "input.float",
      "input.source",
      "input.bool",
      "color.red",
      "color.green",
      "color.new",
      "color.blue",
      "color.orange",
      "plot",
      "bgcolor",
      "plotshape",
      "math.max",
      "array.new_float",
      "array.get",
      "math.min",
      "array.set",
      "math.sqrt",
      "runtime.error",
      "math.abs",
      "github.com",
      "bbs.md",
      "input.int",
      "input.float",
      "input.source",
      "input.bool",
      "shape.circle",
      "location.bottom",
      "color.red",
      "size.tiny",
      "color.green",
      "color.new",
      "color.blue",
      "color.orange",
      "indicator",
      "overlay",
      "input",
      "plot",
      "bgcolor",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-135",
    "type": "example",
    "category": "oscillators",
    "title": "Chande Forecast Oscillator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chande Forecast Oscillator\", \"CFO\", overlay=false)\n\n//@function Chande Forecast Oscillator - measures percentage difference between price and forecasted price\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/cfo.md\n//@param source Price data to analyze\n//@param period Number of bars for linear regression calculation\n//@returns Oscillator value showing forecast error percentage\n//@optimized O(1) complexity using incremental sumXY maintenance\ncfo(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if period > 5000\n        runtime.error(\"Period exceeds maximum of 5000\")\n    \n    var int count = 0\n    var int head = 0\n    var float sumY = 0.0\n    var float sumXY = 0.0\n    var array<float> buffer = array.new_float(period, na)\n    \n    if na(source)\n        na\n    else\n        float oldest = array.get(buffer, head)\n        if not na(oldest)\n            sumY -= oldest\n            sumXY -= sumY\n            sumXY += (period - 1) * source\n        else\n            sumXY += count * source\n            count += 1\n        \n        sumY += source\n        array.set(buffer, head, source)\n        head := (head + 1) % period\n        \n        if count < period\n            na\n        else\n            float sumX = period * (period - 1) / 2\n            float sumX2 = period * (period - 1) * (2 * period - 1) / 6\n            float denomX = period * sumX2 - sumX * sumX\n            \n            float slope = (period * sumXY - sumX * sumY) / denomX\n            float intercept = (sumY - slope * sumX) / period\n            float tsf = intercept + slope * (period - 1)\n            \n            float result = source == 0.0 ? na : 100.0 * (source - tsf) / source\n            result\n\n// ---------- Main loop ----------\n\ni_period = input.int(14, \"Period\", minval=1, maxval=5000)\ni_source = input.source(close, \"Source\")\n\nresult = cfo(i_source, i_period)\n\nplot(result, \"CFO\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_dotted)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "chande forecast oscillator",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "cfo.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "hline.style_dotted",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-136",
    "type": "example",
    "category": "oscillators",
    "title": "Detrended Price Oscillator (DPO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Detrended Price Oscillator (DPO)\", \"DPO\", overlay=false)\n\n//@function Calculates Detrended Price Oscillator (DPO) by removing trend component from price\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/dpo.md\n//@param source Series to calculate DPO from\n//@param period Period for SMA calculation and displacement\n//@returns DPO value (current price - displaced SMA)\ndpo(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int displacement = math.floor(period / 2) + 1\n    float sum = 0.0\n    for i = 0 to period - 1\n        sum += nz(source[i], source)\n    float sma = sum / period\n    float currentPrice = source\n    float displacedSMA = sma[displacement]\n    float result = na\n    if not na(displacedSMA)\n        result := currentPrice - displacedSMA\n    \n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_period = input.int(20, \"Period\", minval=1)\n\n// Calculation\ndpo_value = dpo(i_source, i_period)\n\n// Plot\nplot(dpo_value, \"DPO\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color.gray, hline.style_dotted)\n",
    "functions_used": [
      "runtime.error",
      "math.floor",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "detrended price oscillator (dpo)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "math.floor",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "dpo.md",
      "runtime.error",
      "math.floor",
      "input.source",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_dotted",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-137",
    "type": "example",
    "category": "oscillators",
    "title": "Fisher Transform",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Fisher Transform\", \"FISHER\", overlay=false)\n\n//@function Calculates the Fisher Transform oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/fisher.md\n//@param source Source price (typically hl2)\n//@param period Lookback period for min/max normalization\n//@returns [fisher, signal] Fisher Transform value and signal line\nfisher(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if period > 500\n        runtime.error(\"Period exceeds maximum of 500\")\n\n    var float value = 0.0\n    var float fisher = 0.0\n    var float signal = 0.0\n\n    float highest = ta.highest(source, period)\n    float lowest = ta.lowest(source, period)\n\n    float price_range = highest - lowest\n    float normalized = price_range > 0 ? (source - lowest) / price_range : 0.5\n    normalized := 2.0 * normalized - 1.0\n\n    float alpha = 0.33\n    value := alpha * normalized + (1.0 - alpha) * value\n\n    value := math.max(-0.999, math.min(0.999, value))\n\n    fisher := 0.5 * math.log((1.0 + value) / (1.0 - value))\n\n    signal := alpha * fisher + (1.0 - alpha) * signal\n\n    [fisher, signal]\n\n// ---------- Main loop ----------\n\ni_period = input.int(10, \"Period\", minval=1, maxval=500)\ni_source = input.source(hl2, \"Source\")\n\n[fisher_line, signal_line] = fisher(i_source, i_period)\n\nplot(fisher_line, \"Fisher\", color=color.yellow, linewidth=2)\nplot(signal_line, \"Signal\", color=color.orange, linewidth=1)\nhline(0, \"Zero\", color=color.gray, linestyle=hline.style_dotted)\nhline(2, \"Overbought\", color=color.red, linestyle=hline.style_dashed)\nhline(-2, \"Oversold\", color=color.green, linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "math.max",
      "math.min",
      "math.log",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "color.gray",
      "color.red",
      "color.green",
      "plot",
      "hline"
    ],
    "keywords": [
      "fisher transform",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "math.max",
      "math.min",
      "math.log",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "color.gray",
      "color.red",
      "color.green",
      "plot",
      "hline",
      "github.com",
      "fisher.md",
      "runtime.error",
      "ta.highest",
      "ta.lowest",
      "math.max",
      "math.min",
      "math.log",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "color.gray",
      "hline.style_dotted",
      "color.red",
      "hline.style_dashed",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-138",
    "type": "example",
    "category": "oscillators",
    "title": "Inertia",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Inertia\", \"INERTIA\", overlay=false)\n\n//@function Calculates Inertia oscillator measuring trend strength based on distance from linear regression\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/inertia.md\n//@param source Source series to calculate Inertia for\n//@param length Period for linear regression calculation\n//@returns Inertia value measuring trend strength\ninertia(series float source, simple int length) =>\n    if length <= 0\n        runtime.error(\"Length must be positive\")\n    if na(source)\n        na\n    else\n        available_bars = bar_index + 1\n        effective_length = math.min(length, available_bars)\n        sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0, sum_x2 = 0.0\n        for i = 0 to effective_length - 1\n            x = effective_length - 1 - i\n            y = nz(source[i])\n            sum_x += x, sum_y += y\n            sum_xy += x * y, sum_x2 += x * x\n        n = effective_length\n        denominator = n * sum_x2 - sum_x * sum_x\n        if denominator == 0\n            0.0 \n        else\n            slope = (n * sum_xy - sum_x * sum_y) / denominator\n            intercept = (sum_y - slope * sum_x) / n\n            regression_value = slope * (effective_length - 1) + intercept\n            source - regression_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1, maxval=500, tooltip=\"Period for linear regression calculation\")\ni_source = input.source(close, \"Source\", tooltip=\"Price series to analyze\")\n\n// Calculation\ninertia_value = inertia(i_source, i_length)\n\n// Plots\nplot(inertia_value, \"Inertia\", color=color.yellow, linewidth=2)\n\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "inertia",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "inertia.md",
      "runtime.error",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-139",
    "type": "example",
    "category": "oscillators",
    "title": "KDJ",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"KDJ\", \"KDJ\", overlay=false)\n\n//@function Calculates KDJ (K, D, J) lines - enhanced Stochastic Oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/kdj.md\n//@param high Series of high prices\n//@param low Series of low prices\n//@param close Series of close prices\n//@param length Lookback period for highest/lowest calculation\n//@param signal Smoothing period for K and D lines\n//@returns Tuple [K line, D line, J line]\n//@optimized Uses Wilder's RMA smoothing and deque min/max for highest/lowest, O(n) amortized\nkdj(series float high, series float low, series float close, simple int length, simple int signal) =>\n    if length <= 0 or signal <= 0\n        runtime.error(\"Length and signal must be greater than 0\")\n    if length > 500\n        runtime.error(\"Length exceeds maximum of 500\")\n\n    float alpha = 1.0 / signal\n    float beta = 1.0 - alpha\n    var bool warmupK = true\n    var bool warmupD = true\n    var float eK = 1.0\n    var float eD = 1.0\n    var float k = 0.0\n    var float d = 0.0\n    var float resultK = 50.0\n    var float resultD = 50.0\n\n    var int lastLength = 0\n    var array<int> maxDeque = array.new_int(0)\n    var array<int> minDeque = array.new_int(0)\n    var array<float> highBuffer = array.new_float(0)\n    var array<float> lowBuffer = array.new_float(0)\n\n    if length != lastLength\n        lastLength := length\n        maxDeque := array.new_int(0)\n        minDeque := array.new_int(0)\n        highBuffer := array.new_float(length, na)\n        lowBuffer := array.new_float(length, na)\n        warmupK := true\n        warmupD := true\n        eK := 1.0\n        eD := 1.0\n        k := 0.0\n        d := 0.0\n        resultK := 50.0\n        resultD := 50.0\n\n    if not na(high) and not na(low) and not na(close)\n        int currentBar = bar_index\n        int slot = currentBar % length\n\n        array.set(highBuffer, slot, high)\n        array.set(lowBuffer, slot, low)\n\n        while array.size(maxDeque) > 0 and array.get(maxDeque, 0) <= currentBar - length\n            array.shift(maxDeque)\n\n        while array.size(minDeque) > 0 and array.get(minDeque, 0) <= currentBar - length\n            array.shift(minDeque)\n\n        while array.size(maxDeque) > 0 and array.get(highBuffer, array.get(maxDeque, array.size(maxDeque) - 1) % length) <= high\n            array.pop(maxDeque)\n\n        while array.size(minDeque) > 0 and array.get(lowBuffer, array.get(minDeque, array.size(minDeque) - 1) % length) >= low\n            array.pop(minDeque)\n\n        array.push(maxDeque, currentBar)\n        array.push(minDeque, currentBar)\n\n        float highest = high\n        float lowest = low\n        if array.size(maxDeque) > 0\n            highest := array.get(highBuffer, array.get(maxDeque, 0) % length)\n        if array.size(minDeque) > 0\n            lowest := array.get(lowBuffer, array.get(minDeque, 0) % length)\n\n        float price_range = highest - lowest\n\n        float rsv = price",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.yellow",
      "color.orange",
      "color.gray",
      "color.lime",
      "color.green",
      "plot",
      "hline"
    ],
    "keywords": [
      "kdj",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.yellow",
      "color.orange",
      "color.gray",
      "color.lime",
      "color.green",
      "plot",
      "hline",
      "github.com",
      "kdj.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.max",
      "math.min",
      "input.int",
      "color.blue",
      "color.red",
      "color.yellow",
      "hline.style_dotted",
      "color.orange",
      "color.gray",
      "hline.style_solid",
      "color.lime",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-140",
    "type": "example",
    "category": "oscillators",
    "title": "Pretty Good Oscillator",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pretty Good Oscillator\", \"PGO\", overlay=false)\n\n//@function Calculate Pretty Good Oscillator (PGO)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/pgo.md\n//@param source Price data to analyze\n//@param period Number of bars for SMA and ATR calculation\n//@returns PGO value normalized by ATR\npgo(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if period > 5000\n        runtime.error(\"Period exceeds maximum of 5000\")\n    \n    var array<float> sma_buffer = array.new_float(period, na)\n    var int sma_head = 0\n    var float sma_sum = 0.0\n    var int valid_count = 0\n    \n    float oldest = array.get(sma_buffer, sma_head)\n    if not na(oldest)\n        sma_sum -= oldest\n        valid_count -= 1\n    \n    if not na(source)\n        sma_sum += source\n        valid_count += 1\n    \n    array.set(sma_buffer, sma_head, source)\n    sma_head := (sma_head + 1) % period\n    \n    float sma_value = nz(sma_sum / valid_count, source)\n    \n    float prevClose = nz(close[1], close)\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float tr = math.max(tr1, math.max(tr2, tr3))\n    \n    float a = 1.0 / float(period)\n    float beta = 1.0 - a\n    var bool warmup = true\n    var float e = 1.0\n    var float ema = 0.0\n    var float atr = nz(tr)\n    \n    ema := a * (nz(tr) - ema) + ema\n    \n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        atr := c * ema\n        warmup := e > 1e-10\n    else\n        atr := ema\n    \n    float pgo_value = atr > 0 ? (source - sma_value) / atr : na\n    \n    pgo_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1, maxval=500, tooltip=\"Number of bars for SMA and ATR calculation\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\nresult = pgo(i_source, i_period)\n\n// Plot\nplot(result, \"PGO\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_solid)\nhline(3, \"Overbought\", color=color.red, linestyle=hline.style_dashed)\nhline(-3, \"Oversold\", color=color.green, linestyle=hline.style_dashed)\n\n// Background coloring for extreme zones\nbgcolor(not na(result) and result > 3 ? color.new(color.red, 85) : not na(result) and result < -3 ? color.new(color.green, 85) : na)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.red",
      "color.green",
      "color.new",
      "plot",
      "hline",
      "bgcolor"
    ],
    "keywords": [
      "pretty good oscillator",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "color.red",
      "color.green",
      "color.new",
      "plot",
      "hline",
      "bgcolor",
      "github.com",
      "pgo.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.abs",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "color.gray",
      "hline.style_solid",
      "color.red",
      "hline.style_dashed",
      "color.green",
      "color.new",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "bgcolor",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-141",
    "type": "example",
    "category": "oscillators",
    "title": "Stochastic Momentum Index (SMI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Stochastic Momentum Index (SMI)\", \"SMI\", overlay=false)\n\n//@function Calculates Stochastic Momentum Index oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/smi.md\n//@param source Source series to calculate SMI for\n//@param k_period Lookback period for high/low range calculation\n//@param k_smooth First smoothing period for raw SMI values\n//@param d_smooth Second smoothing period for signal line\n//@param blau Use Blau method (true) or Chande/Kroll method (false)\n//@returns [%K, %D] values of Stochastic Momentum Index\nsmi(series float source, simple int k_period, simple int k_smooth, simple int d_smooth, simple bool blau) =>\n    if k_period <= 0 or k_smooth <= 0 or d_smooth <= 0\n        runtime.error(\"All periods must be positive\")\n    float src_clean = na(source) ? 0 : source\n    if na(source)\n        [na, na]\n    else\n        var array<float> high_buffer = array.new_float(0), var array<float> low_buffer = array.new_float(0)\n        array.push(high_buffer, nz(high)), array.push(low_buffer, nz(low))\n        if array.size(high_buffer) > k_period\n            array.shift(high_buffer)\n        if array.size(low_buffer) > k_period\n            array.shift(low_buffer)\n        highest_high = array.max(high_buffer), lowest_low = array.min(low_buffer)\n        midpoint = (highest_high + lowest_low) / 2, range_half = (highest_high - lowest_low) / 2\n        float a1 = 2.0 / (k_smooth + 1), float a2 = 2.0 / (k_smooth + 1), float a3 = 2.0 / (d_smooth + 1)\n        var float e1 = 1.0, var float e2 = 1.0, var float e3 = 1.0, var bool warmup = true\n        var float ema1_raw = 0.0, var float ema2_raw = 0.0, var float ema3_raw = 0.0\n        var float first_ema = 0.0, var float k_value = 0.0, var float d_value = 0.0\n        if blau\n            raw_smi = range_half > 0 ? 100 * (src_clean - midpoint) / range_half : 0\n            ema1_raw := a1 * (raw_smi - ema1_raw) + ema1_raw\n            if warmup\n                e1 *= (1 - a1), e2 *= (1 - a2), e3 *= (1 - a3)\n                float c1 = 1.0 / (1.0 - e1), float c2 = 1.0 / (1.0 - e2), float c3 = 1.0 / (1.0 - e3)\n                first_ema := ema1_raw * c1\n                ema2_raw := a2 * (first_ema - ema2_raw) + ema2_raw\n                k_value := ema2_raw * c2\n                ema3_raw := a3 * (k_value - ema3_raw) + ema3_raw\n                d_value := ema3_raw * c3\n                warmup := math.max(math.max(e1, e2), e3) > 1e-10\n            else\n                first_ema := ema1_raw\n                ema2_raw := a2 * (first_ema - ema2_raw) + ema2_raw\n                k_value := ema2_raw\n                ema3_raw := a3 * (k_value - ema3_raw) + ema3_raw\n                d_value := ema3_raw\n        else\n            var float num_ema1 = 0.0, var float num_ema2 = 0.0, var float den_ema1 = 0.0, var float den_ema2 = 0.0\n            var float num_first = 0.0, var float den_first = 0.0\n            numerator = src_clean - midpoint, denom",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "stochastic momentum index (smi)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "smi.md",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "math.max",
      "input.int",
      "input.source",
      "input.bool",
      "color.yellow",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-142",
    "type": "example",
    "category": "oscillators",
    "title": "Stochastic Oscillator (STOCH)",
    "version": "v6",
    "code": "//@version=6\nindicator(\"Stochastic Oscillator (STOCH)\", \"Stoch\", overlay=false)\n\n//@function Calculates the Stochastic Oscillator (%K and %D). %K = 100 * (close - lowest_low(kLength)) / (highest_high(kLength) - lowest_low(kLength)). %D = SMA(%K, dPeriod). Uses efficient deque implementation for min/max and buffer-based SMA.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/stoch.md\n//@param kLength `simple int` The lookback period for calculating highest high and lowest low.\n//@param dPeriod `simple int` The smoothing period for the %D line (SMA of %K).\n//@returns `[float, float]` A tuple containing the %K value and the %D value.\nstoch(simple int kLength,simple int dPeriod)=>\n    if kLength<=0 or dPeriod<=0\n        runtime.error(\"Both periods must be positive\")\n    var float kVal=0.0, var float dVal=0.0\n    var int dHead=0, var float dSum=0.0\n    var array<int>lowestDeque=array.new_int(0)\n    var array<float>lowestBuffer=array.new_float(kLength,na)\n    var array<int>highestDeque=array.new_int(0)\n    var array<float>highestBuffer=array.new_float(kLength,na)\n    var array<float>dBuffer=array.new_float(dPeriod,0.0)\n    int idx=bar_index%kLength\n    float lv=nz(low), float hv=nz(high)\n    array.set(lowestBuffer,idx,lv)\n    array.set(highestBuffer,idx,hv)\n    while array.size(lowestDeque)>0\n        if array.get(lowestDeque,0)<=bar_index-kLength\n            array.shift(lowestDeque)\n        else\n            break\n    while array.size(lowestDeque)>0\n        if array.get(lowestBuffer,array.get(lowestDeque,array.size(lowestDeque)-1)%kLength)>=lv\n            array.pop(lowestDeque)\n        else\n            break\n    array.push(lowestDeque,bar_index)\n    while array.size(highestDeque)>0\n        if array.get(highestDeque,0)<=bar_index-kLength\n            array.shift(highestDeque)\n        else\n            break\n    while array.size(highestDeque)>0\n        if array.get(highestBuffer,array.get(highestDeque,array.size(highestDeque)-1)%kLength)<=hv\n            array.pop(highestDeque)\n        else\n            break\n    array.push(highestDeque,bar_index)\n    int li=array.get(lowestDeque,0)\n    int hi=array.get(highestDeque,0)\n    float lowestLow=array.get(lowestBuffer,li%kLength)\n    float highestHigh=array.get(highestBuffer,hi%kLength)\n    float rnge=highestHigh-lowestLow\n    kVal:=rnge>0?100*(close-lowestLow)/rnge:0.0\n    if bar_index==0\n        dSum:=kVal*dPeriod\n        array.fill(dBuffer,kVal)\n    else\n        float oldVal=array.get(dBuffer,dHead)\n        dSum:=dSum-oldVal+kVal\n        array.set(dBuffer,dHead,kVal)\n        dHead:=(dHead+1)%dPeriod\n    dVal:=dSum/dPeriod\n    [kVal,dVal]\n\n\n// ---------- Main loop ----------\n\n// Inputs\nkPeriod = input.int(14, \"K Length\", minval=1)\ndPeriod = input.int(3, \"D Smooth\", minval=1)\n\n// Calculation\n[kValue, dValue] = stoch(kPeriod, dPeriod)\n\n// Plot\nplot(kValue, \"Stochastic %K\", color=color.green, linewidth=2)\nplot(dValue, \"Stochastic %D\", color=color.red, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "array.fill",
      "input.int",
      "color.green",
      "color.red",
      "plot",
      "fill"
    ],
    "keywords": [
      "stochastic oscillator (stoch)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "array.fill",
      "input.int",
      "color.green",
      "color.red",
      "plot",
      "fill",
      "github.com",
      "stoch.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "array.fill",
      "input.int",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-143",
    "type": "example",
    "category": "oscillators",
    "title": "Stochastic Fast (STOCHF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Stochastic Fast (STOCHF)\", \"STOCHF\", overlay=false)\n\n//@function Calculates the Stochastic Fast oscillator (%K and %D)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/stochf.md\n//@param kLength Period for calculating the raw %K line\n//@param dLength Smoothing period for the %D signal line\n//@returns [%K value, %D value] - fast stochastic oscillator values\nstochf(simple int kLength, simple int dLength) =>\n    if kLength <= 0 or dLength <= 0\n        runtime.error(\"Both periods must be positive\")\n    var array<int> lowestDeque = array.new_int(0)\n    var array<float> lowestBuffer = array.new_float(kLength, na)\n    var array<int> highestDeque = array.new_int(0)\n    var array<float> highestBuffer = array.new_float(kLength, na)\n    var array<float> dBuffer = array.new_float(dLength, na)\n    var int dHead = 0, var float dSum = 0.0, var int dCount = 0\n    int idx = bar_index % kLength\n    lv = nz(low), hv = nz(high), cv = nz(close)\n    array.set(lowestBuffer, idx, lv)\n    array.set(highestBuffer, idx, hv)\n    while array.size(lowestDeque) > 0\n        if array.get(lowestDeque, 0) <= bar_index - kLength\n            array.shift(lowestDeque)\n        else\n            break\n    while array.size(lowestDeque) > 0\n        if array.get(lowestBuffer, array.get(lowestDeque, array.size(lowestDeque) - 1) % kLength) >= lv\n            array.pop(lowestDeque)\n        else\n            break\n    array.push(lowestDeque, bar_index)\n    while array.size(highestDeque) > 0\n        if array.get(highestDeque, 0) <= bar_index - kLength\n            array.shift(highestDeque)\n        else\n            break\n    while array.size(highestDeque) > 0\n        if array.get(highestBuffer, array.get(highestDeque, array.size(highestDeque) - 1) % kLength) <= hv\n            array.pop(highestDeque)\n        else\n            break\n    array.push(highestDeque, bar_index)\n    li = array.get(lowestDeque, 0), hi = array.get(highestDeque, 0)\n    lowestLow = array.get(lowestBuffer, li % kLength)\n    highestHigh = array.get(highestBuffer, hi % kLength)\n    range_val = highestHigh - lowestLow\n    kVal = range_val > 0 ? 100 * (cv - lowestLow) / range_val : 0.0\n    oldest = array.get(dBuffer, dHead)\n    dSum := not na(oldest) ? dSum - oldest : dSum\n    dCount := not na(oldest) ? dCount - 1 : dCount\n    dSum := not na(kVal) ? dSum + kVal : dSum\n    dCount := not na(kVal) ? dCount + 1 : dCount\n    array.set(dBuffer, dHead, kVal)\n    dHead := (dHead + 1) % dLength\n    dVal = dCount > 0 ? dSum / dCount : kVal\n    [kVal, dVal]\n\n// ---------- Main loop ----------\n\n// Inputs\nkLength = input.int(5, \"K Length\", minval=1, maxval=100, tooltip=\"Period for calculating the raw %K line\")\ndLength = input.int(3, \"D Length\", minval=1, maxval=50, tooltip=\"Smoothing period for the %D signal line\")\n\n// Calculation\n[kValue, dValue] = stochf(kLength, dLength)\n\n// Plots\nplot(kValue, \"Fast %K\", color=color.yellow, linewidth=2)\nplot(dValue, \"",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "stochastic fast (stochf)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "stochf.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "input.int",
      "color.yellow",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-144",
    "type": "example",
    "category": "oscillators",
    "title": "Stochastic RSI (STOCHRSI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Stochastic RSI (STOCHRSI)\", \"StochRSI\", overlay=false)\n\n//@function Calculates Stochastic RSI oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/stochrsi.md\n//@param source Source series to calculate STOCHRSI for\n//@param rsi_length Period for RSI calculation\n//@param stoch_length Lookback period for Stochastic calculation on RSI\n//@param k_smooth Smoothing period for %K line\n//@param d_smooth Smoothing period for %D line\n//@returns [%K, %D] values of Stochastic RSI\nstochrsi(series float source, simple int rsi_length, simple int stoch_length, simple int k_smooth, simple int d_smooth) =>\n    if rsi_length <= 0 or stoch_length <= 0 or k_smooth <= 0 or d_smooth <= 0\n        runtime.error(\"All periods must be positive\")\n    float src_clean = na(source) ? 0 : source\n    float u = math.max(src_clean - nz(src_clean[1]), 0)\n    float d = math.max(nz(src_clean[1]) - src_clean, 0)\n    float alpha = 1/rsi_length\n    var float smoothUp = 0.0, var float smoothDown = 0.0\n    if bar_index < rsi_length\n        smoothUp := u\n        smoothDown := d\n    else\n        smoothUp := nz(smoothUp[1]) * (1 - alpha) + u * alpha\n        smoothDown := nz(smoothDown[1]) * (1 - alpha) + d * alpha\n    float rs = smoothDown == 0 ? 0 : smoothUp/smoothDown\n    float rsi_val = smoothDown == 0 ? 100 : 100 - (100 / (1 + rs))\n    if na(source)\n        [na, na]\n    else\n        var array<float> rsi_buffer = array.new_float(0)\n        array.push(rsi_buffer, rsi_val)\n        if array.size(rsi_buffer) > stoch_length\n            array.shift(rsi_buffer)\n        highest_rsi = array.max(rsi_buffer)\n        lowest_rsi = array.min(rsi_buffer)\n        rsi_range = highest_rsi - lowest_rsi\n        k_raw = rsi_range > 0 ? 100 * (rsi_val - lowest_rsi) / rsi_range : 50\n        var array<float> k_buffer = array.new_float(0)\n        array.push(k_buffer, k_raw)\n        if array.size(k_buffer) > k_smooth\n            array.shift(k_buffer)\n        k_smoothed = array.sum(k_buffer) / array.size(k_buffer)\n        var array<float> d_buffer = array.new_float(0)\n        array.push(d_buffer, k_smoothed)\n        if array.size(d_buffer) > d_smooth\n            array.shift(d_buffer)\n        d_smoothed = array.sum(d_buffer) / array.size(d_buffer)\n        [k_smoothed, d_smoothed]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_rsi_length = input.int(14, \"RSI Length\", minval=1, maxval=100, tooltip=\"Period for RSI calculation\")\ni_stoch_length = input.int(14, \"Stochastic Length\", minval=1, maxval=100, tooltip=\"Lookback period for Stochastic calculation on RSI\")\ni_k_smooth = input.int(3, \"%K Smooth\", minval=1, maxval=20, tooltip=\"Smoothing period for %K line\")\ni_d_smooth = input.int(3, \"%D Smooth\", minval=1, maxval=20, tooltip=\"Smoothing period for %D line\")\ni_source = input.source(close, \"Source\", tooltip=\"Price series to analyze\")\n\n// Calculation\n[k_value, d_value] = stochrsi(i_source, i_rsi_length, i_stoch_length, i_",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "array.sum",
      "input.int",
      "input.source",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "stochastic rsi (stochrsi)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "array.sum",
      "input.int",
      "input.source",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "stochrsi.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.push",
      "array.size",
      "array.shift",
      "array.max",
      "array.min",
      "array.sum",
      "input.int",
      "input.source",
      "color.yellow",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-145",
    "type": "example",
    "category": "oscillators",
    "title": "TRIX",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"TRIX\", \"TRIX\", overlay=false)\n\n//@function Calculates TRIX oscillator with compensation\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/trix.md\n//@param source Series to calculate TRIX from\n//@param period Period for triple exponential smoothing\n//@returns TRIX value (percentage rate of change of triple EMA)\ntrix(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be positive\")\n    float src = na(source) ? source[1] : source\n    float alpha = 2.0 / (period + 1)\n    float d = 1 - alpha\n    var float e1 = 1.0, var float e2 = 1.0, var float e3 = 1.0\n    var bool warmup = true\n    var float rema1 = 0, var float rema2 = 0, var float rema3 = 0\n    var float ema1 = src, var float ema2 = src, var float ema3 = src\n    var float prev_ema3 = src\n    rema1 := alpha * (src - rema1) + rema1\n    if warmup\n        e1 *= d, e2 *= d, e3 *= d\n        ema1 := rema1 / (1.0 - e1)\n        rema2 := alpha * (ema1 - rema2) + rema2\n        ema2 := rema2 / (1.0 - e2)\n        rema3 := alpha * (ema2 - rema3) + rema3\n        ema3 := rema3 / (1.0 - e3)\n        warmup := e1 > 1e-10\n    else\n        ema1 := rema1\n        rema2 := alpha * (ema1 - rema2) + rema2\n        ema2 := rema2\n        rema3 := alpha * (ema2 - rema3) + rema3\n        ema3 := rema3\n    trix_value = prev_ema3 != 0 ? 100 * (ema3 - prev_ema3) / prev_ema3 : 0\n    prev_ema3 := ema3\n    na(source) ? na : trix_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1, maxval=100, tooltip=\"Period for triple exponential smoothing\")\ni_source = input.source(close, \"Source\", tooltip=\"Price series to analyze\")\n\n// Calculation\ntrix_value = trix(i_source, i_period)\n\n// Plot\nplot(trix_value, \"TRIX\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "trix",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "trix.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-146",
    "type": "example",
    "category": "oscillators",
    "title": "Ultimate Oscillator (ULTOSC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ultimate Oscillator (ULTOSC)\", \"ULTOSC\", overlay=false)\n\n//@function Calculates the Ultimate Oscillator using three weighted time periods\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/ultosc.md\n//@param fastPeriod Short-term period for momentum calculation\n//@param mediumPeriod Medium-term period for momentum calculation\n//@param slowPeriod Long-term period for momentum calculation\n//@param fastWeight Weight applied to fast period calculation\n//@param mediumWeight Weight applied to medium period calculation\n//@param slowWeight Weight applied to slow period calculation\n//@returns Ultimate Oscillator value (0-100 scale)\nultosc(simple int fastPeriod, simple int mediumPeriod, simple int slowPeriod, simple float fastWeight, simple float mediumWeight, simple float slowWeight) =>\n    if fastPeriod <= 0 or mediumPeriod <= 0 or slowPeriod <= 0\n        runtime.error(\"All periods must be positive\")\n    if fastPeriod >= mediumPeriod or mediumPeriod >= slowPeriod\n        runtime.error(\"Periods must be in ascending order: fast < medium < slow\")\n    if fastWeight <= 0 or mediumWeight <= 0 or slowWeight <= 0\n        runtime.error(\"All weights must be positive\")\n    prev_close = nz(close[1], close)\n    true_low = math.min(low, prev_close)\n    true_high = math.max(high, prev_close)\n    buying_pressure = close - true_low\n    true_range = true_high - true_low\n    var array<float> bp_fast_buffer = array.new_float(fastPeriod, na)\n    var array<float> tr_fast_buffer = array.new_float(fastPeriod, na)\n    var array<float> bp_medium_buffer = array.new_float(mediumPeriod, na)\n    var array<float> tr_medium_buffer = array.new_float(mediumPeriod, na)\n    var array<float> bp_slow_buffer = array.new_float(slowPeriod, na)\n    var array<float> tr_slow_buffer = array.new_float(slowPeriod, na)\n    var int fast_head = 0, var int medium_head = 0, var int slow_head = 0\n    var float bp_fast_sum = 0.0, var float tr_fast_sum = 0.0\n    var float bp_medium_sum = 0.0, var float tr_medium_sum = 0.0\n    var float bp_slow_sum = 0.0, var float tr_slow_sum = 0.0\n    var int fast_count = 0, var int medium_count = 0, var int slow_count = 0\n    bp_fast_oldest = array.get(bp_fast_buffer, fast_head)\n    tr_fast_oldest = array.get(tr_fast_buffer, fast_head)\n    bp_fast_sum := not na(bp_fast_oldest) ? bp_fast_sum - bp_fast_oldest : bp_fast_sum\n    tr_fast_sum := not na(tr_fast_oldest) ? tr_fast_sum - tr_fast_oldest : tr_fast_sum\n    fast_count := not na(bp_fast_oldest) ? fast_count - 1 : fast_count\n    bp_fast_sum := not na(buying_pressure) ? bp_fast_sum + buying_pressure : bp_fast_sum\n    tr_fast_sum := not na(true_range) ? tr_fast_sum + true_range : tr_fast_sum\n    fast_count := not na(buying_pressure) ? fast_count + 1 : fast_count\n    array.set(bp_fast_buffer, fast_head, buying_pressure)\n    array.set(tr_fast_buffer, fast_head, true_range)\n    fast_head := (fast_head + 1) % fastPeriod\n    bp_medium_ol",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ultimate oscillator (ultosc)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "ultosc.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-147",
    "type": "example",
    "category": "oscillators",
    "title": "Williams %R (WILLR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Williams %R (WILLR)\", \"WILLR\", overlay=false)\n\n//@function Calculates Williams %R oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/oscillators/willr.md\n//@param period Lookback period for highest high and lowest low calculation\n//@returns Williams %R value (-100 to 0 scale)\nwillr(simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be positive\")\n    var array<float> high_buffer = array.new_float(period, na)\n    var array<float> low_buffer = array.new_float(period, na)\n    var int head = 0, var int count = 0\n    idx = head % period\n    old_high = array.get(high_buffer, idx)\n    if not na(old_high)\n        count := count - 1\n    array.set(high_buffer, idx, high)\n    array.set(low_buffer, idx, low)\n    count := count + 1\n    head := head + 1\n    highest_high = array.max(high_buffer)\n    lowest_low = array.min(low_buffer)\n    range_val = highest_high - lowest_low\n    range_val > 0 ? -100 * (highest_high - close) / range_val : -50\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1, maxval=100, tooltip=\"Lookback period for highest high and lowest low calculation\")\n\n// Calculation\nwillr_value = willr(i_period)\n\n// Plots\nplot(willr_value, \"Williams %R\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "array.max",
      "array.min",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "williams %r (willr)",
      "oscillators",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "array.max",
      "array.min",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "willr.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "array.max",
      "array.min",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-148",
    "type": "example",
    "category": "reversals",
    "title": "Williams Fractals",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Williams Fractals\", \"FRACTALS\", overlay=true)\n\n//@function Detects Williams Fractal patterns (5-bar pattern)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/fractals.md\n//@returns Tuple [up_fractal, down_fractal] with fractal values (na if no fractal)\nfractals() =>\n    bool is_up_fractal = false\n    bool is_down_fractal = false\n    \n    if bar_index >= 4\n        is_up_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]\n        is_down_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]\n    \n    float up_fractal_value = is_up_fractal ? high[2] : na\n    float down_fractal_value = is_down_fractal ? low[2] : na\n    \n    [up_fractal_value, down_fractal_value]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_show_up = input.bool(true, \"Show Up Fractals\", tooltip=\"Display bearish fractals (resistance)\")\ni_show_down = input.bool(true, \"Show Down Fractals\", tooltip=\"Display bullish fractals (support)\")\ni_color_up = input.color(color.red, \"Up Fractal Color\")\ni_color_down = input.color(color.green, \"Down Fractal Color\")\n\n// Calculation\n[up_fractal, down_fractal] = fractals()\n\n// Plot fractal markers\nplotshape(i_show_up and not na(up_fractal) ? up_fractal : na, \"Up Fractal\", style=shape.triangledown, location=location.absolute, color=i_color_up, size=size.small, offset=-2)\nplotshape(i_show_down and not na(down_fractal) ? down_fractal : na, \"Down Fractal\", style=shape.triangleup, location=location.absolute, color=i_color_down, size=size.small, offset=-2)\n",
    "functions_used": [
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "plotshape"
    ],
    "keywords": [
      "williams fractals",
      "reversals",
      "indicator",
      "v6",
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "plotshape",
      "github.com",
      "fractals.md",
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "shape.triangledown",
      "location.absolute",
      "size.small",
      "shape.triangleup",
      "indicator",
      "overlay",
      "input",
      "plot",
      "if"
    ]
  },
  {
    "id": "script-149",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (Classic)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (Classic)\", \"PIVOT\", overlay=true)\n\n//@function Calculates classic/standard/floor pivot points\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivot.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels\n//@references Floor traders, standard pivot point formula\npivot(simple string tf) =>\n    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(cl)\n        [na, na, na, na, na, na, na]\n    else\n        float pp = (hi + lo + cl) / 3.0\n        float r1 = 2.0 * pp - lo\n        float s1 = 2.0 * pp - hi\n        float r2 = pp + (hi - lo)\n        float s2 = pp - (hi - lo)\n        float r3 = hi + 2.0 * (pp - lo)\n        float s3 = lo - 2.0 * (hi - pp)\n        [pp, r1, r2, r3, s1, s2, s3]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1\")\ni_show_r2 = input.bool(true, \"Show R2\")\ni_show_r3 = input.bool(true, \"Show R3\")\ni_show_s1 = input.bool(true, \"Show S1\")\ni_show_s2 = input.bool(true, \"Show S2\")\ni_show_s3 = input.bool(true, \"Show S3\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, r2, r3, s1, s2, s3] = pivot(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r2 ? r2 : na, \"R2\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r3 ? r3 : na, \"R3\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s2 ? s2 : na, \"S2\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s3 ? s3 : na, \"S3\", color=i_color_s, linewidth=1, style=plot.style_stepline)\n",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (classic)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivot.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-150",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (Camarilla)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (Camarilla)\", \"PIVOTCAM\", overlay=true)\n\n//@function Calculates Camarilla pivot points with 8 levels for short-term trading\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivotcam.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, r2, r3, r4, s1, s2, s3, s4] with pivot levels\n//@references Nick Scott, Camarilla equation\npivotcam(simple string tf) =>\n    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(cl)\n        [na, na, na, na, na, na, na, na, na]\n    else\n        float pp = (hi + lo + cl) / 3.0\n        float hl_range = hi - lo\n        float r1 = cl + hl_range * 1.0833 / 12.0\n        float s1 = cl - hl_range * 1.0833 / 12.0\n        float r2 = cl + hl_range * 1.1666 / 12.0\n        float s2 = cl - hl_range * 1.1666 / 12.0\n        float r3 = cl + hl_range * 1.2500 / 12.0\n        float s3 = cl - hl_range * 1.2500 / 12.0\n        float r4 = cl + hl_range * 1.5000 / 12.0\n        float s4 = cl - hl_range * 1.5000 / 12.0\n        [pp, r1, r2, r3, r4, s1, s2, s3, s4]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1\")\ni_show_r2 = input.bool(true, \"Show R2\")\ni_show_r3 = input.bool(true, \"Show R3\")\ni_show_r4 = input.bool(true, \"Show R4\")\ni_show_s1 = input.bool(true, \"Show S1\")\ni_show_s2 = input.bool(true, \"Show S2\")\ni_show_s3 = input.bool(true, \"Show S3\")\ni_show_s4 = input.bool(true, \"Show S4\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, r2, r3, r4, s1, s2, s3, s4] = pivotcam(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r2 ? r2 : na, \"R2\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r3 ? r3 : na, \"R3\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r4 ? r4 : na, \"R4\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s2 ? s2 : na, \"S2\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s3 ? s3 : na, \"S3\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s4 ? s4 : na, \"S4\", color=i_color_s, linewidth=1, style=plot.style_stepline)\n",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (camarilla)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivotcam.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-151",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (DeMark)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (DeMark)\", \"PIVOTDEM\", overlay=true)\n\n//@function Calculates DeMark pivot points with conditional open/close logic\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivotdem.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, s1] with pivot levels (only 3 levels)\n//@references Tom DeMark, conditional pivot formula\npivotdem(simple string tf) =>\n    [hi, lo, op, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], open[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(op) or na(cl)\n        [na, na, na]\n    else\n        float x = 0.0\n        if cl < op\n            x := hi + 2.0 * lo + cl\n        else if cl > op\n            x := 2.0 * hi + lo + cl\n        else\n            x := hi + lo + 2.0 * cl\n        float pp = x / 4.0\n        float r1 = x / 2.0 - lo\n        float s1 = x / 2.0 - hi\n        [pp, r1, s1]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1\")\ni_show_s1 = input.bool(true, \"Show S1\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, s1] = pivotdem(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\n",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (demark)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivotdem.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-152",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (Extended)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (Extended)\", \"PIVOTEXT\", overlay=true)\n\n//@function Calculates extended traditional pivot points with R4-R5 and S4-S5 levels\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivotext.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, r2, r3, r4, r5, s1, s2, s3, s4, s5] with pivot levels\n//@references Extended floor trader pivot formula\npivotext(simple string tf) =>\n    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(cl)\n        [na, na, na, na, na, na, na, na, na, na, na]\n    else\n        float pp = (hi + lo + cl) / 3.0\n        float hl_range = hi - lo\n        float r1 = 2.0 * pp - lo\n        float s1 = 2.0 * pp - hi\n        float r2 = pp + hl_range\n        float s2 = pp - hl_range\n        float r3 = hi + 2.0 * (pp - lo)\n        float s3 = lo - 2.0 * (hi - pp)\n        float r4 = hi + 3.0 * (pp - lo)\n        float s4 = lo - 3.0 * (hi - pp)\n        float r5 = hi + 4.0 * (pp - lo)\n        float s5 = lo - 4.0 * (hi - pp)\n        [pp, r1, r2, r3, r4, r5, s1, s2, s3, s4, s5]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1\")\ni_show_r2 = input.bool(true, \"Show R2\")\ni_show_r3 = input.bool(true, \"Show R3\")\ni_show_r4 = input.bool(true, \"Show R4\")\ni_show_r5 = input.bool(true, \"Show R5\")\ni_show_s1 = input.bool(true, \"Show S1\")\ni_show_s2 = input.bool(true, \"Show S2\")\ni_show_s3 = input.bool(true, \"Show S3\")\ni_show_s4 = input.bool(true, \"Show S4\")\ni_show_s5 = input.bool(true, \"Show S5\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, r2, r3, r4, r5, s1, s2, s3, s4, s5] = pivotext(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r2 ? r2 : na, \"R2\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r3 ? r3 : na, \"R3\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r4 ? r4 : na, \"R4\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r5 ? r5 : na, \"R5\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s2 ? s2 : na, \"S2\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s3 ? s3 : na, \"S3\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s4 ? s4 : na, \"S4\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s5 ? s5 : na, \"S5\", color=i_color_s, linew",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (extended)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivotext.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-153",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (Fibonacci)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (Fibonacci)\", \"PIVOTFIB\", overlay=true)\n\n//@function Calculates Fibonacci pivot points using Fibonacci ratios\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivotfib.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels\n//@references Fibonacci retracement levels applied to pivot points\npivotfib(simple string tf) =>\n    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(cl)\n        [na, na, na, na, na, na, na]\n    else\n        float pp = (hi + lo + cl) / 3.0\n        float hl_range = hi - lo\n        float r1 = pp + 0.382 * hl_range\n        float s1 = pp - 0.382 * hl_range\n        float r2 = pp + 0.618 * hl_range\n        float s2 = pp - 0.618 * hl_range\n        float r3 = pp + 1.000 * hl_range\n        float s3 = pp - 1.000 * hl_range\n        [pp, r1, r2, r3, s1, s2, s3]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1 (38.2%)\")\ni_show_r2 = input.bool(true, \"Show R2 (61.8%)\")\ni_show_r3 = input.bool(true, \"Show R3 (100%)\")\ni_show_s1 = input.bool(true, \"Show S1 (38.2%)\")\ni_show_s2 = input.bool(true, \"Show S2 (61.8%)\")\ni_show_s3 = input.bool(true, \"Show S3 (100%)\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, r2, r3, s1, s2, s3] = pivotfib(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r2 ? r2 : na, \"R2\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r3 ? r3 : na, \"R3\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s2 ? s2 : na, \"S2\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s3 ? s3 : na, \"S3\", color=i_color_s, linewidth=1, style=plot.style_stepline)\n",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (fibonacci)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivotfib.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-154",
    "type": "example",
    "category": "reversals",
    "title": "Pivot Points (Woodie)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pivot Points (Woodie)\", \"PIVOTWOOD\", overlay=true)\n\n//@function Calculates Woodie's pivot points with weighted closing price\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/pivotwood.md\n//@param tf Timeframe for pivot calculation (\"D\", \"W\", \"M\")\n//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels\n//@references Ken Woodie, weighted close formula\npivotwood(simple string tf) =>\n    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)\n    if na(hi) or na(lo) or na(cl)\n        [na, na, na, na, na, na, na]\n    else\n        float pp = (hi + lo + 2.0 * cl) / 4.0\n        float r1 = 2.0 * pp - lo\n        float s1 = 2.0 * pp - hi\n        float r2 = pp + (hi - lo)\n        float s2 = pp - (hi - lo)\n        float r3 = hi + 2.0 * (pp - lo)\n        float s3 = lo - 2.0 * (hi - pp)\n        [pp, r1, r2, r3, s1, s2, s3]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_timeframe = input.timeframe(\"D\", \"Pivot Timeframe\", options=[\"D\", \"W\", \"M\"])\ni_show_pp = input.bool(true, \"Show Pivot Point\")\ni_show_r1 = input.bool(true, \"Show R1\")\ni_show_r2 = input.bool(true, \"Show R2\")\ni_show_r3 = input.bool(true, \"Show R3\")\ni_show_s1 = input.bool(true, \"Show S1\")\ni_show_s2 = input.bool(true, \"Show S2\")\ni_show_s3 = input.bool(true, \"Show S3\")\ni_color_pp = input.color(color.yellow, \"PP Color\")\ni_color_r = input.color(color.red, \"Resistance Color\")\ni_color_s = input.color(color.green, \"Support Color\")\n\n// Calculation\n[pp, r1, r2, r3, s1, s2, s3] = pivotwood(i_timeframe)\n\n// Plot\nplot(i_show_pp ? pp : na, \"PP\", color=i_color_pp, linewidth=2, style=plot.style_stepline)\nplot(i_show_r1 ? r1 : na, \"R1\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r2 ? r2 : na, \"R2\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_r3 ? r3 : na, \"R3\", color=i_color_r, linewidth=1, style=plot.style_stepline)\nplot(i_show_s1 ? s1 : na, \"S1\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s2 ? s2 : na, \"S2\", color=i_color_s, linewidth=1, style=plot.style_stepline)\nplot(i_show_s3 ? s3 : na, \"S3\", color=i_color_s, linewidth=1, style=plot.style_stepline)\n",
    "functions_used": [
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "pivot points (woodie)",
      "reversals",
      "indicator",
      "v6",
      "request.security",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "pivotwood.md",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "input.timeframe",
      "input.bool",
      "input.color",
      "color.yellow",
      "color.red",
      "color.green",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-155",
    "type": "example",
    "category": "reversals",
    "title": "Parabolic SAR",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Parabolic SAR\", \"PSAR\", overlay=true)\n\n//@function Calculates Parabolic Stop And Reverse (SAR)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/psar.md\n//@param af_start Initial acceleration factor (Wilder's original: 0.02)\n//@param af_increment Acceleration factor increment per new extreme (Wilder's original: 0.02)\n//@param af_max Maximum acceleration factor (Wilder's original: 0.20)\n//@returns SAR value (stop level for current trend)\n//@optimized Minimal state variables, O(1) per bar\npsar(simple float af_start=0.02, simple float af_increment=0.02, simple float af_max=0.20) =>\n    if af_start <= 0 or af_start > af_max\n        runtime.error(\"Start AF must be > 0 and <= Max AF\")\n    if af_increment <= 0\n        runtime.error(\"AF increment must be > 0\")\n    if af_max <= af_start\n        runtime.error(\"Max AF must be > Start AF\")\n    var bool is_long = true\n    var float sar = low\n    var float ep = high\n    var float af = af_start\n    if bar_index == 0\n        is_long := close > open\n        sar := is_long ? low : high\n        ep := is_long ? high : low\n        af := af_start\n    else\n        float new_sar = sar + af * (ep - sar)\n        bool reverse = false\n        if is_long\n            new_sar := math.min(new_sar, low[1])\n            if bar_index > 1\n                new_sar := math.min(new_sar, low[2])\n            if low < new_sar\n                reverse := true\n                is_long := false\n                new_sar := ep\n                ep := low\n                af := af_start\n            else\n                if high > ep\n                    ep := high\n                    af := math.min(af + af_increment, af_max)\n        else\n            new_sar := math.max(new_sar, high[1])\n            if bar_index > 1\n                new_sar := math.max(new_sar, high[2])\n            if high > new_sar\n                reverse := true\n                is_long := true\n                new_sar := ep\n                ep := high\n                af := af_start\n            else\n                if low < ep\n                    ep := low\n                    af := math.min(af + af_increment, af_max)\n        sar := new_sar\n    sar\n\n// ---------- Main loop ----------\n\n// Inputs\ni_af_start = input.float(0.02, \"Start AF\", minval=0.001, maxval=1.0, step=0.001)\ni_af_increment = input.float(0.02, \"AF Increment\", minval=0.001, maxval=1.0, step=0.001)\ni_af_max = input.float(0.20, \"Max AF\", minval=0.001, maxval=1.0, step=0.01)\n\n// Calculation\npsar = psar(i_af_start, i_af_increment, i_af_max)\npsar_above = psar > close ? psar : na\npsar_below = psar < close ? psar : na\n\n// Plot\nplot(psar_above, \"PSAR Above\", color=color.red,   style=plot.style_linebr, linewidth=2)\nplot(psar_below, \"PSAR Below\", color=color.green, style=plot.style_linebr, linewidth=2)\n\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "input.float",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "parabolic sar",
      "reversals",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "input.float",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "psar.md",
      "runtime.error",
      "math.min",
      "math.max",
      "input.float",
      "color.red",
      "plot.style_linebr",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-156",
    "type": "example",
    "category": "reversals",
    "title": "Swing High/Low Detection",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Swing High/Low Detection\", \"SWINGS\", overlay=true)\n\n//@function Detects swing highs and swing lows using lookback period\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/reversals/swings.md\n//@param lookback Number of bars on each side to confirm swing point\n//@param source_high Price series for swing high detection (typically high)\n//@param source_low Price series for swing low detection (typically low)\n//@returns Tuple [swing_high, swing_low] with swing point values (na if no swing)\nswings(simple int lookback, series float source_high, series float source_low) =>\n    if lookback <= 0\n        runtime.error(\"Lookback must be greater than 0\")\n    if lookback > 100\n        runtime.error(\"Lookback exceeds maximum of 100\")\n    bool is_swing_high = true\n    bool is_swing_low = true\n    if bar_index < lookback * 2\n        is_swing_high := false\n        is_swing_low := false\n    else\n        float center_high = source_high[lookback]\n        float center_low = source_low[lookback]\n        for i = 1 to lookback\n            if source_high[lookback - i] > center_high or source_high[lookback + i] > center_high\n                is_swing_high := false\n            if source_low[lookback - i] < center_low or source_low[lookback + i] < center_low\n                is_swing_low := false\n    float swing_high_value = is_swing_high ? source_high[lookback] : na\n    float swing_low_value = is_swing_low ? source_low[lookback] : na\n    [swing_high_value, swing_low_value]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_lookback = input.int(5, \"Lookback Period\", minval=1, maxval=100, tooltip=\"Number of bars on each side to confirm swing point\")\ni_source_high = input.source(high, \"Source High\", tooltip=\"Price series for swing high detection\")\ni_source_low = input.source(low, \"Source Low\", tooltip=\"Price series for swing low detection\")\ni_show_high = input.bool(true, \"Show Swing High Lines\")\ni_show_low = input.bool(true, \"Show Swing Low Lines\")\ni_color_high = input.color(color.red, \"Swing High Color\")\ni_color_low = input.color(color.green, \"Swing Low Color\")\n\n// Calculation\n[swing_high, swing_low] = swings(i_lookback, i_source_high, i_source_low)\n\n// Track last confirmed swing points\nvar float last_swing_high = na\nvar float last_swing_low = na\n\n// Update swing levels\nif not na(swing_high)\n    last_swing_high := swing_high\n\nif not na(swing_low)\n    last_swing_low := swing_low\n\n// Plot swing levels as continuous lines\nplot(i_show_high ? last_swing_high : na, \"Swing High\", color=i_color_high, linewidth=2, style=plot.style_line)\nplot(i_show_low ? last_swing_low : na, \"Swing Low\", color=i_color_low, linewidth=2, style=plot.style_line)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "plot"
    ],
    "keywords": [
      "swing high/low detection",
      "reversals",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "plot",
      "github.com",
      "swings.md",
      "runtime.error",
      "input.int",
      "input.source",
      "input.bool",
      "input.color",
      "color.red",
      "color.green",
      "plot.style_line",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-157",
    "type": "example",
    "category": "statistics",
    "title": "Beta Function (BETA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Beta Function (BETA)\", \"BETA\", overlay=false)\n\n//@function Calculates the financial Beta indicator comparing src1 volatility to src2\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/beta.md\n//@param src1 series float Series to analyze\n//@param src2 series float src2 series to compare against\n//@param period simple int Lookback period for calculation\n//@returns float Beta value showing src1 volatility relative to src2\n//@optimized for performance and dirty data\nbeta(series float src1, series float src2, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float last_src1 = na\n    var float last_src2 = na\n    src1_return = last_src1 != 0 and not na(last_src1) ? (src1 - last_src1) / last_src1 : na\n    bench_return = last_src2 != 0 and not na(last_src2) ? (src2 - last_src2) / last_src2 : na\n    last_src1 := src1\n    last_src2 := src2\n    var int count = 0\n    var float sum_sr = 0.0, var float sum_br = 0.0\n    var float sum_sr2 = 0.0, var float sum_br2 = 0.0\n    var float sum_sbr = 0.0\n    var sr_buf = array.new_float(period)\n    var br_buf = array.new_float(period)\n    var int index = 0\n    if not na(src1_return) and not na(bench_return)\n        old_sr = array.get(sr_buf, index)\n        old_br = array.get(br_buf, index)\n        if count >= period\n            sum_sr -= old_sr, sum_br -= old_br\n            sum_sr2 -= old_sr * old_sr, sum_br2 -= old_br * old_br\n            sum_sbr -= old_sr * old_br\n        else\n            count += 1\n        sum_sr += src1_return, sum_br += bench_return\n        sum_sr2 += src1_return * src1_return\n        sum_br2 += bench_return * bench_return\n        sum_sbr += src1_return * bench_return\n        array.set(sr_buf, index, src1_return)\n        array.set(br_buf, index, bench_return)\n        index := (index + 1) % period\n    if count > 0\n        mean_sr = sum_sr / count\n        mean_br = sum_br / count\n        cov = (sum_sbr / count) - (mean_sr * mean_br)\n        var_bench = (sum_br2 / count) - (mean_br * mean_br)\n        if var_bench > 1e-10\n            cov / var_bench\n        else\n            na\n    else\n        na\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_symbol = input.symbol(\"SPY\", \"src2 Symbol\")\ni_period = input.int(14, \"Period\", minval=1)\ni_src1 = input.source(close, \"src1\")\n\n// Get src2 data\nsrc2Price = request.security(i_symbol, timeframe.period, close)\n\n// Calculate beta\nbeta_value = beta(i_src1, src2Price, i_period)\n\n// Plot\nplot(beta_value, \"Beta\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.symbol",
      "input.int",
      "input.source",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "beta function (beta)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.symbol",
      "input.int",
      "input.source",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot",
      "github.com",
      "beta.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.symbol",
      "input.int",
      "input.source",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-158",
    "type": "example",
    "category": "statistics",
    "title": "Bias (BIAS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bias (BIAS)\", \"BIAS\", overlay=false)\n\n//@function Calculates the deviation of a signal from its moving average (BIAS).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/bias.md\n//@param src The source series.\n//@param len The lookback period for the SMA. Must be > 0.\n//@returns The BIAS value.\n//@optimized for performance and dirty data\nbias(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"BIAS length must be greater than 0\")\n    var float sma_sum = 0.0\n    var float[] sma_buffer = array.new_float(len, na)\n    var int sma_head = 0\n    var int sma_validCount = 0\n    float sma_oldestVal = array.get(sma_buffer, sma_head)\n    if not na(sma_oldestVal)\n        sma_sum -= sma_oldestVal\n    else if not na(src)\n        sma_validCount +=1\n    sma_sum += nz(src, 0.0)\n    array.set(sma_buffer, sma_head, src)\n    sma_head := (sma_head + 1) % len\n    float movingAverage = na\n    if sma_validCount >= len or bar_index + 1 >= len \n        movingAverage := sma_sum / math.max(sma_validCount, 1) \n    if bar_index < len -1\n        movingAverage := sma_sum / math.max(bar_index + 1, 1)\n    float bias_result = na\n    if not na(movingAverage) and movingAverage != 0\n        bias_result := (src - movingAverage) / movingAverage\n    bias_result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1)\n\n// Calculation\nbiasValue = bias(i_source, i_length)\n\n// Plot\nplot(biasValue, \"BIAS\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bias (bias)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "bias.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-159",
    "type": "example",
    "category": "statistics",
    "title": "Cointegration (COINTEGRATION)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Cointegration (COINTEGRATION)\", \"COINTEGRATION\", overlay=false)\n\nsma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = period\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        valid_count -= 1\n    if not na(source)\n        sum += source\n        valid_count += 1\n    array.set(buffer, head, source)\n    head := (head + 1) % p\n    nz(sum / valid_count, source)\n\nstddev(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0,  var int count = 0\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float val = nz(src)\n    sum += val\n    sumSq += val * val\n    count += 1\n    array.set(buffer, head, val)\n    head := (head + 1) % p\n    count > 1 ? math.sqrt(math.max(0.0, (sumSq / count) - math.pow(sum / count, 2))) : 0.0\n\ncorrelation(series float src1, series float src2, simple int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer1 = array.new_float(p, na)\n    var array<float> buffer2 = array.new_float(p, na)\n    var int head = 0, var int count = 0\n    var float sum1 = 0.0, var float sum2 = 0.0\n    var float sumSq1 = 0.0, var float sumSq2 = 0.0\n    var float sumProd = 0.0\n    float oldest1 = array.get(buffer1, head)\n    float oldest2 = array.get(buffer2, head)\n    if not na(oldest1) and not na(oldest2)\n        sum1 -= oldest1, sum2 -= oldest2\n        sumSq1 -= oldest1 * oldest1, sumSq2 -= oldest2 * oldest2\n        sumProd -= oldest1 * oldest2\n        count -= 1\n    if not na(src1) and not na(src2)\n        sum1 += src1, sum2 += src2\n        sumSq1 += src1 * src1, sumSq2 += src2 * src2\n        sumProd += src1 * src2\n        count += 1\n        array.set(buffer1, head, src1)\n        array.set(buffer2, head, src2)\n    else\n        array.set(buffer1, head, na)\n        array.set(buffer2, head, na)\n    head := (head + 1) % p\n    if count > 1\n        mean1 = sum1 / count, mean2 = sum2 / count\n        cov = (sumProd / count) - mean1 * mean2\n        var1 = (sumSq1 / count) - mean1 * mean1\n        var2 = (sumSq2 / count) - mean2 * mean2\n        stddev1 = math.sqrt(math.max(0.0, var1))\n        stddev2 = math.sqrt(math.max(0.0, var2))\n        denominator = stddev1 * stddev2\n        if denominator != 0\n            cov / denominator\n        else\n            na\n    else\n        na\n\n//@function Calculates the cointegration of two series using the Engle-Granger method.\n//@doc https://github.c",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.pow",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "cointegration (cointegration)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.pow",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.pow",
      "github.com",
      "cointegration.md",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-160",
    "type": "example",
    "category": "statistics",
    "title": "Pearson",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pearson's Correlation (CORRELATION)\", \"CORRELATION\", overlay=false)\n\n//@function Calculates Pearson correlation coefficient using single pass with circular buffer\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/correlation.md\n//@param src1 series float First series to analyze\n//@param src2 series float Second series to analyze\n//@param len simple int Lookback period for calculation\n//@returns float Pearson correlation coefficient between -1 and 1\n//@optimized for performance using combined covariance and variance calculation\ncorrelation(series float src1, series float src2, simple int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer1 = array.new_float(p, na)\n    var array<float> buffer2 = array.new_float(p, na)\n    var int head = 0, var int count = 0\n    var float sum1 = 0.0, var float sum2 = 0.0\n    var float sumSq1 = 0.0, var float sumSq2 = 0.0\n    var float sumProd = 0.0\n    float oldest1 = array.get(buffer1, head)\n    float oldest2 = array.get(buffer2, head)\n    if not na(oldest1) and not na(oldest2)\n        sum1 -= oldest1, sum2 -= oldest2\n        sumSq1 -= oldest1 * oldest1, sumSq2 -= oldest2 * oldest2\n        sumProd -= oldest1 * oldest2\n        count -= 1\n    if not na(src1) and not na(src2)\n        sum1 += src1, sum2 += src2\n        sumSq1 += src1 * src1, sumSq2 += src2 * src2\n        sumProd += src1 * src2\n        count += 1\n        array.set(buffer1, head, src1)\n        array.set(buffer2, head, src2)\n    else\n        array.set(buffer1, head, na)\n        array.set(buffer2, head, na)\n    head := (head + 1) % p\n    if count > 1\n        mean1 = sum1 / count, mean2 = sum2 / count\n        cov = (sumProd / count) - mean1 * mean2\n        var1 = (sumSq1 / count) - mean1 * mean1\n        var2 = (sumSq2 / count) - mean2 * mean2\n        stddev1 = math.sqrt(math.max(0.0, var1))\n        stddev2 = math.sqrt(math.max(0.0, var2))\n        denominator = stddev1 * stddev2\n        if denominator != 0\n            cov / denominator\n        else\n            na\n    else\n        na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source1 = input.source(close, \"Source 1\")\ni_source2_ticker = input.symbol(\"SPY\", \"Source 2 Ticker (e.g., SPY, AAPL)\")\ni_period = input.int(20, \"Period\", minval=2)\n\ni_source2 = request.security(i_source2_ticker, timeframe.period, close, lookahead=barmerge.lookahead_off)\n\n// Calculation\ncorrelation_value = correlation(i_source1, i_source2, i_period)\n\n// Plot\nplot(correlation_value, \"Correlation\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "pearson",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot",
      "github.com",
      "correlation.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-161",
    "type": "example",
    "category": "statistics",
    "title": "Covariance (COVARIANCE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Covariance (COVARIANCE)\", \"COVARIANCE\", overlay=false)\n\n//@function Calculates covariance using single pass with circular buffer\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/covariance.md\n//@param src1 series float First series to analyze\n//@param src2 series float Second series to analyze\n//@param len simple int Lookback period for calculation\n//@returns float Covariance between src1 and src2\n//@optimized for performance using circular buffer\ncovariance(series float src1, series float src2, simple int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer1 = array.new_float(p, na)\n    var array<float> buffer2 = array.new_float(p, na)\n    var int head = 0, var int count = 0\n    var float sum1 = 0.0, var float sum2 = 0.0\n    var float sumProd = 0.0\n    float oldest1 = array.get(buffer1, head)\n    float oldest2 = array.get(buffer2, head)\n    if not na(oldest1) and not na(oldest2)\n        sum1 -= oldest1\n        sum2 -= oldest2\n        sumProd -= oldest1 * oldest2\n        count -= 1\n    if not na(src1) and not na(src2)\n        sum1 += src1\n        sum2 += src2\n        sumProd += src1 * src2\n        count += 1\n        array.set(buffer1, head, src1)\n        array.set(buffer2, head, src2)\n    else\n        array.set(buffer1, head, na)\n        array.set(buffer2, head, na)\n    head := (head + 1) % p\n    count > 1 ? (sumProd / count) - (sum1 / count) * (sum2 / count) : na\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source1 = input.source(close, \"Source 1\")\ni_source2_ticker = input.symbol(\"SPY\", \"Source 2 Ticker (e.g., SPY, AAPL)\")\ni_period = input.int(20, \"Period\", minval=2)\n\ni_source2 = request.security(i_source2_ticker, timeframe.period, close, lookahead=barmerge.lookahead_off)\n\n// Calculation\nvariance_value = covariance(i_source1, i_source2, i_period)\n\n// Plot\nplot(variance_value, \"Covariance\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "covariance (covariance)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot",
      "github.com",
      "covariance.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-162",
    "type": "example",
    "category": "statistics",
    "title": "Cumulative Mean (CUMMEAN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Cumulative Mean (CUMMEAN)\", \"CUMMEAN\", overlay=false, precision=8)\r\n\r\n//@function Calculates the cumulative arithmetic mean (average) of a series from the start of the data.\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/cummean.md\r\n//@param src series float Input data series.\r\n//@returns series float The cumulative mean of the series, or na if all data so far is na.\r\ncummean(series float src) =>\r\n    var float cumulative_sum = 0.0\r\n    var int valid_data_count = 0\r\n    if not na(src)\r\n        cumulative_sum += src\r\n        valid_data_count += 1\r\n    valid_data_count > 0 ? cumulative_sum / valid_data_count : na\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\n\r\n// Calculation\r\ncummean_value = cummean(i_source)\r\n\r\n// Plot\r\nplot(cummean_value, \"CumMean\", color=color.new(color.blue, 0, color=color.yellow, linewidth=2), linewidth=2)\r\n",
    "functions_used": [
      "input.source",
      "color.new",
      "color.blue",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "cumulative mean (cummean)",
      "statistics",
      "indicator",
      "v6",
      "input.source",
      "color.new",
      "color.blue",
      "color.yellow",
      "plot",
      "github.com",
      "cummean.md",
      "input.source",
      "color.new",
      "color.blue",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "if"
    ]
  },
  {
    "id": "script-163",
    "type": "example",
    "category": "statistics",
    "title": "Entropy (ENTROPY)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Entropy (ENTROPY)\", \"ENTROPY\", overlay=false)\n\n //@function Calculate normalized Shannon entropy of a series over a lookback period.\n //@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/entropy.md\n //@param source series<float> Input data series. NA values are ignored.\n //@param length int Lookback period (>= 1).\n //@returns series<float> Normalized entropy value [0, 1], or na if insufficient data.\n //@optimized for performance and dirty data\nentropy(source, length) =>\n    if length < 1\n        runtime.error(\"Length must be >= 1\")\n    var float validMin = na\n    var float validMax = na\n    var int validCount = 0\n    for i = 0 to length - 1\n        val = source[i]\n        if not na(val)\n            if na(validMin)\n                validMin := val\n                validMax := val\n            else\n                validMin := math.min(validMin, val)\n                validMax := math.max(validMax, val)\n            validCount += 1\n    var float normalizedEntropy = na\n    if validCount < 2\n        normalizedEntropy := na\n    else\n        valueRange = validMax - validMin\n        if valueRange <= 1e-10\n            normalizedEntropy := 0.0\n        else\n            bins = math.min(math.max(validCount, 2), 100)\n            int[] freq = array.new_int(bins, 0)\n            float sumOfValidPoints = 0.0\n            for i = 0 to length - 1\n                val = source[i]\n                if not na(val)\n                    normVal = (val - validMin) / valueRange\n                    bucket = math.floor(math.min(math.max(normVal, 0.0), 1.0 - 1e-10) * bins)\n                    safeBucket = math.max(0, math.min(bucket, bins - 1))\n                    array.set(freq, safeBucket, array.get(freq, safeBucket) + 1)\n                    sumOfValidPoints += 1\n            float entropySumComponent = 0.0\n            if sumOfValidPoints > 0\n                for i = 0 to bins - 1\n                    count = array.get(freq, i)\n                    if count > 0\n                        p = count / sumOfValidPoints\n                        entropySumComponent += -p * math.log(p)\n                maxEntropy = math.log(bins)\n                normalizedEntropy := maxEntropy > 1e-10 ? entropySumComponent / maxEntropy : 0.0\n    normalizedEntropy\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(14, \"Length\", minval=1)\n\n// Calculation\nentropyValue = entropy(i_source, i_length)\n\n// Plot\nplot(entropyValue, \"Entropy\", color=color.blue, color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_int",
      "math.floor",
      "array.set",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "entropy (entropy)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_int",
      "math.floor",
      "array.set",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "plot",
      "github.com",
      "entropy.md",
      "runtime.error",
      "math.min",
      "math.max",
      "array.new_int",
      "math.floor",
      "array.set",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.blue",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-164",
    "type": "example",
    "category": "statistics",
    "title": "Geometric Mean (GEOMEAN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Geometric Mean (GEOMEAN)\", \"GEOMEAN\", overlay=true)\n\n//@function Calculates the Geometric Mean of a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/geomean.md\n//@param src series float Input data series (must contain positive values).\n//@param len simple int Lookback period (must be > 0).\n//@returns series float The Geometric Mean, or na if data is not suitable (e.g., non-positive values, insufficient data).\n//@optimized for performance and dirty data\ngeomean(series float src, simple int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0. Found: \" + str.tostring(len))\n    var float sum_log_src = 0.0\n    var int n_valid = 0\n    var float[] src_buffer = array.new_float(len, na)\n    var int current_index = 0\n    float current_val = src\n    float current_log_val = na\n    bool current_val_is_valid = false\n    if not na(current_val) and current_val > 0\n        current_log_val := math.log(current_val)\n        current_val_is_valid := true\n    float old_src_from_buffer = array.get(src_buffer, current_index)\n    if not na(old_src_from_buffer) and old_src_from_buffer > 0\n        sum_log_src -= math.log(old_src_from_buffer)\n        n_valid -= 1\n    if current_val_is_valid\n        sum_log_src += current_log_val\n        n_valid += 1\n        array.set(src_buffer, current_index, current_val)\n    else\n        array.set(src_buffer, current_index, na)\n    current_index := (current_index + 1) % len\n    if n_valid > 0\n        math.exp(sum_log_src / n_valid)\n    else\n        float(na)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, title=\"Source (must be positive values)\")\ni_length = input.int(14, title=\"Lookback Period\", minval=1)\n\n// Calculation\ngeomean_value = geomean(i_source, i_length)\n\n// Plot\nplot(geomean_value, \"GEOMEAN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "geometric mean (geomean)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "geomean.md",
      "e.g",
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.exp",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-165",
    "type": "example",
    "category": "statistics",
    "title": "Granger Causality Test (GRANGER)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Granger Causality Test (GRANGER)\", \"GRANGER\", overlay=false, precision=4)\r\n\r\n// Helper function to calculate mean over a period using circular buffer\r\n_mean(series float src, simple int len) =>\r\n    var float sum = 0.0\r\n    var int count = 0\r\n    var array<float> buffer = array.new_float(len, na)\r\n    var int head = 0\r\n\r\n    float oldest = array.get(buffer, head)\r\n    if not na(oldest)\r\n        sum -= oldest\r\n        count -=1\r\n\r\n    if not na(src)\r\n        sum += src\r\n        count += 1\r\n        array.set(buffer, head, src)\r\n    else\r\n        array.set(buffer, head, na) // Store na to correctly pop it later\r\n\r\n    head := (head + 1) % len\r\n    count > 0 ? sum / count : na\r\n\r\n// Helper function to calculate variance over a period using circular buffer\r\n_variance(series float src, simple int len, series float src_mean) =>\r\n    var float sumSqDev = 0.0\r\n    var int count = 0\r\n    var array<float> buffer_dev = array.new_float(len, na)\r\n    var int head = 0\r\n\r\n    float val = nz(src) // Align with variance.pine by using nz() on source\r\n    float current_dev = na\r\n    if not na(src_mean) // src is now always a number (0 if was na)\r\n        current_dev := val - src_mean\r\n\r\n    float oldest_dev = array.get(buffer_dev, head)\r\n    if not na(oldest_dev)\r\n        sumSqDev -= oldest_dev * oldest_dev\r\n        count -=1\r\n\r\n    if not na(current_dev) // current_dev can still be na if src_mean was na\r\n        sumSqDev += current_dev * current_dev\r\n        count += 1\r\n        array.set(buffer_dev, head, current_dev)\r\n    else\r\n        array.set(buffer_dev, head, na) // If current_dev is na, store na\r\n\r\n    head := (head + 1) % len\r\n    count > 1 ? sumSqDev / count : 0.0 // Align with variance.pine return for insufficient data\r\n\r\n// Helper function to calculate covariance over a period using circular buffer\r\n_covariance(series float src1, series float src2, simple int len, series float mean1, series float mean2) =>\r\n    var float sumProdDev = 0.0\r\n    var int count = 0\r\n    var array<float> buffer_dev1 = array.new_float(len, na)\r\n    var array<float> buffer_dev2 = array.new_float(len, na)\r\n    var int head = 0\r\n\r\n    float current_dev1 = na\r\n    float current_dev2 = na\r\n\r\n    if not na(src1) and not na(mean1)\r\n        current_dev1 := src1 - mean1\r\n    if not na(src2) and not na(mean2)\r\n        current_dev2 := src2 - mean2\r\n\r\n    float oldest_dev1 = array.get(buffer_dev1, head)\r\n    float oldest_dev2 = array.get(buffer_dev2, head)\r\n\r\n    if not na(oldest_dev1) and not na(oldest_dev2)\r\n        sumProdDev -= oldest_dev1 * oldest_dev2\r\n        count -= 1\r\n\r\n    if not na(current_dev1) and not na(current_dev2)\r\n        sumProdDev += current_dev1 * current_dev2\r\n        count += 1\r\n        array.set(buffer_dev1, head, current_dev1)\r\n        array.set(buffer_dev2, head, current_dev2)\r\n    else\r\n        // If one is na, effectively the product is na for this point\r\n        array.set(buffer_dev1, head, na)\r",
    "functions_used": [
      "array.new_float",
      "array.get",
      "array.set",
      "runtime.error",
      "math.max",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "granger causality test (granger)",
      "statistics",
      "indicator",
      "v6",
      "array.new_float",
      "array.get",
      "array.set",
      "runtime.error",
      "math.max",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.yellow",
      "plot",
      "array.new_float",
      "array.get",
      "array.set",
      "variance.pine",
      "github.com",
      "granger.md",
      "runtime.error",
      "i.e",
      "math.max",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-166",
    "type": "example",
    "category": "statistics",
    "title": "Harmonic Mean (HARMEAN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Harmonic Mean (HARMEAN)\", \"HARMEAN\", overlay=false, precision=6)\n\n//@function Calculates the Harmonic Mean of a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/harmean.md\n//@param src series float Input data series (must contain positive values).\n//@param len simple int Lookback period (must be > 0).\n//@returns series float The Harmonic Mean, or na if data is not suitable (e.g., non-positive values, insufficient data).\n//@optimized for performance and dirty data\nharmean(series float src, simple int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0. Found: \" + str.tostring(len))\n    var float sum_reciprocal_src = 0.0\n    var int n_valid = 0\n    var float[] src_buffer = array.new_float(len, na)\n    var int current_index = 0\n    float current_val = src\n    bool current_val_is_valid = false\n    if not na(current_val) and current_val > 0\n        current_val_is_valid := true\n    float old_val_from_buffer = array.get(src_buffer, current_index)\n    if not na(old_val_from_buffer) and old_val_from_buffer > 0 \n        sum_reciprocal_src -= (1.0 / old_val_from_buffer)\n        n_valid -= 1\n    if current_val_is_valid\n        sum_reciprocal_src += (1.0 / current_val)\n        n_valid += 1\n        array.set(src_buffer, current_index, current_val)\n    else\n        array.set(src_buffer, current_index, na)\n    current_index := (current_index + 1) % len\n    if n_valid > 0 and sum_reciprocal_src > 1e-10\n        n_valid / sum_reciprocal_src\n    else\n        float(na)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, title=\"Source (must be positive values)\")\ni_length = input.int(14, title=\"Lookback Period\", minval=1)\n\n// Calculation\nharmean_value = harmean(i_source, i_length)\n\n// Plot\nplot(harmean_value, \"HARMEAN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "harmonic mean (harmean)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "harmean.md",
      "e.g",
      "runtime.error",
      "str.tostring",
      "array.new_float",
      "array.get",
      "array.set",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-167",
    "type": "example",
    "category": "statistics",
    "title": "Hurst Exponent (HURST)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hurst Exponent (HURST)\", \"HURST\", overlay=false, precision=4)\n\n//@function Calculates the Hurst Exponent for a given series and lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/hurst.md\n//@param source series float The input series.\n//@param length int The lookback period for Hurst Exponent calculation.\n//@returns series float The Hurst Exponent value.\nhurst(series float source, simple int length) =>\n    if length <= 10 \n        runtime.error(\"Length must be greater than 10 for Hurst Exponent.\")\n        na\n    log_returns = math.log(source / source[1])\n    min_n = 10\n    max_n = length / 2\n    if max_n < min_n\n        runtime.error(\"Length too short for sub-period division.\")\n        na\n    array<float> log_n_values = array.new_float(0)\n    array<float> log_rs_values = array.new_float(0)\n    for n = min_n to max_n\n        if n == 0\n            continue\n        num_sub_periods = math.floor(length / n)\n        if num_sub_periods == 0\n            continue\n        rs_sum = 0.0\n        for i = 0 to num_sub_periods - 1\n            start_index = i * n\n            float[] sub_period_returns = array.new_float(n)\n            for j = 0 to n - 1\n                array.set(sub_period_returns, j, log_returns[start_index + j])\n            sub_period_sum = 0.0\n            for k_val = 0 to n - 1\n                sub_period_sum += array.get(sub_period_returns, k_val)\n            sub_mean = sub_period_sum / n\n            float[] cum_dev = array.new_float(n)\n            current_sum = 0.0\n            for j = 0 to n - 1\n                current_sum += (array.get(sub_period_returns, j) - sub_mean)\n                array.set(cum_dev, j, current_sum)\n            range_val = array.max(cum_dev) - array.min(cum_dev)\n            variance_sum = 0.0\n            for j = 0 to n - 1\n                variance_sum += math.pow(array.get(sub_period_returns, j) - sub_mean, 2)\n            std_dev_val_corrected = math.sqrt(variance_sum / n)\n            if std_dev_val_corrected > 0\n                rs_sum += range_val / std_dev_val_corrected\n        if num_sub_periods > 0\n            avg_rs = rs_sum / num_sub_periods\n            if avg_rs > 0 \n                array.push(log_n_values, math.log(n))\n                array.push(log_rs_values, math.log(avg_rs))\n    if array.size(log_n_values) < 2 \n        na\n    else\n        m = array.size(log_n_values)\n        sum_x = 0.0\n        sum_y = 0.0\n        sum_xy = 0.0\n        sum_x_sq = 0.0\n        for i = 0 to m - 1\n            xi = array.get(log_n_values, i)\n            yi = array.get(log_rs_values, i)\n            sum_x += xi\n            sum_y += yi\n            sum_xy += xi * yi\n            sum_x_sq += xi * xi\n        denominator = m * sum_x_sq - math.pow(sum_x, 2)\n        if denominator == 0\n            na \n        else\n            (m * sum_xy - sum_x * sum_y) / denominator\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.sourc",
    "functions_used": [
      "runtime.error",
      "math.log",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "array.max",
      "array.min",
      "math.pow",
      "math.sqrt",
      "array.push",
      "array.size",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hurst exponent (hurst)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "array.max",
      "array.min",
      "math.pow",
      "math.sqrt",
      "array.push",
      "array.size",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "hurst.md",
      "runtime.error",
      "math.log",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "array.max",
      "array.min",
      "math.pow",
      "math.sqrt",
      "array.push",
      "array.size",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-168",
    "type": "example",
    "category": "statistics",
    "title": "Interquartile Range (IQR)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Interquartile Range (IQR)\", \"IQR\", overlay=false, precision=4)\n\n//@function Function to calculate percentile using linear interpolation\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/iqr.md\n//@param src Source series for calculation\n//@param len Lookback period for data collection\n//@param p Percentile value (0-100)\n//@returns Calculated percentile value\n// Adapted from percentile.pine\niqr(series float src, simple int len, simple float p) =>\n    if len <= 0 // Should not happen due to input minval=2\n        runtime.error(\"Lookback Period must be greater than 0.\")\n        float(na)\n    if p < 0 or p > 100\n        runtime.error(\"Percentile 'p' must be between 0 and 100.\")\n        float(na)\n    data_points = array.new_float()\n    for i = 0 to len - 1\n        val = src[i]\n        if not na(val)\n            array.push(data_points, val)\n    n_valid = array.size(data_points)\n    float result = na\n    if n_valid == 0\n        result := na\n    else if n_valid == 1\n        result := array.get(data_points, 0)\n    else\n        array.sort(data_points)\n        rank = (p / 100.0) * (n_valid - 1) \n        if p == 0.0\n            result := array.get(data_points, 0)\n        else if p == 100.0\n            result := array.get(data_points, n_valid - 1) \n        else\n            k_floor_idx = math.floor(rank)\n            k_ceil_idx = math.ceil(rank)\n            int_k_floor = math.max(0, math.min(n_valid - 1, int(k_floor_idx)))\n            int_k_ceil = math.max(0, math.min(n_valid - 1, int(k_ceil_idx)))\n            if int_k_floor == int_k_ceil \n                result := array.get(data_points, int_k_floor)\n            else \n                val_floor = array.get(data_points, int_k_floor)\n                val_ceil = array.get(data_points, int_k_ceil)\n                if val_floor == val_ceil\n                    result := val_floor\n                else\n                    result := val_floor + (rank - k_floor_idx) * (val_ceil - val_floor)\n    result\n\n// Inputs\ni_source = input.source(close, title=\"Source\")\ni_length = input.int(20, title=\"Lookback Period\", minval=2)\n\n// Calculate Q1 (25th percentile) and Q3 (75th percentile)\nq1 = iqr(i_source, i_length, 25.0)\nq3 = iqr(i_source, i_length, 75.0)\n\n// Calculate IQR\niqr_value = q3 - q1\n\n// Plot IQR\nplot(iqr_value, title=\"IQR\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "interquartile range (iqr)",
      "statistics",
      "indicator",
      "v5",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "iqr.md",
      "percentile.pine",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-169",
    "type": "example",
    "category": "statistics",
    "title": "Jarque-Bera Test (JB)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Jarque-Bera Test (JB)\", \"JB\", overlay=false, precision=4)\n\n// Helper function to get a window of series data into an array\n_get_window_array(series float source, simple int length) =>\n    float[] arr = array.new_float(length)\n    for i = 0 to length - 1\n        array.set(arr, i, source[length - 1 - i]) // Oldest to newest\n    arr\n\n// Helper function to calculate the k-th central moment\n// m_k = sum((x_i - mean)^k) / n\n_central_moment(float[] arr, int moment_order, float mean_val) =>\n    n = array.size(arr)\n    if n == 0\n        float(na)\n    else\n        sum_pow_diff = 0.0\n        for i = 0 to n - 1\n            sum_pow_diff += math.pow(array.get(arr, i) - mean_val, moment_order)\n        sum_pow_diff / n\n\n//@function Calculates the Jarque-Bera statistic.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/jb.md\n//@param source series float The input series.\n//@param length simple int The lookback period (sample size). Min 10.\n//@returns series float The Jarque-Bera statistic. Higher values suggest deviation from normality.\njb_stat(series float source, simple int length) => // Renamed function for clarity jb_stat -> jb\n    if length < 10 // Need sufficient sample size\n        float(na)\n    else\n        float[] window_arr = _get_window_array(source, length)\n        \n        float mean_val = array.avg(window_arr) // Pine Script built-in array average\n        \n        if na(mean_val)\n            float(na)\n        else\n            // Calculate variance (2nd central moment)\n            float m2 = _central_moment(window_arr, 2, mean_val)\n            \n            if na(m2) or m2 < 1e-10 // Avoid division by zero or near-zero std dev\n                float(na) // Or 0 if data is truly constant, but JB is ill-defined\n            else\n                float stddev_val = math.sqrt(m2)\n                \n                // Calculate 3rd central moment for skewness\n                float m3 = _central_moment(window_arr, 3, mean_val)\n                float s = m3 / math.pow(stddev_val, 3) // Skewness\n                \n                // Calculate 4th central moment for kurtosis\n                float m4 = _central_moment(window_arr, 4, mean_val)\n                float k_raw = m4 / math.pow(stddev_val, 4) // Raw Kurtosis\n                float ek = k_raw - 3.0 // Excess Kurtosis\n                \n                if na(s) or na(ek)\n                    float(na)\n                else\n                    // Jarque-Bera statistic formula: JB = (n/6) * (S^2 + (EK^2)/4)\n                    float jb_value_calc = (length / 6.0) * (s * s + (ek * ek) / 4.0) // Renamed internal variable\n                    jb_value_calc\n\n// Inputs\ni_source = input.source(close, title=\"Source\")\ni_length = input.int(20, title=\"Lookback Period (Sample Size)\", minval=10, maxval=200, tooltip=\"Number of bars for calculation. Min 10. Max 200 due to array processing. Higher values provide more stable estimates but lag mo",
    "functions_used": [
      "array.new_float",
      "array.set",
      "array.size",
      "math.pow",
      "array.get",
      "array.avg",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.new",
      "color.teal",
      "color.yellow",
      "color.gray",
      "color.orange",
      "color.red",
      "plot",
      "hline"
    ],
    "keywords": [
      "jarque-bera test (jb)",
      "statistics",
      "indicator",
      "v5",
      "array.new_float",
      "array.set",
      "array.size",
      "math.pow",
      "array.get",
      "array.avg",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.new",
      "color.teal",
      "color.yellow",
      "color.gray",
      "color.orange",
      "color.red",
      "plot",
      "hline",
      "array.new_float",
      "array.set",
      "array.size",
      "math.pow",
      "array.get",
      "github.com",
      "jb.md",
      "array.avg",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.new",
      "color.teal",
      "color.yellow",
      "color.gray",
      "hline.style_dotted",
      "color.orange",
      "hline.style_dashed",
      "color.red",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "const",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-170",
    "type": "example",
    "category": "statistics",
    "title": "Kendall Rank Correlation (KENDALL)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Kendall Rank Correlation (KENDALL)\", \"KENDALL\", overlay=false, precision=4)\n\n//@function Calculates Kendall's Tau-a rank correlation coefficient.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/kendall.md\n//@param source1 series float The first input series.\n//@param source2 series float The second input series.\n//@param length int The lookback period. Min 2, Max 60.\n//@returns series float Kendall's Tau-a coefficient, ranging from -1 to +1.\nkendall(series float source1, series float source2, simple int length) =>\n    if length < 2\n        float(na)\n    else\n        float[] src1_window = array.new_float(length)\n        float[] src2_window = array.new_float(length)\n        bool window_has_na = false\n        for k = 0 to length - 1\n            val1_k = source1[length - 1 - k]\n            val2_k = source2[length - 1 - k]\n            if na(val1_k) or na(val2_k)\n                window_has_na := true\n                break\n            array.set(src1_window, k, val1_k)\n            array.set(src2_window, k, val2_k)\n        if window_has_na\n            float(na)\n        else\n            concordant_pairs = 0\n            discordant_pairs = 0\n            for i = 0 to length - 2\n                for j = i + 1 to length - 1\n                    val1_i = array.get(src1_window, i)\n                    val2_i = array.get(src2_window, i)\n                    val1_j = array.get(src1_window, j)\n                    val2_j = array.get(src2_window, j)\n                    diff_val1 = val1_i - val1_j\n                    diff_val2 = val2_i - val2_j\n                    product_of_signs = diff_val1 * diff_val2\n                    if product_of_signs > 0\n                        concordant_pairs += 1\n                    else if product_of_signs < 0\n                        discordant_pairs += 1\n            denominator = length * (length - 1) / 2.0\n            if denominator == 0.0\n                float(na)\n            else\n                (concordant_pairs - discordant_pairs) / denominator\n\n// Inputs\ni_source1 = input.source(close, \"Source 1\")\ni_source2_ticker = input.symbol(\"SPY\", \"Source 2 Ticker (e.g., SPY, AAPL)\")\ni_period = input.int(20, \"Period\", minval=2)\n\ni_source2 = request.security(i_source2_ticker, timeframe.period, close, lookahead=barmerge.lookahead_off)\n\n// Calculation\nkendall_value = kendall(i_source1, i_source2, i_period)\n\n// Plot\nplot(kendall_value, \"Kendall's Tau\", color=color.new(color.yellow,0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "array.new_float",
      "array.set",
      "array.get",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "kendall rank correlation (kendall)",
      "statistics",
      "indicator",
      "v5",
      "array.new_float",
      "array.set",
      "array.get",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "kendall.md",
      "array.new_float",
      "array.set",
      "array.get",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-171",
    "type": "example",
    "category": "statistics",
    "title": "Kurtosis, tailedness (KURTOSIS)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Kurtosis, tailedness (KURTOSIS)\", \"KURTOSIS\", overlay=false, precision=8)\n\n//@function Calculates the excess kurtosis of a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/kurtosis.md\n//@param src Source series.\n//@param len Lookback period. Must be greater than 1.\n//@returns The excess kurtosis value.\nkurtosis(series float src, simple int len) =>\n    if len <= 1\n        runtime.error(\"Length must be greater than 1\")\n    var float sumY = 0.0, var float sumY2 = 0.0, var float sumY3 = 0.0, var float sumY4 = 0.0\n    var int validCount = 0, var array<float> y_values = array.new_float(len), var int head = 0, var bool filled = false\n    float oldY = filled ? array.get(y_values, head) : na\n    if not na(oldY)\n        sumY -= oldY, sumY2 -= oldY * oldY, sumY3 -= oldY * oldY * oldY, sumY4 -= oldY * oldY * oldY * oldY, validCount -= 1\n    float currentY = src\n    array.set(y_values, head, currentY)\n    if not na(currentY)\n        sumY += currentY, sumY2 += currentY * currentY, sumY3 += currentY * currentY * currentY, sumY4 += currentY * currentY * currentY * currentY, validCount += 1\n    head := (head + 1) % len\n    if not filled and head == 0\n        filled := true\n    float excessKurtosis = na\n    if validCount >= 4\n        float n = float(validCount), mean = sumY / n, m2 = sumY2 / n, m3 = sumY3 / n, m4 = sumY4 / n\n        float variance = math.max(m2 - mean * mean, 0.0)\n        if variance > 1e-10\n            float moment4 = m4 - 4 * mean * m3 + 6 * mean * mean * m2 - 3 * mean * mean * mean * mean\n            excessKurtosis := moment4 / (variance * variance) - 3.0\n        else\n            excessKurtosis := 0.0\n    excessKurtosis\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=4) // Minval 4 for kurtosis\ni_source = input.source(close, \"Source\")\n\n// Calculation\nk = kurtosis(i_source, i_period)\n\n// Plot\nplot(k, \"Kurtosis\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "kurtosis, tailedness (kurtosis)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "kurtosis.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-172",
    "type": "example",
    "category": "statistics",
    "title": "Linear Regression (LINREG)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Linear Regression (LINREG)\", \"LINREG\", overlay=false, precision=8)\n\n//@function Calculates linear regression and slope over the specified period\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/linreg.md\n//@param src Source series to calculate linear regression from\n//@param len Lookback period for the calculation\n//@returns Tuple containing [intercept, slope]\nlinreg(series float src, simple int len) =>\n    if len < 2\n        [na, na]\n    else\n        var float lastValid = na\n        var array<float> buf = array.new_float(len, 0.0)\n        var int count = 0\n        var int head = 0\n        float curr = src\n        if na(curr) and not na(lastValid)\n            curr := lastValid\n        if not na(curr)\n            lastValid := curr\n        if not na(curr)\n            array.set(buf, head, curr)\n            if count < len\n                count := count + 1\n            head := (head + 1) % len\n        float n = count\n        if n < 2\n            [na, na]\n        else\n            int start = count < len ? 0 : head\n            float sumY = 0.0, sumXY = 0.0\n            for i = 0 to int(n) - 1\n                int idx = (start + i) % len\n                float y_val = array.get(buf, idx)\n                sumY += y_val\n                sumXY += i * y_val\n            float sumX = 0.5 * (n - 1) * n\n            float sumX2 = (n - 1) * n * (2 * n - 1) / 6.0\n            float D = n * sumX2 - sumX * sumX\n            float s = D != 0 ? (n * sumXY - sumX * sumY) / D : na\n            float intercept = (sumY / n) - s * ((n - 1) / 2)\n            float lr = intercept + s * (n - 1)\n            [lr, s]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation: Assign tuple elements.\n[lr, slope] = linreg(i_source, i_period)\n\n// Plot\nplot(lr, \"LinReg\", color=color.yellow, linewidth=2)\n// plot(slope, \"Slope\", color=color.orange, linewidth=2, plot.style_histogram)\n",
    "functions_used": [
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "plot"
    ],
    "keywords": [
      "linear regression (linreg)",
      "statistics",
      "indicator",
      "v6",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "plot",
      "github.com",
      "linreg.md",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "color.orange",
      "plot.style_histogram",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-173",
    "type": "example",
    "category": "statistics",
    "title": "Median",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Median\", \"MEDIAN\", overlay=false, precision=8)\r\n\r\n//@function Calculates the median of a series over a lookback period.\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/median.md\r\n//@param src series float Input data series.\r\n//@param len simple int Lookback period (must be > 0).\r\n//@returns series float The median of the series over the period, or na if insufficient valid data.\r\nmedian(series float src, simple int len) =>\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    var array<float> values_in_window = array.new_float(0)\r\n    array.clear(values_in_window) // Clear from previous bar's calculation\r\n    for i = 0 to len - 1\r\n        val = src[i]\r\n        if not na(val)\r\n            array.push(values_in_window, val)\r\n    int n = array.size(values_in_window)\r\n    float result = na\r\n    if n > 0\r\n        array.sort(values_in_window) // Sort the array\r\n        if n % 2 == 1 // Odd number of elements\r\n            result := array.get(values_in_window, n / 2)\r\n        else // Even number of elements\r\n            float mid1 = array.get(values_in_window, n / 2 - 1)\r\n            float mid2 = array.get(values_in_window, n / 2)\r\n            result := (mid1 + mid2) / 2.0\r\n    result\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(14, \"Period\", minval=1)\r\n\r\n// Calculation\r\nmedian_value = median(i_source, i_length)\r\n\r\n// Plot\r\nplot(median_value, \"Median\", color=color.new(color.orange, 0, color=color.yellow, linewidth=2), linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "array.get",
      "input.source",
      "input.int",
      "color.new",
      "color.orange",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "median",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "array.get",
      "input.source",
      "input.int",
      "color.new",
      "color.orange",
      "color.yellow",
      "plot",
      "github.com",
      "median.md",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "array.get",
      "input.source",
      "input.int",
      "color.new",
      "color.orange",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-174",
    "type": "example",
    "category": "statistics",
    "title": "Mode",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Mode\", \"MODE\", overlay=false)\r\n\r\n//@function Calculates the mode (most frequent value) of a series over a lookback period.\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/mode.md\r\n//@param src series float Input data series.\r\n//@param len simple int Lookback period (must be > 0).\r\n//@returns series float The mode of the series over the period.\r\nmode(series float src, simple int len) =>\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0\")\r\n    value_counts = map.new<float, int>()\r\n    actual_lookback = math.min(len, bar_index + 1)\r\n    for i = 0 to actual_lookback - 1\r\n        val = src[i]\r\n        if not na(val)\r\n            count = na(map.get(value_counts, val)) ? 0 : map.get(value_counts, val)\r\n            map.put(value_counts, val, count + 1)\r\n    float mode_val = na\r\n    int max_freq = 0\r\n    if map.size(value_counts) > 0\r\n        keys = map.keys(value_counts)\r\n        for key_val in keys\r\n            current_freq = map.get(value_counts, key_val)\r\n            if current_freq > max_freq\r\n                max_freq := current_freq\r\n                mode_val := key_val\r\n        if max_freq <= 1 and map.size(value_counts) > 1\r\n            mode_val := na\r\n    mode_val\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(14, \"Period\", minval=1)\r\n\r\n// Calculation\r\nmode_value = mode(i_source, i_length)\r\n\r\n// Plot\r\nplot(mode_value, \"Mode\", color=color.new(color.green, 0, color=color.yellow, linewidth=2), linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "map.new",
      "math.min",
      "map.get",
      "map.put",
      "map.size",
      "map.keys",
      "input.source",
      "input.int",
      "color.new",
      "color.green",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mode",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "map.new",
      "math.min",
      "map.get",
      "map.put",
      "map.size",
      "map.keys",
      "input.source",
      "input.int",
      "color.new",
      "color.green",
      "color.yellow",
      "plot",
      "github.com",
      "mode.md",
      "runtime.error",
      "map.new",
      "math.min",
      "map.get",
      "map.put",
      "map.size",
      "map.keys",
      "input.source",
      "input.int",
      "color.new",
      "color.green",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-175",
    "type": "example",
    "category": "statistics",
    "title": "Percentile",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n//@version=6\r\nindicator(\"Percentile\", \"PERCENTILE\", overlay=true, precision=8)\r\n\r\n//@function Calculates the value at a given percentile for a series over a lookback period.\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/percentile.md\r\n//@param src series float Input data series.\r\n//@param len simple int Lookback period (must be > 0).\r\n//@param p simple float Percentile to calculate (0-100). For example, 50 for median.\r\n//@returns series float The value at the specified percentile, or na if insufficient data.\r\npercentile(series float src, simple int len, simple float p) => // p is the target percentile (0-100)\r\n    if len <= 0\r\n        runtime.error(\"Length must be greater than 0.\")\r\n    if p < 0 or p > 100\r\n        runtime.error(\"Percentile 'p' must be between 0 and 100.\")\r\n    data_points = array.new_float()\r\n    for i = 0 to len - 1\r\n        val = src[i]\r\n        if not na(val)\r\n            array.push(data_points, val)\r\n    n_valid = array.size(data_points)\r\n    float result = na\r\n    if n_valid == 0\r\n        result := na\r\n    else if n_valid == 1\r\n        result := array.get(data_points, 0)\r\n    else\r\n        array.sort(data_points)\r\n        rank = (p / 100.0) * (n_valid - 1)\r\n        if p == 0.0\r\n            result := array.get(data_points, 0)\r\n        else if p == 100.0\r\n            result := array.get(data_points, n_valid - 1)\r\n        else\r\n            k_floor_idx = math.floor(rank)\r\n            k_ceil_idx = math.ceil(rank)\r\n            int_k_floor = int(k_floor_idx)\r\n            int_k_ceil = int(k_ceil_idx)\r\n            if int_k_floor == int_k_ceil\r\n                result := array.get(data_points, int_k_floor)\r\n            else\r\n                val_floor = array.get(data_points, int_k_floor)\r\n                val_ceil = array.get(data_points, int_k_ceil)\r\n                result := val_floor + (rank - k_floor_idx) * (val_ceil - val_floor)\r\n    result\r\n\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, \"Source\")\r\ni_length = input.int(14, \"Period\", minval=1)\r\ni_percentile = input.float(25, \"Percentile (0-100)\", minval=0, maxval=100, step=0.1)\r\n\r\n// Calculation\r\npercentile_value = percentile(i_source, i_length, i_percentile)\r\n\r\n// Plot\r\nplot(percentile_value, \"Percentile\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "percentile",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "percentile.md",
      "runtime.error",
      "array.new_float",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-176",
    "type": "example",
    "category": "statistics",
    "title": "Quantile (QUANTILE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\r\n// © mihakralj\r\n\r\n//@version=6\r\nindicator(\"Quantile (QUANTILE)\", shorttitle=\"QUANTILE\", overlay=true, precision=8)\r\n\r\n//@function Calculates the quantile of a series over a lookback period using linear interpolation.\r\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/quantile.md\r\n//@param src {series float} The source series to calculate the quantile from.\r\n//@param len {simple int} The lookback period. Must be greater than 0.\r\n//@param q_level {simple float} The quantile level to calculate (between 0.0 and 1.0).\r\n//@returns {series float} The calculated quantile value, or na if insufficient data.\r\nquantile(series float src, simple int len, simple float q_level) =>\r\n    if len <= 0\r\n        runtime.error(\"Period must be greater than 0.\")\r\n    if q_level < 0.0 or q_level > 1.0\r\n        runtime.error(\"Quantile Level must be between 0.0 and 1.0.\")\r\n    var float[] values_arr = array.new_float(0)\r\n    array.clear(values_arr)\r\n    for i = 0 to len - 1\r\n        if not na(src[i])\r\n            array.push(values_arr, src[i])\r\n    int n_valid = array.size(values_arr)\r\n    if n_valid == 0\r\n        na\r\n    else if n_valid == 1\r\n        array.get(values_arr, 0)\r\n    else\r\n        array.sort(values_arr)\r\n        if q_level == 0.0\r\n            array.min(values_arr)\r\n        else if q_level == 1.0\r\n            array.max(values_arr)\r\n        else\r\n            float rank = q_level * (n_valid - 1)\r\n            int k_floor = int(math.floor(rank))\r\n            int k_ceil = int(math.ceil(rank))\r\n            if k_floor == k_ceil\r\n                array.get(values_arr, k_floor)\r\n            else\r\n                float val_floor = array.get(values_arr, k_floor)\r\n                float val_ceil = array.get(values_arr, k_ceil)\r\n                val_floor + (rank - k_floor) * (val_ceil - val_floor)\r\n\r\n// ---------- Main loop ----------\r\n\r\n// Inputs\r\ni_source = input.source(close, title=\"Source\")\r\ni_length = input.int(14, title=\"Period\", minval=1)\r\ni_quantile_level = input.float(0.25, title=\"Quantile Level (0.0-1.0)\", minval=0.0, maxval=1.0, step=0.01)\r\n\r\n// Calculate Quantile\r\nquantile_value = quantile(i_source, i_length, i_quantile_level)\r\n\r\n// Plot\r\nplot(quantile_value, title=\"Quantile\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\r\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "array.min",
      "array.max",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "quantile (quantile)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "array.min",
      "array.max",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "quantile.md",
      "runtime.error",
      "array.new_float",
      "array.clear",
      "array.push",
      "array.size",
      "array.get",
      "array.sort",
      "array.min",
      "array.max",
      "math.floor",
      "math.ceil",
      "input.source",
      "input.int",
      "input.float",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-177",
    "type": "example",
    "category": "statistics",
    "title": "Skewness (SKEW)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Skewness (SKEW)\", \"SKEW\", overlay=false, precision=6)\n\n//@function Calculates the skewness of a source series over a specified period.\n// Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.\n// This implementation calculates the population skewness (Fisher-Pearson coefficient g1).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/skew.md\n//@param src The source series.\n//@param len The lookback period. Must be > 2.\n//@returns The skewness value.\n//@optimized Uses efficient rolling calculations for mean, variance, and the third central moment.\nskew(series float src, simple int len) =>\n    if len <= 2\n        runtime.error(\"Length must be greater than 2 for Skewness calculation.\")\n    var float sum_m = 0.0\n    var array<float> buffer_m = array.new_float(len)\n    var int head_m = 0\n    if bar_index >= len \n        sum_m -= array.get(buffer_m, head_m)\n    float current_src_nz = nz(src) \n    sum_m += current_src_nz\n    array.set(buffer_m, head_m, current_src_nz) \n    head_m := (head_m + 1) % len\n    \n    float mean_val = na\n    if bar_index >= len - 1\n        mean_val := sum_m / len\n    else \n        mean_val := sum_m / (bar_index + 1)\n    float dev = src - mean_val\n    var float sum_v = 0.0\n    var array<float> buffer_v = array.new_float(len)\n    var int head_v = 0\n    float dev_sq_nz = nz(math.pow(dev, 2))\n    if bar_index >= len\n        sum_v -= array.get(buffer_v, head_v)\n    sum_v += dev_sq_nz\n    array.set(buffer_v, head_v, dev_sq_nz)\n    head_v := (head_v + 1) % len\n    float variance_val = na\n    if bar_index >= len - 1\n        variance_val := sum_v / len\n    else\n        variance_val := sum_v / (bar_index + 1)\n    float stddev_val = variance_val > 1e-9 ? math.sqrt(variance_val) : 0.0 \n    var float sum_s3 = 0.0\n    var array<float> buffer_s3 = array.new_float(len)\n    var int head_s3 = 0\n    float dev_cubed_nz = nz(math.pow(dev, 3)) \n    if bar_index >= len\n        sum_s3 -= array.get(buffer_s3, head_s3)\n    sum_s3 += dev_cubed_nz\n    array.set(buffer_s3, head_s3, dev_cubed_nz)\n    head_s3 := (head_s3 + 1) % len\n    float m3 = na \n    if bar_index >= len - 1\n        m3 := sum_s3 / len\n    else\n        m3 := sum_s3 / (bar_index + 1)\n    float skew_val = na\n    if not na(m3) and not na(stddev_val)\n        if stddev_val > 1e-9 \n            float stddev_cubed = math.pow(stddev_val, 3)\n            if stddev_cubed != 0\n                skew_val := m3 / stddev_cubed\n            else \n                skew_val := 0.0 \n        else \n            skew_val := 0.0 \n    skew_val\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=3) // Minval 3 for skewness\n\n// Calculation\nskewValue = skew(i_source, i_length)\n\n// Plot\nplot(skewValue, \"Skewness\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "skewness (skew)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "skew.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-178",
    "type": "example",
    "category": "statistics",
    "title": "Spearman Rank Correlation (SPEARMAN)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Spearman Rank Correlation (SPEARMAN)\", \"SPEARMAN\", overlay=false, precision=4)\n\n// @function Calculates ranks for values in an array.\n// @param values float[] Array of float values to rank.\n// @returns float[] Array of ranks, 1-based, with ties handled by averaging.\nget_ranks(float[] values) =>\n    n = array.size(values)\n    if n == 0\n        array.new_float(0)\n    else\n        float[] ranks = array.new_float(n)\n        for i = 0 to n - 1\n            count_smaller = 0\n            count_equal = 0\n            for j = 0 to n - 1\n                if array.get(values, j) < array.get(values, i)\n                    count_smaller += 1\n                if array.get(values, j) == array.get(values, i)\n                    count_equal += 1\n            // Rank is 1-based. Average rank for ties: count_smaller + (count_equal - 1) / 2.0 + 1\n            array.set(ranks, i, count_smaller + (count_equal - 1) / 2.0 + 1)\n        ranks\n\n// @function Calculates Pearson correlation coefficient on two arrays.\n// @param x_arr float[] Array of x values.\n// @param y_arr float[] Array of y values.\n// @returns float Pearson correlation coefficient, or na if inputs are invalid/insufficient. Returns 0 if one series is constant.\npearson_on_arrays(float[] x_arr, float[] y_arr) =>\n    n = array.size(x_arr)\n    if n == 0 or n != array.size(y_arr) or n < 2 // Need at least 2 points for correlation\n        float(na)\n    else\n        sum_x = 0.0\n        sum_y = 0.0\n        for i = 0 to n - 1\n            sum_x += array.get(x_arr, i)\n            sum_y += array.get(y_arr, i)\n        \n        mean_x = sum_x / n\n        mean_y = sum_y / n\n\n        sum_xy_diff = 0.0\n        sum_x_sq_diff = 0.0\n        sum_y_sq_diff = 0.0\n\n        for i = 0 to n - 1\n            x_diff = array.get(x_arr, i) - mean_x\n            y_diff = array.get(y_arr, i) - mean_y\n            sum_xy_diff += x_diff * y_diff\n            sum_x_sq_diff += x_diff * x_diff\n            sum_y_sq_diff += y_diff * y_diff\n\n        if sum_x_sq_diff == 0.0 or sum_y_sq_diff == 0.0 // If one or both series are constant (zero variance)\n            0.0 // Correlation is typically 0 or undefined. Returning 0.\n        else\n            denominator_sqrt = math.sqrt(sum_x_sq_diff * sum_y_sq_diff)\n            if denominator_sqrt == 0.0 // Should be caught by above, but as a safeguard\n                0.0\n            else\n                sum_xy_diff / denominator_sqrt\n\n//@function Calculates Spearman Rank Correlation Coefficient.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/spearman.md\n//@param source1 series float The first input series.\n//@param source2 series float The second input series.\n//@param length simple int The lookback period. Min 2, Max 60.\n//@returns series float Spearman's Rho coefficient, ranging from -1 to +1.\nspearman_corr(series float source1, series float source2, simple int length) =>\n    if length < 2\n        float(na)\n    else\n     ",
    "functions_used": [
      "array.size",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "input.string",
      "color.new",
      "color.orange",
      "color.yellow",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline"
    ],
    "keywords": [
      "spearman rank correlation (spearman)",
      "statistics",
      "indicator",
      "v5",
      "array.size",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.source",
      "input.symbol",
      "input.int",
      "request.security",
      "timeframe.period",
      "input.string",
      "color.new",
      "color.orange",
      "color.yellow",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "array.size",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "github.com",
      "spearman.md",
      "input.source",
      "input.symbol",
      "e.g",
      "input.int",
      "request.security",
      "timeframe.period",
      "barmerge.lookahead_off",
      "barmerge.gaps_off",
      "input.string",
      "color.new",
      "color.orange",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "color.green",
      "hline.style_dotted",
      "color.red",
      "hline.style_solid",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "const",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-179",
    "type": "example",
    "category": "statistics",
    "title": "Standard Deviation (STDDEV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Standard Deviation (STDDEV)\", \"STDDEV\", overlay=false)\n\n//@function Calculates the standard deviation using a single pass with a circular buffer.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/stddev.md\n//@param src {series float} Source series.\n//@param len {int} Lookback length. `len` > 0.\n//@returns {series float} Standard deviation of `src` for `len` bars back. Returns `na` if not enough data.\nstddev(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0,  var int count = 0\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float val = nz(src)\n    sum += val\n    sumSq += val * val\n    count += 1\n    array.set(buffer, head, val)\n    head := (head + 1) % p\n    count > 1 ? math.sqrt(math.max(0.0, (sumSq / count) - math.pow(sum / count, 2))) : 0.0\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1) // Default period 14\ni_source = input.source(close, \"Source\")\n\n// Calculation\nstddev_value = stddev(i_source, i_period)\n\n// Plot\nplot(stddev_value, \"StdDev\", color=color.yellow, linewidth=2) // Changed color\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "standard deviation (stddev)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "stddev.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "script-180",
    "type": "example",
    "category": "statistics",
    "title": "Theil Index (THEIL)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Theil Index (THEIL)\", \"THEIL\", overlay=false, precision=6)\n\n//@function Calculates Theil's T Index for a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/theil.md\n//@param src series float Input data series (must be positive values).\n//@param len simple int Lookback period (must be > 0).\n//@returns series float The Theil's T Index, or na if data is not suitable.\ntheil_t_index(series float src, simple int len) =>\n    if len <= 0\n        float(na)\n    float sum_src = 0.0\n    int n_valid = 0\n    float[] values_arr = array.new_float()\n    for i = 0 to len - 1\n        val = src[i]\n        if not na(val) and val > 0\n            array.push(values_arr, val)\n            sum_src += val\n            n_valid += 1\n    if n_valid == 0\n        float(na)\n    float mean_val = sum_src / n_valid\n    if mean_val <= 0\n        float(na)\n    float theil_sum = 0.0\n    for i = 0 to n_valid - 1\n        xi = array.get(values_arr, i)\n        ratio = xi / mean_val\n        if ratio > 0\n            theil_sum += ratio * math.log(ratio)\n    float theil_t = na\n    if n_valid > 0\n        theil_t := theil_sum / n_valid\n    \n    theil_t\n\n// Inputs\ni_source = input.source(close, title=\"Source (must be positive values)\")\ni_length = input.int(14, title=\"Lookback Period\", minval=1)\n\n// Calculation\ntheil_value = theil_t_index(i_source, i_length)\n\n// Plot\nplot(theil_value, \"Theil T Index\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "array.new_float",
      "array.push",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "theil index (theil)",
      "statistics",
      "indicator",
      "v5",
      "array.new_float",
      "array.push",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "theil.md",
      "array.new_float",
      "array.push",
      "array.get",
      "math.log",
      "input.source",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-181",
    "type": "example",
    "category": "statistics",
    "title": "Variance, Dispersion or Spread (VARIANCE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Variance, Dispersion or Spread (VARIANCE)\", \"VARIANCE\", overlay=false)\n\n//@function variance\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/variance.md\n//@param src {series float} Source series.\n//@param len {int} Lookback length. `len` > 0.\n//@returns {series float} Variance of `src` for `len` bars back. Returns 0 if not enough data.\nvariance(series float src, int len) =>\n    if len <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, len)\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0,  var int count = 0\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float val = nz(src)\n    sum += val\n    sumSq += val * val\n    count += 1\n    array.set(buffer, head, val)\n    head := (head + 1) % p\n    count > 1 ? math.max(0.0, (sumSq / count) - math.pow(sum / count, 2)) : 0.0\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nvariance_value = variance(i_source, i_period)\n\n// Plot\nplot(variance_value, \"Var\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "variance, dispersion or spread (variance)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "variance.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if"
    ]
  },
  {
    "id": "script-182",
    "type": "example",
    "category": "statistics",
    "title": "Z-Score (ZSCORE)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Z-Score (ZSCORE)\", \"ZSCORE\", overlay=false)\n\n//@function Calculates the Z-Score of a series over a lookback period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/zscore.md\n//@param src Source series.\n//@param len Lookback period. Must be greater than 1.\n//@returns The Z-Score value.\nzscore(series float src, simple int len) =>\n    if len <= 1\n        runtime.error(\"Length must be greater than 1\")\n    var float sumY = 0.0, var float sumY2 = 0.0\n    var int validCount = 0\n    var array<float> y_values = array.new_float(len)\n    var int head = 0\n    var bool filled = false\n    float oldY = filled ? array.get(y_values, head) : na\n    if not na(oldY)\n        sumY -= oldY, sumY2 -= oldY * oldY, validCount -= 1\n    float currentY = src\n    array.set(y_values, head, currentY)\n    if not na(currentY)\n        sumY += currentY, sumY2 += currentY * currentY, validCount += 1\n    head := (head + 1) % len\n    if not filled and head == 0\n        filled := true\n    float zScoreValue = na\n    if validCount >= 2\n        float n = float(validCount), mean = sumY / n\n        float variance = math.max(sumY2 / n - mean * mean, 0.0)\n        float stdDev = math.sqrt(variance)\n        if stdDev > 1e-10\n            zScoreValue := (currentY - mean) / stdDev\n        else\n            zScoreValue := 0.0\n    zScoreValue\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(14, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nz = zscore(i_source, i_period)\n\n// Plot\nplot(z, \"Z-Score\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "z-score (zscore)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "zscore.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-183",
    "type": "example",
    "category": "statistics",
    "title": "One-Sample t-Test (ZTEST)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"One-Sample t-Test (ZTEST)\", \"t-TEST\", overlay=false)\n\n//@function Calculates the t-statistic for a one-sample hypothesis test\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/statistics/ztest.md\n//@param source Source series to test (use returns for meaningful results)\n//@param period Lookback period for calculating sample mean and standard deviation\n//@param mu0 Hypothesized population mean to test against\n//@returns t-statistic (positive values indicate sample mean > mu0, negative indicate sample mean < mu0)\n//@optimized Uses circular buffer with running sums for O(1) complexity, Bessel correction for sample variance\nztest(series float source, simple int period, simple float mu0) =>\n    if period <= 1\n        runtime.error(\"Period must be greater than 1\")\n    \n    int p = period\n    var array<float> buffer = array.new_float(0)\n    var int head = 0\n    var int n = 0\n    var float sum = 0.0\n    var float sumSq = 0.0\n    \n    if array.size(buffer) != p\n        buffer := array.new_float(p, na)\n        head := 0\n        n := 0\n        sum := 0.0\n        sumSq := 0.0\n    \n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        n -= 1\n    \n    if not na(source)\n        sum += source\n        sumSq += source * source\n        n += 1\n        array.set(buffer, head, source)\n    else\n        array.set(buffer, head, na)\n    \n    head := (head + 1) % p\n    \n    float result = na\n    if n >= 2\n        float nf = float(n)\n        float mean = sum / nf\n        float variance = math.max(0.0, (sumSq / nf) - (mean * mean)) * (nf / (nf - 1.0))\n        float stddev = math.sqrt(variance)\n        float standard_error = stddev / math.sqrt(nf)\n        \n        if standard_error > 1e-10\n            result := (mean - mu0) / standard_error\n    \n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_period = input.int(30, \"Period\", minval=2, tooltip=\"Minimum 30 recommended for z-critical approximation\")\ni_mu0 = input.float(0.0, \"Hypothesized Mean (μ₀)\", step=0.01, tooltip=\"Use 0 when testing returns\")\n\n// Calculation\nt_stat = ztest(i_source, i_period, i_mu0)\n\n// Plot\nplot(t_stat, \"t-statistic\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color=color.gray, linestyle=hline.style_dotted)\nhline(2.04, \"95% ~t(30)\", color=color.new(color.green, 70), linestyle=hline.style_dashed)\nhline(-2.04, \"95% ~t(30)\", color=color.new(color.green, 70), linestyle=hline.style_dashed)\nhline(2.75, \"99% ~t(30)\", color=color.new(color.red, 70), linestyle=hline.style_dashed)\nhline(-2.75, \"99% ~t(30)\", color=color.new(color.red, 70), linestyle=hline.style_dashed)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "plot",
      "hline"
    ],
    "keywords": [
      "one-sample t-test (ztest)",
      "statistics",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.gray",
      "color.new",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "github.com",
      "ztest.md",
      "runtime.error",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "color.gray",
      "hline.style_dotted",
      "color.new",
      "color.green",
      "hline.style_dashed",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-184",
    "type": "example",
    "category": "trends_FIR",
    "title": "Arnaud Legoux Moving Average (ALMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Arnaud Legoux Moving Average (ALMA)\", \"ALMA\", overlay=true)\n\n//@function Calculates ALMA using Gaussian distribution weights\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/alma.md\n//@param source Series to calculate ALMA from\n//@param period Lookback period - window size\n//@param offset Controls the Gaussian peak location (0 to 1)\n//@param sigma Controls the Gaussian distribution width/curve shape\n//@returns ALMA value, calculates from first bar using available data\n//@optimized Uses Gaussian weighting with O(n) complexity per bar due to lookback loop\nalma(series float source, simple int period, simple float offset=0.85, simple float sigma=6.0) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if offset < 0.0 or offset > 1.0\n        runtime.error(\"Offset must be between 0 and 1\")\n    if sigma <= 0.0\n        runtime.error(\"Sigma must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    if p <= 1\n        source\n    else\n        float m = (1.0 - offset) * (p - 1)\n        float s = p / sigma\n        float s2 = 2.0 * (s * s)\n        float sum = 0.0\n        float weight_sum = 0.0\n        for i = 0 to p - 1\n            float price = source[i]\n            if not na(price)\n                float diff = i - m\n                float weight = math.exp(-(diff * diff) / s2)\n                sum += price * weight\n                weight_sum += weight\n        nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(50, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\ni_offset = input.float(0.85, \"Offset\", minval=0.0, maxval=1.0, step=0.01)\ni_sigma = input.float(6.0, \"Sigma\", minval=0.1, maxval=20.0, step=0.1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nalma_value = alma(i_source, i_period, i_offset, i_sigma)\n\n// Plot\nplot(alma_value, \"ALMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "arnaud legoux moving average (alma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "alma.md",
      "runtime.error",
      "math.min",
      "math.exp",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-185",
    "type": "example",
    "category": "trends_FIR",
    "title": "Blackman Moving Average (BLMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Blackman Moving Average (BLMA)\", \"BLMA\", overlay=true)\n\n//@function Calculates BLMA using Blackman window weighting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/blma.md\n//@param source Series to calculate BLMA from\n//@param period Lookback period - FIR window size\n//@returns BLMA value, calculates from first bar using available data\n//@optimized Uses Blackman window coefficients with O(n) complexity per bar due to lookback loop\nblma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    if last_p != p\n        weights := array.new_float(p, 0.0)\n        float total_weight = 0.0\n        float a0 = 0.42\n        float a1 = 0.5\n        float a2 = 0.08\n        float inv_p_minus_1 = 1.0 / (p - 1)\n        float pi2 = 2.0 * math.pi\n        float pi4 = 4.0 * math.pi\n        for i = 0 to p - 1\n            float ratio = i * inv_p_minus_1\n            float term1 = a1 * math.cos(pi2 * ratio)\n            float term2 = a2 * math.cos(pi4 * ratio)\n            float w = a0 - term1 + term2\n            array.set(weights, i, w)\n            total_weight += w\n        float inv_total = 1.0 / total_weight\n        for i = 0 to p - 1\n            array.set(weights, i, array.get(weights, i) * inv_total)\n        last_p := p\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nblma_value = blma(i_source, i_period)\n\n// Plot\nplot(blma_value, \"BLMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.pi",
      "math.cos",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "blackman moving average (blma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.pi",
      "math.cos",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "blma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.pi",
      "math.cos",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-186",
    "type": "example",
    "category": "trends_FIR",
    "title": "Bessel-Weighted Moving Average (BWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bessel-Weighted Moving Average (BWMA)\", \"BWMA\", overlay=true)\n\n//@function Calculates BWMA using Bessel window weighting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/bwma.md\n//@param source Series to calculate BWMA from\n//@param period Lookback period - FIR window size\n//@param order Bessel function order (default: 0)\n//@returns BWMA value, calculates from first bar using available data\n//@optimized Uses Bessel window coefficients with O(n) complexity per bar due to lookback loop\nbwma(series float source, simple int period, simple int order=0) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if order < 0\n        runtime.error(\"Bessel order must be non-negative\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    var int last_order = order\n    if last_p != p or last_order != order\n        weights := array.new_float(p, 0.0)\n        float total_weight = 0.0\n        float scale = 2.0 / (p - 1)\n        float power = order / 2.0 + 0.5\n        for i = 0 to p - 1\n            float x = i * scale - 1.0\n            float arg = 1.0 - x * x\n            float w = 0.0\n            if arg > 0.0\n                if order == 0\n                    w := arg\n                else if order == 1\n                    w := arg * math.sqrt(arg)\n                else\n                    w := math.pow(arg, power)\n            array.set(weights, i, w)\n            total_weight += w\n        if total_weight > 0.0\n            float inv_total = 1.0 / total_weight\n            for i = 0 to p - 1\n                array.set(weights, i, array.get(weights, i) * inv_total)\n        last_p := p\n        last_order := order\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_order = input.int(0, \"Bessel Order\", minval=0, maxval=3, tooltip=\"Order of the Bessel function (0-3)\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\nbwma_value = bwma(i_source, i_period, i_order)\n\n// Plot\nplot(bwma_value, \"BWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.sqrt",
      "math.pow",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bessel-weighted moving average (bwma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.sqrt",
      "math.pow",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "bwma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.sqrt",
      "math.pow",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-187",
    "type": "example",
    "category": "trends_FIR",
    "title": "Convolution Moving Average (CONV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Convolution Moving Average (CONV)\", \"CONV\", overlay=true)\n\n//@function Calculates a convolution MA using any custom kernel\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/conv.md\n//@param source Series to calculate CONV from\n//@param kernel Array of weights to use as convolution kernel\n//@returns CONV value, calculates from first bar using available data\n//@optimized Uses custom kernel convolution with O(n) complexity per bar due to lookback loop\nconv(series float source, simple array<float> kernel) =>\n    int kernel_size = array.size(kernel)\n    if kernel_size <= 0\n        runtime.error(\"Kernel must not be empty\")\n    var array<float> norm_kernel = array.new_float(1, 1.0)\n    var int last_kernel_size = 1\n    if last_kernel_size != kernel_size\n        norm_kernel := array.copy(kernel)\n        float kernel_sum = 0.0\n        for i = 0 to kernel_size - 1\n            kernel_sum += array.get(kernel, i)\n        if kernel_sum != 0.0\n            float inv_sum = 1.0 / kernel_sum\n            for i = 0 to kernel_size - 1\n                array.set(norm_kernel, i, array.get(kernel, i) * inv_sum)\n        last_kernel_size := kernel_size\n    int p = math.min(bar_index + 1, kernel_size)\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(norm_kernel, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_kernel = array.from(1.0, 2.5, -3.14, 0.0, 1.0)\n\n// Calculation\nconv_value = conv(i_source, i_kernel)\n\n// Plot\nplot(conv_value, \"CONV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "array.size",
      "runtime.error",
      "array.new_float",
      "array.copy",
      "array.get",
      "array.set",
      "math.min",
      "input.source",
      "array.from",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "convolution moving average (conv)",
      "trends_FIR",
      "indicator",
      "v6",
      "array.size",
      "runtime.error",
      "array.new_float",
      "array.copy",
      "array.get",
      "array.set",
      "math.min",
      "input.source",
      "array.from",
      "color.yellow",
      "plot",
      "github.com",
      "conv.md",
      "array.size",
      "runtime.error",
      "array.new_float",
      "array.copy",
      "array.get",
      "array.set",
      "math.min",
      "input.source",
      "array.from",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-188",
    "type": "example",
    "category": "trends_FIR",
    "title": "Double Weighted Moving Average (DWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Double Weighted Moving Average (DWMA)\", \"DWMA\", overlay=true)\n\n//@function Calculates DWMA using double weighted smoothing with inline O(1) WMA\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/dwma.md\n//@param source Series to calculate DWMA from\n//@param period Lookback period for both smoothing passes\n//@returns DWMA value, calculates from first bar using available data\n//@optimized Uses two inline O(1) WMA calculations for combined O(1) complexity per bar\ndwma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    var array<float> buffer1 = array.new_float(period, na)\n    var int head1 = 0\n    var float sum1 = 0.0\n    var float weighted_sum1 = 0.0\n    var int count1 = 0\n    var float norm1 = 0.0\n    \n    var array<float> buffer2 = array.new_float(period, na)\n    var int head2 = 0\n    var float sum2 = 0.0\n    var float weighted_sum2 = 0.0\n    var int count2 = 0\n    var float norm2 = 0.0\n    \n    float oldest1 = array.get(buffer1, head1)\n    float current1 = nz(source)\n    \n    if not na(oldest1)\n        float old_sum1 = sum1\n        sum1 -= oldest1\n        sum1 += current1\n        weighted_sum1 := weighted_sum1 - old_sum1 + (period * current1)\n    else\n        count1 += 1\n        sum1 += current1\n        weighted_sum1 := weighted_sum1 + (count1 * current1)\n        norm1 := count1 * (count1 + 1) * 0.5\n    \n    array.set(buffer1, head1, current1)\n    head1 := (head1 + 1) % period\n    \n    float wma1 = weighted_sum1 / norm1\n    \n    float oldest2 = array.get(buffer2, head2)\n    float current2 = nz(wma1)\n    \n    if not na(oldest2)\n        float old_sum2 = sum2\n        sum2 -= oldest2\n        sum2 += current2\n        weighted_sum2 := weighted_sum2 - old_sum2 + (period * current2)\n    else\n        count2 += 1\n        sum2 += current2\n        weighted_sum2 := weighted_sum2 + (count2 * current2)\n        norm2 := count2 * (count2 + 1) * 0.5\n    \n    array.set(buffer2, head2, current2)\n    head2 := (head2 + 1) % period\n    \n    weighted_sum2 / norm2\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ndwma_value = dwma(i_source, i_period)\n\n// Plot\nplot(dwma_value, \"DWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "double weighted moving average (dwma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "dwma.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-189",
    "type": "example",
    "category": "trends_FIR",
    "title": "Endpoint Moving Average (EPMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Endpoint Moving Average (EPMA)\", \"EPMA\", overlay=true)\n\n//@function Calculates EPMA using linear weighting with endpoint emphasis\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/epma.md\n//@param source Series to calculate EPMA from\n//@param period Lookback period\n//@returns EPMA value with proper weight distribution\n//@optimized Uses linear weighting with O(n) complexity per bar due to lookback loop\nepma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.max(1, math.min(bar_index + 1, period))\n    if p <= 1\n        source\n    else\n        float weightedSum = 0.0\n        float totalWeight = 0.0\n        for i = 0 to p - 1\n            float price = source[i]\n            if not na(price)\n                int weight = p - i\n                weightedSum += price * weight\n                totalWeight += weight\n        nz(weightedSum / totalWeight, na)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nepma_value = epma(i_source, i_period)\n\n// Plot\nplot(epma_value, \"EPMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "endpoint moving average (epma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "epma.md",
      "runtime.error",
      "math.max",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-190",
    "type": "example",
    "category": "trends_FIR",
    "title": "Gaussian-Weighted Moving Average (GWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Gaussian-Weighted Moving Average (GWMA)\", \"GWMA\", overlay=true)\n\n//@function Calculates GWMA using Gaussian window weighting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/gwma.md\n//@param source Series to calculate GWMA from\n//@param period Lookback period - FIR window size\n//@param sigma Controls the width of the Gaussian bell curve (default: 0.4)\n//@returns GWMA value, calculates from first bar using available data\n//@optimized Uses Gaussian window coefficients with O(n) complexity per bar due to lookback loop\ngwma(series float source, simple int period, simple float sigma=0.4) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    var float last_sigma = sigma\n    if last_p != p or last_sigma != sigma\n        weights := array.new_float(p, 0.0)\n        float center = (p - 1) / 2.0\n        float inv_sigmap = 1.0 / (sigma * p)\n        float total = 0.0\n        for i = 0 to p - 1\n            float x = (i - center) * inv_sigmap\n            float w = math.exp(-0.5 * x * x)\n            array.set(weights, i, w)\n            total += w\n        float inv_total = 1.0 / total\n        for i = 0 to p - 1\n            array.set(weights, i, array.get(weights, i) * inv_total)\n        last_p := p\n        last_sigma := sigma\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_sigma = input.float(0.4, \"Sigma\", minval=0.1, maxval=1.0, step=0.1, tooltip=\"Controls the width of the Gaussian bell curve. Lower values make the curve narrower.\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\ngwma_value = gwma(i_source, i_period, i_sigma)\n\n// Plot\nplot(gwma_value, \"GWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.exp",
      "array.set",
      "array.get",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "gaussian-weighted moving average (gwma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.exp",
      "array.set",
      "array.get",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "gwma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.exp",
      "array.set",
      "array.get",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-191",
    "type": "example",
    "category": "trends_FIR",
    "title": "Hamming Moving Average (HAMMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hamming Moving Average (HAMMA)\", \"HAMMA\", overlay=true)\n\n//@function Calculates HAMMA using Hamming window weighting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/hamma.md\n//@param source Series to calculate HAMMA from\n//@param period Lookback period - FIR window size\n//@returns HAMMA value, calculates from first bar using available data\n//@optimized Uses Hamming window coefficients with O(n) complexity per bar due to lookback loop\nhamma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    if last_p != p\n        weights := array.new_float(p, 0.0)\n        for i = 0 to p - 1\n            float w = 0.54 - 0.46 * math.cos(2.0 * math.pi * i / (p - 1))\n            array.set(weights, i, w)\n        last_p := p\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhamma_value = hamma(i_source, i_period)\n\n// Plot\nplot(hamma_value, \"HAMMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hamming moving average (hamma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hamma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-192",
    "type": "example",
    "category": "trends_FIR",
    "title": "Hanning Moving Average (HANMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hanning Moving Average (HANMA)\", \"HANMA\", overlay=true)\n\n//@function Calculates HANMA using Hanning window weighting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/hanma.md\n//@param source Series to calculate HANMA from\n//@param period Lookback period - FIR window size\n//@returns HANMA value, calculates from first bar using available data\n//@optimized Uses Hanning window coefficients with O(n) complexity per bar due to lookback loop\nhanma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    if last_p != p\n        weights := array.new_float(p, 0.0)\n        for i = 0 to p - 1\n            float w = 0.5 * (1.0 - math.cos(2.0 * math.pi * i / (p - 1)))\n            array.set(weights, i, w)\n        last_p := p\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhanma_value = hanma(i_source, i_period)\n\n// Plot\nplot(hanma_value, \"HANMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hanning moving average (hanma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hanma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.cos",
      "math.pi",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-193",
    "type": "example",
    "category": "trends_FIR",
    "title": "Hull Moving Average (HMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hull Moving Average (HMA)\", \"HMA\", overlay=true)\n\n//@function Calculates WMA using circular buffer with O(1) complexity\n//@param source Series to calculate WMA from\n//@param period Lookback period\n//@returns WMA value\nwma_helper(series float source, simple int period) =>\n    var array<float> buffer = array.new_float(period, na)\n    var int head = 0\n    var float sum = 0.0\n    var float weighted_sum = 0.0\n    var int count = 0\n    var float norm = 0.0\n    \n    float oldest = array.get(buffer, head)\n    float current = nz(source)\n    \n    if not na(oldest)\n        float old_sum = sum\n        sum -= oldest\n        sum += current\n        weighted_sum := weighted_sum - old_sum + (period * current)\n    else\n        count += 1\n        sum += current\n        weighted_sum := weighted_sum + (count * current)\n        norm := count * (count + 1) * 0.5\n    \n    array.set(buffer, head, current)\n    head := (head + 1) % period\n    \n    weighted_sum / norm\n\n//@function Calculates HMA using optimized WMA helper function\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/hma.md\n//@param source Series to calculate HMA from\n//@param period Lookback period - FIR window size\n//@returns HMA value, calculates from first bar using available data\n//@optimized Uses three O(1) WMA calculations for combined O(1) complexity per bar\nhma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    int half_period = math.max(1, math.round(period / 2.0))\n    int sqrt_period = math.max(1, math.round(math.sqrt(period)))\n    \n    float wma_half = wma_helper(source, half_period)\n    float wma_full = wma_helper(source, period)\n    float diff = 2.0 * wma_half - wma_full\n    float hma_value = wma_helper(diff, sqrt_period)\n    \n    hma_value\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhma_value = hma(i_source, i_period)\n\n// Plot\nplot(hma_value, \"HMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "array.new_float",
      "array.get",
      "array.set",
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hull moving average (hma)",
      "trends_FIR",
      "indicator",
      "v6",
      "array.new_float",
      "array.get",
      "array.set",
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "array.new_float",
      "array.get",
      "array.set",
      "github.com",
      "hma.md",
      "runtime.error",
      "math.max",
      "math.round",
      "math.sqrt",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-194",
    "type": "example",
    "category": "trends_FIR",
    "title": "Holt-Winters Moving Average (HWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Holt-Winters Moving Average (HWMA)\", \"HWMA\", overlay=true)\n\n//@function Calculates HWMA using triple exponential smoothing with level, velocity, and acceleration components\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/hwma.md\n//@param source Series to calculate HWMA from\n//@param alpha Level smoothing factor\n//@param beta Velocity smoothing factor\n//@param gamma Acceleration smoothing factor\n//@param period When used, calculate alpha/beta/gamma from period\n//@returns HWMA value from first bar with proper compensation\n//@optimized Uses triple exponential smoothing with O(1) complexity per bar\nhwma(series float source, float alpha=0.0, float beta=0.0, float gamma=0.0, simple int period=0) =>\n    float a = period > 0 ? 2.0 / (float(period) + 1.0) : alpha\n    float b = period > 0 ? 1.0 / float(period) : beta\n    float g = period > 0 ? 1.0 / float(period) : gamma\n    var float F = na\n    var float V = 0.0\n    var float A = 0.0\n    if na(source)\n        if na(F)\n            na\n        else\n            float prevF = F\n            float prevV = V\n            float prevA = A\n            F := prevF + prevV + 0.5 * prevA\n            V := prevV + prevA\n            A := 0.9 * prevA\n            F\n    else\n        if na(F)\n            F := source\n            F\n        else\n            float prevF = F\n            float prevV = V\n            float prevA = A\n            F := a * source + (1.0 - a) * (prevF + prevV + 0.5 * prevA)\n            V := b * (F - prevF) + (1.0 - b) * (prevV + prevA)\n            A := g * (V - prevV) + (1.0 - g) * prevA\n            F + V + 0.5 * A\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhwma_value = hwma(i_source, period=i_period)\n\n// Plot\nplot(hwma_value, \"HWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "holt-winters moving average (hwma)",
      "trends_FIR",
      "indicator",
      "v6",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hwma.md",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "if",
      "else"
    ]
  },
  {
    "id": "script-195",
    "type": "example",
    "category": "trends_FIR",
    "title": "Least Squares Moving Average (LSMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Least Squares Moving Average (LSMA)\", \"LSMA\", overlay=true)\n\n//@function Calculates LSMA by fitting a linear regression line to price data\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/lsma.md\n//@param source Series to calculate LSMA from\n//@param period Lookback period for the linear regression\n//@returns LSMA value, calculates from first bar using available data\n//@optimized Uses circular buffer with linear regression for O(n) complexity per bar\nlsma(series float source, simple int period) =>\n    if period <= 1\n        runtime.error(\"Period must be greater than 1\")\n        source\n    else\n        int p = math.min(bar_index + 1, period)\n        if p <= 1\n            source\n        else\n            var array<float> buffer = array.new_float(period, na)\n            var int head = 0\n            array.set(buffer, head, source)\n            head := (head + 1) % period\n            float sum_y = 0.0\n            float sum_xy = 0.0\n            float sum_x = 0.0\n            float sum_x2 = 0.0\n            float count = 0.0\n            int idx = (head - 1 + period) % period\n            for i = 0 to p - 1\n                float val = array.get(buffer, idx)\n                if not na(val)\n                    sum_x += i\n                    sum_y += val\n                    sum_xy += i * val\n                    sum_x2 += i * i\n                    count += 1.0\n                idx := (idx - 1 + period) % period\n            if count <= 1.0\n                source\n            else\n                float denom = count * sum_x2 - sum_x * sum_x\n                if denom == 0.0\n                    source\n                else\n                    float slope = (count * sum_xy - sum_x * sum_y) / denom\n                    float intercept = (sum_y - slope * sum_x) / count\n                    intercept\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nlsma_value = lsma(i_source, i_period)\n\n// Plot\nplot(lsma_value, \"LSMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "least squares moving average (lsma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "lsma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-196",
    "type": "example",
    "category": "trends_FIR",
    "title": "Pascal Weighted Moving Average (PWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Pascal Weighted Moving Average (PWMA)\", \"PWMA\", overlay=true)\n\n//@function Calculates PWMA using Pascal's triangle coefficients as weights with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/pwma.md\n//@param source Series to calculate PWMA from\n//@param period Lookback period - FIR window size\n//@returns PWMA value, calculates from first bar using available data\n//@optimized Uses Pascal's triangle weighting with O(n) complexity per bar due to lookback loop\npwma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    if last_p != p\n        weights := array.new_float(p, 0.0)\n        array.set(weights, 0, 1.0)\n        if p > 1\n            float prev_weight = 1.0\n            for i = 1 to p - 1\n                float curr_weight = prev_weight * (p - i) / i\n                array.set(weights, i, curr_weight)\n                prev_weight := curr_weight\n        last_p := p\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\npwma_value = pwma(i_source, i_period)\n\n// Plot\nplot(pwma_value, \"PWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "pascal weighted moving average (pwma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "pwma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-197",
    "type": "example",
    "category": "trends_FIR",
    "title": "Savitzky-Golay Moving Average (SGMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Savitzky-Golay Moving Average (SGMA)\", \"SGMA\", overlay=true)\n\n//@function Calculates SGMA using Savitzky-Golay filter with polynomial fitting\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/sgma.md\n//@param source Series to calculate SGMA from\n//@param period Lookback period - FIR window size (must be odd)\n//@param deg Polynomial degree (default: 2)\n//@returns SGMA value, calculates from first bar using available data\n//@optimized Uses Savitzky-Golay coefficients with O(n) complexity per bar due to lookback loop\nsgma(series float source, simple int period, simple int deg=2) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int use_period = period % 2 == 0 ? period + 1 : period\n    int use_deg = deg < 0 or deg >= use_period ? 2 : math.min(deg, 4)\n    int p = math.min(bar_index + 1, use_period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    var int last_deg = use_deg\n    if last_p != p or last_deg != use_deg\n        weights := array.new_float(p, 0.0)\n        if use_deg == 2\n            if p == 5\n                array.set(weights, 0, -0.0857)\n                array.set(weights, 1, 0.3429)\n                array.set(weights, 2, 0.4857)\n                array.set(weights, 3, 0.3429)\n                array.set(weights, 4, -0.0857)\n            else if p == 7\n                array.set(weights, 0, -0.0476)\n                array.set(weights, 1, 0.0952)\n                array.set(weights, 2, 0.2857)\n                array.set(weights, 3, 0.3333)\n                array.set(weights, 4, 0.2857)\n                array.set(weights, 5, 0.0952)\n                array.set(weights, 6, -0.0476)\n            else if p == 9\n                array.set(weights, 0, -0.0281)\n                array.set(weights, 1, 0.0337)\n                array.set(weights, 2, 0.1236)\n                array.set(weights, 3, 0.2247)\n                array.set(weights, 4, 0.2921)\n                array.set(weights, 5, 0.2247)\n                array.set(weights, 6, 0.1236)\n                array.set(weights, 7, 0.0337)\n                array.set(weights, 8, -0.0281)\n            else\n                float half_window = (p - 1) / 2.0\n                float total_weight = 0.0\n                for i = 0 to p - 1\n                    float x = i - half_window\n                    float norm_x = x / half_window\n                    float w = 1.0 - norm_x * norm_x\n                    array.set(weights, i, w)\n                    total_weight += w\n                float inv_total = 1.0 / total_weight\n                for i = 0 to p - 1\n                    array.set(weights, i, array.get(weights, i) * inv_total)\n        else\n            float half_window = (p - 1) / 2.0\n            float total_weight = 0.0\n            for i = 0 to p - 1\n                float x = i - half_window\n                float norm_x = x / half_window\n                float w = 0.0\n                if",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "savitzky-golay moving average (sgma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "sgma.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "array.get",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-198",
    "type": "example",
    "category": "trends_FIR",
    "title": "Sine-weighted Moving Average (SINEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Sine-weighted Moving Average (SINEMA)\", \"SINEMA\", overlay=true)\n\n//@function Calculates SINEMA using sine-wave weighted smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/sinema.md\n//@param source Series to calculate SINEMA from\n//@param period Lookback period - FIR window size\n//@returns SINEMA value, calculates from first bar using available data\n//@optimized Uses sine wave weighting with O(n) complexity per bar due to lookback loop\nsinema(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var int prev_p = 0\n    var array<float> sine_weights = array.new_float(period, 0.0)\n    if p != prev_p\n        sine_weights := array.new_float(p, 0.0)\n        for j = 0 to p - 1\n            array.set(sine_weights, j, math.sin(math.pi * (j + 1) / p))\n        prev_p := p\n    float sum = 0.0\n    float weight = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(sine_weights, i)\n            sum += price * w\n            weight += w\n    nz(sum / weight, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nsinema_value = sinema(i_source, i_period)\n\n// Plot\nplot(sinema_value, \"SINEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "math.sin",
      "math.pi",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "sine-weighted moving average (sinema)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "math.sin",
      "math.pi",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "sinema.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "array.set",
      "math.sin",
      "math.pi",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-199",
    "type": "example",
    "category": "trends_FIR",
    "title": "Simple Moving Average (SMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Simple Moving Average (SMA)\", \"SMA\", overlay=true)\n\n//@function Calculates SMA using simple smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/sma.md\n//@param source Series to calculate SMA from\n//@param period Lookback period - FIR window size\n//@returns SMA value, calculates from first bar using available data\n//@optimized Uses circular buffer and running sum for O(1) complexity\nsma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = period\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0\n    var float sum = 0.0\n    var int count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n    else\n        count += 1\n    float current = nz(source)\n    sum += current\n    array.set(buffer, head, current)\n    head := (head + 1) % p\n    sum / math.max(1, count)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nsma_value = sma(i_source, i_period)\n\n// Plot\nplot(sma_value, \"SMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "simple moving average (sma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "sma.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-200",
    "type": "example",
    "category": "trends_FIR",
    "title": "Triangular Moving Average (TRIMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Triangular Moving Average (TRIMA)\", \"TRIMA\", overlay=true)\n\n//@function Calculates TRIMA using triangular weighted smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/trima.md\n//@param source Series to calculate TRIMA from\n//@param period Lookback period - FIR window size\n//@returns TRIMA value, calculates from first bar using available data\n//@optimized Uses triangular weighting with O(n) complexity per bar due to lookback loop\ntrima(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    int p = math.min(bar_index + 1, period)\n    var array<float> weights = array.new_float(1, 1.0)\n    var int last_p = 1\n    if last_p != p\n        weights := array.new_float(p, 0.0)\n        int mid = math.floor(p / 2)\n        for i = 0 to p - 1\n            array.set(weights, i, math.min(i, p - 1 - i) + 1)\n        last_p := p\n    float sum = 0.0\n    float weight_sum = 0.0\n    for i = 0 to p - 1\n        float price = source[i]\n        if not na(price)\n            float w = array.get(weights, i)\n            sum += price * w\n            weight_sum += w\n    nz(sum / weight_sum, source)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ntrima_value = trima(i_source, i_period)\n\n// Plot\nplot(trima_value, \"TRIMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "triangular moving average (trima)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "trima.md",
      "runtime.error",
      "math.min",
      "array.new_float",
      "math.floor",
      "array.set",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-201",
    "type": "example",
    "category": "trends_FIR",
    "title": "Weighted Moving Average (WMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Weighted Moving Average (WMA)\", \"WMA\", overlay=true)\n\n//@function Calculates WMA using circular buffer with O(1) complexity\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_FIR/wma.md\n//@param source Series to calculate WMA from\n//@param period Lookback period - FIR window size\n//@returns WMA value, calculates from first bar using available data\n//@optimized Uses dual running sums with cached denominator for O(1) complexity per bar\nwma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    var array<float> buffer = array.new_float(period, na)\n    var int head = 0\n    var float sum = 0.0\n    var float weighted_sum = 0.0\n    var int count = 0\n    var float norm = 0.0\n    \n    float oldest = array.get(buffer, head)\n    float current = nz(source)\n    \n    if not na(oldest)\n        float old_sum = sum\n        sum -= oldest\n        sum += current\n        weighted_sum := weighted_sum - old_sum + (period * current)\n    else\n        count += 1\n        sum += current\n        weighted_sum := weighted_sum + (count * current)\n        norm := count * (count + 1) * 0.5\n    \n    array.set(buffer, head, current)\n    head := (head + 1) % period\n    \n    weighted_sum / norm\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nwma_value = wma(i_source, i_period)\n\n// Plot\nplot(wma_value, \"WMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "weighted moving average (wma)",
      "trends_FIR",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "wma.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-202",
    "type": "example",
    "category": "trends_IIR",
    "title": "Double Exponential Moving Average (DEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Double Exponential Moving Average (DEMA)\", \"DEMA\", overlay=true)\n\n//@function Calculates DEMA using double exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/dema.md\n//@param source Series to calculate DEMA from\n//@param period Lookback period for DEMA calculation\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns DEMA value from first bar with proper compensation\n//@optimized Uses exponential warmup compensator on both EMA stages for O(1) complexity\ndema(series float source, simple int period=0, simple float alpha=0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a = alpha > 0 ? alpha : 2.0 / (period + 1)\n    float beta = 1.0 - a\n    var bool warmup = true\n    var float e = 1.0\n    var float ema1_raw = 0.0\n    var float ema2_raw = 0.0\n    var float ema1 = source\n    var float ema2 = source\n    ema1_raw := a * (source - ema1_raw) + ema1_raw\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        ema1 := c * ema1_raw\n        ema2_raw := a * (ema1 - ema2_raw) + ema2_raw\n        ema2 := c * ema2_raw\n        warmup := e > 1e-10\n    else\n        ema1 := ema1_raw\n        ema2_raw := a * (ema1 - ema2_raw) + ema2_raw\n        ema2 := ema2_raw\n    2 * ema1 - ema2\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ndema_value = dema(i_source, period=i_period)\n\n// Plot\nplot(dema_value, \"DEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "double exponential moving average (dema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "dema.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-203",
    "type": "example",
    "category": "trends_IIR",
    "title": "Deviation-Scaled Moving Average (DSMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Deviation-Scaled Moving Average (DSMA)\", \"DSMA\", overlay=true)\n\n//@function Calculates DSMA using standard deviation to scale the averaging factor\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/dsma.md\n//@param source Series to calculate DSMA from\n//@param period Length of the lookback period for both average and deviation calculation\n//@param scaleFactor Combined scaling/smoothing factor (0.01-0.9)\n//@returns DSMA value that adapts to market volatility through deviation scaling\n//@optimized Uses circular buffer for RMS calculation and adaptive alpha for O(1) complexity\ndsma(series float source, simple int period, simple float scaleFactor=0.5) =>\n    float a1 = math.exp(-1.414 * math.pi / (period * 0.5))\n    float b1 = 2.0 * a1 * math.cos(1.414 * math.pi / (period * 0.5))\n    float c1 = 1.0 - b1 + (a1 * a1)\n    float c1Half = c1 * 0.5\n    float periodRecip = 1.0 / period\n    float scaleAdjustment = scaleFactor * 5.0 * periodRecip\n    var float result = na\n    var float filt = 0.0\n    var float filt1 = 0.0\n    var float filt2 = 0.0\n    var float zeros1 = 0.0\n    var float sumSquared = 0.0\n    var array<float> filtSquared = array.new_float(period, 0.0)\n    var int bufferIndex = 0\n    if na(source)\n        result\n    else\n        if na(result)\n            result := source\n        else\n            float zeros = source - result\n            filt := c1Half * (zeros + zeros1) + b1 * filt1 - (a1 * a1) * filt2\n            float filtSq = filt * filt\n            sumSquared := sumSquared + filtSq - array.get(filtSquared, bufferIndex)\n            array.set(filtSquared, bufferIndex, filtSq)\n            bufferIndex := (bufferIndex + 1) % period\n            float rms = math.sqrt(math.max(sumSquared * periodRecip, 1e-10))\n            float alpha = math.min(scaleAdjustment * math.abs(filt / rms), 1.0)\n            result := alpha * source + (1 - alpha) * result\n            zeros1 := zeros\n            filt2 := filt1\n            filt1 := filt\n        result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_period = input.int(25, \"Period\", minval=2)\ni_scale = input.float(0.9, \"Scale Factor\", minval=0.01, maxval=0.9, step=0.01)\n\n// Calculation\ndsma_value = dsma(i_source, i_period, i_scale)\n\n// Plot\nplot(dsma_value, \"DSMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.exp",
      "math.pi",
      "math.cos",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.min",
      "math.abs",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "deviation-scaled moving average (dsma)",
      "trends_IIR",
      "indicator",
      "v6",
      "math.exp",
      "math.pi",
      "math.cos",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.min",
      "math.abs",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "dsma.md",
      "math.exp",
      "math.pi",
      "math.cos",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.min",
      "math.abs",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-204",
    "type": "example",
    "category": "trends_IIR",
    "title": "Exponential Moving Average (EMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Exponential Moving Average (EMA)\", \"EMA\", overlay=true)\n\n//@function Calculates EMA using exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/ema.md\n//@param source Series to calculate EMA from\n//@param period Lookback period for EMA calculation\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns EMA value from first bar with proper compensation\n//@optimized Uses exponential warmup compensator for O(1) complexity and valid output from bar 1\nema(series float source, simple int period=0, simple float alpha=0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a = alpha > 0 ? alpha : 2.0 / (period + 1)\n    float beta = 1.0 - a\n    var bool warmup = true\n    var float e = 1.0\n    var float ema = 0.0\n    var float result = source\n    ema := a * (source - ema) + ema\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := c * ema\n        warmup := e > 1e-10\n    else\n        result := ema\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nema_value = ema(i_source, period=i_period)\n\n// Plot\nplot(ema_value, \"EMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "exponential moving average (ema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "ema.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-205",
    "type": "example",
    "category": "trends_IIR",
    "title": "Fractal Adaptive Moving Average (FRAMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Fractal Adaptive Moving Average (FRAMA)\", \"FRAMA\", overlay=true)\n\n//@function Calculates FRAMA using fractal dimension to determine the optimal alpha\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/frama.md\n//@param source Series to calculate FRAMA from\n//@param period Number of bars used in the calculation\n//@returns FRAMA value with fractal-based adaptive smoothing\n//@optimized Uses fractal dimension calculation for adaptive alpha, achieving O(n) per bar due to lookback requirements\nframa(series float src, simple int period) =>\n    int p = math.max(2, period)\n    int p_adj = p % 2 == 0 ? p : p + 1\n    int i_h_p = int(p_adj / 2)\n    float n1 = na\n    float n2 = na\n    float n3 = na\n    bool data_available = bar_index >= (p_adj - 1) and not na(src[p_adj - 1])\n    if data_available\n        float hh1 = src\n        float ll1 = src\n        for i = 1 to i_h_p - 1\n            float val = src[i]\n            if not na(val)\n                hh1 := math.max(hh1, val)\n                ll1 := math.min(ll1, val)\n        float hh2_calc = src[i_h_p]\n        float ll2_calc = src[i_h_p]\n        bool second_half_na = na(hh2_calc)\n        if not second_half_na\n            for i = i_h_p + 1 to p_adj - 1\n                float val = src[i]\n                if not na(val)\n                    hh2_calc := math.max(hh2_calc, val)\n                    ll2_calc := math.min(ll2_calc, val)\n                else\n                    second_half_na := true\n                    break\n        float hh3 = src\n        float ll3 = src\n        for i = 1 to p_adj - 1\n            float val = src[i]\n            if not na(val)\n                hh3 := math.max(hh3, val)\n                ll3 := math.min(ll3, val)\n        if not na(hh1) and not na(ll1) and i_h_p > 0\n            n1 := (hh1 - ll1) / i_h_p\n        if not second_half_na and i_h_p > 0\n            n2 := (hh2_calc - ll2_calc) / i_h_p\n        if not na(hh3) and not na(ll3) and p_adj > 0\n            n3 := (hh3 - ll3) / p_adj\n    var float result = na\n    float alpha = 1.0\n    if n1 > 0 and n2 > 0 and n3 > 0\n        float dimen = (math.log(n1 + n2) - math.log(n3)) / math.log(2.0)\n        alpha := math.exp(-4.6 * (dimen - 1.0))\n        alpha := math.max(0.01, math.min(1.0, alpha))\n    if not na(src)\n        float prev_f = nz(result[1], src)\n        result := alpha * src + (1.0 - alpha) * prev_f\n    else\n        result := na\n    data_available ? result : na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(16, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nframa_value = frama(i_source, i_period)\n\n// Plot\nplot(frama_value, \"FRAMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "math.min",
      "math.log",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "fractal adaptive moving average (frama)",
      "trends_IIR",
      "indicator",
      "v6",
      "math.max",
      "math.min",
      "math.log",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "frama.md",
      "math.max",
      "math.min",
      "math.log",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-206",
    "type": "example",
    "category": "trends_IIR",
    "title": "Hull Exponential Moving Average (HEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hull Exponential Moving Average (HEMA)\", \"HEMA\", overlay=true)\n\n//@function Calculates HEMA (Hull Exponential Moving Average) combining multiple EMA calculations\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/hema.md\n//@param source Series to calculate HEMA from\n//@param period Lookback period for calculation\n//@returns HEMA value that combines fast and slow EMAs with logarithmic weighting\n//@optimized Uses three-stage exponential warmup compensators for O(1) complexity\nhema(series float src, simple int N) =>\n    float alphaSlow = 3.0 / (2.0 * N - 1.0)\n    float lambdaSlow = -math.log(1.0 - alphaSlow)\n    float ratio = math.log(2.0) / (1.0 + math.log(2.0))\n    float alphaFast = 1.0 - math.exp(-lambdaSlow / ratio)\n    float alphaSmooth = 2.0 / (math.sqrt(N) / 2.0 + 1.0)\n    float betaSlow = 1.0 - alphaSlow\n    float betaFast = 1.0 - alphaFast\n    float betaSmooth = 1.0 - alphaSmooth\n    float chkSlow = nz(alphaSlow, 1.0)\n    float chkFast = nz(alphaFast, 1.0)\n    float chkSmth = nz(alphaSmooth, 1.0)\n    float alphaMin = math.min(chkSlow, chkFast, chkSmth, 0.000001)\n    var bool warmup = true\n    var float decaySlow = 1.0\n    var float decayFast = 1.0\n    var float decaySmooth = 1.0\n    var float emaSlowRaw = 0.0\n    var float emaFastRaw = 0.0\n    var float emaSmoothRaw = 0.0\n    float emaSlow = na\n    float emaFast = na\n    float hemaVal = na\n    emaSlowRaw := alphaSlow * (src - emaSlowRaw) + emaSlowRaw\n    emaFastRaw := alphaFast * (src - emaFastRaw) + emaFastRaw\n    if warmup\n        decaySlow *= betaSlow\n        decayFast *= betaFast\n        decaySmooth *= betaSmooth\n        emaSlow := (1.0 / (1.0 - decaySlow)) * emaSlowRaw\n        emaFast := (1.0 / (1.0 - decayFast)) * emaFastRaw\n        float deLag = emaFast / (1.0 - ratio) - ratio * emaSlow / (1.0 - ratio)\n        emaSmoothRaw := alphaSmooth * (deLag - emaSmoothRaw) + emaSmoothRaw\n        hemaVal := (1.0 / (1.0 - decaySmooth)) * emaSmoothRaw\n        warmup := decaySlow > 1e-10\n    else\n        emaSlow := emaSlowRaw\n        emaFast := emaFastRaw\n        float deLag = emaFast / (1.0 - ratio) - ratio * emaSlow / (1.0 - ratio)\n        emaSmoothRaw := alphaSmooth * (deLag - emaSmoothRaw) + emaSmoothRaw\n        hemaVal := emaSmoothRaw\n    hemaVal\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhema_value = hema(i_source, i_period)\n\n// Plot\nplot(hema_value, \"HEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.log",
      "math.exp",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hull exponential moving average (hema)",
      "trends_IIR",
      "indicator",
      "v6",
      "math.log",
      "math.exp",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "hema.md",
      "math.log",
      "math.exp",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-207",
    "type": "example",
    "category": "trends_IIR",
    "title": "Hilbert Trendline (HTIT)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Hilbert Trendline (HTIT)\", \"HTIT\", overlay=true)\n\n//@function Calculates the Hilbert Transform Instantaneous Trendline (HTIT)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/htit.md\n//@param source Series to calculate HTIT from\n//@returns HTIT value using Hilbert Transform with adaptive period estimation\n//@optimized Uses Hilbert Transform quadrature components for O(1) complexity per bar\nhtit(series float source) =>\n    var float price = na\n    var float smooth = na\n    var float detrender = 0.0\n    var float I1 = 0.0\n    var float Q1 = 0.0\n    var float I2 = 0.0\n    var float Q2 = 0.0\n    var float Re = 0.0\n    var float Im = 0.0\n    var float periodEst = 10.0\n    var float iTrend = na\n    var float iTrend1 = na\n    var float iTrend2 = na\n    float result = na\n    price := (4 * source + 3 * source[1] + 2 * source[2] + source[3]) / 10\n    smooth := (4 * price + 3 * price[1] + 2 * price[2] + price[3]) / 10\n    float padAdj = 0.075 * periodEst + 0.54\n    detrender := (0.0962 * smooth + 0.5769 * smooth[2] - 0.5769 * smooth[4] - 0.0962 * smooth[6]) * padAdj\n    I1 := nz(detrender[3])\n    Q1 := (0.0962 * detrender + 0.5769 * detrender[2] - 0.5769 * detrender[4] - 0.0962 * detrender[6]) * padAdj\n    float jI = (0.0962 * I1 + 0.5769 * I1[2] - 0.5769 * I1[4] - 0.0962 * I1[6]) * padAdj\n    float jQ = (0.0962 * Q1 + 0.5769 * Q1[2] - 0.5769 * Q1[4] - 0.0962 * Q1[6]) * padAdj\n    I2 := 0.2 * (I1 - jQ) + 0.8 * nz(I2[1])\n    Q2 := 0.2 * (Q1 + jI) + 0.8 * nz(Q2[1])\n    Re := 0.2 * (I2 * nz(I2[1]) + Q2 * nz(Q2[1])) + 0.8 * nz(Re[1])\n    Im := 0.2 * (I2 * nz(Q2[1]) - Q2 * nz(I2[1])) + 0.8 * nz(Im[1])\n    float newP = Im != 0 and Re != 0 ? 2 * math.pi / math.atan(Im / Re) : periodEst\n    periodEst := math.max(6, math.min(50, 0.2 * newP + 0.8 * periodEst))\n    float angle = I1 != 0 ? math.atan(Q1 / I1) : math.pi / 2 * math.sign(Q1)\n    angle += I1 < 0 ? math.pi : Q1 < 0 and I1 > 0 ? 2 * math.pi : 0\n    angle := angle % (2 * math.pi)\n    float trendPower = math.sqrt(I1 * I1 + Q1 * Q1)\n    float newITrendComponent = smooth + 0.07 * trendPower * math.sin(angle)\n    float currentITrend2 = nz(iTrend1[1], smooth)\n    float currentITrend1 = nz(iTrend[1], smooth)\n    float currentITrend = 0.9 * newITrendComponent + 1.1 * currentITrend1 - 1.0 * currentITrend2\n    iTrend2 := currentITrend1\n    iTrend1 := currentITrend\n    iTrend := currentITrend\n    result := currentITrend\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\n\n// Calculation\nhtit_value = htit(i_source)\n\n// Plot\nplot(htit_value, \"HTIT\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.sign",
      "math.sqrt",
      "math.sin",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "hilbert trendline (htit)",
      "trends_IIR",
      "indicator",
      "v6",
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.sign",
      "math.sqrt",
      "math.sin",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "htit.md",
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.sign",
      "math.sqrt",
      "math.sin",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for"
    ]
  },
  {
    "id": "script-208",
    "type": "example",
    "category": "trends_IIR",
    "title": "Jurik Moving Average (JMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Jurik Moving Average (JMA)\", \"JMA\", overlay=true)\n\n//@function Calculates JMA using adaptive techniques to adjust to market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/jma.md\n//@param source Series to calculate JMA from\n//@param period Number of bars used in the calculation\n//@param phase Phase shift (-100 to 100). Negative values reduce lag but may cause overshoot\n//@param power Smoothing factor (0.1-1.0). Lower values create smoother curves\n//@returns JMA value with adaptive smoothing and reduced lag\n//@optimized Uses adaptive volatility adjustment and phase control for O(1) complexity per bar\njma(series float source, simple int period, simple int phase=0, simple float power=0.45) =>\n    simple float PHASE_VALUE = math.min(math.max((phase * 0.01) + 1.5, 0.5), 2.5)\n    simple float BETA = power * (period - 1) / ((power * (period - 1)) + 2)\n    simple float LEN1 = math.max((math.log(math.sqrt(0.5 * (period - 1))) / math.log(2.0)) + 2.0, 0)\n    simple float POW1 = math.max(LEN1 - 2.0, 0.5)\n    simple float LEN2 = math.sqrt(0.5 * (period - 1)) * LEN1\n    simple float POW1_RECIPROCAL = 1.0 / POW1\n    simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)\n    simple float DIV = 1.0 / (10.0 + 10.0 * (math.min(math.max(period - 10, 0), 100)) / 100.0)\n    var float upperBand_state = na\n    var float lowerBand_state = na\n    var float ma1_state = na\n    var float jma_state = na\n    var float vSum_state = 0.0\n    var float det0_state = 0.0\n    var float det1_state = 0.0\n    var float avgVolty_state = na\n    var array<float> volty_array_state = array.new_float(11, 0.0)\n    float current_jma = na\n    if not na(source)\n        float del1 = source - nz(upperBand_state, source)\n        float del2 = source - nz(lowerBand_state, source)\n        float volty = math.abs(del1) == math.abs(del2) ? 0.0 : math.max(math.abs(del1), math.abs(del2))\n        array.unshift(volty_array_state, nz(volty, 0.0))\n        array.pop(volty_array_state)\n        if not na(volty)\n            vSum_state := vSum_state + (volty - array.get(volty_array_state, 10)) * DIV\n            avgVolty_state := nz(avgVolty_state, vSum_state) + AVG_VOLTY_ALPHA * (vSum_state - nz(avgVolty_state, vSum_state))\n        float rvolty = math.min(math.max(nz(avgVolty_state, 0) > 0 ? nz(volty, 0.0) / nz(avgVolty_state, 1.0) : 1.0, 1.0), math.pow(LEN1, POW1_RECIPROCAL))\n        float pow2 = math.pow(rvolty, POW1)\n        float Kv = math.pow(LEN2 / (LEN2 + 1), math.sqrt(pow2))\n        upperBand_state := del1 > 0 ? source : source - Kv * del1\n        lowerBand_state := del2 < 0 ? source : source - Kv * del2\n        float alpha = math.pow(BETA, pow2)\n        float alphaSquared = alpha * alpha\n        float oneMinusAlpha = 1.0 - alpha\n        float oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha\n        ma1_state := source + (alpha * (nz(ma1_state, source) - source))\n        det0_state :",
    "functions_used": [
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "jurik moving average (jma)",
      "trends_IIR",
      "indicator",
      "v6",
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "jma.md",
      "math.min",
      "math.max",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "math.abs",
      "array.unshift",
      "array.pop",
      "array.get",
      "math.pow",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-209",
    "type": "example",
    "category": "trends_IIR",
    "title": "Kaufman",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Kaufman's Adaptive Moving Average (KAMA)\", \"KAMA\", overlay=true)\n\n//@function Calculates KAMA using adaptive smoothing based on market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/kama.md\n//@param source Series to calculate KAMA from\n//@param period Length of the efficiency ratio lookback period\n//@param fast_alpha Fastest EMA constant (2/(2+1))\n//@param slow_alpha Slowest EMA constant (2/(30+1))\n//@returns KAMA value with efficiency ratio-based adaptive smoothing\n//@optimized Uses efficiency ratio calculation for O(n) complexity per bar due to lookback sum\nkama(series float source, simple int period, simple float fast_alpha=0.666667, simple float slow_alpha=0.0645) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if fast_alpha <= 0 or slow_alpha <= 0\n        runtime.error(\"Alpha values must be greater than 0\")\n    if fast_alpha <= slow_alpha\n        runtime.error(\"Fast alpha must be greater than slow alpha\")\n    var float kama_state = na\n    float current_kama = na\n    if not na(source)\n        float change_val = math.abs(source - source[period])\n        float volatility_val = math.sum(math.abs(source - source[1]), period)\n        float er = 0.0\n        if not na(change_val) and not na(volatility_val) and volatility_val != 0.0\n            er := change_val / volatility_val\n        float sc = math.pow(er * (fast_alpha - slow_alpha) + slow_alpha, 2)\n        kama_state := na(kama_state) ? source : kama_state + sc * (source - kama_state)\n        current_kama := kama_state\n    current_kama\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_fast = input.int(2, \"Fast EMA Period\", minval=2)\ni_slow = input.int(30, \"Slow EMA Period\", minval=2)\n\n// Calculation\nfloat fast_alpha = 2.0 / (float(i_fast) + 1.0)\nfloat slow_alpha = 2.0 / (float(i_slow) + 1.0)\nkama_value = kama(i_source, i_period, fast_alpha, slow_alpha)\n\n// Plot\nplot(kama_value, \"KAMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.sum",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "kaufman",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.sum",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "kama.md",
      "runtime.error",
      "math.abs",
      "math.sum",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "const",
      "for",
      "if"
    ]
  },
  {
    "id": "script-210",
    "type": "example",
    "category": "trends_IIR",
    "title": "Linear Time Moving Average (LTMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Linear Time Moving Average (LTMA)\", \"LTMA\", overlay=true)\n\n//@function Calculates LTMA using linear time-weighted values (not linear regression)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/ltma.md\n//@param source Series to calculate LTMA from\n//@param period Lookback period for calculation\n//@returns LTMA value with linearly increasing weights based on recency (weight = period - i)\n//@optimized Uses linear weighting with O(n) complexity per bar due to lookback loop\nltma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float sum = 0.0\n    float weight_sum = 0.0\n    int count = 0\n    for i = 0 to period - 1\n        if not na(source[i])\n            float weight = float(period - i)\n            sum += source[i] * weight\n            weight_sum += weight\n            count += 1\n    count > 0 and weight_sum > 0 ? sum / weight_sum : source\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nltma_value = ltma(i_source, i_period)\n\n// Plot\nplot(ltma_value, \"LTMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "linear time moving average (ltma)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "ltma.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-211",
    "type": "example",
    "category": "trends_IIR",
    "title": "MESA Adaptive Moving Average (MAMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"MESA Adaptive Moving Average (MAMA)\", \"MAMA\", overlay=true)\n\n//@function Calculates MAMA and FAMA using Ehlers' MESA adaptive algorithm\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/mama.md\n//@param source Series to calculate MAMA from\n//@param fastLimit Maximum rate of adaptation (0.5 typical)\n//@param slowLimit Minimum rate of adaptation (0.05 typical)\n//@returns [mama, fama] array containing MAMA and FAMA values\n//@optimized Uses Hilbert Transform phase detection for O(1) complexity per bar\nmama(series float source, float fastLimit=0.5, float slowLimit=0.05) =>\n    if fastLimit < slowLimit or fastLimit <= 0 or slowLimit < 0\n        runtime.error(\"MAMA: fastLimit must be > slowLimit > 0\")\n    var float mama_val = na\n    var float fama_val = na\n    var float period = 0.0\n    var float phase = 0.0\n    var float smooth = na\n    var float dt = na\n    var float I1 = 0.0\n    var float Q1 = 0.0\n    var float I2 = 0.0\n    var float Q2 = 0.0\n    var float Re = 0.0\n    var float Im = 0.0\n    float TWOPI = 2.0 * math.pi\n    float c1 = 0.0962\n    float c2 = 0.5769\n    float price = not na(source[3]) ? (4.0 * source + 3.0 * source[1] + 2.0 * source[2] + source[3]) / 10.0 : not na(source[2]) ? (4.0 * source + 3.0 * source[1] + 2.0 * source[2]) / 9.0 : not na(source[1]) ? (4.0 * source + 3.0 * source[1]) / 7.0 : source\n    if na(mama_val)\n        mama_val := price\n        fama_val := price\n        smooth := price\n    else\n        smooth := (4.0 * price + 3.0 * price[1] + 2.0 * price[2] + price[3]) / 10.0\n        float padj = 0.075 * period + 0.54\n        dt := (c1 * smooth + c2 * smooth[2] - c2 * smooth[4] - c1 * smooth[6]) * padj\n        I1 := dt[3]\n        Q1 := (c1 * dt + c2 * dt[2] - c2 * dt[4] - c1 * dt[6]) * padj\n        float jI = (c1 * I1 + c2 * I1[2] - c2 * I1[4] - c1 * I1[6]) * padj\n        float jQ = (c1 * Q1 + c2 * Q1[2] - c2 * Q1[4] - c1 * Q1[6]) * padj\n        I2 := 0.2 * (I1 - jQ) + 0.8 * I2[1]\n        Q2 := 0.2 * (Q1 + jI) + 0.8 * Q2[1]\n        Re := 0.2 * (I2 * I2[1] + Q2 * Q2[1]) + 0.8 * Re[1]\n        Im := 0.2 * (I2 * Q2[1] - Q2 * I2[1]) + 0.8 * Im[1]\n        if Im != 0.0 and Re != 0.0\n            period := TWOPI / math.atan(Im / Re)\n        period := 0.2 * math.max(6.0, math.min(50.0, period)) + 0.8 * period[1]\n        if I1 != 0.0\n            phase := math.atan(Q1 / I1)\n        float deltaPhase = phase[1] - phase\n        if deltaPhase >= 1.0\n            deltaPhase := 0.0\n        if deltaPhase < 0.0\n            deltaPhase += TWOPI\n        float alpha = math.min(fastLimit, math.max(slowLimit, fastLimit / math.pow(deltaPhase / 0.5, 2)))\n        float oneMinusAlpha = 1.0 - alpha\n        mama_val := alpha * price + oneMinusAlpha * mama_val[1]\n        fama_val := 0.5 * alpha * mama_val + (1.0 - 0.5 * alpha) * fama_val[1]\n    [mama_val, fama_val]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_fastLimit = inp",
    "functions_used": [
      "runtime.error",
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.pow",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mesa adaptive moving average (mama)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.pow",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "mama.md",
      "runtime.error",
      "math.pi",
      "math.atan",
      "math.max",
      "math.min",
      "math.pow",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-212",
    "type": "example",
    "category": "trends_IIR",
    "title": "McGinley Dynamic Indicator (MGDI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"McGinley Dynamic Indicator (MGDI)\", \"MGDI\", overlay=true)\n\n//@function Calculates MGDI using dynamic factor based on price movement\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/mgdi.md\n//@param source Series to calculate MGDI from\n//@param period Lookback period for initial SMA value\n//@param factor McGinley factor (default 0.6)\n//@returns MGDI value that tracks price movements more closely than EMAs\n//@optimized Uses adaptive smoothing with O(1) complexity after initialization\nmgdi(series float source, simple int period, simple float factor=0.6) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if factor <= 0\n        runtime.error(\"Factor must be greater than 0\")\n    var float mgdi_val = na\n    if not na(source)\n        if na(mgdi_val)\n            float sum = 0.0\n            int count = 0\n            for i = 0 to period - 1\n                if not na(source[i])\n                    sum += source[i]\n                    count += 1\n            mgdi_val := count > 0 ? sum / count : source\n        else\n            if math.abs(mgdi_val) < 1e-10\n                mgdi_val := source\n            else\n                float ratio = source / mgdi_val\n                float denom = factor * period * math.pow(ratio, 4)\n                denom := math.sign(denom) * math.max(0.001, math.abs(denom))\n                mgdi_val := mgdi_val + (source - mgdi_val) / denom\n    mgdi_val\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_factor = input.float(0.6, \"Factor\", minval=0.01, maxval=5.0, step=0.01)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nmgdi_value = mgdi(i_source, i_period, i_factor)\n\n// Plot\nplot(mgdi_value, \"MGDI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.pow",
      "math.sign",
      "math.max",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mcginley dynamic indicator (mgdi)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.pow",
      "math.sign",
      "math.max",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "mgdi.md",
      "runtime.error",
      "math.abs",
      "math.pow",
      "math.sign",
      "math.max",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-213",
    "type": "example",
    "category": "trends_IIR",
    "title": "Modified Moving Average (MMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Modified Moving Average (MMA)\", \"MMA\", overlay=true)\n\n//@function Calculates MMA using combined simple and weighted moving average components\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/mma.md\n//@param source Series to calculate MMA from\n//@param period Lookback period - must be at least 2\n//@returns MMA value, combines SMA with weighted component for balanced smoothing\n//@optimized Uses circular buffer for O(1) sum updates, O(n) for weighted component\nmma(series float source, simple int period) =>\n    if period < 2\n        runtime.error(\"Period must be at least 2\")\n    var array<float> buffer = array.new_float(math.min(math.max(2, period), 4000), na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    sum := sum + (not na(source) ? source : 0) - (not na(oldest) ? oldest : 0)\n    valid_count := valid_count + (not na(source) ? 1 : 0) - (not na(oldest) ? 1 : 0)\n    array.set(buffer, head, source)\n    head := (head + 1) % array.size(buffer)\n    if valid_count <= 0\n        source\n    else\n        float sma = sum / valid_count\n        float weighted_sum = 0.0\n        int count = 0\n        for i = 0 to array.size(buffer) - 1\n            float val = array.get(buffer, (head - 1 - i + array.size(buffer)) % array.size(buffer))\n            if not na(val)\n                weighted_sum += ((valid_count - ((2 * count) + 1)) * 0.5) * val\n                count += 1\n        sma + (weighted_sum * 6.0) / ((valid_count + 1) * valid_count)\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=2)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nmma_value = mma(i_source, i_period)\n\n// Plot\nplot(mma_value, \"MMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.min",
      "math.max",
      "array.get",
      "array.set",
      "array.size",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "modified moving average (mma)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "math.min",
      "math.max",
      "array.get",
      "array.set",
      "array.size",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "mma.md",
      "runtime.error",
      "array.new_float",
      "math.min",
      "math.max",
      "array.get",
      "array.set",
      "array.size",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-214",
    "type": "example",
    "category": "trends_IIR",
    "title": "Quadruple EMA (QEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Quadruple EMA (QEMA)\", \"QEMA\", overlay=true)\n\n//@function Calculates QEMA using quadruple exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/qema.md\n//@param source Series to calculate QEMA from\n//@param period Lookback period for QEMA calculation\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns QEMA value from first bar with proper compensation\n//@optimized Uses exponential warmup compensator on all four EMA stages for O(1) complexity\nqema(series float source, simple int period=0, simple float alpha=0.0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a1 = alpha > 0 ? alpha : (period > 0 ? 2.0 / (period + 1) : 0.1)\n    float r = math.pow(1.0 / a1, 1.0 / 3.0)\n    float a2 = a1 * r\n    float a3 = a2 * r\n    float a4 = a3 * r\n    float beta1 = 1.0 - a1\n    float beta2 = 1.0 - a2\n    float beta3 = 1.0 - a3\n    float beta4 = 1.0 - a4\n    var float e1 = 1.0\n    var float e2 = 1.0\n    var float e3 = 1.0\n    var float e4 = 1.0\n    var bool warmup = true\n    var float rema1 = 0.0\n    var float rema2 = 0.0\n    var float rema3 = 0.0\n    var float rema4 = 0.0\n    var float ema1 = source\n    var float ema2 = source\n    var float ema3 = source\n    var float ema4 = source\n    rema1 := a1 * (source - rema1) + rema1\n    if warmup\n        e1 *= beta1\n        e2 *= beta2\n        e3 *= beta3\n        e4 *= beta4\n        float c1 = 1.0 / (1.0 - e1)\n        float c2 = 1.0 / (1.0 - e2)\n        float c3 = 1.0 / (1.0 - e3)\n        float c4 = 1.0 / (1.0 - e4)\n        ema1 := rema1 * c1\n        rema2 := a2 * (ema1 - rema2) + rema2\n        ema2 := rema2 * c2\n        rema3 := a3 * (ema2 - rema3) + rema3\n        ema3 := rema3 * c3\n        rema4 := a4 * (ema3 - rema4) + rema4\n        ema4 := rema4 * c4\n        warmup := e1 > 1e-10\n    else\n        ema1 := rema1\n        rema2 := a2 * (ema1 - rema2) + rema2\n        ema2 := rema2\n        rema3 := a3 * (ema2 - rema3) + rema3\n        ema3 := rema3\n        rema4 := a4 * (ema3 - rema4) + rema4\n        ema4 := rema4\n    4 * ema1 - 6 * ema2 + 4 * ema3 - ema4\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nqema_value = qema(i_source, i_period)\n\n// Plot\nplot(qema_value, \"QEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "quadruple ema (qema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "qema.md",
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-215",
    "type": "example",
    "category": "trends_IIR",
    "title": "Regularized EMA (REMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Regularized EMA (REMA)\", \"REMA\", overlay=true)\n\n//@function Calculates REMA using exponential smoothing with regularization term\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/rema.md\n//@param source Series to calculate REMA from\n//@param period Lookback period used to determine alpha value\n//@param lambda Regularization parameter (0-1) controlling smoothness\n//@returns REMA value, calculates from first bar using available data\n//@optimized Uses regularization term to reduce noise for O(1) complexity\nrema(series float source, simple int period, simple float lambda=0.5) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if lambda < 0.0 or lambda > 1.0\n        runtime.error(\"Lambda must be between 0 and 1\")\n    float alpha = 2.0 / (period + 1.0)\n    var float rema_val = na\n    var float prev_rema = na\n    float result = na\n    if not na(source)\n        if na(rema_val)\n            rema_val := source\n            prev_rema := source\n            result := rema_val\n        else\n            prev_rema := rema_val\n            float ema_component = alpha * (source - rema_val) + rema_val\n            float reg_component = rema_val + (rema_val - prev_rema)\n            rema_val := lambda * (ema_component - reg_component) + reg_component\n            result := rema_val\n    else\n        result := rema_val\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_lambda = input.float(0.5, \"Lambda\", minval=0.0, maxval=1.0, step=0.1, tooltip=\"Regularization parameter: 0 = maximum regularization, 1 = standard EMA\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\nrema_value = rema(i_source, i_period, i_lambda)\n\n// Plot\nplot(rema_value, \"REMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "regularized ema (rema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "rema.md",
      "runtime.error",
      "input.int",
      "input.float",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-216",
    "type": "example",
    "category": "trends_IIR",
    "title": "Recursive Gaussian Moving Average (RGMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Recursive Gaussian Moving Average (RGMA)\", \"RGMA\", overlay=true)\n\n//@function Calculates RGMA using cascaded recursive filters to approximate Gaussian smoothing\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/rgma.md\n//@param source Series to calculate RGMA from\n//@param period Effective smoothing period\n//@param passes Number of recursive passes (higher = more Gaussian-like)\n//@returns RGMA value with gaussian-like smoothing properties using recursive calculation\n//@optimized Uses cascaded exponential filters for O(1) complexity per bar\nrgma(series float source, simple int period, simple int passes=3) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    if passes <= 0\n        runtime.error(\"Passes must be greater than 0\")\n    simple float alpha = 2.0 / (period / math.sqrt(passes) + 1.0)\n    var array<float> filters = array.new_float(passes, na)\n    float result = na\n    if not na(source)\n        if na(array.get(filters, 0))\n            array.fill(filters, source)\n            result := source\n        else\n            array.set(filters, 0, alpha * (source - array.get(filters, 0)) + array.get(filters, 0))\n            if passes > 1\n                for i = 1 to passes - 1\n                    array.set(filters, i, alpha * (array.get(filters, i - 1) - array.get(filters, i)) + array.get(filters, i))\n            result := array.get(filters, passes - 1)\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_passes = input.int(3, \"Passes\", minval=1, maxval=10, tooltip=\"More passes create more Gaussian-like smoothing\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\nrgma_value = rgma(i_source, i_period, i_passes)\n\n// Plot\nplot(rgma_value, \"RGMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.sqrt",
      "array.new_float",
      "array.get",
      "array.fill",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "fill"
    ],
    "keywords": [
      "recursive gaussian moving average (rgma)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.sqrt",
      "array.new_float",
      "array.get",
      "array.fill",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "fill",
      "github.com",
      "rgma.md",
      "runtime.error",
      "math.sqrt",
      "array.new_float",
      "array.get",
      "array.fill",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-217",
    "type": "example",
    "category": "trends_IIR",
    "title": "Wilder",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Wilder's Moving Average (RMA)\", \"RMA\", overlay=true)\n\n//@function Calculates Welles Wilder's Relative Moving Average (RMA/SMMA)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/rma.md\n//@param source Series to calculate RMA from\n//@param period Smoothing period\n//@returns RMA value from first bar with proper compensation for early values\n//@optimized Uses exponential warmup compensator with Wilder's alpha (1/period) for O(1) complexity\nrma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be provided\")\n    float a = 1.0 / float(period)\n    float beta = 1.0 - a\n    var bool warmup = true\n    var float e = 1.0\n    var float ema = 0.0\n    var float result = source\n    ema := a * (source - ema) + ema\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := c * ema\n        warmup := e > 1e-10\n    else\n        result := ema\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nrma_value = rma(i_source, i_period)\n\n// Plot\nplot(rma_value, \"RMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "wilder",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "rma.md",
      "runtime.error",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-218",
    "type": "example",
    "category": "trends_IIR",
    "title": "Tillson T3 Moving Average (T3)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Tillson T3 Moving Average (T3)\", \"T3\", overlay=true)\n\n//@function Calculates T3 using six EMAs with volume factor optimization\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/t3.md\n//@param source Series to calculate T3 from\n//@param period Smoothing period\n//@param v Volume factor controlling smoothing (default 0.7)\n//@returns T3 value with optimized coefficients\n//@optimized Uses six cascaded EMAs with precomputed coefficients for O(1) complexity\nt3(series float src, simple int period, simple float v) =>\n    if period <= 0\n        runtime.error(\"T3 period must be > 0\")\n    float a = 2.0 / (period + 1)\n    float v2 = v * v\n    float v3 = v2 * v\n    float c1 = -v3\n    float c2 = 3.0 * (v2 + v3)\n    float c3 = -3.0 * (2.0 * v2 + v + v3)\n    float c4 = 1.0 + 3.0 * v + 3.0 * v2 + v3\n    var float e1 = na\n    var float e2 = na\n    var float e3 = na\n    var float e4 = na\n    var float e5 = na\n    var float e6 = na\n    float res = na\n    if not na(src)\n        if na(e1)\n            e1 := src\n            e2 := src\n            e3 := src\n            e4 := src\n            e5 := src\n            e6 := src\n            res := src\n        else\n            e1 := e1 + a * (src - e1)\n            e2 := e2 + a * (e1 - e2)\n            e3 := e3 + a * (e2 - e3)\n            e4 := e4 + a * (e3 - e4)\n            e5 := e5 + a * (e4 - e5)\n            e6 := e6 + a * (e5 - e6)\n            res := c1 * e6 + c2 * e5 + c3 * e4 + c4 * e3\n    res\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_period = input.int(10, \"Period\", minval=1)\ni_vfactor = input.float(0.7, \"Volume Factor\", minval=0.0, maxval=1.0, step=0.1)\n\n// Calculation\nt3_value = t3(i_source, i_period, i_vfactor)\n\n// Plot\nplot(t3_value, \"T3\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "tillson t3 moving average (t3)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "runtime.error",
      "input.source",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-219",
    "type": "example",
    "category": "trends_IIR",
    "title": "Triple Exponential Moving Average (TEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Triple Exponential Moving Average (TEMA)\", \"TEMA\", overlay=true)\n\n//@function Calculates TEMA using triple exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/tema.md\n//@param source Series to calculate TEMA from\n//@param period Lookback period for TEMA calculation\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@param corrected Use diminishing alpha factors for each stage\n//@returns TEMA value from first bar with proper compensation\n//@optimized Uses exponential warmup compensator on all three EMA stages for O(1) complexity\ntema(series float source, simple int period=0, simple float alpha=0.0, simple bool corrected=false) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a1 = alpha > 0 ? alpha : (period > 0 ? 2.0 / (period + 1) : 0.1)\n    float r = math.pow(1.0 / a1, 1.0 / 3.0)\n    float a2 = corrected ? a1 * r : a1\n    float a3 = corrected ? a2 * r : a1\n    float beta1 = 1.0 - a1\n    float beta2 = 1.0 - a2\n    float beta3 = 1.0 - a3\n    var float e1 = 1.0\n    var float e2 = 1.0\n    var float e3 = 1.0\n    var bool warmup = true\n    var float rema1 = 0.0\n    var float rema2 = 0.0\n    var float rema3 = 0.0\n    var float ema1 = source\n    var float ema2 = source\n    var float ema3 = source\n    rema1 := a1 * (source - rema1) + rema1\n    if warmup\n        e1 *= beta1\n        e2 *= beta2\n        e3 *= beta3\n        float c1 = 1.0 / (1.0 - e1)\n        float c2 = 1.0 / (1.0 - e2)\n        float c3 = 1.0 / (1.0 - e3)\n        ema1 := rema1 * c1\n        rema2 := a2 * (ema1 - rema2) + rema2\n        ema2 := rema2 * c2\n        rema3 := a3 * (ema2 - rema3) + rema3\n        ema3 := rema3 * c3\n        warmup := e1 > 1e-10\n    else\n        ema1 := rema1\n        rema2 := a2 * (ema1 - rema2) + rema2\n        ema2 := rema2\n        rema3 := a3 * (ema2 - rema3) + rema3\n        ema3 := rema3\n    3 * ema1 - 3 * ema2 + ema3\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\ntema_value = tema(i_source, period=i_period)\n\n// Plot\nplot(tema_value, \"TEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "triple exponential moving average (tema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "tema.md",
      "runtime.error",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-220",
    "type": "example",
    "category": "trends_IIR",
    "title": "Volatility Adjusted Moving Average (VAMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volatility Adjusted Moving Average (VAMA)\", \"VAMA\", overlay=true)\n\n//@function Calculates VAMA by adjusting MA length based on volatility ratio using ATR\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/vama.md\n//@param source Series to calculate VAMA from\n//@param base_length Base lookback period for the moving average\n//@param short_atr_period Short-term ATR period for current volatility measurement\n//@param long_atr_period Long-term ATR period for reference volatility measurement\n//@param min_length Minimum allowed adjusted length\n//@param max_length Maximum allowed adjusted length\n//@returns VAMA value\n//@optimized Uses RMA compensator for ATR and circular buffer for O(1) sum updates\nvama(series float source, simple int base_length, simple int short_atr_period=10, simple int long_atr_period=50, simple int min_length=5, simple int max_length=100) =>\n    if base_length <= 0\n        runtime.error(\"Base length must be greater than 0\")\n    if short_atr_period <= 0 or long_atr_period <= 0\n        runtime.error(\"ATR periods must be greater than 0\")\n    if min_length <= 0 or max_length <= 0\n        runtime.error(\"Min and max length must be greater than 0\")\n    if min_length > max_length\n        runtime.error(\"Min length must be less than or equal to max length\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float EPSILON = 1e-10\n    var float raw_rma_short = 0.0\n    var float e_short = 1.0\n    var float raw_rma_long = 0.0\n    var float e_long = 1.0\n    float short_atr = na\n    float long_atr = na\n    if not na(trueRange)\n        float alpha_short = 1.0 / float(short_atr_period)\n        float beta_short = 1.0 - alpha_short\n        raw_rma_short := (raw_rma_short * (short_atr_period - 1) + trueRange) / short_atr_period\n        e_short := beta_short * e_short\n        short_atr := e_short > EPSILON ? raw_rma_short / (1.0 - e_short) : raw_rma_short\n        float alpha_long = 1.0 / float(long_atr_period)\n        float beta_long = 1.0 - alpha_long\n        raw_rma_long := (raw_rma_long * (long_atr_period - 1) + trueRange) / long_atr_period\n        e_long := beta_long * e_long\n        long_atr := e_long > EPSILON ? raw_rma_long / (1.0 - e_long) : raw_rma_long\n    float volatility_ratio = not na(short_atr) and not na(long_atr) and short_atr != 0.0 ? long_atr / short_atr : 1.0\n    float calc_length = base_length * volatility_ratio\n    int adjusted_length = int(math.max(min_length, math.min(max_length, calc_length)))\n    var array<float> buffer = array.new_float(max_length, na)\n    var int head = 0\n    var float sum = 0.0\n    var int valid_count = 0\n    if array.size(buffer) != max_length\n        buffer := array.new_float(max_length, na)\n        head := 0\n        sum := 0.0\n        valid_count := 0\n   ",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volatility adjusted moving average (vama)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "vama.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "array.new_float",
      "array.size",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-221",
    "type": "example",
    "category": "trends_IIR",
    "title": "Variable Index Dynamic Average (VIDYA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Variable Index Dynamic Average (VIDYA)\", \"VIDYA\", overlay=true)\n\n//@function Calculates VIDYA using adaptive smoothing based on market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/vidya.md\n//@param source Series to calculate VIDYA from\n//@param period Length of the smoothing period\n//@param std_period Length of the standard deviation period, defaults to same as period\n//@returns VIDYA value that adapts to market volatility\n//@optimized Uses volatility index calculation with O(n) complexity per bar due to lookback loops\nvidya(series float source, simple int period, simple int std_period=0) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float alpha = 2.0 / (period + 1.0)\n    var float vidya = na\n    if not na(source)\n        int p = std_period > 0 ? std_period : period\n        float sum_p = 0.0\n        float sumSq_p = 0.0\n        float count_p = 0.0\n        float sum_5 = 0.0\n        float sumSq_5 = 0.0\n        float count_5 = 0.0\n        for i = 0 to math.max(p, 5) - 1\n            if not na(source[i])\n                float val = source[i]\n                if i < p\n                    sum_p += val\n                    sumSq_p += val * val\n                    count_p += 1\n                if i < 5\n                    sum_5 += val\n                    sumSq_5 += val * val\n                    count_5 += 1\n        float std = count_p > 0 ? math.sqrt(math.max((sumSq_p / count_p) - (sum_p / count_p) * (sum_p / count_p), 0.0)) : 0.0\n        float std_5 = count_5 > 0 ? math.sqrt(math.max((sumSq_5 / count_5) - (sum_5 / count_5) * (sum_5 / count_5), 0.0)) : 0.0\n        float vol_idx = std > 0 ? std_5 / std : 1.0\n        vol_idx := math.min(math.max(vol_idx, 0.0), 1.0)\n        float sc = alpha * vol_idx\n        vidya := na(vidya) ? source : source * sc + vidya * (1.0 - sc)\n    vidya\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_std_period = input.int(0, \"Std Dev Period (0=use Period)\", minval=0)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nvidya_value = vidya(i_source, i_period, i_std_period)\n\n// Plot\nplot(vidya_value, \"VIDYA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "variable index dynamic average (vidya)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "vidya.md",
      "runtime.error",
      "math.max",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-222",
    "type": "example",
    "category": "trends_IIR",
    "title": "Yang-Zhang Volatility Adjusted Moving Average (YZVAMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Yang-Zhang Volatility Adjusted Moving Average (YZVAMA)\", \"YZVAMA\", overlay=true)\n\n//@function Calculates YZVAMA by adjusting MA length based on percentile rank of short-term YZV\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/yzvama.md\n//@param source Series to calculate YZVAMA from\n//@param yzv_short_period Short-term YZV period for current volatility\n//@param yzv_long_period Long-term YZV period for baseline volatility\n//@param percentile_lookback Lookback for percentile calculation\n//@param min_length Minimum allowed adjusted length\n//@param max_length Maximum allowed adjusted length\n//@returns YZVAMA value\n//@optimized Uses RMA compensators for YZV and circular buffers for O(1) sum updates\nyzvama(series float source, simple int yzv_short_period=3, simple int yzv_long_period=50, simple int percentile_lookback=100, simple int min_length=5, simple int max_length=100) =>\n    if yzv_short_period <= 0 or yzv_long_period <= 0\n        runtime.error(\"All periods must be greater than 0\")\n    if min_length <= 0 or max_length <= 0\n        runtime.error(\"Min and max length must be greater than 0\")\n    if min_length > max_length\n        runtime.error(\"Min length must be less than or equal to max length\")\n    if percentile_lookback <= 0\n        runtime.error(\"Percentile lookback must be greater than 0\")\n    var float prev_close = close\n    float o = open\n    float h = high\n    float l = low\n    float c = close\n    float pc = na(prev_close) ? open : prev_close\n    prev_close := c\n    float ro = math.log(o / pc)\n    float rc = math.log(c / o)\n    float rh = math.log(h / o)\n    float rl = math.log(l / o)\n    float s_o_sq = ro * ro\n    float s_c_sq = rc * rc\n    float s_rs_sq = rh * (rh - rc) + rl * (rl - rc)\n    float ratio_N_short = yzv_short_period <= 1 ? 1.0 : (float(yzv_short_period) + 1.0) / (float(yzv_short_period) - 1.0)\n    float k_yz_short = 0.34 / (1.34 + ratio_N_short)\n    float s_sq_daily_short = s_o_sq + k_yz_short * s_c_sq + (1.0 - k_yz_short) * s_rs_sq\n    float EPSILON = 1e-10\n    var float raw_rma_short = 0.0\n    var float e_comp_short = 1.0\n    float yzv_short = na\n    if not na(s_sq_daily_short)\n        float rma_alpha_short = 1.0 / float(yzv_short_period)\n        float rma_beta_short = 1.0 - rma_alpha_short\n        raw_rma_short := (raw_rma_short * (yzv_short_period - 1) + s_sq_daily_short) / yzv_short_period\n        e_comp_short := rma_beta_short * e_comp_short\n        float smoothed_s_sq_short = e_comp_short > EPSILON ? raw_rma_short / (1.0 - e_comp_short) : raw_rma_short\n        yzv_short := math.sqrt(smoothed_s_sq_short)\n    float ratio_N_long = yzv_long_period <= 1 ? 1.0 : (float(yzv_long_period) + 1.0) / (float(yzv_long_period) - 1.0)\n    float k_yz_long = 0.34 / (1.34 + ratio_N_long)\n    float s_sq_daily_long = s_o_sq + k_yz_long * s_c_sq + (1.0 - k_yz_long) * s_rs_sq\n    var float raw_rma_long = 0.0\n    var float e_comp_long = 1.0\n    floa",
    "functions_used": [
      "runtime.error",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "array.set",
      "array.get",
      "array.push",
      "array.size",
      "array.sort",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "yang-zhang volatility adjusted moving average (yzvama)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "array.set",
      "array.get",
      "array.push",
      "array.size",
      "array.sort",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "yzvama.md",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "array.new_float",
      "array.set",
      "array.get",
      "array.push",
      "array.size",
      "array.sort",
      "math.max",
      "math.min",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-223",
    "type": "example",
    "category": "trends_IIR",
    "title": "Zero-Lag Double EMA (ZLDEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Zero-Lag Double EMA (ZLDEMA)\", \"ZLDEMA\", overlay=true)\n\n//@function Calculates ZLDEMA using zero-lag price and double exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/zldema.md\n//@param source Series to calculate ZLDEMA from\n//@param period Smoothing period\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns ZLDEMA value with zero-lag effect applied\n//@optimized Uses lag compensation buffer and exponential warmup compensator on both EMA stages for O(1) complexity\nzldema(series float source, simple int period=0, simple float alpha=0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a = alpha > 0 ? alpha : 2.0 / (period + 1)\n    float beta = 1.0 - a\n    simple int lag = math.max(1, math.round((period - 1) / 2))\n    var bool warmup = true\n    var float e = 1.0\n    var float ema1_raw = 0.0\n    var float ema2_raw = 0.0\n    var float ema1 = source\n    var float ema2 = source\n    var priceBuffer = array.new<float>(lag + 1, na)\n    if not na(source)\n        array.shift(priceBuffer)\n        array.push(priceBuffer, source)\n        float laggedPrice = nz(array.get(priceBuffer, 0), source)\n        float signal = 2 * source - laggedPrice\n        ema1_raw := a * (signal - ema1_raw) + ema1_raw\n        if warmup\n            e *= beta\n            float c = 1.0 / (1.0 - e)\n            ema1 := c * ema1_raw\n            ema2_raw := a * (ema1 - ema2_raw) + ema2_raw\n            ema2 := c * ema2_raw\n            warmup := e > 1e-10\n        else\n            ema1 := ema1_raw\n            ema2_raw := a * (ema1 - ema2_raw) + ema2_raw\n            ema2 := ema2_raw\n        2 * ema1 - ema2\n    else\n        na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nzldema_value = zldema(i_source, i_period)\n\n// Plot\nplot(zldema_value, \"ZLDEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "zero-lag double ema (zldema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "zldema.md",
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-224",
    "type": "example",
    "category": "trends_IIR",
    "title": "Zero-Lag EMA (ZLEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Zero-Lag EMA (ZLEMA)\", \"ZLEMA\", overlay=true)\n\n//@function Calculates ZLEMA using zero-lag price and exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/zlema.md\n//@param source Series to calculate ZLEMA from\n//@param period Smoothing period\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns ZLEMA value with zero-lag effect applied\n//@optimized Uses lag compensation buffer and exponential warmup compensator for O(1) complexity\nzlema(series float source, simple int period=0, simple float alpha=0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a = alpha > 0 ? alpha : 2.0 / (period + 1)\n    float beta = 1.0 - a\n    simple int lag = math.max(1, math.round((period - 1) / 2))\n    var bool warmup = true\n    var float e = 1.0\n    var float zlema = 0.0\n    var float result = source\n    var priceBuffer = array.new<float>(lag + 1, 0.0)\n    if not na(source)\n        array.shift(priceBuffer)\n        array.push(priceBuffer, source)\n        float laggedPrice = array.get(priceBuffer, 0)\n        float signal = 2 * source - laggedPrice\n        zlema := a * (signal - zlema) + zlema\n        if warmup\n            e *= beta\n            float c = 1.0 / (1.0 - e)\n            result := c * zlema\n            warmup := e > 1e-10\n        else\n            result := zlema\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nzlema_value = zlema(i_source, i_period)\n\n// Plot\nplot(zlema_value, \"ZLEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "zero-lag ema (zlema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "zlema.md",
      "runtime.error",
      "math.max",
      "math.round",
      "array.new",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-225",
    "type": "example",
    "category": "trends_IIR",
    "title": "Zero-Lag Triple EMA (ZLTEMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Zero-Lag Triple EMA (ZLTEMA)\", \"ZLTEMA\", overlay=true)\n\n//@function Calculates ZLTEMA using zero-lag price and triple exponential smoothing with compensator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/trends_IIR/zltema.md\n//@param source Series to calculate ZLTEMA from\n//@param period Smoothing period\n//@param alpha Optional smoothing factor (overrides period if provided)\n//@returns ZLTEMA value with zero-lag effect applied\n//@optimized Uses lag compensation buffer and exponential warmup compensator on all three EMA stages for O(1) complexity\nzltema(series float source, simple int period=0, simple float alpha=0) =>\n    if alpha <= 0 and period <= 0\n        runtime.error(\"Alpha or period must be provided\")\n    float a1 = alpha > 0 ? alpha : 2.0 / (period + 1)\n    float beta1 = 1.0 - a1\n    float r = math.pow(1.0 / a1, 1.0 / 3.0)\n    float a2 = a1 * r\n    float a3 = a2 * r\n    simple int lag = math.max(1, math.round((period - 1) / 2))\n    var bool warmup = true\n    var float e = 1.0\n    var float ema1_raw = 0.0\n    var float ema2_raw = 0.0\n    var float ema3_raw = 0.0\n    var float ema1 = na\n    var float ema2 = na\n    var float ema3 = na\n    var priceBuffer = array.new<float>(lag + 1, na)\n    if not na(source)\n        if na(ema1)\n            ema1 := source\n            ema2 := source\n            ema3 := source\n            array.fill(priceBuffer, source)\n        array.shift(priceBuffer)\n        array.push(priceBuffer, source)\n        float laggedPrice = nz(array.get(priceBuffer, 0), source)\n        float signal = 2 * source - laggedPrice\n        ema1_raw := a1 * (signal - ema1_raw) + ema1_raw\n        if warmup\n            e *= beta1\n            float c = 1.0 / (1.0 - e)\n            ema1 := c * ema1_raw\n            ema2_raw := a2 * (ema1 - ema2_raw) + ema2_raw\n            ema2 := c * ema2_raw\n            ema3_raw := a3 * (ema2 - ema3_raw) + ema3_raw\n            ema3 := c * ema3_raw\n            warmup := e > 1e-10\n        else\n            ema1 := ema1_raw\n            ema2_raw := a2 * (ema1 - ema2_raw) + ema2_raw\n            ema2 := ema2_raw\n            ema3_raw := a3 * (ema2 - ema3_raw) + ema3_raw\n            ema3 := ema3_raw\n        3 * ema1 - 3 * ema2 + ema3\n    else\n        na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nzltema_value = zltema(i_source, i_period)\n\n// Plot\nplot(zltema_value, \"ZLTEMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.pow",
      "math.max",
      "math.round",
      "array.new",
      "array.fill",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "fill"
    ],
    "keywords": [
      "zero-lag triple ema (zltema)",
      "trends_IIR",
      "indicator",
      "v6",
      "runtime.error",
      "math.pow",
      "math.max",
      "math.round",
      "array.new",
      "array.fill",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "fill",
      "github.com",
      "zltema.md",
      "runtime.error",
      "math.pow",
      "math.max",
      "math.round",
      "array.new",
      "array.fill",
      "array.shift",
      "array.push",
      "array.get",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-226",
    "type": "example",
    "category": "volatility",
    "title": "Average Daily Range (ADR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Average Daily Range (ADR)\", \"ADR\", overlay=false)\n\n//@function Calculates Average Daily Range with choice of smoothing method\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/adr.md\n//@param length Period for smoothing calculations\n//@param method Smoothing method (1=SMA, 2=EMA, 3=WMA)\n//@returns float ADR value\n//@optimized for performance and dirty data\nadr(simple int length, simple int method = 1) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if method < 1 or method > 3\n        runtime.error(\"Method must be 1 (SMA), 2 (EMA), or 3 (WMA)\")\n    var int p = math.max(1, length)\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0\n    var float wsum = 0.0\n    float dayRange = high - low\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        count -= 1\n    sum += dayRange\n    count += 1\n    array.set(buffer, head, dayRange)\n    head := (head + 1) % p\n    var float EPSILON = 1e-10\n    var float raw_ema = 0.0\n    var float e = 1.0\n    float result = na\n    if method == 1  // SMA\n        result := nz(sum / count, dayRange)\n    else if method == 2  // EMA\n        float alpha = 1.0/float(length)\n        raw_ema := (raw_ema * (length - 1) + dayRange) / length\n        e := (1 - alpha) * e\n        result := e > EPSILON ? raw_ema / (1.0 - e) : raw_ema\n    else  // WMA\n        wsum := 0.0\n        float weight = length\n        for i = 0 to length - 1\n            wsum += nz(array.get(buffer, (head - i - 1 + p) % p)) * weight\n            weight -= 1.0\n        float divisor = length * (length + 1) / 2\n        result := wsum / divisor\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, maxval=500, tooltip=\"Number of bars to average the daily range over\")\ni_method = input.int(1, \"Method\", minval=1, maxval=3, tooltip=\"1=SMA, 2=EMA, 3=WMA\")\n\n// Calculation\nadrValue = adr(i_length, i_method)\n\n// Plot\nplot(adrValue, \"ADR\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average daily range (adr)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "adr.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-227",
    "type": "example",
    "category": "volatility",
    "title": "Average True Range (ATR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Average True Range (ATR)\", \"ATR\", overlay=false)\n\n//@function Calculates the Average True Range (ATR)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/atr.md\n//@param length The period length for the ATR calculation.\n//@returns The ATR value.\n//@optimized Beta precomputation for RMA warmup compensation\natr(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    else\n        na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, tooltip=\"Number of bars used for the ATR calculation\")\n\n// Calculation\natrValue = atr(i_length)\n\n// Plot\nplot(atrValue, \"ATR\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average true range (atr)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "atr.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-228",
    "type": "example",
    "category": "volatility",
    "title": "Average True Range Normalized (ATRN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Average True Range Normalized (ATRN)\", \"ATRN\", overlay=false, format=format.percent, precision=2)\n\n//@function Calculates the Average True Range Normalized (ATRN) relative to its maximum value over a longer period.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/atrn.md\n//@param length The period length for the ATR calculation. The highest uses a length of 10 * length.\n//@returns The ATRN value, normalized relative to its maximum over the longer period.\n//@optimized Beta precomputation for RMA warmup compensation\natrn(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atrValue = na\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        atrValue := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    int lookbackWindow = math.min(10 * length, bar_index + 1)\n    float maxAtr = ta.highest(atrValue, lookbackWindow)\n    float minAtr = ta.lowest(atrValue, lookbackWindow)\n    minAtr < maxAtr ? (atrValue - minAtr) / (maxAtr - minAtr) : 0.5\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, tooltip=\"Number of bars used for the ATR calculation\")\n\n// Calculation\natrnValue = atrn(i_length)\n\n// Plot\nplot(atrnValue, \"ATRN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "ta.highest",
      "ta.lowest",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average true range normalized (atrn)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "ta.highest",
      "ta.lowest",
      "input.int",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "atrn.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "math.min",
      "ta.highest",
      "ta.lowest",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-229",
    "type": "example",
    "category": "volatility",
    "title": "Average True Range Percent (ATRP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Average True Range Percent (ATRP)\", \"ATRP\", overlay=false, format=format.percent, precision=2)\n\n//@function Calculates the Average True Range Percent (ATRP)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/atrp.md\n//@param length The period length for the ATR calculation.\n//@returns The ATRP value.\n//@optimized Beta precomputation for RMA warmup compensation\natrp(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atr = na\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        atr := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    close != 0.0 ? atr / close * 100 : na\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, tooltip=\"Number of bars used for the ATR calculation\")\n\n// Calculation\natrpValue = atrp(i_length)\n\n// Plot\nplot(atrpValue, \"ATRP\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "average true range percent (atrp)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "atrp.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-230",
    "type": "example",
    "category": "volatility",
    "title": "Bollinger Band Width (BBW)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger Band Width (BBW)\", \"BBW\", overlay=false)\n\n//@function Calculates Bollinger Band Width as the difference between upper and lower bands\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/bbw.md\n//@param source Series to calculate Bollinger Bands from\n//@param period Lookback period for calculations\n//@param multiplier Standard deviation multiplier for band width\n//@returns BBW value representing the width between Bollinger Bands\n//@optimized for performance and dirty data\nbbw(series float source, simple int period, simple float multiplier) =>\n    if period <= 0 or multiplier <= 0.0\n        runtime.error(\"Period and multiplier must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0, var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float current_val = nz(source)\n    sum += current_val\n    sumSq += current_val * current_val\n    count += 1\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    float basis = nz(sum / count, source)\n    float dev = count > 1 ? multiplier * math.sqrt(math.max(0.0, sumSq / count - basis * basis)) : 0.0\n    2 * dev\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"StdDev Multiplier\", minval=0.001)\n\n// Calculation\nbbw_value = bbw(i_source, i_period, i_multiplier)\n\n// Plot\nplot(bbw_value, \"BBW\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bollinger band width (bbw)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "bbw.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-231",
    "type": "example",
    "category": "volatility",
    "title": "Bollinger Band Width Normalized (BBWN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger Band Width Normalized (BBWN)\", \"BBWN\", overlay=false)\n\n//@function Calculates Bollinger Band Width Normalized to [0,1] range\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/bbwn.md\n//@param source Series to calculate Bollinger Bands from\n//@param period Lookback period for BB calculations\n//@param multiplier Standard deviation multiplier for band width\n//@param lookback Historical lookback period for normalization\n//@returns BBWN value representing current BBW normalized to [0,1] range\n//@optimized for performance and dirty data\nbbwn(series float source, simple int period, simple float multiplier, simple int lookback) =>\n    if period <= 0 or multiplier <= 0.0 or lookback <= 0\n        runtime.error(\"Period, multiplier, and lookback must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0, var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float current_val = nz(source)\n    sum += current_val\n    sumSq += current_val * current_val\n    count += 1\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    float basis = nz(sum / count, source)\n    float dev = count > 1 ? multiplier * math.sqrt(math.max(0.0, sumSq / count - basis * basis)) : 0.0\n    float bbw = 2 * dev\n    var int l = math.max(1, lookback), var int hist_head = 0, var int hist_count = 0\n    var array<float> hist_buffer = array.new_float(l, na)\n    var float min_val = bbw, var float max_val = bbw\n    float hist_oldest = array.get(hist_buffer, hist_head)\n    if not na(hist_oldest)\n        hist_count -= 1\n    if not na(bbw)\n        hist_count += 1\n    array.set(hist_buffer, hist_head, bbw)\n    hist_head := (hist_head + 1) % l\n    if hist_count >= 1\n        min_val := bbw\n        max_val := bbw\n        for i = 0 to hist_count - 1\n            float val = array.get(hist_buffer, i)\n            if not na(val)\n                min_val := math.min(min_val, val)\n                max_val := math.max(max_val, val)\n    float range_val = max_val - min_val\n    range_val > 0 ? (bbw - min_val) / range_val : 0.5\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"StdDev Multiplier\", minval=0.001)\ni_lookback = input.int(252, \"Lookback Period\", minval=1)\n\n// Calculation\nbbwn_value = bbwn(i_source, i_period, i_multiplier, i_lookback)\n\n// Plot\nplot(bbwn_value, \"BBWN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bollinger band width normalized (bbwn)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "bbwn.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.min",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-232",
    "type": "example",
    "category": "volatility",
    "title": "Bollinger Band Width Percentile (BBWP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Bollinger Band Width Percentile (BBWP)\", \"BBWP\", overlay=false, format=format.percent)\n\n//@function Calculates Bollinger Band Width Percentile relative to historical range\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/bbwp.md\n//@param source Series to calculate Bollinger Bands from\n//@param period Lookback period for BB calculations\n//@param multiplier Standard deviation multiplier for band width\n//@param lookback Historical lookback period for percentile calculation\n//@returns BBWP value representing current BBW percentile in historical range\n//@optimized for performance and dirty data\nbbwp(series float source, simple int period, simple float multiplier, simple int lookback) =>\n    if period <= 0 or multiplier <= 0.0 or lookback <= 0\n        runtime.error(\"Period, multiplier, and lookback must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0, var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0, var float sumSq = 0.0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        sumSq -= oldest * oldest\n        count -= 1\n    float current_val = nz(source)\n    sum += current_val\n    sumSq += current_val * current_val\n    count += 1\n    array.set(buffer, head, current_val)\n    head := (head + 1) % p\n    float basis = nz(sum / count, source)\n    float dev = count > 1 ? multiplier * math.sqrt(math.max(0.0, sumSq / count - basis * basis)) : 0.0\n    float bbw = 2 * dev\n    var int l = math.max(1, lookback), var int hist_head = 0, var int hist_count = 0\n    var array<float> hist_buffer = array.new_float(l, na)\n    float hist_oldest = array.get(hist_buffer, hist_head)\n    if not na(hist_oldest)\n        hist_count -= 1\n    if not na(bbw)\n        hist_count += 1\n    array.set(hist_buffer, hist_head, bbw)\n    hist_head := (hist_head + 1) % l\n    if hist_count < 2\n        0.5\n    else\n        int below_count = 0\n        for i = 0 to hist_count - 1\n            float val = array.get(hist_buffer, i)\n            if not na(val) and val < bbw\n                below_count += 1\n        below_count / hist_count\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\ni_multiplier = input.float(2.0, \"StdDev Multiplier\", minval=0.001)\ni_lookback = input.int(252, \"Lookback Period\", minval=1)\n\n// Calculation\nbbwp_value = bbwp(i_source, i_period, i_multiplier, i_lookback)\n\n// Plot\nplot(bbwp_value, \"BBWP\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "bollinger band width percentile (bbwp)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "bbwp.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "input.int",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-233",
    "type": "example",
    "category": "volatility",
    "title": "Close-to-Close Volatility (CCV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Close-to-Close Volatility (CCV)\", \"CCV\", overlay=false)\n\n//@function Calculates Close-to-Close Volatility using closing price returns\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/ccv.md\n//@param length Period for volatility calculations\n//@param method Smoothing method (1=SMA, 2=EMA, 3=WMA)\n//@returns float Volatility value\n//@optimized Beta precomputation for RMA warmup compensation\nccv(simple int length, simple int method) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if method < 1 or method > 3\n        runtime.error(\"Method must be 1 (SMA), 2 (EMA), or 3 (WMA)\")\n    var int p = math.max(1, length)\n    var int head = 0\n    var int count = 0\n    var array<float> buffer = array.new_float(p, na)\n    var float sum = 0.0\n    var float wsum = 0.0\n    float priceReturn = math.log(close / close[1])\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        count -= 1\n    sum += priceReturn\n    count += 1\n    array.set(buffer, head, priceReturn)\n    head := (head + 1) % p\n    float mean = nz(sum / count)\n    float squaredSum = 0.0\n    for i = 0 to length - 1\n        float val = array.get(buffer, (head - i - 1 + p) % p)\n        if not na(val)\n            squaredSum += math.pow(val - mean, 2)\n    float annualizedStdDev = math.sqrt(squaredSum / count) * math.sqrt(252)\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float result = na\n    if method == 1\n        result := annualizedStdDev\n    else if method == 2\n        raw_rma := (raw_rma * (length - 1) + annualizedStdDev) / length\n        e *= beta\n        result := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    else\n        float sumWeight = length * (length + 1) / 2\n        float weightedSum = 0.0\n        float weight = length\n        for i = 0 to length - 1\n            weightedSum += annualizedStdDev * weight\n            weight -= 1.0\n        result := weightedSum / sumWeight\n    result\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1, maxval=500, tooltip=\"Number of bars for volatility calculation\")\ni_method = input.int(1, \"Method\", minval=1, maxval=3, tooltip=\"1=SMA, 2=EMA, 3=WMA\")\n\n// Calculation\nccvValue = ccv(i_length, i_method)\n\n// Plot\nplot(ccvValue, \"CCV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "close-to-close volatility (ccv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "ccv.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-234",
    "type": "example",
    "category": "volatility",
    "title": "Conditional Volatility (CV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Conditional Volatility (CV)\", \"CV\", overlay=false)\n\n//@function Calculates GARCH(1,1) conditional volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/cv.md\n//@param length Initial period for parameter estimation\n//@param alpha Weight on previous squared return\n//@param beta Weight on previous variance\n//@returns float Conditional volatility value\n//@optimized for performance and efficient variance updating\ncv(simple int length, simple float alpha, simple float beta) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if alpha <= 0.0 or alpha >= 1.0\n        runtime.error(\"Alpha must be between 0 and 1\")\n    if beta <= 0.0 or beta >= 1.0\n        runtime.error(\"Beta must be between 0 and 1\")\n    if alpha + beta >= 1.0\n        runtime.error(\"Alpha + Beta must be less than 1 for stationarity\")\n    var float omega = 0.0\n    var float longRunVar = 0.0\n    var float prevVariance = 0.0\n    float DAYS_IN_YEAR = 252.0\n    float MIN_PRICE = 1e-10\n    float DEFAULT_VARIANCE = 0.0001\n    float safeClose = nz(close, close[1])\n    safeClose := math.max(safeClose, MIN_PRICE)\n    float safePrevClose = nz(close[1], close[2] != 0.0 ? close[2] : safeClose)\n    safePrevClose := math.max(safePrevClose, MIN_PRICE)\n    float logReturn = 0.0\n    if safeClose > 0.0 and safePrevClose > 0.0\n        logReturn := math.log(safeClose / safePrevClose)\n    logReturn := math.abs(logReturn) > 0.2 ? math.sign(logReturn) * 0.2 : logReturn\n    float squaredReturn = logReturn * logReturn\n    if bar_index < length\n        longRunVar := (bar_index * longRunVar + squaredReturn) / (bar_index + 1)\n        prevVariance := longRunVar\n    else if bar_index == length\n        omega := (1.0 - alpha - beta) * longRunVar\n        prevVariance := longRunVar\n    float variance = nz(prevVariance, DEFAULT_VARIANCE)\n    variance := omega + alpha * squaredReturn + beta * variance\n    variance := math.max(variance, 0.0000001)\n    prevVariance := variance\n    math.sqrt(DAYS_IN_YEAR * variance) * 100\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=10, maxval=500, tooltip=\"Initial period for estimation\")\ni_alpha = input.float(0.2, \"Alpha\", minval=0.01, maxval=0.99, step=0.01, tooltip=\"Weight on previous squared return\")\ni_beta = input.float(0.7, \"Beta\", minval=0.01, maxval=0.99, step=0.01, tooltip=\"Weight on previous variance\")\n\n// Calculation\ncvValue = cv(i_length, i_alpha, i_beta)\n\n// Plot\nplot(cvValue, \"CV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.log",
      "math.abs",
      "math.sign",
      "math.sqrt",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "conditional volatility (cv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.log",
      "math.abs",
      "math.sign",
      "math.sqrt",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "cv.md",
      "runtime.error",
      "math.max",
      "math.log",
      "math.abs",
      "math.sign",
      "math.sqrt",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-235",
    "type": "example",
    "category": "volatility",
    "title": "Chaikin",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chaikin's Volatility (CVI)\", \"CVI\", overlay=false)\n\n//@function Calculates Chaikin's Volatility using high-low range and ROC of EMA\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/cvi.md\n//@param roc_length Period for Rate of Change calculation\n//@param smooth_length Period for EMA smoothing\n//@returns float Volatility value measuring change in trading ranges\n//@optimized for performance using efficient range ROC calculation\ncvi(simple int roc_length, simple int smooth_length) =>\n    if roc_length <= 0 or smooth_length <= 0\n        runtime.error(\"Lengths must be greater than 0\")\n    var float prevEma = 0.0\n    hlRange = high - low\n    alpha = 2.0 / (smooth_length + 1)\n    if bar_index == 0\n        float sum = 0.0\n        for i = 0 to smooth_length-1\n            sum += nz(hlRange[i])\n        prevEma := sum/smooth_length\n    ema = nz(prevEma)\n    ema := (hlRange - ema) * alpha + ema\n    prevEma := ema\n    float roc = na\n    if bar_index >= roc_length\n        roc := ((ema - ema[roc_length])/ema[roc_length]) * 100\n    roc\n\n// ---------- Main loop ----------\n\n// Inputs\ni_roc = input.int(10, \"ROC Length\", minval=1, maxval=500, tooltip=\"Period for Rate of Change calculation\")\ni_smooth = input.int(10, \"Smoothing Length\", minval=1, maxval=500, tooltip=\"Period for EMA smoothing of high-low range\")\n\n// Calculation\ncviValue = cvi(i_roc, i_smooth)\n\n// Plot\nplot(cviValue, \"CVI\", color=color.yellow, linewidth=2)\nplot(0, \"Zero\", color.gray, 1, plot.style_circles)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot"
    ],
    "keywords": [
      "chaikin",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot",
      "github.com",
      "cvi.md",
      "runtime.error",
      "input.int",
      "color.yellow",
      "color.gray",
      "plot.style_circles",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-236",
    "type": "example",
    "category": "volatility",
    "title": "Exponential Weighted MA Volatility",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Exponential Weighted MA Volatility\", \"EWMA Volty\", overlay=false)\n\n//@function Calculates Exponential Weighted Moving Average (EWMA) Volatility.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/ewma.md\n//@param src The source series for price data. Default is close.\n//@param length The period length for the EWMA calculation.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The EWMA Volatility value.\n//@optimized for performance and dirty data\newmaVolty(series float src, simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    float logReturn = nz(math.log(src / src[1]),0.0)\n    float squaredReturn = logReturn * logReturn\n    var float raw_rma_sq_ret = 0.0, var float e_rma = 1.0\n    float rma_alpha = 1.0 / float(length)\n    if not na(squaredReturn)\n        raw_rma_sq_ret := na(raw_rma_sq_ret[1]) ? squaredReturn : (nz(raw_rma_sq_ret[1],squaredReturn) * (length - 1) + squaredReturn) / length\n        e_rma := na(e_rma[1]) ? (1.0 - rma_alpha) : (1.0 - rma_alpha) * nz(e_rma[1],1.0)\n    float EPSILON = 1e-10\n    float corrected_rma_sq_ret = e_rma > EPSILON and not na(raw_rma_sq_ret) ? raw_rma_sq_ret / (1.0 - e_rma) : raw_rma_sq_ret\n    float currentEwmaSqReturns = nz(corrected_rma_sq_ret, squaredReturn)\n    float volatility = currentEwmaSqReturns < 0 ? na : math.sqrt(currentEwmaSqReturns)\n    annualize and not na(volatility) ? volatility * math.sqrt(float(annualPeriods)) : volatility\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=1, tooltip=\"Period for EWMA calculation\")\ni_annualize = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the volatility output\")\ni_annualPeriods = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly)\")\n\n// Calculation\newmaVolatilityValue = ewmaVolty(i_source, i_length, i_annualize, i_annualPeriods)\n\n// Plot\nplot(ewmaVolatilityValue, \"EWMA Volty\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "exponential weighted ma volatility",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "ewma.md",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.source",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-237",
    "type": "example",
    "category": "volatility",
    "title": "Garman-Klass Volatility (GKV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Garman-Klass Volatility (GKV)\", \"GKV\", overlay=false)\n\n//@function Calculates Garman-Klass Volatility.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/gkv.md\n//@param length The period length for smoothing the Garman-Klass estimator.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The Garman-Klass Volatility value.\n//@optimized for performance and dirty data\ngkv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    float lnH = math.log(high), float lnL = math.log(low), float lnO = math.log(open), float lnC = math.log(close)\n    float C_2LN2_1 = 0.3862941611 // 2 * math.log(2) - 1\n    float term1 = 0.5 * math.pow(lnH - lnL, 2)\n    float term2 = C_2LN2_1 * math.pow(lnC - lnO, 2)\n    float gkEstimator = term1 - term2\n    var float raw_rma_gk = 0.0, var float e_rma = 1.0\n    float rma_alpha = 1.0 / float(length)\n    if not na(gkEstimator)\n        raw_rma_gk := na(raw_rma_gk[1]) ? gkEstimator : (nz(raw_rma_gk[1], gkEstimator) * (length - 1) + gkEstimator) / length\n        e_rma := na(e_rma[1]) ? (1.0 - rma_alpha) : (1.0 - rma_alpha) * nz(e_rma[1], 1.0)\n    float EPSILON = 1e-10\n    float corrected_rma_gk = e_rma > EPSILON and not na(raw_rma_gk) ? raw_rma_gk / (1.0 - e_rma) : raw_rma_gk\n    float smoothedGkEstimator = nz(corrected_rma_gk, gkEstimator)\n    float volatility = smoothedGkEstimator < 0 ? na : math.sqrt(smoothedGkEstimator)\n    annualize and not na(volatility) ? volatility * math.sqrt(float(annualPeriods)) : volatility\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1, tooltip=\"Period for smoothing the Garman-Klass estimator\")\ni_annualize = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the volatility output\")\ni_annualPeriods = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly)\")\n\n// Calculation\ngkvValue = gkv(i_length, i_annualize, i_annualPeriods)\n\n// Plot\nplot(gkvValue, \"GKV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "garman-klass volatility (gkv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "gkv.md",
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-238",
    "type": "example",
    "category": "volatility",
    "title": "High-Low Volatility (HLV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"High-Low Volatility (HLV)\", \"HLV\", overlay=false)\n\n//@function Calculates High-Low Volatility based on the Parkinson number.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/hlv.md\n//@param length The period length for smoothing the Parkinson estimator.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The High-Low Volatility value.\n//@optimized for performance and dirty data\nhlv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    float lnH = math.log(high), float lnL = math.log(low)\n    float C_4LN2_INV = 0.3606737602 // 1.0 / (4.0 * math.log(2.0))\n    float parkinsonEstimator = C_4LN2_INV * math.pow(lnH - lnL, 2)\n    var float raw_rma_parkinson = 0.0, var float e_rma = 1.0\n    float rma_alpha = 1.0 / float(length)\n    if not na(parkinsonEstimator)\n        raw_rma_parkinson := na(raw_rma_parkinson[1]) ? parkinsonEstimator : (nz(raw_rma_parkinson[1], parkinsonEstimator) * (length - 1) + parkinsonEstimator) / length\n        e_rma := na(e_rma[1]) ? (1.0 - rma_alpha) : (1.0 - rma_alpha) * nz(e_rma[1], 1.0)\n    float EPSILON = 1e-10\n    float corrected_rma_parkinson = e_rma > EPSILON and not na(raw_rma_parkinson) ? raw_rma_parkinson / (1.0 - e_rma) : raw_rma_parkinson\n    float smoothedParkinsonEstimator = nz(corrected_rma_parkinson, parkinsonEstimator)\n    float volatility = smoothedParkinsonEstimator < 0 ? na : math.sqrt(smoothedParkinsonEstimator)\n    annualize and not na(volatility) ? volatility * math.sqrt(float(annualPeriods)) : volatility\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(20, \"Length\", minval=1, tooltip=\"Period for smoothing the Parkinson estimator\")\ni_annualize = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the volatility output\")\ni_annualPeriods = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly)\")\n\n// Calculation\nhlvValue = hlv(i_length, i_annualize, i_annualPeriods)\n\n// Plot\nplot(hlvValue, \"HLV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "high-low volatility (hlv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "hlv.md",
      "runtime.error",
      "math.log",
      "math.pow",
      "math.sqrt",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-239",
    "type": "example",
    "category": "volatility",
    "title": "Historical Volatility (HV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Historical Volatility (HV)\", \"HV\", overlay=false)\n\n//@function Calculates Historical Volatility (Close-to-Close).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/hv.md\n//@param src_price The source series to calculate returns from. Default is close.\n//@param length_hv The period length for calculating the standard deviation of returns.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The Historical Volatility value.\n//@optimized for performance and dirty data\nhv(series float src_price, simple int length_hv, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length_hv <= 1\n        runtime.error(\"Length for HV must be greater than 1\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    var array<float> _buffer_hv = array.new_float(length_hv, na)\n    var int _head_idx_hv = 0\n    var int _current_fill_count_hv = 0\n    var float _sum_val_hv = 0.0\n    var float _sum_sq_val_hv = 0.0\n    float logReturn = na(src_price[1]) or src_price[1] == 0 ? na : math.log(src_price / nz(src_price[1], src_price))\n    float stdDevLogReturns = na\n    if not na(logReturn)\n        float _oldest_val_in_buffer_hv = array.get(_buffer_hv, _head_idx_hv)\n        if not na(_oldest_val_in_buffer_hv)\n            _sum_val_hv -= _oldest_val_in_buffer_hv\n            _sum_sq_val_hv -= _oldest_val_in_buffer_hv * _oldest_val_in_buffer_hv\n            _current_fill_count_hv -= 1\n        float _current_log_return_val = nz(logReturn) \n        _sum_val_hv += _current_log_return_val\n        _sum_sq_val_hv += _current_log_return_val * _current_log_return_val\n        _current_fill_count_hv += 1\n        array.set(_buffer_hv, _head_idx_hv, _current_log_return_val)\n        _head_idx_hv := (_head_idx_hv + 1) % length_hv\n        if _current_fill_count_hv > 1\n            float _variance_hv = (_sum_sq_val_hv / _current_fill_count_hv) - math.pow(_sum_val_hv / _current_fill_count_hv, 2)\n            stdDevLogReturns := math.sqrt(math.max(0.0, _variance_hv))\n        else\n            stdDevLogReturns := 0.0\n    else\n        stdDevLogReturns := na \n    float volatility = stdDevLogReturns\n    if annualize and not na(volatility)\n        volatility := volatility * math.sqrt(float(annualPeriods))\n    volatility\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(close, \"Source\")\ni_length = input.int(20, \"Length\", minval=2, tooltip=\"Period for calculating standard deviation of returns\")\ni_annualize = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the volatility output\")\ni_annualPeriods = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly)\")\n\n// Calculation",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "historical volatility (hv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "hv.md",
      "runtime.error",
      "array.new_float",
      "math.log",
      "array.get",
      "array.set",
      "math.pow",
      "math.sqrt",
      "math.max",
      "input.source",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "fill",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-240",
    "type": "example",
    "category": "volatility",
    "title": "Jurik Volatility (JVOLTY)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Jurik Volatility (JVOLTY)\", \"JVOLTY\", overlay=false)\n\n//@function Calculates JVOLTY using adaptive techniques to adjust to market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/jvolty.md\n//@param source Series to calculate Jvolty from\n//@param period Number of bars used in the calculation\n//@returns JVOLTY volatility\n//@optimized for performance and dirty data\njvolty(series float source, simple int period) =>\n    var simple float LEN1 = math.max((math.log(math.sqrt(0.5*(period-1))) / math.log(2.0)) + 2.0, 0)\n    var simple float POW1 = math.max(LEN1 - 2.0, 0.5)\n    var simple float LEN2 = math.sqrt(0.5*(period-1))*LEN1\n    var simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)\n    var simple float DIV = 1.0/(10.0 + 10.0*(math.min(math.max(period-10,0),100))/100.0)\n    var float upperBand = nz(source)\n    var float lowerBand = nz(source)\n    var float vSum = 0.0\n    var float avgVolty = 0.0\n    if na(source)\n        na\n    else\n        float del1 = source - upperBand\n        float del2 = source - lowerBand\n        float volty = math.max(math.abs(del1), math.abs(del2))\n        float past_volty = na(volty[10]) ? 0.0 : volty[10]\n        vSum := vSum + (volty - past_volty) * DIV\n        avgVolty := na(avgVolty) ? vSum : avgVolty + AVG_VOLTY_ALPHA * (vSum - avgVolty)\n        float rvolty = 1.0\n        if avgVolty > 0\n            rvolty := volty / avgVolty\n            rvolty := math.min(math.max(rvolty, 1.0), math.pow(LEN1, 1.0 / POW1))\n        float Kv = math.pow(LEN2/(LEN2+1), math.sqrt(math.pow(rvolty, POW1)))\n        upperBand := del1 > 0 ? source : source - Kv * del1\n        lowerBand := del2 < 0 ? source : source - Kv * del2\n        rvolty\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\njvolty= jvolty(i_source, i_period)\n\n// Plot\nplot(jvolty, \"JVolty\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "jurik volatility (jvolty)",
      "volatility",
      "indicator",
      "v6",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "jvolty.md",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-241",
    "type": "example",
    "category": "volatility",
    "title": "Normalized Jurik Volatility (JVOLTYN)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Normalized Jurik Volatility (JVOLTYN)\", \"JVOLTYN\", overlay=false)\n\n//@function Calculates normalized JVOLTYN using adaptive techniques to adjust to market volatility\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/jvoltyn.md\n//@param source Series to calculate Jvolty from\n//@param period Number of bars used in the calculation\n//@returns JVOLTYN volatility\n//@optimized for performance and dirty data\njvoltyn(series float source, simple int period) =>\n    var simple float LEN1 = math.max((math.log(math.sqrt(0.5*(period-1))) / math.log(2.0)) + 2.0, 0)\n    var simple float POW1 = math.max(LEN1 - 2.0, 0.5)\n    var simple float LEN2 = math.sqrt(0.5*(period-1))*LEN1\n    var simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)\n    var simple float DIV = 1.0/(10.0 + 10.0*(math.min(math.max(period-10,0),100))/100.0)\n    var float upperBand = nz(source)\n    var float lowerBand = nz(source)\n    var float vSum = 0.0\n    var float avgVolty = 0.0\n    if na(source)\n        na\n    else\n        float del1 = source - upperBand\n        float del2 = source - lowerBand\n        float volty = math.max(math.abs(del1), math.abs(del2))\n        float past_volty = na(volty[10]) ? 0.0 : volty[10]\n        vSum := vSum + (volty - past_volty) * DIV\n        avgVolty := na(avgVolty) ? vSum : avgVolty + AVG_VOLTY_ALPHA * (vSum - avgVolty)\n        float rvolty = 1.0\n        if avgVolty > 0\n            rvolty := volty / avgVolty\n            rvolty := math.min(math.max(rvolty, 1.0), math.pow(LEN1, 1.0 / POW1))\n        float Kv = math.pow(LEN2/(LEN2+1), math.sqrt(math.pow(rvolty, POW1)))\n        upperBand := del1 > 0 ? source : source - Kv * del1\n        lowerBand := del2 < 0 ? source : source - Kv * del2\n        1.0 / (1.0 + math.exp(-(rvolty - 1.0) * 1.5))\n    \n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(10, \"Period\", minval=1, tooltip=\"Number of bars used in the calculation\")\ni_source = input.source(close, \"Source\")\n\n// Calculation\njvoltyn= jvoltyn(i_source, i_period)\n\n// Plot\nplot(jvoltyn, \"JVoltyN\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "normalized jurik volatility (jvoltyn)",
      "volatility",
      "indicator",
      "v6",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "jvoltyn.md",
      "math.max",
      "math.log",
      "math.sqrt",
      "math.min",
      "math.abs",
      "math.pow",
      "math.exp",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-242",
    "type": "example",
    "category": "volatility",
    "title": "Mass Index (MASSI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Mass Index (MASSI)\", \"MASSI\", overlay=false)\n\n//@function Calculates the Mass Index indicator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/massi.md\n//@param ema_length Period for EMA smoothing of high-low range\n//@param sum_length Period for summing the EMA ratio\n//@returns float Mass Index value\n//@optimized for performance and dirty data\nmassi(simple int ema_length, simple int sum_length) =>\n    if ema_length <= 0 or sum_length <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    float a = 2.0 / (ema_length + 1)\n    float beta = 1.0 - a\n    var bool warmup = true, var float e = 1.0\n    var float ema1_raw = 0.0, var float ema2_raw = 0.0\n    float span = nz(high - low)\n    ema1_raw := a * (span - ema1_raw) + ema1_raw\n    ema2_raw := a * (ema1_raw - ema2_raw) + ema2_raw\n    if warmup\n        e *= beta\n        warmup := e > 1e-10\n    float c = warmup ? 1.0 / (1.0 - e) : 1.0\n    float ema1 = c * ema1_raw\n    float ema2 = c * ema2_raw\n    math.sum(ema2 != 0 ? ema1 / ema2 : 0, sum_length)\n\n// ---------- Main loop ----------\n// Inputs\ni_ema_length = input.int(9, \"EMA Length\", minval=1, tooltip=\"Period for EMA smoothing of high-low range\")\ni_sum_length = input.int(25, \"Sum Length\", minval=1, tooltip=\"Period for summing the EMA ratio\")\n\n// Calculation\nmassi_value = massi(i_ema_length, i_sum_length)\n\n// Plot\nplot(massi_value, \"MASSI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.sum",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "mass index (massi)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.sum",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "massi.md",
      "runtime.error",
      "math.sum",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-243",
    "type": "example",
    "category": "volatility",
    "title": "Normalized Average True Range",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Normalized Average True Range\", \"NATR\", overlay=false, format=format.percent, precision=2)\n\n//@function Calculates the Normalized Average True Range (NATR)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/natr.md\n//@param length The period length for the ATR calculation.\n//@returns The NATR value as a percentage of close price.\n//@optimized Beta precomputation for RMA warmup compensation\nnatr(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float prevClose = nz(close[1], close)\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, math.max(tr2, tr3))\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    float atrValue = na\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        atrValue := e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    float natrValue = close != 0 ? (atrValue / close) * 100 : 0\n    natrValue\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Length\", minval=1, tooltip=\"Number of bars used for the ATR calculation\")\n\n// Calculation\nnatrValue = natr(i_length)\n\n// Plot\nplot(natrValue, \"NATR\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "normalized average true range",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "plot",
      "format.percent",
      "github.com",
      "natr.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-244",
    "type": "example",
    "category": "volatility",
    "title": "Parkinson Volatility (PV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Parkinson Volatility (PV)\", \"PV\", overlay=false)\n\n//@function Calculates Parkinson Volatility.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/pv.md\n//@param length The lookback period for the RMA smoothing of squared log returns (High/Low). Default is 20.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The Parkinson Volatility value.\npv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    float parkinson_hl_term = high == low ? 0.0 : math.log(high / low)\n    float parkinson_hl_sq = parkinson_hl_term * parkinson_hl_term\n    float smoothed_parkinson_hl_sq = ta.rma(parkinson_hl_sq, length)\n    float volatility_period = math.sqrt(smoothed_parkinson_hl_sq / (4 * math.log(2)))\n    float final_volatility = volatility_period\n    if annualize and not na(final_volatility)\n        final_volatility := final_volatility * math.sqrt(float(annualPeriods))\n    final_volatility\n\n// ---------- Main loop ----------\n// Inputs\ni_length_pv = input.int(20, \"Length\", minval=1, tooltip=\"Lookback period for RMA smoothing of High/Low squared log returns.\")\ni_annualize_pv = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the Parkinson Volatility output.\")\ni_annualPeriods_pv = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly).\")\n\n// Calculation\npvValue = pv(i_length_pv, i_annualize_pv, i_annualPeriods_pv)\n\n// Plot\nplot(pvValue, \"PV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.log",
      "ta.rma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "parkinson volatility (pv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.log",
      "ta.rma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "pv.md",
      "runtime.error",
      "math.log",
      "ta.rma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-245",
    "type": "example",
    "category": "volatility",
    "title": "Rogers-Satchell Volatility (RSV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Rogers-Satchell Volatility (RSV)\", \"RSV\", overlay=false)\n\n//@function Calculates Rogers-Satchell Volatility.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/rsv.md\n//@param length The lookback period for the SMA smoothing of the Rogers-Satchell variance. Default is 20.\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods in a year for annualization. Default is 252 for daily data.\n//@returns float The Rogers-Satchell Volatility value.\nrsv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    float h = math.max(high, 0.0000001)\n    float l = math.max(low, 0.0000001)\n    float o = math.max(open, 0.0000001)\n    float c = math.max(close, 0.0000001)\n    float term1 = math.log(h / o)\n    float term2 = math.log(h / c)\n    float term3 = math.log(l / o)\n    float term4 = math.log(l / c)\n    float rs_variance_period = (term1 * term2) + (term3 * term4)\n    float smoothed_rs_variance = ta.sma(rs_variance_period, length)\n    float volatility_period = math.sqrt(math.max(0.0, smoothed_rs_variance))\n    float final_volatility = volatility_period\n    if annualize and not na(final_volatility)\n        final_volatility := final_volatility * math.sqrt(float(annualPeriods))\n    final_volatility\n\n// ---------- Main loop ----------\n// Inputs\ni_length_rsv = input.int(20, \"Length\", minval=1, tooltip=\"Lookback period for SMA smoothing of Rogers-Satchell variance.\")\ni_annualize_rsv = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the Rogers-Satchell Volatility output.\")\ni_annualPeriods_rsv = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of periods in a year for annualization (e.g., 252 for daily, 52 for weekly).\")\n\n// Calculation\nrsvValue = rsv(i_length_rsv, i_annualize_rsv, i_annualPeriods_rsv)\n\n// Plot\nplot(rsvValue, \"RSV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.log",
      "ta.sma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "rogers-satchell volatility (rsv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.log",
      "ta.sma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "rsv.md",
      "runtime.error",
      "math.max",
      "math.log",
      "ta.sma",
      "math.sqrt",
      "input.int",
      "input.bool",
      "e.g",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-246",
    "type": "example",
    "category": "volatility",
    "title": "Realized Volatility (RV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Realized Volatility (RV)\", \"RV\", overlay=false)\n\n//@function Calculates Realized Volatility using intraday data.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/rv.md\n//@param length The lookback period for smoothing the period volatilities (e.g., daily RVs). Default is 20.\n//@param intradayTimeframe The lower timeframe string (e.g., \"1\", \"5\", \"60\") to sample for returns. Must be a lower timeframe than the chart. Default is \"5\".\n//@param annualize Boolean to indicate if the volatility should be annualized. Default is true.\n//@param annualPeriods Number of periods (of the main chart's timeframe) in a year for annualization. Default is 252 (assuming daily chart).\n//@returns float The Realized Volatility value.\nrv(simple int length = 20, simple string intradayTimeframe = \"5\", simple bool annualize = true, simple int annualPeriods = 252) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0\")\n    if annualize and annualPeriods <= 0\n        runtime.error(\"Annual periods must be greater than 0 if annualizing\")\n    intraday_closes_arr = request.security_lower_tf(syminfo.tickerid, intradayTimeframe, close)\n    float sum_sq_log_returns = 0.0\n    if array.size(intraday_closes_arr) > 1\n        for i = 1 to array.size(intraday_closes_arr) - 1\n            float prev_close = array.get(intraday_closes_arr, i - 1)\n            float curr_close = array.get(intraday_closes_arr, i)\n            if not na(prev_close) and not na(curr_close) and prev_close > 0 and curr_close > 0\n                float log_return = math.log(curr_close / prev_close)\n                sum_sq_log_returns += log_return * log_return\n            else\n                sum_sq_log_returns := na\n                break \n    else \n        sum_sq_log_returns := 0.0\n    float realized_variance_this_period = sum_sq_log_returns\n    float volatility_this_period = na \n    if not na(realized_variance_this_period)\n        if realized_variance_this_period >= 0\n            volatility_this_period := math.sqrt(realized_variance_this_period)\n    float smoothed_volatility = ta.sma(volatility_this_period, length)\n    float final_volatility = smoothed_volatility\n    if annualize and not na(final_volatility)\n        final_volatility := final_volatility * math.sqrt(float(annualPeriods))\n    final_volatility\n\n// ---------- Main loop ----------\n// Inputs\ni_length_rv = input.int(20, \"Smoothing Length\", minval=1, tooltip=\"Lookback period for smoothing the period realized volatilities (e.g., daily RVs).\")\ni_intraday_tf_rv = input.timeframe(\"5\", \"Intraday Timeframe\", tooltip=\"Lower timeframe for calculating intraday returns (e.g., \\\"1\\\", \\\"5\\\", \\\"60\\\"). Must be a lower timeframe than the chart.\")\ni_annualize_rv = input.bool(true, \"Annualize Volatility\", tooltip=\"Annualize the Realized Volatility output.\")\ni_annualPeriods_rv = input.int(252, \"Annual Periods\", minval=1, tooltip=\"Number of main chart periods in a yea",
    "functions_used": [
      "runtime.error",
      "request.security_lower_tf",
      "array.size",
      "array.get",
      "math.log",
      "math.sqrt",
      "ta.sma",
      "input.int",
      "input.timeframe",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "realized volatility (rv)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "request.security_lower_tf",
      "array.size",
      "array.get",
      "math.log",
      "math.sqrt",
      "ta.sma",
      "input.int",
      "input.timeframe",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "rv.md",
      "e.g",
      "runtime.error",
      "request.security_lower_tf",
      "syminfo.tickerid",
      "array.size",
      "array.get",
      "math.log",
      "math.sqrt",
      "ta.sma",
      "input.int",
      "input.timeframe",
      "input.bool",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-247",
    "type": "example",
    "category": "volatility",
    "title": "Relative Volatility Index (RVI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Relative Volatility Index (RVI)\", shorttitle=\"RVI\", overlay=false)\n\n//@function Calculates the Relative Volatility Index (RVI).\n//@doc The logic of custom stddev and rma is now inlined within this function.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/rvi.md\n//@param src The source series to calculate RVI from. Default is `close`.\n//@param stdevLength The lookback period for calculating the standard deviation of source prices. Default is 10.\n//@param rmaLength The lookback period for Wilder's smoothing (RMA) of the upward and downward standard deviations. Default is 14.\n//@returns float The Relative Volatility Index value.\nrvi(series float src = close, simple int stdevLength = 10, simple int rmaLength = 14) =>\n    if stdevLength <= 1 \n        runtime.error(\"Standard Deviation Length must be greater than 1\")\n    if rmaLength <= 0\n        runtime.error(\"RMA Length must be greater than 0\")\n    float currentStdDev = 0.0\n    var array<float> buffer_stddev = array.new_float(stdevLength, na) // p_stddev simplified\n    var int head_stddev = 0, var int count_stddev = 0\n    var float sum_stddev = 0.0, var float sumSq_stddev = 0.0\n    float oldest_stddev = array.get(buffer_stddev, head_stddev)\n    if not na(oldest_stddev)\n        sum_stddev -= oldest_stddev\n        sumSq_stddev -= oldest_stddev * oldest_stddev\n        count_stddev -= 1\n    float val_stddev = nz(src) \n    sum_stddev += val_stddev\n    sumSq_stddev += val_stddev * val_stddev\n    count_stddev += 1\n    array.set(buffer_stddev, head_stddev, val_stddev)\n    head_stddev := (head_stddev + 1) % stdevLength // p_stddev simplified\n    if count_stddev > 1\n        currentStdDev := math.sqrt(math.max(0.0, (sumSq_stddev / count_stddev) - math.pow(sum_stddev / count_stddev, 2)))\n    else\n        currentStdDev := 0.0 \n    float priceChange = src - src[1]\n    float upStd_val = 0.0, float downStd_val = 0.0\n    if priceChange > 0\n        upStd_val := currentStdDev\n    else if priceChange < 0\n        downStd_val := currentStdDev\n    var float raw_rma_up = 0.0, var float e_up = 1.0\n    var float avgUpStd = 0.0 , var float EPSILON_rma = 1e-10 \n    if not na(upStd_val) \n        float alpha_up = 1.0 / float(rmaLength)\n        raw_rma_up := (raw_rma_up * (rmaLength - 1) + upStd_val) / rmaLength\n        e_up := (1 - alpha_up) * e_up\n    avgUpStd := e_up > EPSILON_rma ? raw_rma_up / (1.0 - e_up) : raw_rma_up\n    if rmaLength == 0 \n        avgUpStd := upStd_val\n    var float raw_rma_down = 0.0, var float e_down = 1.0\n    var float avgDownStd = 0.0\n    if not na(downStd_val) \n        float alpha_down = 1.0 / float(rmaLength)\n        raw_rma_down := (raw_rma_down * (rmaLength - 1) + downStd_val) / rmaLength\n        e_down := (1 - alpha_down) * e_down\n    avgDownStd := e_down > EPSILON_rma ? raw_rma_down / (1.0 - e_down) : raw_rma_down\n    if rmaLength == 0\n        avgDownStd := downStd_val\n    float rviValue = 50.0 \n    float",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "relative volatility index (rvi)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "rvi.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.max",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-248",
    "type": "example",
    "category": "volatility",
    "title": "True Range",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"True Range\", \"TR\", overlay=false)\n\n//@function Calculates the True Range\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/tr.md\n//@returns The True Range value for the current bar.\ntr() =>\n    float prevClose = nz(close[1], close)\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, math.max(tr2, tr3))\n    trueRange\n\n// ---------- Main loop ----------\n\n// Calculation\ntrValue = tr()\n\n// Plot\nplot(trValue, \"TR\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.abs",
      "math.max",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "true range",
      "volatility",
      "indicator",
      "v6",
      "math.abs",
      "math.max",
      "color.yellow",
      "plot",
      "github.com",
      "tr.md",
      "math.abs",
      "math.max",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "for"
    ]
  },
  {
    "id": "script-249",
    "type": "example",
    "category": "volatility",
    "title": "Ulcer Index (UI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ulcer Index (UI)\", shorttitle=\"UI\", format=format.price, precision=2, overlay=false)\n\n//@function Calculates the Ulcer Index (UI).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/ui.md\n//@param src The source series. Default is `close`.\n//@param period The lookback period. Default is 14.\n//@returns float The Ulcer Index value.\nui(series float src, int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var deque = array.new_int(0)\n    var src_buffer = array.new_float(period, na)\n    var int current_index = 0\n    float current_val = nz(src)\n    array.set(src_buffer, current_index, current_val)\n    while array.size(deque) > 0 and array.get(deque, 0) <= bar_index - period\n        array.shift(deque)\n    while array.size(deque) > 0\n        int last_index_in_deque = array.get(deque, array.size(deque) - 1)\n        int buffer_lookup_index = last_index_in_deque % period\n        if array.get(src_buffer, buffer_lookup_index) <= current_val\n            array.pop(deque)\n        else\n            break\n    array.push(deque, bar_index)\n    int highest_index = array.get(deque, 0)\n    int highest_buffer_index = highest_index % period\n    highestClose = array.get(src_buffer, highest_buffer_index)\n    current_index := (current_index + 1) % period\n    percentDrawdown = ((src - highestClose) / highestClose) * 100.0\n    squaredDrawdown = math.pow(percentDrawdown, 2)\n    sumSquaredDrawdown = math.sum(squaredDrawdown, period)\n    averageSquaredDrawdown = sumSquaredDrawdown / period\n    ui = math.sqrt(averageSquaredDrawdown)\n    ui\n\n// Inputs\ni_src_ui = input.source(close, \"Source\")\ni_period_ui = input.int(14, \"Period\", minval=1, tooltip=\"Lookback period for calculating the Ulcer Index.\")\n\n// Calculation\nuiValue = ui(i_src_ui, i_period_ui)\n\n// Plot\nplot(uiValue, \"UI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.pow",
      "math.sum",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ulcer index (ui)",
      "volatility",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.pow",
      "math.sum",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "format.price",
      "github.com",
      "ui.md",
      "runtime.error",
      "array.new_int",
      "array.new_float",
      "array.set",
      "array.size",
      "array.get",
      "array.shift",
      "array.pop",
      "array.push",
      "math.pow",
      "math.sum",
      "math.sqrt",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "while",
      "if",
      "else"
    ]
  },
  {
    "id": "script-250",
    "type": "example",
    "category": "volatility",
    "title": "Volatility of Volatility (VOV)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Volatility of Volatility (VOV)\", shorttitle=\"VOV\", format=format.price, precision=4, overlay=false)\n\n//@function Calculates the Volatility of Volatility (VOV) with embedded rolling standard deviation algorithms.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/vov.md\n//@param src The source series. Default is `close`.\n//@param volatilityPeriod The lookback period for the initial volatility calculation. Default is 20.\n//@param vovPeriod The lookback period for calculating the standard deviation of the volatility series. Default is 10.\n//@returns float The VOV value.\nvov(series float src, int volatilityPeriod, int vovPeriod) =>\n    if volatilityPeriod <= 0 or vovPeriod <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    var int p1 = 0\n    var array<float> buffer1 = array.new_float(0)\n    var int head1 = 0, var int count1 = 0\n    var float sum1 = 0.0, var float sumSq1 = 0.0\n    if p1 != volatilityPeriod \n        p1 := math.max(1, volatilityPeriod)\n        buffer1 := array.new_float(p1, na)\n        head1 := 0, count1 := 0, sum1 := 0.0, sumSq1 := 0.0\n    float oldest1 = array.get(buffer1, head1)\n    if not na(oldest1)\n        sum1 -= oldest1\n        sumSq1 -= oldest1 * oldest1\n        count1 := count1 == p1 ? count1 - 1 : count1\n    float val1 = nz(src)\n    sum1 += val1\n    sumSq1 += val1 * val1\n    count1 := count1 < p1 ? count1 + 1 : count1\n    array.set(buffer1, head1, val1)\n    head1 := (head1 + 1) % p1\n    float initialVolatility = count1 > 1 ? math.sqrt(math.max(0.0, (sumSq1 / count1) - math.pow(sum1 / count1, 2))) : 0.0\n    var int p2 = 0\n    var array<float> buffer2 = array.new_float(0)\n    var int head2 = 0, var int count2 = 0\n    var float sum2 = 0.0, var float sumSq2 = 0.0\n    if p2 != vovPeriod \n        p2 := math.max(1, vovPeriod)\n        buffer2 := array.new_float(p2, na)\n        head2 := 0, count2 := 0, sum2 := 0.0, sumSq2 := 0.0\n    float oldest2 = array.get(buffer2, head2)\n    if not na(oldest2)\n        sum2 -= oldest2\n        sumSq2 -= oldest2 * oldest2\n        count2 := count2 == p2 ? count2 - 1 : count2\n    float val2 = nz(initialVolatility)\n    sum2 += val2\n    sumSq2 += val2 * val2\n    count2 := count2 < p2 ? count2 + 1 : count2\n    array.set(buffer2, head2, val2)\n    head2 := (head2 + 1) % p2\n    float vovValue = count2 > 1 ? math.sqrt(math.max(0.0, (sumSq2 / count2) - math.pow(sum2 / count2, 2))) : 0.0\n    vovValue\n\n// Inputs\ni_src = input.source(close, \"Source\")\ni_volatilityPeriod = input.int(20, \"Volatility Period\", minval=1, tooltip=\"Period for initial volatility calculation.\")\ni_vovPeriod = input.int(10, \"VOV Period\", minval=1, tooltip=\"Period for StDev of the volatility series.\")\n\n// Calculation\nvovValue = vov(i_src, i_volatilityPeriod, i_vovPeriod)\n\n// Plot\nplot(vovValue, \"VOV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "math.max",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volatility of volatility (vov)",
      "volatility",
      "indicator",
      "v5",
      "runtime.error",
      "array.new_float",
      "math.max",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "plot",
      "format.price",
      "github.com",
      "vov.md",
      "runtime.error",
      "array.new_float",
      "math.max",
      "array.get",
      "array.set",
      "math.sqrt",
      "math.pow",
      "input.source",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "type",
      "for",
      "if"
    ]
  },
  {
    "id": "script-251",
    "type": "example",
    "category": "volatility",
    "title": "Volatility Ratio (VR)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Volatility Ratio (VR)\", shorttitle=\"VR\", format=format.price, precision=2, overlay=false)\n\n//@function Calculates the Volatility Ratio (VR).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/vr.md\n// All logic for True Range and ATR calculation is encapsulated within this function.\n// ATR uses Wilder's RMA with bias correction for initialization.\n//@param atrPeriod The lookback period for ATR. Must be > 0.\n//@returns float The Volatility Ratio value for the current bar.\nvr(int atrPeriod) =>\n    if atrPeriod <= 0\n        runtime.error(\"ATR Period must be greater than 0\")\n    var float EPSILON_ATR = 1e-10\n    var float raw_atr = 0.0\n    var float e_compensator = 1.0\n    float tr = na\n    float h_l = high - low\n    if not na(close[1])\n        float h_pc = math.abs(high - close[1])\n        float l_pc = math.abs(low - close[1])\n        tr := math.max(h_l, h_pc, l_pc)\n    else\n        tr := h_l\n    float trForAtr = nz(tr)\n    float atrCurrent = na\n    if not na(trForAtr)\n        float alpha = 1.0 / float(atrPeriod)\n        if na(raw_atr[1]) and e_compensator == 1.0\n            raw_atr := trForAtr\n        else\n            raw_atr := (nz(raw_atr[1]) * (atrPeriod - 1) + trForAtr) / atrPeriod\n        e_compensator := (1.0 - alpha) * e_compensator\n        atrCurrent := e_compensator > EPSILON_ATR ? raw_atr / (1.0 - e_compensator) : raw_atr\n    float volatilityRatio = na\n    if not na(atrCurrent) and atrCurrent != 0\n        volatilityRatio := tr / atrCurrent\n    volatilityRatio\n\n// Inputs\ni_atrPeriod = input.int(14, title=\"ATR Period\", minval=1, tooltip=\"The lookbook period for calculating the Average True Range (ATR).\")\n\n// Calculation\nvrValue = vr(i_atrPeriod)\n\n// Plot\nplot(vrValue, title=\"VR\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volatility ratio (vr)",
      "volatility",
      "indicator",
      "v5",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "format.price",
      "github.com",
      "vr.md",
      "runtime.error",
      "math.abs",
      "math.max",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-252",
    "type": "example",
    "category": "volatility",
    "title": "Yang-Zhang Volatility (YZV)",
    "version": "v5",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=5\nindicator(\"Yang-Zhang Volatility (YZV)\", shorttitle=\"YZV\", overlay=false)\n\n//@function Calculates Yang-Zhang Volatility (YZV).\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volatility/yzv.md\n// YZV is a historical volatility measure that incorporates open, high, low, and close prices,\n// as well as overnight gaps. It uses a bias-corrected RMA for smoothing.\n// @param length The lookback period for smoothing the daily variance estimates. Must be > 0.\n// @returns float The Yang-Zhang Volatility value for the current bar.\nyzv(int length) =>\n    if length <= 0\n        runtime.error(\"Length must be greater than 0 for YZV calculation.\")\n        float(na)\n    o=open,h=high,l=low,c=close,pc=na(close[1])?open:close[1]\n    ro=math.log(o/pc),rc=math.log(c/o),rh=math.log(h/o),rl=math.log(l/o)\n    s_o_sq=ro*ro,s_c_sq=rc*rc\n    s_rs_sq=rh*(rh-rc)+rl*(rl-rc)\n    ratio_N=length<=1?1.0:(float(length)+1.0)/(float(length)-1.0)\n    k_yz=0.34/(1.34+ratio_N)\n    s_sq_daily=s_o_sq+k_yz*s_c_sq+(1.0-k_yz)*s_rs_sq\n    var float EPSILON_YZV = 1e-10 // Consistent with VR's EPSILON_ATR\n    var float raw_rma_val = 0.0\n    var float e_comp_val = 1.0\n    float smoothed_s_sq = na\n    if not na(s_sq_daily)\n        rma_alpha = 1.0 / float(length)\n        if na(raw_rma_val[1]) and e_comp_val == 1.0 // First valid calculation for RMA\n            raw_rma_val := s_sq_daily\n        else\n            raw_rma_val := (nz(raw_rma_val[1]) * (length - 1) + s_sq_daily) / length\n        e_comp_val := (1.0 - rma_alpha) * e_comp_val\n        smoothed_s_sq := e_comp_val > EPSILON_YZV ? raw_rma_val / (1.0 - e_comp_val) : raw_rma_val\n    result = math.sqrt(smoothed_s_sq)\n    result\n\n// Inputs\ni_length = input.int(20, title=\"Length\", minval=1, tooltip=\"The lookback period for smoothing Yang-Zhang daily variance estimates.\")\n\n// Calculation\nyzvValue = yzv(i_length)\n\n// Plot\nplot(yzvValue, title=\"YZV\", color=color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "yang-zhang volatility (yzv)",
      "volatility",
      "indicator",
      "v5",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "yzv.md",
      "runtime.error",
      "math.log",
      "math.sqrt",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-253",
    "type": "example",
    "category": "volume",
    "title": "Accumulation/Distribution Line (ADL)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Accumulation/Distribution Line (ADL)\", \"ADL\", overlay=false)\n\n//@function Calculates the Accumulation/Distribution Line (ADL), a volume-based indicator that measures money flow into and out of a security\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/adl.md\n//@param src_high The high price (default: built-in high)\n//@param src_low The low price (default: built-in low)\n//@param src_close The close price (default: built-in close)\n//@param src_vol The volume (default: built-in volume)\n//@returns The cumulative ADL value representing buying/selling pressure\nadl(src_high = high, src_low = low, src_close = close, src_vol = volume) =>\n    float mfm = 0.0\n    if not na(src_high) and not na(src_low) and not na(src_close)\n        mfm := (src_close - src_low) - (src_high - src_close)\n        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0\n    float mfv = na(src_vol) ? 0.0 : src_vol * mfm\n    var float cumulativeSum = 0.0\n    cumulativeSum := na(mfv) ? cumulativeSum : cumulativeSum + mfv\n    cumulativeSum\n\n// ---------- Inputs ----------\n\n// ---------- Calculations ----------\nadl_val = adl(high, low, close, volume)\n\n// ---------- Plotting ----------\nplot(adl_val, \"ADL\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "accumulation/distribution line (adl)",
      "volume",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "adl.md",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "if"
    ]
  },
  {
    "id": "script-254",
    "type": "example",
    "category": "volume",
    "title": "Chaikin A/D Oscillator (ADOSC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chaikin A/D Oscillator (ADOSC)\", \"ADOSC\", overlay=false)\n\n//@function Calculates the Chaikin Accumulation/Distribution Oscillator (ADOSC), a momentum indicator derived from the ADL\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/adosc.md\n//@param shortPeriod (simple int) Length of the short-term EMA applied to the ADL\n//@param longPeriod (simple int) Length of the long-term EMA applied to the ADL\n//@returns (float) The ADOSC value for the current bar (difference between short and long EMAs of ADL)\nadosc(simple int shortPeriod, simple int longPeriod) =>\n    float EPSILON = 1e-10\n    if shortPeriod <= 0 or longPeriod <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    short_alpha = 2.0 / (shortPeriod + 1)\n    long_alpha = 2.0 / (longPeriod + 1)\n    one_minus_long_alpha = 1.0 - long_alpha\n    float rng = high - low\n    float mf = rng != 0.0 ? ((2 * close - high - low) / rng) * volume : 0.0\n    var float cum = 0.0\n    var float e = 1.0\n    cum := bar_index == 0 ? mf : cum + mf\n    var float short_raw_ema = 0.0\n    short_raw_ema := short_alpha * (cum - short_raw_ema) + short_raw_ema\n    float short_ema = e > EPSILON ? short_raw_ema / (1.0 - e) : short_raw_ema\n    var float long_raw_ema = 0.0\n    long_raw_ema := long_alpha * (cum - long_raw_ema) + long_raw_ema\n    float long_ema = e > EPSILON ? long_raw_ema / (1.0 - e) : long_raw_ema\n    e := one_minus_long_alpha * e\n    short_ema - long_ema\n\n// ---------- Inputs ----------\nshortPeriod = input.int(3, \"Short Period\", minval=1)\nlongPeriod = input.int(10, \"Long Period\", minval=1)\n\n// ---------- Calculations ----------\nosc = adosc(shortPeriod, longPeriod)\n\n// ---------- Plotting ----------\nplot(osc, \"ADOSC\", color.new(color.yellow, 0, color=color.yellow, linewidth=2), linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "color.new",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "chaikin a/d oscillator (adosc)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "color.new",
      "color.yellow",
      "plot",
      "github.com",
      "adosc.md",
      "runtime.error",
      "input.int",
      "color.new",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-255",
    "type": "example",
    "category": "volume",
    "title": "AOBV - Archer On-Balance Volume (AOBV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"AOBV - Archer On-Balance Volume (AOBV)\", \"AOBV\", overlay=false)\n\n//@function Computes AOBV Fast and Slow from OBV using custom EMA calculations without helper functions.\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/aobv.md\n//@param src (series float) Price source.\n//@param vol (series float) Volume data.\n//@returns ([float, float]) Tuple with AOBV Fast and AOBV Slow values.\n//@optimized Beta precomputation for EMA warmup compensation\naobv(src, vol) =>\n    var float prev_src = na\n    safe_src = not na(src) ? src : (not na(prev_src) ? prev_src : 0)\n    safe_vol = not na(vol) ? vol : 0\n    safe_prev = not na(prev_src) ? prev_src : safe_src\n    var float obv_val = 0.0\n    obv_val := bar_index == 0 ? (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0) : obv_val + (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0)\n    if not na(src)\n        prev_src := src\n    periods = array.from(4, 14)\n    var emaArr = array.new_float(2, na)\n    var eArr = array.new_float(2, 1.0)\n    var warmupArr = array.new_bool(2, true)\n    var betaArr = array.new_float(2, 0.0)\n    resArr = array.new_float(2, na)\n    for i = 0 to array.size(periods) - 1\n        period = array.get(periods, i)\n        alpha = 2.0 / math.max(period, 1)\n        beta = array.get(betaArr, i)\n        if beta == 0.0\n            beta := 1.0 - alpha\n            array.set(betaArr, i, beta)\n        ema_val = array.get(emaArr, i)\n        if na(ema_val)\n            ema_val := 0.0\n            array.set(emaArr, i, ema_val)\n            array.set(resArr, i, obv_val)\n        else\n            ema_val := alpha * (obv_val - ema_val) + ema_val\n            array.set(emaArr, i, ema_val)\n            if array.get(warmupArr, i)\n                new_e = array.get(eArr, i) * beta\n                array.set(eArr, i, new_e)\n                c = 1.0 / (1.0 - new_e)\n                array.set(resArr, i, c * ema_val)\n                if new_e <= 1e-10\n                    array.set(warmupArr, i, false)\n            else\n                array.set(resArr, i, ema_val)\n    [array.get(resArr, 0), array.get(resArr, 1)]\n\n// ---------- Inputs ----------\nsrc = input(close, \"Source\")\nvol = input(volume, \"Volume\")\n\n// ---------- Calculations ----------\n[aobvFast, aobvSlow] = aobv(src, vol)\n\n// ---------- Plotting ----------\nplot(aobvFast, \"AOBV Fast\", color.blue, linewidth=2)\nplot(aobvSlow, \"AOBV Slow\", color.red, linewidth=2)\n",
    "functions_used": [
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "color.blue",
      "color.red",
      "plot"
    ],
    "keywords": [
      "aobv - archer on-balance volume (aobv)",
      "volume",
      "indicator",
      "v6",
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "color.blue",
      "color.red",
      "plot",
      "github.com",
      "aobv.md",
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "color.blue",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-256",
    "type": "example",
    "category": "volume",
    "title": "Chaikin Money Flow (CMF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Chaikin Money Flow (CMF)\", \"CMF\", overlay=false)\n\n//@function Calculates the Chaikin Money Flow (CMF), measuring buying and selling pressure through price and volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/cmf.md\n//@param len Lookback period length (default: 20)\n//@param src_high The high price (default: built-in high)\n//@param src_low The low price (default: built-in low)\n//@param src_close The close price (default: built-in close)\n//@param src_vol The volume (default: built-in volume)\n//@returns float CMF value between -1 and 1\ncmf(len = 20, src_high = high, src_low = low, src_close = close, src_vol = volume) =>\n    // Validate parameters\n    if len < 1\n        runtime.error(\"Length must be >= 1\")\n\n    // Calculate Money Flow Multiplier\n    float mfm = 0.0\n    if not na(src_high) and not na(src_low) and not na(src_close)\n        mfm := (src_close - src_low) - (src_high - src_close)\n        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0\n\n    // Calculate Money Flow Volume\n    float mfv = na(src_vol) ? 0.0 : mfm * src_vol\n\n    // Calculate CMF\n    var float sum_mfv = 0.0\n    var float sum_vol = 0.0\n\n    // Update rolling sums\n    sum_mfv := sum_mfv + mfv - (bar_index >= len ? mfv[len] : 0)\n    sum_vol := sum_vol + src_vol - (bar_index >= len ? src_vol[len] : 0)\n\n    // Calculate CMF value\n    float cmf_value = sum_vol != 0 ? sum_mfv / sum_vol : 0.0\n    cmf_value\n\n// ---------- Inputs ----------\ni_length = input.int(20, \"Length\", minval=1)\n\n// ---------- Calculations ----------\ncmf_val = cmf(i_length)\n\n// ---------- Plotting ----------\nplot(cmf_val, \"CMF\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "chaikin money flow (cmf)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "cmf.md",
      "runtime.error",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "if"
    ]
  },
  {
    "id": "script-257",
    "type": "example",
    "category": "volume",
    "title": "Elder",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Elder's Force Index (EFI)\", \"EFI\", overlay=false)\n\n//@function Calculates Elder's Force Index (EFI), measuring buying and selling pressure through price change and volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/efi.md\n//@param len Lookback period for EMA smoothing (default: 13)\n//@param src Source price for calculation (default: built-in close)\n//@param src_vol The volume (default: built-in volume)\n//@returns float The smoothed Force Index value\nefi(len = 13, src = close, src_vol = volume) =>\n    if len < 1\n        runtime.error(\"Length must be >= 1\")\n    var float prev_src = src\n    float raw_force = (nz(src) - nz(prev_src)) * nz(src_vol)\n    prev_src := src\n    float a = 2.0 / (len + 1.0)\n    float beta = 1.0 - a\n    var float ema = na\n    var float result = na\n    var float e = 1.0\n    var bool warmup = true\n    if na(ema)\n        ema := 0\n        result := raw_force\n    else\n        ema := a * (raw_force - ema) + ema\n        if warmup\n            e *= beta\n            float c = 1.0 / (1.0 - e)\n            result := c * ema\n            if e <= 1e-10\n                warmup := false\n        else\n            result := ema\n    result\n\n\n// ---------- Inputs ----------\ni_length = input.int(13, \"Length\", minval=1)\n\n// ---------- Calculations ----------\nefi_val = efi(i_length)\n\n// ---------- Plotting ----------\nplot(efi_val, \"EFI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "elder",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "efi.md",
      "runtime.error",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-258",
    "type": "example",
    "category": "volume",
    "title": "Ease of Movement (EOM)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Ease of Movement (EOM)\", \"EOM\", overlay=false)\n\n//@function Calculate Ease of Movement Volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/eom.md\n//@param i_length integer Length for box ratio calculation\n//@param i_smoothing integer Smoothing length for EOM\n//@returns float Ease of Movement value\n//@optimized for performance and dirty data\neom(i_smoothing, i_vol_scale, i_high=high, i_low=low, i_volume=volume) =>\n    if i_smoothing < 1 or i_vol_scale <= 0\n        runtime.error(\"Smoothing or Volume scale out or range\")\n    var float oldMidPoint = na\n    midPoint = (i_high + i_low) * 0.5\n    midPointChange = midPoint - nz(oldMidPoint, midPoint)\n    oldMidPoint := midPoint\n    priceRange = i_high - i_low\n    boxRatio = priceRange > 0 and i_volume > 0 ? (i_volume / i_vol_scale) / priceRange : na\n    rawEom = not na(boxRatio) and boxRatio != 0 ? midPointChange / boxRatio : 0.0\n    var array<float> buffer = array.new_float(i_smoothing, 0.0)\n    var int head = 0\n    var float sum = 0.0\n    float oldest = array.get(buffer, head)\n    if bar_index >= i_smoothing\n        sum -= oldest\n    currentValue = nz(rawEom)\n    sum += currentValue\n    array.set(buffer, head, currentValue)\n    head := (head + 1) % i_smoothing\n    average = bar_index < i_smoothing ? sum / (bar_index + 1) : sum / i_smoothing\n    average\n\n\n// ---------- Main loop ----------\n\n// Inputs\ni_length = input.int(14, \"Period\", minval=1)\ni_smoothing = input.int(14, \"Smoothing\", minval=1)\n\n// Calculation\neomValue = eom(i_length, i_smoothing)\n\n// Plot\nplot(eomValue, \"EOM\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "ease of movement (eom)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "eom.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "for",
      "if"
    ]
  },
  {
    "id": "script-259",
    "type": "example",
    "category": "volume",
    "title": "Intraday Intensity Index (III)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Intraday Intensity Index (III)\", \"III\", overlay=false)\n\n//@function Calculates Intraday Intensity Index\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/iii.md\n//@param period Smoothing period for the intensity index\n//@param cumulative Whether to accumulate intensity values\n//@param h High price series\n//@param l Low price series\n//@param c Close price series\n//@param vol Volume series\n//@returns Smoothed or raw intensity value\niii(simple int period, simple bool cumulative=false, series float h=high, series float l=low, series float c=close, series float vol=volume) =>\n    high_val = nz(h, close)\n    low_val = nz(l, close)\n    close_val = nz(c, close)\n    volume_val = math.max(nz(vol, 0.0), 1.0)\n    range_val = high_val - low_val\n    position_multiplier = range_val > 0 ? (2 * close_val - high_val - low_val) / range_val : 0.0\n    raw_iii = position_multiplier * volume_val\n    var buffer = array.new_float(period, na)\n    var head = 0, var sum = 0.0, var valid_count = 0, var cumulative_value = 0.0\n    oldest = array.get(buffer, head)\n    sum := not na(oldest) ? sum - oldest : sum\n    valid_count := not na(oldest) ? valid_count - 1 : valid_count\n    sum := not na(raw_iii) ? sum + raw_iii : sum\n    valid_count := not na(raw_iii) ? valid_count + 1 : valid_count\n    array.set(buffer, head, raw_iii)\n    head := (head + 1) % period\n    smoothed_iii = sum / period\n    cumulative_value := cumulative_value + raw_iii\n    cumulative ? cumulative_value : smoothed_iii\n\n\n// ---------- Main Calculation ----------\n\n// Parameters\nperiod = input.int(14, \"Period\", minval=1, maxval=100, tooltip=\"Smoothing period for the intensity index\")\ncumulative = input.bool(false, \"Cumulative Mode\", tooltip=\"Accumulate intensity values for trend analysis\")\n\n// Calculation\niii_value = iii(period, cumulative)\n\n// ---------- Plots ----------\n\nplot(iii_value, \"III\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "intraday intensity index (iii)",
      "volume",
      "indicator",
      "v6",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.bool",
      "color.yellow",
      "plot",
      "github.com",
      "iii.md",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.bool",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for"
    ]
  },
  {
    "id": "script-260",
    "type": "example",
    "category": "volume",
    "title": "Klinger Volume Oscillator (KVO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Klinger Volume Oscillator (KVO)\", \"KVO\", overlay=false)\n\n//@function Calculates Klinger Volume Oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/kvo.md\n//@param fast_len Fast EMA period\n//@param slow_len Slow EMA period\n//@param signal_len Signal line period\n//@param src_open Open price series\n//@param src_high High price series\n//@param src_low Low price series\n//@param src_close Close price series\n//@param src_vol Volume series\n//@returns [KVO line, Signal line]\n//@optimized for performance and dirty data\nkvo(int fast_len = 34, int slow_len = 55, int signal_len = 13, series float src_open = open, series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>\n    float hlc3 = (src_high + src_low + src_close) / 3.0\n    float hlc3_prev = nz(hlc3[1], hlc3)\n    var float trend = 1.0\n    trend := hlc3 > hlc3_prev ? 1.0 : hlc3 < hlc3_prev ? -1.0 : trend\n    float high_low_range = src_high - src_low\n    float cm = high_low_range > 0 ? math.abs(2 * ((high_low_range - (src_close - src_low)) / high_low_range) - 1) : 0.0\n    float dm = trend * nz(src_vol, 0.0) * cm\n    float alpha_f = 2.0 / (fast_len + 1), float alpha_s = 2.0 / (slow_len + 1), float alpha_sig = 2.0 / (signal_len + 1)\n    var bool warmup = true, var float e_f = 1.0, var float e_s = 1.0, var float e_sig = 1.0\n    var float ema_val_f = 0.0, var float ema_val_s = 0.0, var float ema_val_sig = 0.0\n    var float fast_ema = dm, var float slow_ema = dm\n    ema_val_f := alpha_f * (dm - ema_val_f) + ema_val_f\n    ema_val_s := alpha_s * (dm - ema_val_s) + ema_val_s\n    if warmup\n        e_f *= (1.0 - alpha_f), e_s *= (1.0 - alpha_s)\n        float c_f = 1.0 / (1.0 - e_f), float c_s = 1.0 / (1.0 - e_s)\n        fast_ema := c_f * ema_val_f, slow_ema := c_s * ema_val_s\n        warmup := e_sig > 1e-10\n    else\n        fast_ema := ema_val_f, slow_ema := ema_val_s\n    float kvo_line = fast_ema - slow_ema\n    var float signal_line = kvo_line\n    ema_val_sig := alpha_sig * (kvo_line - ema_val_sig) + ema_val_sig\n    if warmup\n        e_sig *= (1.0 - alpha_sig)\n        float c_sig = 1.0 / (1.0 - e_sig)\n        signal_line := c_sig * ema_val_sig\n    else\n        signal_line := ema_val_sig\n    [kvo_line, signal_line]\n\n// ---------- Main Calculation ----------\n\n// Parameters\nfast_period = input.int(34, \"Fast EMA Period\", minval=1)\nslow_period = input.int(55, \"Slow EMA Period\", minval=1)\nsignal_period = input.int(13, \"Signal Line Period\", minval=1)\n\n// Calculation\n[kvo_line, signal_line] = kvo(fast_period, slow_period, signal_period)\n\n// ---------- Plots ----------\n\nplot(kvo_line, \"KVO\", color.yellow, 2)\nplot(signal_line, \"Signal\", color.blue, 1)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n\nhistogram = kvo_line - signal_line\nplot(histogram, \"Histogram\", style=plot.style_histogram, \n     color=histogram >= 0 ? color.green : color.red)\n",
    "functions_used": [
      "math.abs",
      "input.int",
      "color.yellow",
      "color.blue",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline"
    ],
    "keywords": [
      "klinger volume oscillator (kvo)",
      "volume",
      "indicator",
      "v6",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.blue",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "github.com",
      "kvo.md",
      "math.abs",
      "input.int",
      "color.yellow",
      "color.blue",
      "color.gray",
      "hline.style_dashed",
      "plot.style_histogram",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-261",
    "type": "example",
    "category": "volume",
    "title": "Money Flow Index (MFI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Money Flow Index (MFI)\", \"MFI\", overlay=false)\n\n//@function Calculates Money Flow Index, a volume-weighted RSI that measures buying/selling pressure\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/mfi.md\n//@param len Period for MFI calculation\n//@param src_high High price series\n//@param src_low Low price series\n//@param src_close Close price series\n//@param src_vol Volume series\n//@returns float The MFI value (0-100)\n//@optimized Uses circular buffers for O(1) performance with proper NA handling\nmfi(simple int len, series float src_high=high, series float src_low=low, series float src_close=close, series float src_vol=volume) =>\n    if len < 1\n        runtime.error(\"Invalid parameter: len must be >= 1\")\n    float typical_price = (src_high + src_low + src_close) / 3.0\n    float raw_money_flow = typical_price * nz(src_vol, 0.0)\n    float prev_typical_price = nz(typical_price[1], typical_price)\n    bool is_positive = typical_price > prev_typical_price\n    bool is_negative = typical_price < prev_typical_price\n    float positive_money_flow = is_positive ? raw_money_flow : 0.0\n    float negative_money_flow = is_negative ? raw_money_flow : 0.0\n    var array<float> pos_buffer = array.new_float(len, na)\n    var array<float> neg_buffer = array.new_float(len, na)\n    var int head = 0\n    var float sum_positive_mf = 0.0\n    var float sum_negative_mf = 0.0\n    var int count = 0\n    float pos_oldest = array.get(pos_buffer, head)\n    float neg_oldest = array.get(neg_buffer, head)\n    if not na(pos_oldest)\n        sum_positive_mf -= pos_oldest\n        sum_negative_mf -= neg_oldest\n    else\n        count += 1\n    sum_positive_mf += positive_money_flow\n    sum_negative_mf += negative_money_flow\n    array.set(pos_buffer, head, positive_money_flow)\n    array.set(neg_buffer, head, negative_money_flow)\n    head := (head + 1) % len\n    float money_flow_ratio = sum_negative_mf != 0 ? sum_positive_mf / sum_negative_mf : 0.0\n    float mfi_value = 100.0 - (100.0 / (1.0 + money_flow_ratio))\n    mfi_value\n\n// ---------- Main Calculation ----------\n\n// Parameters\nlen = input.int(14, \"MFI Period\", minval=1, maxval=100)\n\n// Calculation\nmfi_line = mfi(len)\n\n// ---------- Plots ----------\n\nplot(mfi_line, \"MFI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "money flow index (mfi)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "mfi.md",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-262",
    "type": "example",
    "category": "volume",
    "title": "Negative Volume Index (NVI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Negative Volume Index (NVI)\", \"NVI\", overlay=false)\n\n//@function Calculates Negative Volume Index, tracks price changes on days with lower volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/nvi.md\n//@param src Price series to use for calculation\n//@param vol Volume series\n//@param start_value Starting value for NVI (typically 100 or 1000)\n//@returns float The NVI value\nnvi(series float src, series float vol = volume, simple float start_value = 100.0) =>\n    var float nvi_value = start_value\n    if not (na(src) or na(vol) or na(src[1]) or na(vol[1]) or src[1] == 0.0 or vol[1] <= 0.0) and vol < vol[1]\n        nvi_value := nvi_value * src / src[1]\n    nvi_value\n\n// ---------- Main Calculation ----------\n\n// Parameters\nsrc = input.source(close, \"Price Source\")\n\n// Calculations\nnvi_line = nvi(src, volume)\n\n// Plot\nplot(nvi_line, \"NVI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "negative volume index (nvi)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "nvi.md",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-263",
    "type": "example",
    "category": "volume",
    "title": "On Balance Volume (OBV)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"On Balance Volume (OBV)\", \"OBV\", overlay=false)\n\n//@function Calculates On Balance Volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/obv.md\n//@param c Close price series\n//@param vol Volume series\n//@returns Cumulative On Balance Volume value\n//@optimized for performance and dirty data\nobv(series float c = close, series float vol = volume) =>\n    float close_price = nz(c, close)\n    float volume_val = nz(vol, 0.0)\n    float prev_close = nz(close_price[1], close_price)\n    var float obv_cumulative = 0.0\n    obv_cumulative += close_price > prev_close ? volume_val : close_price < prev_close ? -volume_val : 0.0\n    obv_cumulative\n\n// ---------- Main loop ----------\n\n// Calculation\nobv_value = obv(close, volume)\n\n// Plot\nplot(obv_value, \"OBV\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "on balance volume (obv)",
      "volume",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "obv.md",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "for"
    ]
  },
  {
    "id": "script-264",
    "type": "example",
    "category": "volume",
    "title": "Price Volume Divergence (PVD)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Price Volume Divergence (PVD)\", \"PVD\", overlay=false)\n\n//@function Calculates Price Volume Divergence\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/pvd.md\n//@param price_period Lookback period for price momentum\n//@param volume_period Lookback period for volume momentum\n//@param smoothing_period Period for smoothing divergence signals\n//@param c Close price series\n//@param vol Volume series\n//@returns Smoothed divergence value\n//@optimized for performance and dirty data\npvd(simple int price_period, simple int volume_period, simple int smoothing_period, series float c=close, series float vol=volume ) =>\n    if smoothing_period <= 0\n        runtime.error(\"Smoothing period must be greater than 0\")\n    float close_price = nz(c, close)\n    float volume_val = math.max(nz(vol, 0.0), 1.0)\n    float prev_close = bar_index < price_period ? close_price[math.max(bar_index, 1)] : close_price[price_period]\n    float prev_volume = bar_index < volume_period ? volume_val[math.max(bar_index, 1)] : volume_val[volume_period]\n    float price_roc = prev_close > 0 ? (close_price - prev_close) / prev_close * 100 : 0.0\n    float volume_roc = prev_volume > 0 ? (volume_val - prev_volume) / prev_volume * 100 : 0.0\n    int price_momentum = price_roc > 0 ? 1 : price_roc < 0 ? -1 : 0\n    int volume_momentum = volume_roc > 0 ? 1 : volume_roc < 0 ? -1 : 0\n    float magnitude = math.abs(price_roc) + math.abs(volume_roc)\n    float divergence_raw = price_momentum * -volume_momentum * magnitude\n    var int p = smoothing_period\n    var array<float> buffer = array.new_float(p, na)\n    var int head = 0, var float sum = 0.0, var int valid_count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n        valid_count -= 1\n    if not na(divergence_raw)\n        sum += divergence_raw\n        valid_count += 1\n    array.set(buffer, head, divergence_raw)\n    head := (head + 1) % p\n    valid_count > 0 ? sum / valid_count : divergence_raw\n\n// ---------- Inputs ----------\n\nprice_period = input.int(14, \"Price Period\", minval=1, maxval=100)\nvolume_period = input.int(14, \"Volume Period\", minval=1, maxval=100)\ndivergence_threshold = input.float(50.0, \"Divergence Threshold\", minval=0)\nsmoothing_period = input.int(3, \"Smoothing Period\", minval=1, maxval=20)\n\n// ---------- Main loop ----------\n\n// Calculation\npvd_value = pvd(price_period, volume_period, smoothing_period)\n\n// Plot main line\nplot(pvd_value, \"PVD\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "price volume divergence (pvd)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "pvd.md",
      "runtime.error",
      "math.max",
      "math.abs",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-265",
    "type": "example",
    "category": "volume",
    "title": "Positive Volume Index (PVI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Positive Volume Index (PVI)\", \"PVI\", overlay=false)\n\n//@function Calculates Positive Volume Index, tracks price changes on days with higher volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/pvi.md\n//@param src Price series to use for calculation\n//@param vol Volume series\n//@param start_value Starting value for PVI (typically 100 or 1000)\n//@returns float The PVI value\npvi(series float src, series float vol = volume, simple float start_value = 100.0) =>\n    var float pvi_value = start_value\n    if not (na(src) or na(vol) or na(src[1]) or na(vol[1]) or src[1] == 0.0 or vol[1] <= 0.0) and vol > vol[1]\n        pvi_value := pvi_value * src / src[1]\n    pvi_value\n\n// ---------- Main Calculation ----------\n\n// Parameters\nsrc = input.source(close, \"Price Source\")\n\n// Calculations\npvi_line = pvi(src, volume)\n\n// Plot\nplot(pvi_line, \"PVI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "positive volume index (pvi)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "pvi.md",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-266",
    "type": "example",
    "category": "volume",
    "title": "Percentage Volume Oscillator (PVO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Percentage Volume Oscillator (PVO)\", \"PVO\", overlay=false)\n\n//@function Calculates Percentage Volume Oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/pvo.md\n//@param vol Volume series\n//@param fast_period Fast period for volume MA\n//@param slow_period Slow period for volume MA\n//@param signal_period Signal line smoothing period\n//@returns tuple with [pvo, signal, histogram] values\n//@optimized Beta precomputation for EMA warmup compensation\npvo(series float vol, simple int fast_period, simple int slow_period, simple int signal_period) =>\n    if fast_period <= 0 or slow_period <= 0 or signal_period <= 0\n        runtime.error(\"All periods must be greater than 0\")\n    if fast_period >= slow_period\n        runtime.error(\"Fast period must be less than slow period\")\n    float vol_val = nz(vol, 0.0)\n    float fast_alpha = 2.0 / (fast_period + 1)\n    float slow_alpha = 2.0 / (slow_period + 1)\n    float signal_alpha = 2.0 / (signal_period + 1)\n    float fast_beta = 1.0 - fast_alpha\n    float slow_beta = 1.0 - slow_alpha\n    float signal_beta = 1.0 - signal_alpha\n    float slowest_beta = math.max(fast_beta, slow_beta, signal_beta)\n    var bool warmup = true\n    var float e_fast = 1.0\n    var float e_slow = 1.0\n    var float e_signal = 1.0\n    var float e_slowest = 1.0\n    var float fast_ema = 0.0\n    var float slow_ema = 0.0\n    var float signal_ema = 0.0\n    fast_ema := fast_alpha * (vol_val - fast_ema) + fast_ema\n    slow_ema := slow_alpha * (vol_val - slow_ema) + slow_ema\n    if warmup\n        e_fast *= fast_beta\n        e_slow *= slow_beta\n        e_signal *= signal_beta\n        e_slowest *= slowest_beta\n        warmup := e_slowest > 1e-10\n    float c_fast = warmup ? 1.0 / (1.0 - e_fast) : 1.0\n    float c_slow = warmup ? 1.0 / (1.0 - e_slow) : 1.0\n    float c_signal = warmup ? 1.0 / (1.0 - e_signal) : 1.0\n    float fast_comp = c_fast * fast_ema\n    float slow_comp = c_slow * slow_ema\n    float pvo_val = slow_comp != 0.0 ? ((fast_comp - slow_comp) / slow_comp) * 100.0 : 0.0\n    signal_ema := signal_alpha * (pvo_val - signal_ema) + signal_ema\n    float signal_val = c_signal * signal_ema\n    float histogram_val = pvo_val - signal_val\n    [pvo_val, signal_val, histogram_val]\n\n// ---------- Main loop ----------\n\n// Inputs\ni_fast_period = input.int(12, \"Fast Period\", minval=1)\ni_slow_period = input.int(26, \"Slow Period\", minval=1)\ni_signal_period = input.int(9, \"Signal Period\", minval=1)\n\n// Calculation\n[pvo_value, signal_value, histogram_value] = pvo(volume, i_fast_period, i_slow_period, i_signal_period)\n\n// Plot\nplot(pvo_value, \"PVO\", color=color.yellow, linewidth=2)\nplot(signal_value, \"Signal\", color=color.red, linewidth=2)\nplot(histogram_value, \"Histogram\", color=color.blue, linewidth=2, style=plot.style_histogram)\nhline(0, \"Zero Line\", color.gray)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "input.int",
      "color.yellow",
      "color.red",
      "color.blue",
      "color.gray",
      "plot",
      "hline"
    ],
    "keywords": [
      "percentage volume oscillator (pvo)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "input.int",
      "color.yellow",
      "color.red",
      "color.blue",
      "color.gray",
      "plot",
      "hline",
      "github.com",
      "pvo.md",
      "runtime.error",
      "math.max",
      "input.int",
      "color.yellow",
      "color.red",
      "color.blue",
      "plot.style_histogram",
      "color.gray",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-267",
    "type": "example",
    "category": "volume",
    "title": "Price Volume Rank (PVR)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Price Volume Rank (PVR)\", \"PVR\", overlay=false)\n\n//@function Calculates Price Volume Rank\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/pvr.md\n//@param price Price series for comparison\n//@param vol Volume series for comparison\n//@returns Price Volume Rank (0-4)\n//@optimized for performance and dirty data\npvr(series float price, series float vol=volume) =>\n    float p = nz(price, close), float v = nz(vol, 0.0)\n    float pp = nz(p[1], p), float pv = nz(v[1], v)\n    p > pp ? (v > pv ? 1 : 2) : p < pp ? (v < pv ? 3 : 4) : 0\n\n// ---------- Main loop ----------\n\n// Inputs\ni_price_source = input.source(close, \"Price Source\")\n\n// Calculation\npvr_value = pvr(i_price_source)\n\n// Plot\nplot(pvr_value, \"PVR\", color=color.yellow, linewidth=2, plot.style_stepline)\n",
    "functions_used": [
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "price volume rank (pvr)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "pvr.md",
      "input.source",
      "color.yellow",
      "plot.style_stepline",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "for"
    ]
  },
  {
    "id": "script-268",
    "type": "example",
    "category": "volume",
    "title": "Price Volume Trend (PVT)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Price Volume Trend (PVT)\", \"PVT\", overlay=false)\n\n//@function Calculates Price Volume Trend, cumulative volume adjusted by relative price changes\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/pvt.md\n//@param src Source price for calculation (typically close)\n//@param src_vol Volume data\n//@returns float The cumulative PVT value\npvt(series float src, series float src_vol) =>\n    float price_change = src - nz(src[1], src)\n    float price_prev = nz(src[1], src)\n    float price_change_ratio = price_prev != 0 ? price_change / price_prev : 0.0\n    float volume_adjustment = nz(src_vol, 0.0) * price_change_ratio\n    var float cumulative_pvt = 0.0\n    cumulative_pvt += volume_adjustment\n    cumulative_pvt\n\n// ---------- Main Calculation ----------\n\n// Parameters - PVT typically doesn't need input parameters as it's cumulative\n\n// Calculation\npvt_line = pvt(close, volume)\n\n// ---------- Plots ----------\n\nplot(pvt_line, \"PVT\", color.yellow, 2)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n\n// Signal line (optional smoothed version)\nsignal_length = input.int(14, \"Signal Line Period\", minval=1)\npvt_signal = ta.sma(pvt_line, signal_length)\nplot(pvt_signal, \"PVT Signal\", color.red, 1)\n\n// Background coloring for trend indication\nbgcolor(pvt_line > pvt_signal ? color.green : color.red)\n",
    "functions_used": [
      "color.yellow",
      "color.gray",
      "input.int",
      "ta.sma",
      "color.red",
      "color.green",
      "plot",
      "hline",
      "bgcolor"
    ],
    "keywords": [
      "price volume trend (pvt)",
      "volume",
      "indicator",
      "v6",
      "color.yellow",
      "color.gray",
      "input.int",
      "ta.sma",
      "color.red",
      "color.green",
      "plot",
      "hline",
      "bgcolor",
      "github.com",
      "pvt.md",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "input.int",
      "ta.sma",
      "color.red",
      "color.green",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "bgcolor",
      "var",
      "series",
      "for"
    ]
  },
  {
    "id": "script-269",
    "type": "example",
    "category": "volume",
    "title": "Trade Volume Index (TVI)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Trade Volume Index (TVI)\", \"TVI\", overlay=false)\n\n//@function Calculates Trade Volume Index\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/tvi.md\n//@param price Price series for tick direction analysis\n//@param vol Volume series for weighting\n//@param min_tick Minimum price movement to register direction change\n//@returns Trade Volume Index value\n//@optimized for performance and dirty data\ntvi(series float price, simple float min_tick, series float vol=volume) =>\n    float p = nz(price, close), float v = nz(vol, 0.0)\n    float pp = nz(p[1], p)\n    float price_change = p - pp\n    var int direction = 1\n    var float tvi_sum = 0.0\n    direction := price_change > min_tick ? 1 : price_change < -min_tick ? 0 : direction\n    tvi_sum += direction == 1 ? v : -v\n    tvi_sum\n\n// ---------- Main loop ----------\n\n// Inputs\ni_price_source = input.source(close, \"Price Field\", tooltip=\"Open, High, Low or Closing price\")\ni_min_tick = input.float(0.125, \"Min. Move\", minval=0.0001, tooltip=\"Minimum price change to register direction\")\n\n// Calculation\ntvi_value = tvi(i_price_source, i_min_tick)\n\n// Plot\nplot(tvi_value, \"TVI\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "input.float",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "trade volume index (tvi)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "input.float",
      "color.yellow",
      "plot",
      "github.com",
      "tvi.md",
      "input.source",
      "input.float",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for"
    ]
  },
  {
    "id": "script-270",
    "type": "example",
    "category": "volume",
    "title": "Time Weighted Average Price (TWAP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Time Weighted Average Price (TWAP)\", \"TWAP\", overlay=true)\n\n//@function Calculates session-based TWAP (Time Weighted Average Price)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/twap.md\n//@param src Source price series (typically ohlc4 or hlc3)\n//@param reset_condition Condition to reset TWAP calculation\n//@returns TWAP value representing simple average price from session start\n//@optimized for performance and dirty data\ntwap(series float src, series bool reset_condition) =>\n    var float sum_prices = 0.0\n    var int count = 0\n    float current_price = nz(src)\n    if reset_condition\n        sum_prices := 0.0\n        count := 0\n    sum_prices += current_price\n    count += 1\n    count > 0 ? sum_prices / count : src\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(ohlc4, \"Source\")\ni_session_type = input.string(\"1D\", \"Session Reset\", options=[\"1m\", \"2m\", \"3m\", \"5m\", \"10m\", \"15m\", \"30m\", \"45m\", \"1H\", \"2H\", \"3H\", \"4H\", \"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"12M\", \"Never\"])\n\n// Calculate reset condition\nreset_condition = switch i_session_type\n    \"1m\" => ta.change(time(\"1\")) != 0\n    \"2m\" => ta.change(time(\"2\")) != 0\n    \"3m\" => ta.change(time(\"3\")) != 0\n    \"5m\" => ta.change(time(\"5\")) != 0\n    \"10m\" => ta.change(time(\"10\")) != 0\n    \"15m\" => ta.change(time(\"15\")) != 0\n    \"30m\" => ta.change(time(\"30\")) != 0\n    \"45m\" => ta.change(time(\"45\")) != 0\n    \"1H\" => ta.change(time(\"60\")) != 0\n    \"2H\" => ta.change(time(\"120\")) != 0\n    \"3H\" => ta.change(time(\"180\")) != 0\n    \"4H\" => ta.change(time(\"240\")) != 0\n    \"1D\" => ta.change(time(\"1D\")) != 0\n    \"1W\" => ta.change(time(\"1W\")) != 0\n    \"1M\" => ta.change(time(\"1M\")) != 0\n    \"3M\" => ta.change(time(\"3M\")) != 0\n    \"6M\" => ta.change(time(\"6M\")) != 0\n    \"12M\" => ta.change(time(\"12M\")) != 0\n    \"Never\" => bar_index == 0\n    => false\n\n// Calculation\ntwap_value = twap(i_source, reset_condition)\n\n// Plot\nplot(twap_value, \"TWAP\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "time weighted average price (twap)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "plot",
      "github.com",
      "twap.md",
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "type",
      "switch",
      "for",
      "if"
    ]
  },
  {
    "id": "script-271",
    "type": "example",
    "category": "volume",
    "title": "Volume Accumulation (VA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Accumulation (VA)\", \"VA\", overlay=false)\n\n//@function Calculates Volume Accumulation\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/va.md\n//@param h High price series\n//@param l Low price series\n//@param c Close price series\n//@param vol Volume series\n//@returns Cumulative Volume Accumulation value\n//@optimized for performance and dirty data\nva(series float h=high, series float l=low, series float c=close, series float vol=volume) =>\n    float high_price = nz(h, close), float low_price = nz(l, close)\n    float close_price = nz(c, close), float volume_val = nz(vol, 0.0)\n    float midpoint = (high_price + low_price) / 2.0\n    float va_period = volume_val * (close_price - midpoint)\n    var float va_cumulative = 0.0\n    va_cumulative += va_period\n    va_cumulative\n\n// ---------- Main loop ----------\n\n// No inputs required - uses standard OHLC and volume data\n\n// Calculation\nva_value = va()\n\n// Plot\nplot(va_value, \"VA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volume accumulation (va)",
      "volume",
      "indicator",
      "v6",
      "color.yellow",
      "plot",
      "github.com",
      "va.md",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "for"
    ]
  },
  {
    "id": "script-272",
    "type": "example",
    "category": "volume",
    "title": "Volume Force (VF)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Force (VF)\", \"VF\", overlay=false)\n\n//@function Calculates Volume Force, measuring the force of volume behind price movements\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vf.md\n//@param len Smoothing period (default: 14)\n//@param src Source price for calculation (default: close)\n//@param src_vol Volume data (default: volume)\n//@returns float The Volume Force value\nvf(simple int len, series float src = close, series float src_vol = volume) =>\n    float price_change = src - nz(src[1], src)\n    float raw_vf = price_change * nz(src_vol, 0.0)\n    float alpha = 2.0 / (len + 1)\n    var bool warmup = true\n    var float e = 1.0\n    var float ema_val = 0.0\n    var float vf_result = raw_vf\n    ema_val := alpha * (raw_vf - ema_val) + ema_val\n    if warmup\n        e *= (1.0 - alpha)\n        float compensator = 1.0 / (1.0 - e)\n        vf_result := compensator * ema_val\n        warmup := e > 1e-10\n    else\n        vf_result := ema_val\n    vf_result\n\n// ---------- Main Calculation ----------\n\n// Parameters\nlength = input.int(14, \"Smoothing Period\", minval=1)\n\n// Calculation\nvf_line = vf(length, close, volume)\n\n// ---------- Plots ----------\n\nplot(vf_line, \"Volume Force\", color=color.yellow, linewidth=2)\nhline(0, \"Zero Line\", color.gray, linestyle=hline.style_dashed)\n\n// Color zones for visual clarity\nbgcolor(vf_line > 0 ? color.green : color.red)\n",
    "functions_used": [
      "input.int",
      "color.yellow",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "bgcolor"
    ],
    "keywords": [
      "volume force (vf)",
      "volume",
      "indicator",
      "v6",
      "input.int",
      "color.yellow",
      "color.gray",
      "color.green",
      "color.red",
      "plot",
      "hline",
      "bgcolor",
      "github.com",
      "vf.md",
      "input.int",
      "color.yellow",
      "color.gray",
      "hline.style_dashed",
      "color.green",
      "color.red",
      "indicator",
      "overlay",
      "input",
      "plot",
      "hline",
      "bgcolor",
      "var",
      "series",
      "simple",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-273",
    "type": "example",
    "category": "volume",
    "title": "Volume Oscillator (VO)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Oscillator (VO)\", \"VO\", overlay=false)\n\n//@function Calculates Volume Oscillator\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vo.md\n//@param short_period Period for short-term volume moving average\n//@param long_period Period for long-term volume moving average\n//@param signal_period Period for signal line moving average\n//@param vol Volume series\n//@returns Volume Oscillator value\n//@optimized for performance and dirty data\nvo(simple int short_period, simple int long_period, simple int signal_period, series float vol=volume) =>\n    if short_period >= long_period\n        runtime.error(\"Short period must be less than long period\")\n    volume_val = math.max(nz(vol, 0.0), 1.0)\n    var p_short = short_period\n    var buffer_short = array.new_float(p_short, na)\n    var head_short = 0, var sum_short = 0.0, var valid_count_short = 0\n    oldest_short = array.get(buffer_short, head_short)\n    sum_short := not na(oldest_short) ? sum_short - oldest_short : sum_short\n    valid_count_short := not na(oldest_short) ? valid_count_short - 1 : valid_count_short\n    sum_short := not na(volume_val) ? sum_short + volume_val : sum_short\n    valid_count_short := not na(volume_val) ? valid_count_short + 1 : valid_count_short\n    array.set(buffer_short, head_short, volume_val)\n    head_short := (head_short + 1) % p_short\n    short_ma = valid_count_short > 0 ? sum_short / valid_count_short : volume_val\n    var p_long = long_period\n    var buffer_long = array.new_float(p_long, na)\n    var head_long = 0, var sum_long = 0.0, var valid_count_long = 0\n    oldest_long = array.get(buffer_long, head_long)\n    sum_long := not na(oldest_long) ? sum_long - oldest_long : sum_long\n    valid_count_long := not na(oldest_long) ? valid_count_long - 1 : valid_count_long\n    sum_long := not na(volume_val) ? sum_long + volume_val : sum_long\n    valid_count_long := not na(volume_val) ? valid_count_long + 1 : valid_count_long\n    array.set(buffer_long, head_long, volume_val)\n    head_long := (head_long + 1) % p_long\n    long_ma = valid_count_long > 0 ? sum_long / valid_count_long : volume_val\n    vo_value = long_ma > 0 ? ((short_ma - long_ma) / long_ma) * 100 : 0.0\n    var p_signal = signal_period\n    var buffer_signal = array.new_float(p_signal, na)\n    var head_signal = 0, var sum_signal = 0.0, var valid_count_signal = 0\n    oldest_signal = array.get(buffer_signal, head_signal)\n    sum_signal := not na(oldest_signal) ? sum_signal - oldest_signal : sum_signal\n    valid_count_signal := not na(oldest_signal) ? valid_count_signal - 1 : valid_count_signal\n    sum_signal := not na(vo_value) ? sum_signal + vo_value : sum_signal\n    valid_count_signal := not na(vo_value) ? valid_count_signal + 1 : valid_count_signal\n    array.set(buffer_signal, head_signal, vo_value)\n    head_signal := (head_signal + 1) % p_signal\n    signal_line = valid_count_signal > 0 ? sum_signal / valid_count_signal : vo_value\n  ",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "color.blue",
      "plot"
    ],
    "keywords": [
      "volume oscillator (vo)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "color.blue",
      "plot",
      "github.com",
      "vo.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "color.blue",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-274",
    "type": "example",
    "category": "volume",
    "title": "Volume Rate of Change (VROC)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Rate of Change (VROC)\", \"VROC\", overlay=false)\n\n//@function Calculates Volume Rate of Change\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vroc.md\n//@param vol Volume series for rate of change calculation\n//@param period Number of periods for comparison\n//@param calc_type Calculation type: true for percentage, false for point change\n//@returns Volume Rate of Change value\n//@optimized for performance and dirty data\nvroc(simple int period, simple bool calc_type, series float vol = volume) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    \n    float current_volume = vol\n    float historical_volume = vol[period]\n    if na(current_volume) or na(historical_volume)\n        na\n    else if calc_type\n        historical_volume != 0.0 ? ((current_volume - historical_volume) / historical_volume) * 100.0 : na\n    else\n        current_volume - historical_volume\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(12, \"Period\", minval=1, tooltip=\"Number of periods for comparison\")\ni_calc_type = input.string(\"Point\", \"Calculation Type\", options=[\"Point\", \"Percent\"], tooltip=\"Point or Percent calculation\")\n\n// Calculation\nis_percent = i_calc_type == \"Percent\"\nvroc_value = vroc(i_period, is_percent)\n\n// Plot\nplot(vroc_value, \"VROC\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "input.int",
      "input.string",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volume rate of change (vroc)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "input.int",
      "input.string",
      "color.yellow",
      "plot",
      "github.com",
      "vroc.md",
      "runtime.error",
      "input.int",
      "input.string",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "series",
      "simple",
      "type",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-275",
    "type": "example",
    "category": "volume",
    "title": "Volume Weighted Accumulation/Distribution (VWAD)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Weighted Accumulation/Distribution (VWAD)\", \"VWAD\", overlay=false)\n\n//@function Calculates VWAD using volume weighting for enhanced sensitivity\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vwad.md\n//@param src_high High price series\n//@param src_low Low price series\n//@param src_close Close price series\n//@param src_vol Volume series\n//@param period Lookback period for volume weighting\n//@returns VWAD value representing volume-weighted accumulation/distribution\n//@optimized for performance and dirty data\nvwad(simple int period, series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0\n    var array<float> vol_buffer = array.new_float(p, na)\n    var float sum_vol = 0.0\n    float old_vol = array.get(vol_buffer, head)\n    if not na(old_vol)\n        sum_vol -= old_vol\n    float current_vol = nz(src_vol, 0.0)\n    sum_vol += current_vol\n    array.set(vol_buffer, head, current_vol)\n    head := (head + 1) % p\n    float mfm = 0.0\n    if not na(src_high) and not na(src_low) and not na(src_close)\n        mfm := (src_close - src_low) - (src_high - src_close)\n        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0\n    float vol_weight = sum_vol > 0.0 ? current_vol / sum_vol : 0.0\n    float weighted_mfv = current_vol * mfm * vol_weight\n    var float cumulative_vwad = 0.0\n    cumulative_vwad += weighted_mfv\n    cumulative_vwad\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Volume Weight Period\", minval=1)\n\n// Calculation\nvwad_value = vwad(i_period)\n\n// Plot\nplot(vwad_value, \"VWAD\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volume weighted accumulation/distribution (vwad)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "plot",
      "github.com",
      "vwad.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-276",
    "type": "example",
    "category": "volume",
    "title": "Volume Weighted Average Price (VWAP)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Weighted Average Price (VWAP)\", \"VWAP\", overlay=true)\n\n//@function Calculates session-based VWAP (Volume Weighted Average Price)\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vwap.md\n//@param src Source price series (typically hlc3)\n//@param vol Volume series\n//@param reset_condition Condition to reset VWAP calculation\n//@returns VWAP value representing cumulative volume-weighted average price from session start\n//@optimized for performance and dirty data\nvwap(series float src, series float vol, series bool reset_condition) =>\n    var float sum_pv = 0.0, var float sum_vol = 0.0\n    float current_price = nz(src), float current_vol = nz(vol, 0.0)\n    if reset_condition\n        sum_pv := current_vol > 0.0 ? current_price * current_vol : 0.0\n        sum_vol := current_vol > 0.0 ? current_vol : 0.0\n    else\n        if current_vol > 0.0\n            sum_pv += current_price * current_vol\n            sum_vol += current_vol\n    sum_vol > 0.0 ? sum_pv / sum_vol : src\n\n// ---------- Main loop ----------\n\n// Inputs\ni_source = input.source(hlc3, \"Source\")\ni_session_type = input.string(\"1D\", \"Session Reset\", options=[\"1m\", \"2m\", \"3m\", \"5m\", \"10m\", \"15m\", \"30m\", \"45m\", \"1H\", \"2H\", \"3H\", \"4H\", \"1D\", \"1W\", \"1M\", \"3M\", \"6M\", \"12M\", \"Never\"])\n\n// Calculate reset condition\nreset_condition = switch i_session_type\n    \"1m\" => ta.change(time(\"1\")) != 0\n    \"2m\" => ta.change(time(\"2\")) != 0\n    \"3m\" => ta.change(time(\"3\")) != 0\n    \"5m\" => ta.change(time(\"5\")) != 0\n    \"10m\" => ta.change(time(\"10\")) != 0\n    \"15m\" => ta.change(time(\"15\")) != 0\n    \"30m\" => ta.change(time(\"30\")) != 0\n    \"45m\" => ta.change(time(\"45\")) != 0\n    \"1H\" => ta.change(time(\"60\")) != 0\n    \"2H\" => ta.change(time(\"120\")) != 0\n    \"3H\" => ta.change(time(\"180\")) != 0\n    \"4H\" => ta.change(time(\"240\")) != 0\n    \"1D\" => ta.change(time(\"1D\")) != 0\n    \"1W\" => ta.change(time(\"1W\")) != 0\n    \"1M\" => ta.change(time(\"1M\")) != 0\n    \"3M\" => ta.change(time(\"3M\")) != 0\n    \"6M\" => ta.change(time(\"6M\")) != 0\n    \"12M\" => ta.change(time(\"12M\")) != 0\n    \"Never\" => bar_index == 0\n    => false\n\n// Calculation\nvwap_value = vwap(i_source, volume, reset_condition)\n\n// Plot\nplot(vwap_value, \"VWAP\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volume weighted average price (vwap)",
      "volume",
      "indicator",
      "v6",
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "plot",
      "github.com",
      "vwap.md",
      "input.source",
      "input.string",
      "ta.change",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "type",
      "switch",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-277",
    "type": "example",
    "category": "volume",
    "title": "Volume Weighted Moving Average (VWMA)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Volume Weighted Moving Average (VWMA)\", \"VWMA\", overlay=true)\n\n//@function Calculates VWMA using circular buffer for efficient computation\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/vwma.md\n//@param src Source price series\n//@param vol Volume series\n//@param period Lookback period for VWMA calculation\n//@returns VWMA value representing volume-weighted moving average\n//@optimized for performance and dirty data\nvwma(series float src, series float vol, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var int p = math.max(1, period), var int head = 0, var int count = 0\n    var array<float> price_buffer = array.new_float(p, na)\n    var array<float> vol_buffer = array.new_float(p, na)\n    var float sum_pv = 0.0, var float sum_vol = 0.0\n    float old_price = array.get(price_buffer, head), float old_vol = array.get(vol_buffer, head)\n    if not na(old_price) and not na(old_vol)\n        sum_pv -= old_price * old_vol\n        sum_vol -= old_vol\n        count -= 1\n    float current_price = nz(src), float current_vol = nz(vol, 0.0)\n    if current_vol > 0.0\n        sum_pv += current_price * current_vol\n        sum_vol += current_vol\n        count += 1\n    array.set(price_buffer, head, current_price)\n    array.set(vol_buffer, head, current_vol)\n    head := (head + 1) % p\n    sum_vol > 0.0 ? sum_pv / sum_vol : src\n\n// ---------- Main loop ----------\n\n// Inputs\ni_period = input.int(20, \"Period\", minval=1)\ni_source = input.source(close, \"Source\")\n\n// Calculation\nvwma_value = vwma(i_source, volume, i_period)\n\n// Plot\nplot(vwma_value, \"VWMA\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "volume weighted moving average (vwma)",
      "volume",
      "indicator",
      "v6",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "plot",
      "github.com",
      "vwma.md",
      "runtime.error",
      "math.max",
      "array.new_float",
      "array.get",
      "array.set",
      "input.int",
      "input.source",
      "color.yellow",
      "indicator",
      "overlay",
      "input",
      "plot",
      "var",
      "series",
      "simple",
      "for",
      "if"
    ]
  },
  {
    "id": "script-278",
    "type": "example",
    "category": "volume",
    "title": "Williams Accumulation/Distribution (WAD)",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\nindicator(\"Williams Accumulation/Distribution (WAD)\", \"WAD\", overlay=false)\n\n//@function Calculates Williams A/D using price relationships and volume\n//@doc https://github.com/mihakralj/pinescript/blob/main/indicators/volume/wad.md\n//@param src_high High price series\n//@param src_low Low price series\n//@param src_close Close price series\n//@param src_open Open price series (if available)\n//@param src_vol Volume series\n//@returns WAD value representing Williams accumulation/distribution\n//@optimized for performance and dirty data\nwad( series float src_open=open, series float src_high=high, series float src_low=low, series float src_close=close, series float src_vol=volume) =>\n    float close_prev = nz(src_close[1], src_close)\n    float true_range_high = math.max(src_high, close_prev)\n    float true_range_low = math.min(src_low, close_prev)\n    float pm = 0.0\n    if not na(src_close) and not na(close_prev)\n        if src_close > close_prev\n            pm := src_close - true_range_low\n        else if src_close < close_prev\n            pm := src_close - true_range_high\n        else\n            pm := 0.0\n    float ad_value = pm * nz(src_vol, 0.0)\n    var float cumulative_wad = 0.0\n    cumulative_wad += ad_value\n    cumulative_wad\n\n// ---------- Main loop ----------\n\n// Calculation\nwad_value = wad()\n\n// Plot\nplot(wad_value, \"WAD\", color=color.yellow, linewidth=2)\n",
    "functions_used": [
      "math.max",
      "math.min",
      "color.yellow",
      "plot"
    ],
    "keywords": [
      "williams accumulation/distribution (wad)",
      "volume",
      "indicator",
      "v6",
      "math.max",
      "math.min",
      "color.yellow",
      "plot",
      "github.com",
      "wad.md",
      "math.max",
      "math.min",
      "color.yellow",
      "indicator",
      "overlay",
      "plot",
      "var",
      "series",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-279",
    "type": "example",
    "category": "libraries",
    "title": "reversals",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n\n//@library Library of reversal and pivot point detection indicators\nlibrary(\"reversals\")\n\n//@function Calculates Parabolic Stop And Reverse (SAR)\n//@param af_start Initial acceleration factor (Wilder's original: 0.02)\n//@param af_increment Acceleration factor increment per new extreme (Wilder's original: 0.02)\n//@param af_max Maximum acceleration factor (Wilder's original: 0.20)\n//@returns SAR value (stop level for current trend)\nexport psar(simple float af_start=0.02, simple float af_increment=0.02, simple float af_max=0.20) =>\n    if af_start <= 0 or af_start > af_max\n        runtime.error(\"Start AF must be > 0 and <= Max AF\")\n    if af_increment <= 0\n        runtime.error(\"AF increment must be > 0\")\n    if af_max <= af_start\n        runtime.error(\"Max AF must be > Start AF\")\n    var bool is_long = true\n    var float sar = low\n    var float ep = high\n    var float af = af_start\n    if bar_index == 0\n        is_long := close > open\n        sar := is_long ? low : high\n        ep := is_long ? high : low\n        af := af_start\n    else\n        float new_sar = sar + af * (ep - sar)\n        bool reverse = false\n        if is_long\n            new_sar := math.min(new_sar, low[1])\n            if bar_index > 1\n                new_sar := math.min(new_sar, low[2])\n            if low < new_sar\n                reverse := true\n                is_long := false\n                new_sar := ep\n                ep := low\n                af := af_start\n            else\n                if high > ep\n                    ep := high\n                    af := math.min(af + af_increment, af_max)\n        else\n            new_sar := math.max(new_sar, high[1])\n            if bar_index > 1\n                new_sar := math.max(new_sar, high[2])\n            if high > new_sar\n                reverse := true\n                is_long := true\n                new_sar := ep\n                ep := high\n                af := af_start\n            else\n                if low < ep\n                    ep := low\n                    af := math.min(af + af_increment, af_max)\n        sar := new_sar\n    sar\n\n//@function Detects Williams Fractal patterns (5-bar pattern)\n//@returns Tuple [up_fractal, down_fractal] with fractal values (na if no fractal)\nexport fractals() =>\n    bool is_up_fractal = false\n    bool is_down_fractal = false\n    if bar_index >= 4\n        is_up_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]\n        is_down_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]\n    float up_fractal_value = is_up_fractal ? high[2] : na\n    float down_fractal_value = is_down_fractal ? low[2] : na\n    [up_fractal_value, down_fractal_value]\n\n//@function Detects swing highs and swing lows using lookback period\n//@param lookback Number of bars on each side to confirm swing point\n//@param source_high Price series for swing high detection (typically high)\n//@param sour",
    "functions_used": [
      "runtime.error",
      "math.min",
      "math.max",
      "request.security"
    ],
    "keywords": [
      "reversals",
      "libraries",
      "library",
      "v6",
      "runtime.error",
      "math.min",
      "math.max",
      "request.security",
      "runtime.error",
      "math.min",
      "math.max",
      "request.security",
      "syminfo.tickerid",
      "barmerge.lookahead_on",
      "indicator",
      "var",
      "series",
      "simple",
      "export",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-280",
    "type": "example",
    "category": "libraries",
    "title": "statistics",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n\n//@library Statistics\n//@description Library of 27 statistical indicators for analyzing data distributions, relationships, and properties\nlibrary(\"statistics\")\n\n//@function Calculates the financial Beta coefficient comparing src1 volatility to src2\n//@param src1 Series to analyze\n//@param src2 Benchmark series to compare against\n//@param period Lookback period for calculation\n//@returns Beta value showing src1 volatility relative to src2\nexport beta(series float src1, series float src2, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float last_src1 = na\n    var float last_src2 = na\n    src1_return = last_src1 != 0 and not na(last_src1) ? (src1 - last_src1) / last_src1 : na\n    bench_return = last_src2 != 0 and not na(last_src2) ? (src2 - last_src2) / last_src2 : na\n    last_src1 := src1\n    last_src2 := src2\n    var int count = 0\n    var float sum_sr = 0.0, var float sum_br = 0.0\n    var float sum_sr2 = 0.0, var float sum_br2 = 0.0\n    var float sum_sbr = 0.0\n    var sr_buf = array.new_float(period)\n    var br_buf = array.new_float(period)\n    var int index = 0\n    if not na(src1_return) and not na(bench_return)\n        old_sr = array.get(sr_buf, index)\n        old_br = array.get(br_buf, index)\n        if count >= period\n            sum_sr -= old_sr, sum_br -= old_br\n            sum_sr2 -= old_sr * old_sr, sum_br2 -= old_br * old_br\n            sum_sbr -= old_sr * old_br\n        else\n            count += 1\n        sum_sr += src1_return, sum_br += bench_return\n        sum_sr2 += src1_return * src1_return\n        sum_br2 += bench_return * bench_return\n        sum_sbr += src1_return * bench_return\n        array.set(sr_buf, index, src1_return)\n        array.set(br_buf, index, bench_return)\n        index := (index + 1) % period\n    if count > 0\n        mean_sr = sum_sr / count\n        mean_br = sum_br / count\n        cov = (sum_sbr / count) - (mean_sr * mean_br)\n        var_bench = (sum_br2 / count) - (mean_br * mean_br)\n        if var_bench > 1e-10\n            cov / var_bench\n        else\n            na\n    else\n        na\n\n//@function Calculates the deviation of a signal from its moving average (BIAS)\n//@param src The source series\n//@param len The lookback period for the SMA\n//@returns The BIAS value\nexport bias(series float src, simple int len) =>\n    if len <= 0\n        runtime.error(\"BIAS length must be greater than 0\")\n    var float sma_sum = 0.0\n    var float[] sma_buffer = array.new_float(len, na)\n    var int sma_head = 0\n    var int sma_validCount = 0\n    float sma_oldestVal = array.get(sma_buffer, sma_head)\n    if not na(sma_oldestVal)\n        sma_sum -= sma_oldestVal\n    else if not na(src)\n        sma_validCount +=1\n    sma_sum += nz(src, 0.0)\n    array.set(sma_buffer, sma_head, src)\n    sma_head := (sma_head + 1) % len\n    float movingAverage = na\n    if sma_validCount >= len or bar_index + 1 >= len\n        movingAverage := sma_",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "str.tostring",
      "math.log",
      "math.exp",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.min",
      "array.new_int",
      "math.pow"
    ],
    "keywords": [
      "statistics",
      "libraries",
      "library",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "str.tostring",
      "math.log",
      "math.exp",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.min",
      "array.new_int",
      "math.pow",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "str.tostring",
      "math.log",
      "math.exp",
      "array.clear",
      "array.push",
      "array.size",
      "array.sort",
      "math.floor",
      "math.ceil",
      "math.min",
      "array.new_int",
      "math.pow",
      "indicator",
      "input",
      "fill",
      "var",
      "series",
      "simple",
      "export",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-281",
    "type": "example",
    "category": "libraries",
    "title": "trends_FIR",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n//@description Library of FIR (Finite Impulse Response) trend filters - 17 self-contained moving averages with no external dependencies\n\nlibrary(\"trends_FIR\", overlay=true)\n\n//@function Simple Moving Average - arithmetic mean with O(1) circular buffer\n//@param source Series to calculate SMA from\n//@param period Lookback period\n//@returns SMA value from first bar\nexport sma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var array<float> buffer = array.new_float(period, na)\n    var int head = 0\n    var float sum = 0.0\n    var int count = 0\n    float oldest = array.get(buffer, head)\n    if not na(oldest)\n        sum -= oldest\n    else\n        count += 1\n    float current = nz(source)\n    sum += current\n    array.set(buffer, head, current)\n    head := (head + 1) % period\n    sum / math.max(1, count)\n\n//@function Weighted Moving Average - O(1) circular buffer with dual running sums\n//@param source Series to calculate WMA from\n//@param period Lookback period\n//@returns WMA value from first bar\nexport wma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var array<float> buffer = array.new_float(period, na)\n    var int head = 0\n    var float sum = 0.0\n    var float weighted_sum = 0.0\n    var int count = 0\n    var float norm = 0.0\n    float oldest = array.get(buffer, head)\n    float current = nz(source)\n    if not na(oldest)\n        float old_sum = sum\n        sum -= oldest\n        sum += current\n        weighted_sum := weighted_sum - old_sum + (period * current)\n    else\n        count += 1\n        sum += current\n        weighted_sum := weighted_sum + (count * current)\n        norm := count * (count + 1) * 0.5\n    array.set(buffer, head, current)\n    head := (head + 1) % period\n    weighted_sum / norm\n\n//@function Double Weighted Moving Average - O(1) two-pass WMA with inline calculations\n//@param source Series to calculate DWMA from\n//@param period Lookback period\n//@returns DWMA value from first bar\nexport dwma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var array<float> buffer1 = array.new_float(period, na)\n    var int head1 = 0\n    var float sum1 = 0.0\n    var float weighted_sum1 = 0.0\n    var int count1 = 0\n    var float norm1 = 0.0\n    var array<float> buffer2 = array.new_float(period, na)\n    var int head2 = 0\n    var float sum2 = 0.0\n    var float weighted_sum2 = 0.0\n    var int count2 = 0\n    var float norm2 = 0.0\n    float oldest1 = array.get(buffer1, head1)\n    float current1 = nz(source)\n    if not na(oldest1)\n        float old_sum1 = sum1\n        sum1 -= oldest1\n        sum1 += current1\n        weighted_sum1 := weighted_sum1 - old_sum1 + (period * current1)\n    else\n        count1 += 1\n        sum1 += current1\n        weighted_sum1 := weighted_sum1 + (count1 * current1)\n ",
    "functions_used": [
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.min",
      "math.floor",
      "math.sin",
      "math.pi",
      "math.exp",
      "math.cos",
      "math.sqrt",
      "math.pow",
      "math.round",
      "math.abs",
      "array.size",
      "array.copy"
    ],
    "keywords": [
      "trends_fir",
      "libraries",
      "library",
      "v6",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.min",
      "math.floor",
      "math.sin",
      "math.pi",
      "math.exp",
      "math.cos",
      "math.sqrt",
      "math.pow",
      "math.round",
      "math.abs",
      "array.size",
      "array.copy",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.min",
      "math.floor",
      "math.sin",
      "math.pi",
      "math.exp",
      "math.cos",
      "math.sqrt",
      "math.pow",
      "math.round",
      "math.abs",
      "array.size",
      "array.copy",
      "overlay",
      "var",
      "series",
      "simple",
      "export",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-282",
    "type": "example",
    "category": "libraries",
    "title": "trends_IIR",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n//@description Library of IIR (Infinite Impulse Response) trend filters - 23 self-contained moving averages with no external dependencies\n\nlibrary(\"trends_IIR\", overlay=true)\n\n// =============================================================================\n// BASIC EXPONENTIAL SMOOTHING\n// =============================================================================\n\n//@function Exponential Moving Average - exponential weighting with O(1) complexity\n//@param source Series to calculate EMA from\n//@param period Lookback period\n//@returns EMA value from first bar\nexport ema(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float alpha = 2.0 / (period + 1)\n    float beta = 1.0 - alpha\n    var bool warmup = true\n    var float e = 1.0\n    var float ema = 0.0\n    var float result = source\n    ema := alpha * (source - ema) + ema\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := c * ema\n        warmup := e > 1e-10\n    else\n        result := ema\n    result\n\n//@function Wilder's Moving Average (RMA) - Wilder's smoothing method\n//@param source Series to calculate RMA from\n//@param period Lookback period\n//@returns RMA value from first bar\nexport rma(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float alpha = 1.0 / period\n    float beta = 1.0 - alpha\n    var bool warmup = true\n    var float e = 1.0\n    var float rma = 0.0\n    var float result = source\n    rma := alpha * (source - rma) + rma\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := c * rma\n        warmup := e > 1e-10\n    else\n        result := rma\n    result\n\n// =============================================================================\n// CASCADED EXPONENTIAL SMOOTHING\n// =============================================================================\n\n//@function Double Exponential Moving Average - two-pass EMA\n//@param source Series to calculate DEMA from\n//@param period Lookback period\n//@returns DEMA value from first bar\nexport dema(series float source, simple int period) =>\n    if period <= 0\n        runtime.error(\"Period must be greater than 0\")\n    float alpha = 2.0 / (period + 1)\n    float beta = 1.0 - alpha\n    var bool warmup = true\n    var float e = 1.0\n    var float ema1 = 0.0\n    var float ema2 = 0.0\n    var float result = source\n    ema1 := alpha * (source - ema1) + ema1\n    ema2 := alpha * (ema1 - ema2) + ema2\n    if warmup\n        e *= beta\n        float c = 1.0 / (1.0 - e)\n        result := 2.0 * (c * ema1) - (c * ema2)\n        warmup := e > 1e-10\n    else\n        result := 2.0 * ema1 - ema2\n    result\n\n//@function Triple Exponential Moving Average - three-pass EMA\n//@param source Series to calculate TEMA from\n//@param period Lookback period\n//@returns TEMA value from first bar\nexport tema(series float source, simple int p",
    "functions_used": [
      "runtime.error",
      "math.round",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.abs",
      "math.min",
      "math.log",
      "math.sum",
      "math.pow",
      "math.exp",
      "math.pi",
      "math.cos",
      "array.unshift",
      "array.pop",
      "math.atan",
      "math.sign",
      "math.sin",
      "array.fill",
      "array.size",
      "fill"
    ],
    "keywords": [
      "trends_iir",
      "libraries",
      "library",
      "v6",
      "runtime.error",
      "math.round",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.abs",
      "math.min",
      "math.log",
      "math.sum",
      "math.pow",
      "math.exp",
      "math.pi",
      "math.cos",
      "array.unshift",
      "array.pop",
      "math.atan",
      "math.sign",
      "math.sin",
      "array.fill",
      "array.size",
      "fill",
      "runtime.error",
      "math.round",
      "array.new_float",
      "array.get",
      "array.set",
      "math.max",
      "math.sqrt",
      "math.abs",
      "math.min",
      "math.log",
      "math.sum",
      "math.pow",
      "math.exp",
      "math.pi",
      "math.cos",
      "array.unshift",
      "array.pop",
      "math.atan",
      "math.sign",
      "math.sin",
      "array.fill",
      "array.size",
      "indicator",
      "overlay",
      "fill",
      "var",
      "series",
      "simple",
      "const",
      "export",
      "method",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-283",
    "type": "example",
    "category": "libraries",
    "title": "volatility",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n//@description Library of volatility indicators - 26 self-contained volatility measures with no external dependencies\n\nlibrary(\"volatility\", overlay=false)\n\n// =============================================================================\n// BASIC RANGE MEASURES\n// =============================================================================\n\n//@function True Range - fundamental volatility measure\n//@returns True Range value for current bar\nexport tr() =>\n    float prevClose = nz(close[1], close)\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    math.max(tr1, math.max(tr2, tr3))\n\n//@function Average True Range - smoothed true range\n//@param length Period for ATR calculation\n//@returns ATR value\nexport atr(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n    else\n        na\n\n//@function Normalized ATR - ATR as percentage of price\n//@param length Period for ATR calculation\n//@returns NATR value as percentage\nexport natr(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    if not na(trueRange)\n        raw_rma := (raw_rma * (length - 1) + trueRange) / length\n        e *= beta\n        float atr_val = e > EPSILON ? raw_rma / (1.0 - e) : raw_rma\n        close > 0 ? (atr_val / close) * 100 : na\n    else\n        na\n\n//@function ATR Normalized - ATR divided by typical price\n//@param length Period for ATR calculation\n//@returns ATRN value\nexport atrn(simple int length) =>\n    if length <= 0\n        runtime.error(\"Period must be greater than 0\")\n    var float prevClose = close\n    float tr1 = high - low\n    float tr2 = math.abs(high - prevClose)\n    float tr3 = math.abs(low - prevClose)\n    float trueRange = math.max(tr1, tr2, tr3)\n    prevClose := close\n    float typicalPrice = (high + low + close) / 3\n    float alpha = 1.0 / float(length)\n    float beta = 1.0 - alpha\n    var float EPSILON = 1e-10\n    var float raw_rma = 0.0\n    var float e = 1.0\n    if not na(trueRange)\n        raw_rma",
    "functions_used": [
      "math.abs",
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.log",
      "math.pow",
      "math.sqrt"
    ],
    "keywords": [
      "volatility",
      "libraries",
      "library",
      "v6",
      "math.abs",
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.log",
      "math.pow",
      "math.sqrt",
      "math.abs",
      "math.max",
      "runtime.error",
      "array.new_float",
      "array.get",
      "array.set",
      "math.log",
      "math.pow",
      "math.sqrt",
      "indicator",
      "overlay",
      "fill",
      "var",
      "series",
      "simple",
      "export",
      "for",
      "if",
      "else"
    ]
  },
  {
    "id": "script-284",
    "type": "example",
    "category": "libraries",
    "title": "volume",
    "version": "v6",
    "code": "// The MIT License (MIT)\n// © mihakralj\n//@version=6\n\n//@library Volume\n//@description Library of 26 volume-based technical indicators for analyzing trading volume patterns and money flow\nlibrary(\"volume\")\n\n//@function Calculates the Accumulation/Distribution Line (ADL), a volume-based indicator that measures money flow\n//@param src_high The high price\n//@param src_low The low price\n//@param src_close The close price\n//@param src_vol The volume\n//@returns The cumulative ADL value\nexport adl(series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>\n    float mfm = 0.0\n    if not na(src_high) and not na(src_low) and not na(src_close)\n        mfm := (src_close - src_low) - (src_high - src_close)\n        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0\n    float mfv = na(src_vol) ? 0.0 : src_vol * mfm\n    var float cumulativeSum = 0.0\n    cumulativeSum := na(mfv) ? cumulativeSum : cumulativeSum + mfv\n    cumulativeSum\n\n//@function Calculates the Chaikin Accumulation/Distribution Oscillator (ADOSC)\n//@param shortPeriod Length of the short-term EMA applied to the ADL\n//@param longPeriod Length of the long-term EMA applied to the ADL\n//@returns The ADOSC value\nexport adosc(simple int shortPeriod, simple int longPeriod) =>\n    float EPSILON = 1e-10\n    if shortPeriod <= 0 or longPeriod <= 0\n        runtime.error(\"Periods must be greater than 0\")\n    short_alpha = 2.0 / (shortPeriod + 1)\n    long_alpha = 2.0 / (longPeriod + 1)\n    one_minus_long_alpha = 1.0 - long_alpha\n    float rng = high - low\n    float mf = rng != 0.0 ? ((2 * close - high - low) / rng) * volume : 0.0\n    var float cum = 0.0\n    var float e = 1.0\n    cum := bar_index == 0 ? mf : cum + mf\n    var float short_raw_ema = 0.0\n    short_raw_ema := short_alpha * (cum - short_raw_ema) + short_raw_ema\n    float short_ema = e > EPSILON ? short_raw_ema / (1.0 - e) : short_raw_ema\n    var float long_raw_ema = 0.0\n    long_raw_ema := long_alpha * (cum - long_raw_ema) + long_raw_ema\n    float long_ema = e > EPSILON ? long_raw_ema / (1.0 - e) : long_raw_ema\n    e := one_minus_long_alpha * e\n    short_ema - long_ema\n\n//@function Computes Archer On-Balance Volume (AOBV) Fast and Slow\n//@param src Price source\n//@param vol Volume data\n//@returns [AOBV Fast, AOBV Slow]\n//@optimized Beta precomputation for EMA warmup compensation\nexport aobv(series float src, series float vol) =>\n    var float prev_src = na\n    safe_src = not na(src) ? src : (not na(prev_src) ? prev_src : 0)\n    safe_vol = not na(vol) ? vol : 0\n    safe_prev = not na(prev_src) ? prev_src : safe_src\n    var float obv_val = 0.0\n    obv_val := bar_index == 0 ? (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0) : obv_val + (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0)\n    if not na(src)\n        prev_src := src\n    periods = array.from(4, 14)\n    var emaArr = array.new_float(2, na)\n    var eArr = array.new_float(2, 1.",
    "functions_used": [
      "runtime.error",
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "math.abs",
      "math.min"
    ],
    "keywords": [
      "volume",
      "libraries",
      "library",
      "v6",
      "runtime.error",
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "math.abs",
      "math.min",
      "runtime.error",
      "array.from",
      "array.new_float",
      "array.new_bool",
      "array.size",
      "array.get",
      "math.max",
      "array.set",
      "math.abs",
      "math.min",
      "indicator",
      "var",
      "series",
      "simple",
      "export",
      "type",
      "for",
      "if",
      "else"
    ]
  }
]